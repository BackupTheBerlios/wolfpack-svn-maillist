<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Wolfpack-svn] r6839 - in trunk/WPGM: . Components	Components/Graphics32 Components/VirtualTreeview	Components/VirtualTreeview/Packages ImportDefinitions UOLib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wolfpack-svn/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:wolfpack-svn%40lists.berlios.de?Subject=Re%3A%20%5BWolfpack-svn%5D%20r6839%20-%20in%20trunk/WPGM%3A%20.%20Components%0A%09Components/Graphics32%20Components/VirtualTreeview%0A%09Components/VirtualTreeview/Packages%20ImportDefinitions%20UOLib&In-Reply-To=%3C200706221752.l5MHqgYV003121%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000043.html">
   <LINK REL="Next"  HREF="000045.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Wolfpack-svn] r6839 - in trunk/WPGM: . Components	Components/Graphics32 Components/VirtualTreeview	Components/VirtualTreeview/Packages ImportDefinitions UOLib</H1>
    <B>correa at mail.berlios.de</B> 
    <A HREF="mailto:wolfpack-svn%40lists.berlios.de?Subject=Re%3A%20%5BWolfpack-svn%5D%20r6839%20-%20in%20trunk/WPGM%3A%20.%20Components%0A%09Components/Graphics32%20Components/VirtualTreeview%0A%09Components/VirtualTreeview/Packages%20ImportDefinitions%20UOLib&In-Reply-To=%3C200706221752.l5MHqgYV003121%40sheep.berlios.de%3E"
       TITLE="[Wolfpack-svn] r6839 - in trunk/WPGM: . Components	Components/Graphics32 Components/VirtualTreeview	Components/VirtualTreeview/Packages ImportDefinitions UOLib">correa at mail.berlios.de
       </A><BR>
    <I>Fri Jun 22 19:52:42 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000043.html">[Wolfpack-svn] r6838 - in trunk/server:	boost/include/boost/python/detail	boost/include/boost/tuple/detail src src/ai src/muls	src/network src/python src/twofish
</A></li>
        <LI>Next message: <A HREF="000045.html">[Wolfpack-svn] r6840 - trunk/server/release/scripts/wolfpack
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#44">[ date ]</a>
              <a href="thread.html#44">[ thread ]</a>
              <a href="subject.html#44">[ subject ]</a>
              <a href="author.html#44">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: correa
Date: 2007-06-22 19:52:13 +0200 (Fri, 22 Jun 2007)
New Revision: 6839

Removed:
   trunk/WPGM/Components/Graphics32/GR32_Blend.dcu
   trunk/WPGM/Components/Graphics32/GR32_ByteMaps.dcu
   trunk/WPGM/Components/Graphics32/GR32_DrawingEx.dcu
   trunk/WPGM/Components/Graphics32/GR32_Dsgn_Bitmap.dcu
   trunk/WPGM/Components/Graphics32/GR32_Dsgn_Color.dcu
   trunk/WPGM/Components/Graphics32/GR32_Filters.dcu
   trunk/WPGM/Components/Graphics32/GR32_Image.dcu
   trunk/WPGM/Components/Graphics32/GR32_Layers.dcu
   trunk/WPGM/Components/Graphics32/GR32_LowLevel.dcu
   trunk/WPGM/Components/Graphics32/GR32_Polygons.dcu
   trunk/WPGM/Components/Graphics32/GR32_RangeBars.dcu
   trunk/WPGM/Components/Graphics32/GR32_Reg.dcu
   trunk/WPGM/Components/Graphics32/GR32_System.dcu
   trunk/WPGM/Components/Graphics32/GR32_Transforms.dcu
   trunk/WPGM/Components/PDJButton.dcu
   trunk/WPGM/Components/VirtualTreeview/Packages/VirtualTreesD5.dcu
   trunk/WPGM/Components/VirtualTreeview/Packages/VirtualTreesD5D.dcu
   trunk/WPGM/Components/VirtualTreeview/Packages/VirtualTreesD7.dcu
   trunk/WPGM/Components/VirtualTreeview/Packages/VirtualTreesD7D.dcu
   trunk/WPGM/Components/VirtualTreeview/Packages/VirtualTreesReg.dcu
   trunk/WPGM/Components/VirtualTreeview/VTHeaderPopup.dcu
   trunk/WPGM/Components/VirtualTreeview/VirtualTrees.dcu
   trunk/WPGM/Components/VirtualTreeview/VirtualTrees.~pas
   trunk/WPGM/ImportDefinitions/ImportDefinitions.~dpr
   trunk/WPGM/ImportDefinitions/Main.dcu
   trunk/WPGM/ImportDefinitions/Main.~dfm
   trunk/WPGM/ImportDefinitions/Main.~pas
   trunk/WPGM/ImportDefinitions/Strlib.dcu
   trunk/WPGM/ImportDefinitions/WpConfiguration.dcu
   trunk/WPGM/ImportDefinitions/WpConfiguration.~pas
   trunk/WPGM/ImportDefinitions/XmlReader.dcu
   trunk/WPGM/ImportDefinitions/XmlReader.~pas
   trunk/WPGM/Main.dcu
   trunk/WPGM/Main.~ddp
   trunk/WPGM/Main.~dfm
   trunk/WPGM/Main.~pas
   trunk/WPGM/Overview.dcu
   trunk/WPGM/Overview.~ddp
   trunk/WPGM/Overview.~dfm
   trunk/WPGM/Overview.~pas
   trunk/WPGM/Progress.dcu
   trunk/WPGM/Progress.~dfm
   trunk/WPGM/Progress.~pas
   trunk/WPGM/SQLite.dcu
   trunk/WPGM/SQLiteTable.dcu
   trunk/WPGM/Spawnregions.dcu
   trunk/WPGM/Spawnregions.~ddp
   trunk/WPGM/Spawnregions.~dfm
   trunk/WPGM/Spawnregions.~pas
   trunk/WPGM/Strlib.dcu
   trunk/WPGM/UOCache.dcu
   trunk/WPGM/UOCache.~pas
   trunk/WPGM/UOHues.dcu
   trunk/WPGM/UOHues.~pas
   trunk/WPGM/UOLib/UOAnim.dcu
   trunk/WPGM/UOLib/UOAnim.~pas
   trunk/WPGM/UOLib/UOArt.dcu
   trunk/WPGM/UOLib/UOArt.~pas
   trunk/WPGM/UOLib/UOTiledata.dcu
   trunk/WPGM/UOLib/UOTiledata.~pas
   trunk/WPGM/UOLib/UOUtilities.dcu
   trunk/WPGM/UOLib/UOUtilities.~pas
   trunk/WPGM/UOMap.dcu
   trunk/WPGM/UOMap.~pas
   trunk/WPGM/UORadarCol.dcu
   trunk/WPGM/UORadarCol.~pas
   trunk/WPGM/UOStatics.dcu
   trunk/WPGM/UOStatics.~pas
   trunk/WPGM/WPGM.~dpr
   trunk/WPGM/XMLReader.dcu
   trunk/WPGM/uCenter.dcu
   trunk/WPGM/uCenter.~dfm
   trunk/WPGM/uCenter.~pas
   trunk/WPGM/uChooseHue.dcu
   trunk/WPGM/uChooseHue.~ddp
   trunk/WPGM/uChooseHue.~dfm
   trunk/WPGM/uChooseHue.~pas
   trunk/WPGM/uConfig.dcu
   trunk/WPGM/uConfig.~pas
   trunk/WPGM/uPatternColor.dcu
   trunk/WPGM/uPatternColor.~dfm
   trunk/WPGM/uPatternColor.~pas
Modified:
   trunk/WPGM/
Log:
Remove generated binaries and backup files.


Property changes on: trunk/WPGM
___________________________________________________________________
Name: svn:ignore
   + *.~pas
*.dcu
*.~dfm
*.~ddp
*.~dpr


Deleted: trunk/WPGM/Components/Graphics32/GR32_Blend.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_ByteMaps.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_DrawingEx.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_Dsgn_Bitmap.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_Dsgn_Color.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_Filters.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_Image.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_Layers.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_LowLevel.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_Polygons.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_RangeBars.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_Reg.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_System.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/Graphics32/GR32_Transforms.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/PDJButton.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/VirtualTreeview/Packages/VirtualTreesD5.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/VirtualTreeview/Packages/VirtualTreesD5D.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/VirtualTreeview/Packages/VirtualTreesD7.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/VirtualTreeview/Packages/VirtualTreesD7D.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/VirtualTreeview/Packages/VirtualTreesReg.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/VirtualTreeview/VTHeaderPopup.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/VirtualTreeview/VirtualTrees.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Components/VirtualTreeview/VirtualTrees.~pas
===================================================================
--- trunk/WPGM/Components/VirtualTreeview/VirtualTrees.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/Components/VirtualTreeview/VirtualTrees.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,29873 +0,0 @@
-unit VirtualTrees;
-
-// Version 3.8.3
-//
-// The contents of this file are subject to the Mozilla Public License
-// Version 1.1 (the &quot;License&quot;); you may not use this file except in compliance
-// with the License. You may obtain a copy of the License at <A HREF="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</A>
-//
-// Alternatively, you may redistribute this library, use and/or modify it under the terms of the
-// GNU Lesser General Public License as published by the Free Software Foundation;
-// either version 2.1 of the License, or (at your option) any later version.
-// You may obtain a copy of the LGPL at <A HREF="http://www.gnu.org/copyleft/.">http://www.gnu.org/copyleft/.</A>
-//
-// Software distributed under the License is distributed on an &quot;AS IS&quot; basis,
-// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for the
-// specific language governing rights and limitations under the License.
-//
-// The original code is VirtualTrees.pas, released September 30, 2000.
-//
-// The initial developer of the original code is digital publishing AG (Munich, Germany, www.digitalpublishing.de),
-// written by Dipl. Ing. Mike Lischke (<A HREF="https://lists.berlios.de/mailman/listinfo/wolfpack-svn">public at lischke-online.de</A>, www.lischke-online.de).
-//
-// Portions created by digital publishing AG are Copyright
-// (C) 1999-2001 digital publishing AG. All Rights Reserved.
-//----------------------------------------------------------------------------------------------------------------------
-//                                         
-// For full document history see help file.
-//
-// Credits for their valuable assistance and code donations go to:
-//   Freddy Ertl, Marian Aldenh&#246;vel, Thomas Bogenrieder, Jim Kuenemann, Werner Lehmann, Jens Treichler,
-//   Paul Gallagher (IBO tree), Ondrej Kelle, Ronaldo Melo Ferraz, Heri Bender, Roland Bed&#252;rftig (BCB)
-//   Anthony Mills, Alexander Egorushkin (BCB), Mathias Torell (BCB), Frank van den Bergh, Vadim Sedulin, Peter Evans,
-//   Milan Vandrovec (BCB), Steve Moss (system check images), Joe White, David Clark (local node memory manager),
-//   Anders Thomsen, Igor Afanasyev
-// Beta testers:
-//   Freddy Ertl, Hans-J&#252;rgen Schnorrenberg, Werner Lehmann, Jim Kueneman, Vadim Sedulin, Moritz Franckenstein,
-//   Wim van der Vegt, Franc v/d Westelaken
-// Indirect contribution (via publicly accessible work of those persons):
-//   Alex Denissov, Hiroyuki Hori (MMXAsm expert)
-// Documentation:
-//   Markus Spoettl and toolsfactory GbR (<A HREF="http://www.doc-o-matic.com/,">http://www.doc-o-matic.com/,</A> sponsoring Virtual Treeview
-//   with a free copy of the Doc-O-Matic help authoring system), Sven H. (Step by step tutorial)
-// CLX:
-//   Dmitri Dmitrienko (initial developer)
-//----------------------------------------------------------------------------------------------------------------------
-
-interface
-
-{$BOOLEVAL OFF} // Use fastest possible boolean evaluation.
-
-{$I Compilers.inc}
-{.$define UseFlatScrollbars}
-{.$define ReverseFullExpandHotKey} // Used to define Ctrl+'+' instead of Ctrl+Shift+'+' for full expand (and similar for collapsing).
-{$define ThemeSupport}
-
-// Virtual Treeview can use a tiny but very effective local memory manager for node allocation.
-// The local memory manager was implemented by David Clark from Caelo Software Inc.
-// See below for more info about it.
-{.$define UseLocalMemoryManager}
-
-{.$define TntSupport} // Added by Igor Afanasyev to support unicode-aware inplace editor. This implementation uses
-                     // Troy Wolbrink's TNT controls, which can be found at:
-                     // <A HREF="http://home.ccci.org/wolbrink/tnt/delphi_unicode_controls.htm.">http://home.ccci.org/wolbrink/tnt/delphi_unicode_controls.htm.</A>
-
-{$HPPEMIT '#include &lt;objidl.h&gt;'}
-{$HPPEMIT '#include &lt;oleidl.h&gt;'} // Necessary for BCB 6 SP 2.
-
-uses
-  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, ImgList, ActiveX, StdCtrls, Menus, Printers,
-  SyncObjs  // critical sections
-  {$ifdef ThemeSupport}
-    {$ifndef COMPILER_7_UP}
-      , ThemeSrv, TMSchema, UxTheme  // Windows XP themes support. Get these units from www.delphi-gems.com.
-    {$else}
-      , Themes, UxTheme
-    {$endif COMPILE_7_UP}
-  {$endif ThemeSupport}
-  {$ifdef TntSupport}
-    , TntStdCtrls       // Unicode aware inplace editor.
-  {$endif TntSupport}
-  ;
-
-const
-  VTVersion = '3.8.3';
-  VTTreeStreamVersion = 2;
-  VTHeaderStreamVersion = 2;    // The header needs an own stream version to indicate changes only relevant to the header.
-
-  CacheThreshold = 2000;        // Number of nodes a tree must at least have to start caching and at the same
-                                // time the maximum number of nodes between two cache entries.
-  FadeAnimationStepCount = 255; // Number of animation steps for hint fading (0..255).
-  ShadowSize = 5;               // Size in pixels of the hint shadow. This value has no influence on Win2K and XP systems
-                                // as those OSes have native shadow support.
-
-  // Special identifiers for columns.
-  NoColumn = -1;
-  InvalidColumn = -2;
-
-  // Indices for check state images used for checking.
-  ckEmpty                  =  0;  // an empty image used as place holder
-  // radio buttons
-  ckRadioUncheckedNormal   =  1;
-  ckRadioUncheckedHot      =  2;
-  ckRadioUncheckedPressed  =  3;
-  ckRadioUncheckedDisabled =  4;
-  ckRadioCheckedNormal     =  5;
-  ckRadioCheckedHot        =  6;
-  ckRadioCheckedPressed    =  7;
-  ckRadioCheckedDisabled   =  8;
-  // check boxes
-  ckCheckUncheckedNormal   =  9;
-  ckCheckUncheckedHot      = 10;
-  ckCheckUncheckedPressed  = 11;
-  ckCheckUncheckedDisabled = 12;
-  ckCheckCheckedNormal     = 13;
-  ckCheckCheckedHot        = 14;
-  ckCheckCheckedPressed    = 15;
-  ckCheckCheckedDisabled   = 16;
-  ckCheckMixedNormal       = 17;
-  ckCheckMixedHot          = 18;
-  ckCheckMixedPressed      = 19;
-  ckCheckMixedDisabled     = 20;
-  // simple button
-  ckButtonNormal           = 21;
-  ckButtonHot              = 22;
-  ckButtonPressed          = 23;
-  ckButtonDisabled         = 24;
-
-  // Instead using a TTimer class for each of the various events I use Windows timers with messages
-  // as this is more economical.
-  ExpandTimer = 1;
-  EditTimer = 2;
-  HeaderTimer = 3;
-  ScrollTimer = 4;
-  ChangeTimer = 5;
-  StructureChangeTimer = 6;
-  SearchTimer = 7;
-
-  // Need to use this message to release the edit link interface asynchronly.
-  WM_RELEASEEDITLINK = WM_APP + 31;
-  WM_CHANGESTATE = WM_APP + 32;
-
-  // Virtual Treeview does not need to be subclass by an eventual Theme Manager class as it handles
-  // Windows XP theme painting itself. Hence the special non-subclass message is used to prevent subclassing.
-  CM_DENYSUBCLASSING = CM_BASE + 2000;
-
-  // Decoupling message for auto-adjusting the internal edit window.
-  CM_AUTOADJUST = CM_BASE + 2005;
-
-  // VT's own clipboard formats,
-  // Note: The reference format is used internally to allow to link to a tree reference
-  //       to implement optimized moves and other back references.
-  CFSTR_VIRTUALTREE = 'Virtual Tree Data';
-  CFSTR_VTREFERENCE = 'Virtual Tree Reference';
-  CFSTR_HTML = 'HTML Format';
-  CFSTR_RTF = 'Rich Text Format';
-  CFSTR_RTFNOOBJS = 'Rich Text Format Without Objects';
-  CFSTR_CSV = 'CSV';
-
-  // Drag image helpers for Windows 2000 and up.
-  IID_IDropTargetHelper: TGUID = (D1: $4657278B; D2: $411B; D3: $11D2; D4: ($83, $9A, $00, $C0, $4F, $D9, $18, $D0));
-  IID_IDragSourceHelper: TGUID = (D1: $DE5BF786; D2: $477A; D3: $11D2; D4: ($83, $9D, $00, $C0, $4F, $D9, $18, $D0));
-  IID_IDropTarget: TGUID = (D1: $00000122; D2: $0000; D3: $0000; D4: ($C0, $00, $00, $00, $00, $00, $00, $46));
-  CLSID_DragDropHelper: TGUID = (D1: $4657278A; D2: $411B; D3: $11D2; D4: ($83, $9A, $00, $C0, $4F, $D9, $18, $D0));
-
-  SID_IDropTargetHelper = '{4657278B-411B-11D2-839A-00C04FD918D0}';
-  SID_IDragSourceHelper = '{DE5BF786-477A-11D2-839D-00C04FD918D0}';
-  SID_IDropTarget = '{00000122-0000-0000-C000-000000000046}';
-
-  // Help identifiers for exceptions. Application developers are responsible to link them with actual help topics.
-  hcTFEditLinkIsNil      = 2000;
-  hcTFWrongMoveError     = 2001;
-  hcTFWrongStreamFormat  = 2002;
-  hcTFWrongStreamVersion = 2003;
-  hcTFStreamTooSmall     = 2004;
-  hcTFCorruptStream1     = 2005;
-  hcTFCorruptStream2     = 2006;
-  hcTFClipboardFailed    = 2007;
-  hcTFCannotSetUserData  = 2008;
-
-  // Header standard split cursor.
-  crHeaderSplit = TCursor(100);
-
-  UtilityImageSize = 16; // Needed by descentants for hittests.
-  
-var // Clipboard format IDs used in OLE drag'n drop and clipboard transfers.
-  CF_VIRTUALTREE,
-  CF_VTREFERENCE,
-  CF_VRTF,
-  CF_VRTFNOOBJS,   // Unfortunately CF_RTF* is already defined as being
-                   // registration strings so I have to use different identifiers.
-  CF_HTML,
-  CF_CSV: Word;
-
-  MMXAvailable: Boolean; // necessary to know because the blend code uses MMX instructions
-
-{$MinEnumSize 1, make enumerations as small as possible}
-
-type
-  // The exception used by the trees.
-  EVirtualTreeError = class(Exception);
-
-
-
-  PCardinal = ^Cardinal;
-
-  // Limits the speed interval which can be used for auto scrolling (milliseconds).
-  TAutoScrollInterval = 1..1000;
-
-  // Need to declare the correct WMNCPaint record as the VCL (D5-) doesn't.
-  TRealWMNCPaint = packed record
-    Msg: Cardinal;
-    Rgn: HRGN;
-    lParam: Integer;
-    Result: Integer;
-  end;
-
-  // The next two message records are not declared in Delphi 6 and lower.
-  TWMPrint = packed record
-    Msg: Cardinal;
-    DC: HDC;
-    Flags: Cardinal;
-    Result: Integer;
-  end;
-
-  TWMPrintClient = TWMPrint;
-
-  {$ifndef COMPILER_5_UP}
-    TWMContextMenu = TWMMouse;
-  {$endif COMPILER_5_UP}
-
-  // Be careful when adding new states as this might change the size of the type which in turn
-  // changes the alignment in the node record as well as the stream chunks.
-  // Do not reorder the states and always add new states at the end of this enumeration in order to avoid
-  // breaking existing code. 
-  TVirtualNodeState = (
-    vsInitialized,       // Set after the node has been initialized.
-    vsChecking,          // Node's check state is changing, avoid propagation.
-    vsCutOrCopy,         // Node is selected as cut or copy and paste source.
-    vsDisabled,          // Set if node is disabled.
-    vsDeleting,          // Set when the node is about to be freed.
-    vsExpanded,          // Set if the node is expanded.
-    vsHasChildren,       // Indicates the presence of child nodes without actually setting them.
-    vsVisible,           // Indicate whether the node is visible or not (independant of the expand states of its parents).
-    vsSelected,          // Set if the node is in the current selection.
-    vsInitialUserData,   // Set if (via AddChild or InsertNode) initial user data has been set which requires OnFreeNode.
-    vsAllChildrenHidden, // Set if vsHasChildren is set and no child node has the vsVisible flag set.
-    vsClearing,          // A node's children are being deleted. Don't register structure change event.
-    vsMultiline          // Node text is wrapped at the cell boundaries instead of being shorted.
-  );
-  TVirtualNodeStates = set of TVirtualNodeState;
-
-  // States used in InitNode to indicate states a node shall initially have.
-  TVirtualNodeInitState = ( 
-    ivsDisabled,
-    ivsExpanded,
-    ivsHasChildren,
-    ivsMultiline,
-    ivsSelected
-  );
-  TVirtualNodeInitStates = set of TVirtualNodeInitState;
-
-  TScrollBarStyle = (
-    sbmRegular,
-    sbmFlat,
-    sbm3D
-  );
-
-  // options per column
-  TVTColumnOption = (
-    coAllowClick,
-    coDraggable,
-    coEnabled,
-    coParentBidiMode,
-    coParentColor,
-    coResizable,
-    coShowDropMark,
-    coVisible
-  );
-  TVTColumnOptions = set of TVTColumnOption;
-
-  // These flags are returned by the hit test method.
-  THitPosition = (
-    hiAbove,          // above the client area (if relative) or the absolute tree area
-    hiBelow,          // below the client area (if relative) or the absolute tree area
-    hiNowhere,        // no node is involved (possible only if the tree is not as tall as the client area)
-    hiOnItem,         // on the bitmaps/buttons or label associated with an item
-    hiOnItemButton,   // on the button associated with an item
-    hiOnItemCheckbox, // on the checkbox if enabled
-    hiOnItemIndent,   // in the indentation area in front of a node
-    hiOnItemLabel,    // on the normal text area associated with an item
-    hiOnItemLeft,     // in the area to the left of a node's text area (e.g. when right aligned or centered)
-    hiOnItemRight,    // in the area to the right of a node's text area (e.g. if left aligned or centered)
-    hiOnNormalIcon,   // on the &quot;normal&quot; image
-    hiOnStateIcon,    // on the state image
-    hiToLeft,         // to the left of the client area (if relative) or the absolute tree area
-    hiToRight         // to the right of the client area (if relative) or the absolute tree area
-  );
-  THitPositions = set of THitPosition;
-
-  TCheckType = (
-    ctNone,
-    ctTriStateCheckBox,
-    ctCheckBox,
-    ctRadioButton,
-    ctButton
-  );
-
-  // The check states include both, transient and fluent (temporary) states. The only temporary state defined so
-  // far is the pressed state.
-  TCheckState = (
-    csUncheckedNormal,  // unchecked and not pressed
-    csUncheckedPressed, // unchecked and pressed
-    csCheckedNormal,    // checked and not pressed
-    csCheckedPressed,   // checked and pressed
-    csMixedNormal,      // 3-state check box and not pressed
-    csMixedPressed      // 3-state check box and pressed
-  );
-
-  TCheckImageKind = (
-    ckLightCheck,     // gray cross
-    ckDarkCheck,      // black cross
-    ckLightTick,      // gray tick mark
-    ckDarkTick,       // black tick mark
-    ckFlat,           // flat images (no 3D border)
-    ckXP,             // Windows XP style
-    ckCustom,         // application defined check images
-    ckSystem,         // System defined check images.
-    ckSystemFlat      // Flat system defined check images.
-  );
-
-  // mode to describe a move action
-  TVTNodeAttachMode = (
-    amNoWhere,        // just for simplified tests, means to ignore the Add/Insert command
-    amInsertBefore,   // insert node just before destination (as sibling of destination)
-    amInsertAfter,    // insert node just after destionation (as sibling of destination)
-    amAddChildFirst,  // add node as first child of destination
-    amAddChildLast    // add node as last child of destination
-  );
-
-  // modes to determine drop position further
-  TDropMode = (
-    dmNowhere,
-    dmAbove,
-    dmOnNode,
-    dmBelow
-  );
-
-  // operations basically allowed during drag'n drop
-  TDragOperation = (
-    doCopy,
-    doMove,
-    doLink
-  );
-  TDragOperations = set of TDragOperation;
-
-  TVTImageKind = (
-    ikNormal,
-    ikSelected,
-    ikState,
-    ikOverlay
-  );
-
-  TVTHintMode = (
-    hmDefault,            // show the hint of the control
-    hmHint,               // show node specific hint string returned by the application
-    hmHintAndDefault,     // same as hmHint but show the control's hint if no node is concerned
-    hmTooltip             // show the text of the node if it isn't already fully shown
-  );
-
-  TMouseButtons = set of TMouseButton;
-
-  // Used to describe the action to do when using the OnBeforeItemErase event.
-  TItemEraseAction = (
-    eaColor,   // use the provided color to erase the background instead the one of the tree
-    eaDefault  // the tree should erase the item's background (bitmap or solid)
-  );
-
-  
-  // There is a heap of switchable behavior in the tree. Since published properties may never exceed 4 bytes,
-  // which limits sets to at most 32 members, and because for better overview tree options are splitted
-  // in various sub-options and are held in a commom options class.
-  //
-  // Options to customize tree appearance:
-  TVTPaintOption = (
-    toHideFocusRect,           // Avoid drawing the dotted rectangle around the currently focused node.
-    toHideSelection,           // Selected nodes are drawn as unselected nodes if the tree is unfocused.
-    toHotTrack,                // Track which node is under the mouse cursor.
-    toPopupMode,               // Paint tree as would it always have the focus (useful for tree combo boxes etc.)
-    toShowBackground,          // Use the background image if there's one.
-    toShowButtons,             // Display collapse/expand buttons left to a node.
-    toShowDropmark,            // Show the dropmark during drag'n drop operations.
-    toShowHorzGridLines,       // Display horizontal lines to simulate a grid.
-    toShowRoot,                // Show lines also at top level (does not show the hidden/internal root node).
-    toShowTreeLines,           // Display tree lines to show hierarchy of nodes.
-    toShowVertGridLines,       // Display vertical lines (depending on columns) to simulate a grid.
-    toThemeAware,              // Draw UI elements (header, tree buttons etc.) according to the current theme if
-                               // enabled (Windows XP+ only, application must be themed).
-    toUseBlendedImages,        // Enable alpha blending for ghosted nodes or those which are being cut/copied.
-    toGhostedIfUnfocused       // Ghosted images are still shown as ghosted if unfocused (otherwise the become non-ghosted
-                               // images). 
-  );
-  TVTPaintOptions = set of TVTPaintOption;
-
-  // Options to toggle animation support:
-  TVTAnimationOption = (
-    toAnimatedToggle           // Expanding and collapsing a node is animated (quick window scroll).
-  );
-  TVTAnimationOptions = set of TVTAnimationOption;
-
-  // Options which toggle automatic handling of certain situations:
-  TVTAutoOption = (
-    toAutoDropExpand,          // Expand node if it is the drop target for more than certain time.
-    toAutoExpand,              // Nodes are expanded (collapsed) when getting (losing) the focus.
-    toAutoScroll,              // Scroll if mouse is near the border while dragging or selecting.
-    toAutoScrollOnExpand,      // Scroll as many child nodes in view as possible after expanding a node.
-    toAutoSort,                // Sort tree when Header.SortColumn or Header.SortDirection change or sort node if
-                               // child nodes are added.
-    toAutoSpanColumns,         // Large entries continue into next column(s) if there's no text in them (no clipping).
-    toAutoTristateTracking,    // Checkstates are automatically propagated for tri state check boxes.
-    toAutoHideButtons,         // Node buttons are hidden when there are child nodes, but all are invisible.
-    toAutoDeleteMovedNodes,    // Delete nodes which where moved in a drag operation (if not directed otherwise).
-    toDisableAutoscrollOnFocus,// Disable scrolling a column entirely into view if it gets focused.
-    toAutoChangeScale,         // Change default node height automatically if the system's font scale is set to big fonts.
-    toAutoFreeOnCollapse       // Frees any child node after a node has been collapsed (HasChildren flag stays there). 
-  );
-  TVTAutoOptions = set of TVTAutoOption;
-
-  // Options which determine the tree's behavior when selecting nodes:
-  TVTSelectionOption = (
-    toDisableDrawSelection,    // Prevent user from selecting with the selection rectangle in multiselect mode.
-    toExtendedFocus,           // Entries other than in the main column can be selected, edited etc.
-    toFullRowSelect,           // Hit test as well as selection highlight are not constrained to the text of a node.
-    toLevelSelectConstraint,   // Constrain selection to the same level as the selection anchor.
-    toMiddleClickSelect,       // Allow selection, dragging etc. with the middle mouse button. This and toWheelPanning
-                               // are mutual exclusive.
-    toMultiSelect,             // Allow more than one node to be selected.
-    toRightClickSelect,        // Allow selection, dragging etc. with the right mouse button.
-    toSiblingSelectConstraint, // constrain selection to nodes with same parent
-    toCenterScrollIntoView     // Center nodes vertically in the client area when scrolling into view.
-  );
-  TVTSelectionOptions = set of TVTSelectionOption;
-
-  // Options which do not fit into any of the other groups:
-  TVTMiscOption = (
-    toAcceptOLEDrop,           // Register tree as OLE accepting drop target
-    toCheckSupport,            // Show checkboxes/radio buttons.
-    toEditable,                // Node captions can be edited.
-    toFullRepaintOnResize,     // Fully invalidate the tree when its window is resized (CS_HREDRAW/CS_VREDRAW).
-    toGridExtensions,          // Use some special enhancements to simulate and support grid behavior.
-    toInitOnSave,              // Initialize nodes when saving a tree to a stream.
-    toReportMode,              // Tree behaves like TListView in report mode.
-    toToggleOnDblClick,        // Toggle node expansion state when it is double clicked.
-    toWheelPanning,            // Support for mouse panning (wheel mice only). This option and toMiddleClickSelect are
-                               // mutal exclusive, where panning has precedence.
-    toReadOnly                 // The tree does not allow to be modified in any way. No action is executed and
-                               // node editing is not possible.
-  );
-  TVTMiscOptions = set of TVTMiscOption;
-
-const
-  DefaultPaintOptions = [toShowButtons, toShowButtons, toShowDropmark, toShowTreeLines, toShowRoot, toThemeAware,
-    toUseBlendedImages];
-  DefaultAnimationOptions = [];
-  DefaultAutoOptions = [toAutoDropExpand, toAutoTristateTracking, toAutoScrollOnExpand, toAutoDeleteMovedNodes];
-  DefaultSelectionOptions = [];
-  DefaultMiscOptions = [toAcceptOLEDrop, toFullRepaintOnResize, toInitOnSave, toToggleOnDblClick, toWheelPanning];
-  DefaultColumnOptions = [coAllowClick, coDraggable, coEnabled, coParentColor, coParentBidiMode, coResizable,
-    coShowDropmark, coVisible];
-
-type
-  TBaseVirtualTree = class;
-  TVirtualTreeClass = class of TBaseVirtualTree;
-
-  PVirtualNode = ^TVirtualNode;
-
-  TColumnIndex = type Integer;
-  TColumnPosition = type Cardinal;
-
-  // This record must already be defined here and not later because otherwise BCB users will not be able
-  // to compile (conversion done by BCB is wrong).
-  TCacheEntry = record
-    Node: PVirtualNode;
-    AbsoluteTop: Cardinal;
-  end;
-
-  TCache = array of TCacheEntry;
-  TNodeArray = array of PVirtualNode;
-
-  TCustomVirtualTreeOptions = class(TPersistent)
-  private
-    FOwner: TBaseVirtualTree;
-    FPaintOptions: TVTPaintOptions;                           
-    FAnimationOptions: TVTAnimationOptions;
-    FAutoOptions: TVTAutoOptions;
-    FSelectionOptions: TVTSelectionOptions;
-    FMiscOptions: TVTMiscOptions;
-    procedure SetAnimationOptions(const Value: TVTAnimationOptions);
-    procedure SetAutoOptions(const Value: TVTAutoOptions);
-    procedure SetMiscOptions(const Value: TVTMiscOptions);
-    procedure SetPaintOptions(const Value: TVTPaintOptions);
-    procedure SetSelectionOptions(const Value: TVTSelectionOptions);
-  protected
-    property AnimationOptions: TVTAnimationOptions read FAnimationOptions write SetAnimationOptions
-      default DefaultAnimationOptions;
-    property AutoOptions: TVTAutoOptions read FAutoOptions write SetAutoOptions default DefaultAutoOptions;
-    property MiscOptions: TVTMiscOptions read FMiscOptions write SetMiscOptions default DefaultMiscOptions;
-    property PaintOptions: TVTPaintOptions read FPaintOptions write SetPaintOptions default DefaultPaintOptions;
-    property SelectionOptions: TVTSelectionOptions read FSelectionOptions write SetSelectionOptions
-      default DefaultSelectionOptions;
-  public
-    constructor Create(AOwner: TBaseVirtualTree); virtual;
-
-    procedure AssignTo(Dest: TPersistent); override;
-
-    property Owner: TBaseVirtualTree read FOwner;
-  end;
-
-  TTreeOptionsClass = class of TCustomVirtualTreeOptions;
-  
-  TVirtualTreeOptions = class(TCustomVirtualTreeOptions)
-  published
-    property AnimationOptions;
-    property AutoOptions;
-    property MiscOptions;
-    property PaintOptions;
-    property SelectionOptions;
-  end;
-
-  // Used in the CF_VTREFERENCE clipboard format.
-  PVTReference = ^TVTReference;
-  TVTReference = record
-    Process: Cardinal;
-    Tree: TBaseVirtualTree;
-  end;
-                  
-  TVirtualNode = packed record
-    Index,                   // index of node with regard to its parent
-    ChildCount: Cardinal;    // number of child nodes
-    NodeHeight: Word;        // height in pixels
-    States: TVirtualNodeStates; // states describing various properties of the node (expanded, initialized etc.)
-    Align: Byte;             // line/button alignment
-    CheckState: TCheckState; // indicates the current check state (e.g. checked, pressed etc.)
-    CheckType: TCheckType;   // indicates which check type shall be used for this node
-    Dummy: Byte;             // dummy value to fill DWORD boundary 
-    TotalCount,              // sum of this node, all of its child nodes and their child nodes etc.
-    TotalHeight: Cardinal;   // height in pixels this node covers on screen including the height of all of its
-                             // children
-    // Note: Some copy routines require that all pointers (as well as the data area) in a node are
-    //       located at the end of the node! Hence if you want to add new member fields (except pointers to internal
-    //       data) then put them before field Parent.
-    Parent,                  // reference to the node's parent (for the root this contains the treeview)
-    PrevSibling,             // link to the node's previous sibling or nil if it is the first node
-    NextSibling,             // link to the node's next sibling or nil if it is the last node
-    FirstChild,              // link to the node's first child...
-    LastChild: PVirtualNode; // link to the node's last child...
-    Data: record end;        // this is a placeholder, each node gets extra data determined by NodeDataSize
-  end;
-
-  // TVTNodeMemoryManager is a high-performance local memory manager for allocating TVirtualNode structures.
-  // It is not thread-safe in itself, because it assumes that the virtual tree is being used within a single
-  // thread. The local memory manager supports only fixed-length allocation requests - all requests must be of
-  // the same size. The performance improvements are a result of TVTNodeMemoryManager getting 16K blocks
-  // of memory from the Delphi memory manager and then managing them in a highly efficient manner.
-  // A consequence is that node memory allocations/deallocations are not visible to memory debugging tools.
-  //
-  // The local memory manager is disabled by default - to enable it {$define UseLocalMemoryManager}. For smaller trees,
-  // say less than 10,000 nodes, there is really no major performance benefit in using the local memory manager.
-  {$ifdef UseLocalMemoryManager}
-    TVTNodeMemoryManager = class
-    private
-      FAllocSize: Cardinal;       // The memory allocated for each node
-      FBlockList: TList;          // List of allocated blocks
-      FBytesAvailable: Cardinal;  // Bytes available in current block
-      FNext: PVirtualNode;        // Pointer to next available node in current block
-      FFreeSpace: PVirtualNode;   // Pointer to free space chain
-    public
-      constructor Create;
-      destructor Destroy; override;
-
-      function AllocNode(const Size: Cardinal): PVirtualNode;
-      procedure FreeNode(const Node: PVirtualNode);
-      procedure Clear;
-    end;
-  {$endif UseLocalMemoryManager}
-
-  // structure used when info about a certain position in the tree is needed
-  THitInfo = record
-    HitNode: PVirtualNode;
-    HitPositions: THitPositions;
-    HitColumn: TColumnIndex;
-  end;
-
-  // auto scroll directions
-  TScrollDirections = set of (
-    sdLeft,
-    sdUp,
-    sdRight,
-    sdDown
-  );
-
-  // OLE drag'n drop support
-  TFormatEtcArray = array of TFormatEtc;
-  TFormatArray = array of Word;
-
-  // IDataObject.SetData support
-  TInternalStgMedium = packed record
-    Format: TClipFormat;
-    Medium: TStgMedium;
-  end;
-  TInternalStgMediumArray = array of TInternalStgMedium;
-
-  TEnumFormatEtc = class(TInterfacedObject, IEnumFormatEtc)
-  private
-    FTree: TBaseVirtualTree;
-    FFormatEtcArray: TFormatEtcArray;
-    FCurrentIndex: Integer;
-  public
-    constructor Create(Tree: TBaseVirtualTree; AFormatEtcArray: TFormatEtcArray);
-
-    function Clone(out Enum: IEnumFormatEtc): HResult; stdcall;
-    function Next(celt: Integer; out elt; pceltFetched: PLongint): HResult; stdcall;
-    function Reset: HResult; stdcall;
-    function Skip(celt: Integer): HResult; stdcall;
-  end;
-
-  // ----- OLE drag'n drop handling
-  IDropTargetHelper = interface(IUnknown)
-    [SID_IDropTargetHelper]
-    function DragEnter(hwndTarget: HWND; pDataObject: IDataObject; var ppt: TPoint; dwEffect: Integer): HRESULT; stdcall;
-    function DragLeave: HRESULT; stdcall;
-    function DragOver(var ppt: TPoint; dwEffect: Integer): HRESULT; stdcall;
-    function Drop(pDataObject: IDataObject; var ppt: TPoint; dwEffect: Integer): HRESULT; stdcall;
-    function Show(fShow: Boolean): HRESULT; stdcall;
-  end;
-
-  PSHDragImage = ^TSHDragImage;
-  TSHDragImage = packed record
-    sizeDragImage: TSize;
-    ptOffset: TPoint;
-    hbmpDragImage: HBITMAP;
-    ColorRef: TColorRef;
-  end;
-
-  IDragSourceHelper = interface(IUnknown)
-    [SID_IDragSourceHelper]
-    function InitializeFromBitmap(var SHDragImage: TSHDragImage; pDataObject: IDataObject): HRESULT; stdcall;
-    function InitializeFromWindow(Window: HWND; var ppt: TPoint; pDataObject: IDataObject): HRESULT; stdcall;
-  end;
-
-  IVTDragManager = interface(IUnknown)
-    ['{C4B25559-14DA-446B-8901-0C879000EB16}']
-    procedure ForceDragLeave; stdcall;
-    function GetDataObject: IDataObject; stdcall;
-    function GetDragSource: TBaseVirtualTree; stdcall;
-    function GetDropTargetHelperSupported: Boolean; stdcall;
-    function GetIsDropTarget: Boolean; stdcall;
-
-    property DataObject: IDataObject read GetDataObject;
-    property DragSource: TBaseVirtualTree read GetDragSource;
-    property DropTargetHelperSupported: Boolean read GetDropTargetHelperSupported;
-    property IsDropTarget: Boolean read GetIsDropTarget;
-  end;
-
-  // This data object is used in two different places. One is for clipboard operations and the other while dragging.
-  TVTDataObject = class(TInterfacedObject, IDataObject)
-  private
-    FOwner: TBaseVirtualTree;          // The tree which provides clipboard or drag data.
-    FForClipboard: Boolean;            // Determines which data to render with GetData.
-    FFormatEtcArray: TFormatEtcArray;
-    FInternalStgMediumArray: TInternalStgMediumArray;  // The available formats in the DataObject
-    FAdviseHolder: IDataAdviseHolder;  // Reference to an OLE supplied implementation for advising.
-  protected
-    function CanonicalIUnknown(TestUnknown: IUnknown): IUnknown;
-    function EqualFormatEtc(FormatEtc1, FormatEtc2: TFormatEtc): Boolean;
-    function FindFormatEtc(TestFormatEtc: TFormatEtc; const FormatEtcArray: TFormatEtcArray): integer;
-    function FindInternalStgMedium(Format: TClipFormat): PStgMedium;
-    function HGlobalClone(HGlobal: THandle): THandle;
-    function RenderInternalOLEData(const FormatEtcIn: TFormatEtc; var Medium: TStgMedium; var OLEResult: HResult): Boolean;
-    function StgMediumIncRef(const InStgMedium: TStgMedium; var OutStgMedium: TStgMedium;
-      CopyInMedium: Boolean; DataObject: IDataObject): HRESULT;
-
-    property ForClipboard: Boolean read FForClipboard;
-    property FormatEtcArray: TFormatEtcArray read FFormatEtcArray write FFormatEtcArray;
-    property InternalStgMediumArray: TInternalStgMediumArray read FInternalStgMediumArray write FInternalStgMediumArray;
-    property Owner: TBaseVirtualTree read FOwner;
-  public
-    constructor Create(AOwner: TBaseVirtualTree; ForClipboard: Boolean); virtual;
-    destructor Destroy; override;
-
-    function DAdvise(const FormatEtc: TFormatEtc; advf: Integer; const advSink: IAdviseSink; out dwConnection: Integer):
-      HResult; virtual; stdcall;
-    function DUnadvise(dwConnection: Integer): HResult; virtual; stdcall;
-    function EnumDAdvise(out enumAdvise: IEnumStatData): HResult; virtual; stdcall;
-    function EnumFormatEtc(Direction: Integer; out EnumFormatEtc: IEnumFormatEtc): HResult; virtual; stdcall;
-    function GetCanonicalFormatEtc(const FormatEtc: TFormatEtc; out FormatEtcOut: TFormatEtc): HResult; virtual; stdcall;
-    function GetData(const FormatEtcIn: TFormatEtc; out Medium: TStgMedium): HResult; virtual; stdcall;
-    function GetDataHere(const FormatEtc: TFormatEtc; out Medium: TStgMedium): HResult; virtual; stdcall;
-    function QueryGetData(const FormatEtc: TFormatEtc): HResult; virtual; stdcall;
-    function SetData(const FormatEtc: TFormatEtc; var Medium: TStgMedium; DoRelease: BOOL): HResult; virtual; stdcall;
-  end;
-
-  // TVTDragManager is a class to manage drag and drop in a Virtual Treeview.
-  TVTDragManager = class(TInterfacedObject, IVTDragManager, IDropSource, IDropTarget)
-  private
-    FOwner,                            // The tree which is responsible for drag management.
-    FDragSource: TBaseVirtualTree;     // Reference to the source tree if the source was a VT, might be different than
-                                       // the owner tree.
-    FIsDropTarget: Boolean;            // True if the owner is currently the drop target.
-    FDataObject: IDataObject;          // A reference to the data object passed in by DragEnter (only used when the owner
-                                       // tree is the current drop target).
-    FDropTargetHelper: IDropTargetHelper; // Win2k &gt; Drag image support
-    FFullDragging: BOOL;               // True, if full dragging is currently enabled in the system.
-
-    function GetDataObject: IDataObject; stdcall;
-    function GetDragSource: TBaseVirtualTree; stdcall;
-    function GetDropTargetHelperSupported: Boolean; stdcall;
-    function GetIsDropTarget: Boolean; stdcall;
-  public
-    constructor Create(AOwner: TBaseVirtualTree); virtual;
-    destructor Destroy; override;
-
-    function DragEnter(const DataObject: IDataObject; KeyState: Integer; Pt: TPoint;
-      var Effect: Integer): HResult; stdcall;
-    function DragLeave: HResult; stdcall;
-    function DragOver(KeyState: Integer; Pt: TPoint; var Effect: Integer): HResult; stdcall;
-    function Drop(const DataObject: IDataObject; KeyState: Integer; Pt: TPoint; var Effect: Integer): HResult; stdcall;
-    procedure ForceDragLeave; stdcall;
-    function GiveFeedback(Effect: Integer): HResult; stdcall;
-    function QueryContinueDrag(EscapePressed: BOOL; KeyState: Integer): HResult; stdcall;
-  end;
-
-  PVTHintData = ^TVTHintData;
-  TVTHintData = record
-    Tree: TBaseVirtualTree;
-    Node: PVirtualNode;
-    Column: TColumnIndex;
-    HintRect: TRect;         // used for draw trees only, string trees get the size from the hint string
-    DefaultHint: WideString; // used only if there is no node specific hint string available
-                             // or a header hint is about to appear
-    HintText: WideString;    // set when size of the hint window is calculated
-    BidiMode: TBidiMode;
-    Alignment: TAlignment;
-  end;
-
-  // Determines the kind of animation when a hint is activated.
-  THintAnimationType = (
-    hatNone,                 // no animation at all, just display hint/tooltip
-    hatFade,                 // fade in the hint/tooltip, like in Windows 2000
-    hatSlide,                // slide in the hint/tooltip, like in Windows 98
-    hatSystemDefault         // use what the system is using (slide for Win9x, slide/fade for Win2K+, depends on settings)
-  );
-
-  // The trees need an own hint window class because of Unicode output and adjusted font.
-  TVirtualTreeHintWindow = class(THintWindow)
-  private
-    FHintData: TVTHintData;
-    FBackground,
-    FDrawBuffer,
-    FTarget: TBitmap;
-    FTextHeight: Integer;
-    function AnimationCallback(Step, StepSize: Integer; Data: Pointer): Boolean;
-    procedure InternalPaint(Step, StepSize: Integer);
-    procedure CMTextChanged(var Message: TMessage); message CM_TEXTCHANGED;
-    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
-    procedure WMNCPaint(var Message: TMessage); message WM_NCPAINT;
-    procedure WMShowWindow(var Message: TWMShowWindow); message WM_SHOWWINDOW;
-  protected
-    procedure CreateParams(var Params: TCreateParams); override;
-
-    procedure Paint; override;
-  public
-    constructor Create(AOwner: TComponent); override;
-    destructor Destroy; override;
-
-    procedure ActivateHint(Rect: TRect; const AHint: string); override;
-    function CalcHintRect(MaxWidth: Integer; const AHint: string; AData: Pointer): TRect; override;
-    function IsHintMsg(var Msg: TMsg): Boolean; override;
-  end;
-
-  // Drag image support for the tree.
-  TVTTransparency = 0..255;
-  TVTBias = -128..127;
-
-  // Simple move limitation for the drag image.
-  TVTDragMoveRestriction = (
-    dmrNone,
-    dmrHorizontalOnly,
-    dmrVerticalOnly
-  );
-
-  TVTDragImageStates = set of (
-    disHidden,          // Internal drag image is currently hidden (always hidden if drag image helper interfaces are used).
-    disInDrag,          // Drag image class is currently being used.
-    disPrepared,        // Drag image class is prepared.
-    disSystemSupport    // Running on Windows 2000 or higher. System supports drag images natively.
-  );
-
-  // Class to manage header and tree drag image during a drag'n drop operation.
-  TVTDragImage = class
-  private
-    FOwner: TBaseVirtualTree;
-    FBackImage,                        // backup of overwritten screen area
-    FAlphaImage,                       // target for alpha blending
-    FDragImage: TBitmap;               // the actual drag image to blend to screen
-    FImagePosition,                    // position of image (upper left corner) in screen coordinates
-    FLastPosition: TPoint;             // last mouse position in screen coordinates
-    FTransparency: TVTTransparency;    // alpha value of the drag image (0 - fully transparent, 255 - fully opaque)
-    FPreBlendBias,                     // value to darken or lighten the drag image before it is blended
-    FPostBlendBias: TVTBias;           // value to darken or lighten the alpha blend result
-    FFade: Boolean;                    // determines whether to fade the drag image from center to borders or not
-    FRestriction: TVTDragMoveRestriction;  // determines in which directions the drag image can be moved
-    FColorKey: TColor;                 // color to make fully transparent regardless of any other setting
-    FStates: TVTDragImageStates;       // Determines the states of the drag image class.
-    function GetVisible: Boolean;      // True if the drag image is currently hidden (used only when dragging)
-  protected
-    procedure InternalShowDragImage(ScreenDC: HDC);
-    procedure MakeAlphaChannel(Source, Target: TBitmap);
-  public
-    constructor Create(AOwner: TBaseVirtualTree);
-    destructor Destroy; override;
-
-    function DragTo(P: TPoint; ForceRepaint: Boolean): Boolean;
-    procedure EndDrag;
-    function GetDragImageRect: TRect;
-    procedure HideDragImage;
-    procedure PrepareDrag(DragImage: TBitmap; ImagePosition, HotSpot: TPoint; const DataObject: IDataObject);
-    procedure RecaptureBackground(Tree: TBaseVirtualTree; R: TRect; VisibleRegion: HRGN; CaptureNCArea,
-      ReshowDragImage: Boolean);
-    procedure ShowDragImage;
-    function WillMove(P: TPoint): Boolean;
-
-    property ColorKey: TColor read FColorKey write FColorKey default clWindow;
-    property Fade: Boolean read FFade write FFade default False;
-    property MoveRestriction: TVTDragMoveRestriction read FRestriction write FRestriction default dmrNone;
-    property PostBlendBias: TVTBias read FPostBlendBias write FPostBlendBias default 0;
-    property PreBlendBias: TVTBias read FPreBlendBias write FPreBlendBias default 0;
-    property Transparency: TVTTransparency read FTransparency write FTransparency default 128;
-    property Visible: Boolean read GetVisible;
-  end;
-
-  // tree columns implementation
-  TVirtualTreeColumns = class;
-  TVTHeader = class;
-
-  TVirtualTreeColumnStyle = (
-    vsText,
-    vsOwnerDraw
-  );
-
-  {$ifndef COMPILER_5_UP}
-    TImageIndex = Integer;
-  {$endif COMPILER_5_UP}
-
-  TVTHeaderColumnLayout = (
-    blGlyphLeft,
-    blGlyphRight,
-    blGlyphTop,
-    blGlyphBottom
-  );
-
-  TVirtualTreeColumn = class(TCollectionItem)
-  private
-    FText,
-    FHint: WideString;
-    FLeft,
-    FWidth: Integer;
-    FPosition: TColumnPosition;
-    FMinWidth: Integer;
-    FMaxWidth: Integer;
-    FStyle: TVirtualTreeColumnStyle;
-    FImageIndex: TImageIndex;
-    FBiDiMode: TBiDiMode;
-    FLayout: TVTHeaderColumnLayout;
-    FMargin,
-    FSpacing: Integer;
-    FOptions: TVTColumnOptions;
-    FTag: Integer;
-    FAlignment: TAlignment;
-    FLastWidth: Integer;
-    FColor: TColor;
-    function GetLeft: Integer;
-    function IsBiDiModeStored: Boolean;
-    function IsColorStored: Boolean;
-    procedure SetAlignment(const Value: TAlignment);
-    procedure SetBiDiMode(Value: TBiDiMode);
-    procedure SetColor(const Value: TColor);
-    procedure SetImageIndex(Value: TImageIndex);
-    procedure SetLayout(Value: TVTHeaderColumnLayout);
-    procedure SetMargin(Value: Integer);
-    procedure SetMaxWidth(Value: Integer);
-    procedure SetMinWidth(Value: Integer);
-    procedure SetOptions(Value: TVTColumnOptions);
-    procedure SetPosition(Value: TColumnPosition);
-    procedure SetSpacing(Value: Integer);
-    procedure SetStyle(Value: TVirtualTreeColumnStyle);
-    procedure SetText(const Value: WideString);
-    procedure SetWidth(Value: Integer);
-  protected
-    procedure ComputeHeaderLayout(DC: HDC; const Client: TRect; UseHeaderGlyph, UseSortGlyph: Boolean;
-      var HeaderGlyphPos, SortGlyphPos: TPoint; var TextBounds: TRect);
-    procedure DefineProperties(Filer: TFiler); override;
-    procedure GetAbsoluteBounds(var Left, Right: Integer);
-    function GetDisplayName: string; override;
-    function GetOwner: TVirtualTreeColumns; reintroduce;
-    procedure ReadHint(Reader: TReader);
-    procedure ReadText(Reader: TReader);
-    procedure SetIndex(Value: Integer); override;
-    procedure WriteHint(Writer: TWriter);
-    procedure WriteText(Writer: TWriter);
-  public
-    constructor Create(Collection: TCollection); override;
-    destructor Destroy; override;
-
-    procedure Assign(Source: TPersistent); override;
-    function Equals(OtherColumn: TVirtualTreeColumn): Boolean; virtual;
-    function GetRect: TRect;
-    procedure LoadFromStream(const Stream: TStream; Version: Integer);
-    procedure ParentBiDiModeChanged;
-    procedure ParentColorChanged;
-    procedure RestoreLastWidth;
-    procedure SaveToStream(const Stream: TStream);
-    function UseRightToLeftReading: Boolean;
-
-    property Left: Integer read GetLeft;
-    property Owner: TVirtualTreeColumns read GetOwner;
-  published
-    property Alignment: TAlignment read FAlignment write SetAlignment default taLeftJustify;
-    property BiDiMode: TBiDiMode read FBiDiMode write SetBiDiMode stored IsBiDiModeStored default bdLeftToRight;
-    property Color: TColor read FColor write SetColor stored IsColorStored default clWindow;
-    property Hint: WideString read FHint write FHint stored False;
-    property ImageIndex: TImageIndex read FImageIndex write SetImageIndex default -1;
-    property Layout: TVTHeaderColumnLayout read FLayout write SetLayout default blGlyphLeft;
-    property Margin: Integer read FMargin write SetMargin default 4;
-    property MaxWidth: Integer read FMaxWidth write SetMaxWidth default 10000;
-    property MinWidth: Integer read FMinWidth write SetMinWidth default 10;
-    property Options: TVTColumnOptions read FOptions write SetOptions default DefaultColumnOptions;
-    property Position: TColumnPosition read FPosition write SetPosition;
-    property Spacing: Integer read FSpacing write SetSpacing default 4;
-    property Style: TVirtualTreeColumnStyle read FStyle write SetStyle default vsText;
-    property Tag: Integer read FTag write FTag default 0;
-    property Text: WideString read FText write SetText stored False; // Never let the VCL store the wide string,
-                                                                     // it is simply unable to write it correctly.
-                                                                     // We use DefineProperties here.
-    property Width: Integer read FWidth write SetWidth default 50;
-  end;
-
-  TVirtualTreeColumnClass = class of TVirtualTreeColumn;
-
-  TColumnsArray = array of TVirtualTreeColumn;
-  TCardinalArray = array of Cardinal;
-  TIndexArray = array of TColumnIndex;
-
-  TVirtualTreeColumns = class(TCollection)
-  private
-    FHeader: TVTHeader;
-    FHeaderBitmap: TBitmap;               // backbuffer for drawing
-    FHoverIndex,                          // currently &quot;hot&quot; column
-    FDownIndex,                           // Column on which a mouse button is held down.
-    FTrackIndex: TColumnIndex;            // Index of column which is currently being resized
-    FClickIndex: TColumnIndex;            // last clicked column
-    FPositionToIndex: TIndexArray;
-    FNeedPositionsFix: Boolean;           // True if FixPositions must still be called after DFM loading.
-    FClearing: Boolean;                   // True if columns are being deleted entirely.
-
-    // drag support
-    FDragIndex: TColumnIndex;             // index of column currently being dragged
-    FDropTarget: TColumnIndex;            // current target column (index) while dragging
-    FDropBefore: Boolean;                 // True if drop position is in the left half of a column, False for the right
-                                          // side to drop the dragged column to
-    procedure DrawButtonText(DC: HDC; Caption: WideString; Bounds: TRect; Enabled, Hot: Boolean; DrawFormat: Cardinal);
-    function GetItem(Index: TColumnIndex): TVirtualTreeColumn;
-    function GetNewIndex(P: TPoint; var OldIndex: TColumnIndex): Boolean;
-    procedure SetItem(Index: TColumnIndex; Value: TVirtualTreeColumn);
-  protected
-    procedure AdjustAutoSize(CurrentIndex: TColumnIndex; Force: Boolean = False);
-    function AdjustDownColumn(P: TPoint): TColumnIndex;
-    function AdjustHoverColumn(P: TPoint): Boolean;
-    procedure AdjustPosition(Column: TVirtualTreeColumn; Position: Cardinal);
-    procedure FixPositions;
-    function GetColumnAndBounds(P: TPoint; var ColumnLeft, ColumnRight: Integer; Relative: Boolean = True): Integer;
-    function GetOwner: TPersistent; override;
-    procedure HandleClick(P: TPoint; Button: TMouseButton; Force, DblClick: Boolean);
-    procedure IndexChanged(OldIndex, NewIndex: Integer);
-    procedure InitializePositionArray;
-    procedure Update(Item: TCollectionItem); override;
-    procedure UpdatePositions(Force: Boolean = False);
-
-    property HeaderBitmap: TBitmap read FHeaderBitmap;
-    property PositionToIndex: TIndexArray read FPositionToIndex;
-  public
-    constructor Create(AOwner: TVTHeader);
-    destructor Destroy; override;
-
-    function Add: TVirtualTreeColumn; virtual;
-    procedure AnimatedResize(Column: TColumnIndex; NewWidth: Integer);
-    procedure Assign(Source: TPersistent); override;
-    procedure Clear; virtual;
-    function ColumnFromPosition(P: TPoint; Relative: Boolean = True): TColumnIndex; overload; virtual;
-    function ColumnFromPosition(PositionIndex: TColumnPosition): TColumnIndex; overload; virtual;
-    function Equals(OtherColumns: TVirtualTreeColumns): Boolean;
-    procedure GetColumnBounds(Column: TColumnIndex; var Left, Right: Integer);
-    function GetFirstVisibleColumn: TColumnIndex;
-    function GetLastVisibleColumn: TColumnIndex;
-    function GetNextColumn(Column: TColumnIndex): TColumnIndex;
-    function GetNextVisibleColumn(Column: TColumnIndex): TColumnIndex;
-    function GetPreviousColumn(Column: TColumnIndex): TColumnIndex;
-    function GetPreviousVisibleColumn(Column: TColumnIndex): TColumnIndex;
-    function GetVisibleColumns: TColumnsArray;
-    function IsValidColumn(Column: TColumnIndex): Boolean;
-    procedure LoadFromStream(const Stream: TStream; Version: Integer);
-    procedure PaintHeader(DC: HDC; R: TRect; HOffset: Integer; VOffset: Integer = 0); virtual;
-    procedure SaveToStream(const Stream: TStream);
-    function TotalWidth: Integer;
-
-    property ClickIndex: TColumnIndex read FClickIndex;
-    property Items[Index: TColumnIndex]: TVirtualTreeColumn read GetItem write SetItem; default;
-    property Header: TVTHeader read FHeader;
-    property TrackIndex: TColumnIndex read FTrackIndex;
-  end;
-
-  TVirtualTreeColumnsClass = class of TVirtualTreeColumns;
-  
-  TVTHeaderStyle = (
-    hsThickButtons,    // TButton look and feel
-    hsFlatButtons,     // flatter look than hsThickButton, like an always raised flat TToolButton
-    hsPlates,          // flat TToolButton look and feel (raise on hover etc.)
-    hsXPStyle          // Windows XP style
-  );
-
-  TVTHeaderOption = (
-    hoAutoResize,      // adjust a column so that the header never exceeds client width of owner control
-    hoColumnResize,    // resizing columns is allowed
-    hoDblClickResize,  // allows a column to resize itself to its largest entry
-    hoDrag,            // dragging columns is allowed
-    hoHotTrack,        // header captions are highlighted when mouse is over a particular column
-    hoOwnerDraw,       // header items with the owner draw style can be drawn by the application via event
-    hoRestrictDrag,    // header can only be dragged horizontally
-    hoShowHint,        // show application defined header hint
-    hoShowImages,      // show images
-    hoShowSortGlyphs,  // allow visible sort glyphs
-    hoVisible          // header is visible
-  );
-  TVTHeaderOptions = set of TVTHeaderOption;
-
-  THeaderState = (
-    hsAutoSizing,      // auto size chain is in progess, do not trigger again on WM_SIZE
-    hsDragging,        // header dragging is in progress (only if enabled)
-    hsDragPending,     // left button is down, user might want to start dragging a column
-    hsLoading,         // The header currently loads from stream, so updates are not necessary.
-    hsTracking,        // column resizing is in progress
-    hsTrackPending     // left button is down, user might want to start resize a column
-  );
-  THeaderStates = set of THeaderState;
-
-  TSortDirection = (
-    sdAscending,
-    sdDescending
-  );
-
-  // desribes what made a structure change event happen
-  TChangeReason = (
-    crIgnore,       // used as placeholder
-    crAccumulated,  // used for delayed changes
-    crChildAdded,   // one or more child nodes have been added
-    crChildDeleted, // one or more child nodes have been deleted
-    crNodeAdded,    // a node has been added
-    crNodeCopied,   // a node has been duplicated
-    crNodeMoved     // a node has been moved to a new place
-  );
-
-  TVTHeader = class(TPersistent)
-  private
-    FOwner: TBaseVirtualTree;
-    FColumns: TVirtualTreeColumns;
-    FHeight: Cardinal;
-    FFont: TFont;
-    FOptions: TVTHeaderOptions;
-    FStates: THeaderStates;            // used to keep track of internal states the header can enter
-    FLeftTrackPos: Integer;            // left border of this column to quickly calculate its width on resize
-    FStyle: TVTHeaderStyle;            // button style
-    FBackground: TColor;
-    FAutoSizeIndex: TColumnIndex;
-    FPopupMenu: TPopupMenu;
-    FMainColumn: TColumnIndex;         // the column which holds the tree
-    FImages: TImageList;
-    FImageChangeLink: TChangeLink;     // connections to the image list to get notified about changes
-    FSortColumn: TColumnIndex;
-    FSortDirection: TSortDirection;
-    FTrackStart: TPoint;               // client coordinates of the tracking start point
-    FDragStart: TPoint;                // initial mouse drag position
-    FDragImage: TVTDragImage;          // drag image management during header drag
-    procedure FontChanged(Sender: TObject);
-    function GetMainColumn: TColumnIndex;
-    function GetUseColumns: Boolean;
-    procedure SetAutoSizeIndex(Value: TColumnIndex);
-    procedure SetBackground(Value: TColor);
-    procedure SetColumns(Value: TVirtualTreeColumns);
-    procedure SetFont(const Value: TFont);
-    procedure SetHeight(Value: Cardinal);
-    procedure SetImages(const Value: TImageList);
-    procedure SetMainColumn(Value: TColumnIndex);
-    procedure SetOptions(Value: TVTHeaderOptions);
-    procedure SetSortColumn(Value: TColumnIndex);
-    procedure SetSortDirection(const Value: TSortDirection);
-    procedure SetStyle(Value: TVTHeaderStyle);
-  protected
-    function CanWriteColumns: Boolean; virtual;
-    procedure ChangeScale(M, D: Integer); virtual;
-    function DetermineSplitterIndex(P: TPoint): Boolean; virtual;
-    procedure DragTo(P: TPoint);
-    function GetColumnsClass: TVirtualTreeColumnsClass; virtual;
-    function GetOwner: TPersistent; override;
-    function GetShiftState: TShiftState;
-    function HandleHeaderMouseMove(var Message: TWMMouseMove): Boolean;
-    function HandleMessage(var Message: TMessage): Boolean; virtual;
-    procedure ImageListChange(Sender: TObject);
-    procedure PrepareDrag(P, Start: TPoint);
-    procedure ReadColumns(Reader: TReader);
-    procedure RecalculateHeader; virtual;
-    procedure UpdateMainColumn;
-    procedure WriteColumns(Writer: TWriter);
-  public
-    constructor Create(AOwner: TBaseVirtualTree); virtual;
-    destructor Destroy; override;
-
-    procedure Assign(Source: TPersistent); override;
-    procedure AutoFitColumns;
-    function InHeader(P: TPoint): Boolean; virtual;
-    procedure Invalidate(Column: TVirtualTreeColumn; ExpandToRight: Boolean = False);
-    procedure LoadFromStream(const Stream: TStream); virtual;
-    procedure RestoreColumns;
-    procedure SaveToStream(const Stream: TStream); virtual;
-
-    property DragImage: TVTDragImage read FDragImage;
-    property States: THeaderStates read FStates;
-    property Treeview: TBaseVirtualTree read FOwner;
-    property UseColumns: Boolean read GetUseColumns;
-  published
-    property AutoSizeIndex: TColumnIndex read FAutoSizeIndex write SetAutoSizeIndex;
-    property Background: TColor read FBackground write SetBackground default clBtnFace;
-    property Columns: TVirtualTreeColumns read FColumns write SetColumns stored False; // Stored by the owner tree to
-                                                                                       // support VFI.
-    property Font: TFont read FFont write SetFont;
-    property Height: Cardinal read FHeight write SetHeight default 17;
-    property Images: TImageList read FImages write SetImages;
-    property MainColumn: TColumnIndex read GetMainColumn write SetMainColumn default 0;
-    property Options: TVTHeaderOptions read FOptions write SetOptions default [hoColumnResize, hoDrag, hoShowSortGlyphs];
-    property PopupMenu: TPopupMenu read FPopupMenu write FPopUpMenu;
-    property SortColumn: TColumnIndex read FSortColumn write SetSortColumn default NoColumn;
-    property SortDirection: TSortDirection read FSortDirection write SetSortDirection default sdAscending;
-    property Style: TVTHeaderStyle read FStyle write SetStyle default hsThickButtons;
-  end;
-
-  TVTHeaderClass = class of TVTHeader;
-
-  // Communication interface between a tree editor and the tree itself (declared as using stdcall in case it
-  // is implemented in a (C/C++) DLL). The GUID is not nessecary in Delphi but important for BCB users
-  // to allow QueryInterface and _uuidof calls.
-  IVTEditLink = interface
-    ['{2BE3EAFA-5ACB-45B4-9D9A-B58BCC496E17}']
-    function BeginEdit: Boolean; stdcall;                  // called when editing actually starts
-    function CancelEdit: Boolean; stdcall;                 // called when editing has been cancelled by the tree
-    function EndEdit: Boolean; stdcall;                    // called when editing has been finished by the tree
-    function PrepareEdit(Tree: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex): Boolean; stdcall;
-                                                           // called after creation to allow a setup
-    function GetBounds: TRect; stdcall;                    // called to get the current size of the edit window
-                                                           // (only important if the edit resizes itself)
-    procedure ProcessMessage(var Message: TMessage); stdcall;
-                                                           // used to forward messages to the edit window(s)
-    procedure SetBounds(R: TRect); stdcall;                // called to place the editor
-  end;
-
-  // Indicates in the OnUpdating event what state the tree is currently in.
-  TVTUpdateState = (
-    usBegin,       // The tree just entered the update state (BeginUpdate call for the first time).
-    usBeginSynch,  // The tree just entered the synch update state (BeginSynch call for the first time).
-    usSynch,       // Begin/EndSynch has been called but the tree did not change the update state.
-    usUpdate,      // Begin/EndUpdate has been called but the tree did not change the update state.
-    usEnd,         // The tree just left the update state (EndUpdate called for the last level).
-    usEndSynch     // The tree just left the synch update state (EndSynch called for the last level).
-  );
-
-  // Used during owner draw of the header to indicate which drop mark for the column must be drawn.
-  TVTDropMarkMode = (
-    dmmNone,
-    dmmLeft,
-    dmmRight
-  );
-
-  // This structure carries all important information about header painting and is used in the advanced header painting.
-  THeaderPaintInfo = record
-    TargetCanvas: TCanvas;
-    Column: TVirtualTreeColumn;
-    PaintRectangle: TRect;
-    TextRectangle: TRect;
-    IsHoverIndex,
-    IsDownIndex,
-    IsEnabled,
-    ShowHeaderGlyph,
-    ShowSortGlyph,
-    ShowRightBorder: Boolean;
-    DropMark: TVTDropMarkMode;
-    GlyphPos,
-    SortGlyphPos: TPoint;
-  end;
-
-  // These elements are used both to query the application, which of them it wants to draw itself and to tell it during
-  // painting, which elements must be drawn during the advanced custom draw events.
-  THeaderPaintElements = set of (
-    hpeBackground,
-    hpeDropMark,
-    hpeHeaderGlyph,
-    hpeSortGlyph,
-    hpeText
-  );
-
-  // Various events must be handled at different places than they were initiated or need
-  // a persistent storage until they are reset.
-  TVirtualTreeStates = set of (
-    tsChangePending,          // A selection change is pending.
-    tsCollapsing,             // A full collapse operation is in progress.
-    tsClearFocusedSelection,  // Node selection was modifed using Ctrl-click. Change selection state on next mouse up.
-    tsClearPending,           // Need to clear the current selection on next mouse move.
-    tsClipboardFlushing,      // Set during flushing the clipboard to avoid freeing the content.
-    tsCopyPending,            // Indicates a pending copy operation which needs to be finished.
-    tsCutPending,             // Indicates a pending cut operation which needs to be finished.
-    tsDrawSelPending,         // Multiselection only. User held down the left mouse button on a free
-                              // area and might want to start draw selection.
-    tsDrawSelecting,          // Multiselection only. Draw selection has actually started.
-    tsEditing,                // Indicates that an edit operation is currently in progress.
-    tsEditPending,            // An mouse up start edit if dragging has not started.
-    tsExpanding,              // A full expand operation is in progress.
-    tsHint,                   // Set when our hint is visible or soon will be.
-    tsInAnimation,            // Set if the tree is currently in an animation loop.
-    tsIncrementalSearching,   // Set when the user starts incremental search.
-    tsIncrementalSearchPending, // Set in WM_KEYDOWN to tell to use the char in WM_CHAR for incremental search.
-    tsIterating,              // Set when IterateSubtree is currently in progress.
-    tsKeyCheckPending,        // A check operation is under way, initiated by a key press (space key). Ignore mouse.
-    tsLeftButtonDown,         // Set when the left mouse button is down.
-    tsMouseCheckPending,      // A check operation is under way, initiated by a mouse click. Ignore space key.
-    tsMiddleButtonDown,       // Set when the middle mouse button is down.
-    tsNeedScale,              // On next ChangeScale scale the default node height.
-    tsNeedRootCountUpdate,    // Set if while loading a root node count is set.
-    tsOLEDragging,            // OLE dragging in progress.
-    tsOLEDragPending,         // User has requested to start delayed dragging.
-    tsPainting,               // The tree is currently painting itself.
-    tsRightButtonDown,        // Set when the right mouse button is down.
-    tsScrolling,              // Set when autoscrolling is active.
-    tsScrollPending,          // Set when waiting for the scroll delay time to elapse.
-    tsSizing,                 // Set when the tree window is being resized. This is used to prevent recursive calls
-                              // due to setting the scrollbars when sizing.
-    tsStopValidation,         // Cache validation can be stopped (usually because a change has occured meanwhile).
-    tsStructureChangePending, // The structure of the tree has been changed while the update was locked.
-    tsSynchMode,              // Set when the tree is in synch mode, where no timer events are triggered.
-    tsThumbTracking,          // Stop updating the horizontal scroll bar while dragging the vertical thumb and vice versa.
-    tsUpdateHiddenChildrenNeeded, // Pending update for the hidden children flag after massive visibility changes.
-    tsUpdating,               // The tree does currently not update its window because a BeginUpdate has not yet ended.
-    tsUseCache,               // The tree's node caches are validated and non-empty.
-    tsUserDragObject,         // Signals that the application created an own drag object in OnStartDrag.
-    tsUseThemes,              // The tree runs under WinXP+, is theme aware and themes are enabled.
-    tsValidating,             // The tree's node caches are currently validated.
-    tsValidationNeeded,       // Something in the structure of the tree has changed. The cache needs validation.
-    tsVCLDragging,            // VCL drag'n drop in progress.
-    tsVCLDragPending,         // One-shot flag to avoid clearing the current selection on implicit mouse up for VCL drag.
-    tsWheelPanning,           // Wheel mouse panning is active or soon will be.
-    tsWheelScrolling,         // Wheel mouse scrolling is active or soon will be.
-    tsWindowCreating          // set during window handle creation to avoid frequent unnecessary updates
-  );
-
-  TChangeStates = set of (
-    csStopValidation,         // Cache validation can be stopped (usually because a change has occured meanwhile).
-    csUseCache,               // The tree's node caches are validated and non-empty.
-    csValidating,             // The tree's node caches are currently validated.
-    csValidationNeeded        // Something in the structure of the tree has changed. The cache needs validation.
-  );
-
-  // determines whether and how the drag image is to show
-  TVTDragImageKind = (
-    diComplete,       // show a complete drag image with all columns, only visible columns are shown
-    diMainColumnOnly, // show only the main column (the tree column)
-    diNoImage         // don't show a drag image at all
-  );
-
-  // Switch for OLE and VCL drag'n drop. Because it is not possible to have both simultanously.
-  TVTDragType = (
-    dtOLE,
-    dtVCL
-  );
-
-  // options which determine what to draw in PaintTree
-  TVTInternalPaintOption = (
-    poBackground,       // draw background image if there is any and it is enabled
-    poColumnColor,      // erase node's background with the column's color
-    poDrawFocusRect,    // draw focus rectangle around the focused node
-    poDrawSelection,    // draw selected nodes with the normal selection color
-    poDrawDropMark,     // draw drop mark if a node is currently the drop target
-    poGridLines,        // draw grid lines if enabled
-    poMainOnly,         // draw only the main column
-    poSelectedOnly      // draw only selected nodes
-  );
-  TVTInternalPaintOptions = set of TVTInternalPaintOption;
-
-  // Determines the look of a tree's lines.
-  TVTLineStyle = (
-    lsCustomStyle,           // application provides a line pattern
-    lsDotted,                // usual dotted lines (default)
-    lsSolid                  // simple solid lines
-  );
-
-  // TVTLineType is used during painting a tree
-  TVTLineType = (
-    ltNone,          // no line at all
-    ltBottomRight,   // a line from bottom to the center and from there to the right
-    ltTopDown,       // a line from top to bottom
-    ltTopDownRight,  // a line from top to bottom and from center to the right
-    ltRight,         // a line from center to the right
-    ltTopRight,      // a line from bottom to center and from there to the right
-    // special styles for alternative drawings of tree lines
-    ltLeft,          // a line from top to bottom at the left
-    ltLeftBottom     // a combination of ltLeft and a line at the bottom from left to right
-  );
-
-  // Determines how to draw tree lines.
-  TVTLineMode = (
-    lmNormal,        // usual tree lines (as in TTreeview)
-    lmBands          // looks similar to a Nassi-Schneidermann diagram
-  );
-
-  // A collection of line type IDs which is used while painting a node.
-  TLineImage = array of TVTLineType;
-
-  TVTScrollIncrement = 1..10000;
-  
-  // A class to manage scroll bar aspects.
-  TScrollBarOptions = class(TPersistent)
-  private
-    FAlwaysVisible: Boolean;
-    FOwner: TBaseVirtualTree;
-    FScrollBars: TScrollStyle;                   // used to hide or show vertical and/or horizontal scrollbar
-    FScrollBarStyle: TScrollBarStyle;            // kind of scrollbars to use
-    FIncrementX,
-    FIncrementY: TVTScrollIncrement;             // number of pixels to scroll in one step (when auto scrolling)
-    procedure SetAlwaysVisible(Value: Boolean);
-    procedure SetScrollBars(Value: TScrollStyle);
-    procedure SetScrollBarStyle(Value: TScrollBarStyle);
-  protected
-    function GetOwner: TPersistent; override;
-  public
-    constructor Create(AOwner: TBaseVirtualTree);
-
-    procedure Assign(Source: TPersistent); override;
-  published
-    property AlwaysVisible: Boolean read FAlwaysVisible write SetAlwaysVisible default False;
-    property HorizontalIncrement: TVTScrollIncrement read FIncrementX write FIncrementX default 20;
-    property ScrollBars: TScrollStyle read FScrollbars write SetScrollBars default ssBoth;
-    property ScrollBarStyle: TScrollBarStyle read FScrollBarStyle write SetScrollBarStyle default sbmRegular;
-    property VerticalIncrement: TVTScrollIncrement read FIncrementY write FIncrementY default 20;
-  end;
-
-  // class to collect all switchable colors into one place
-  TVTColors = class(TPersistent)
-  private
-    FOwner: TBaseVirtualTree;
-    FColors: array[0..13] of TColor;
-    function GetColor(const Index: Integer): TColor;
-    procedure SetColor(const Index: Integer; const Value: TColor);
-  public
-    constructor Create(AOwner: TBaseVirtualTree);
-
-    procedure Assign(Source: TPersistent); override;
-  published
-    property BorderColor: TColor index 7 read GetColor write SetColor default clBtnFace;
-    property DisabledColor: TColor index 0 read GetColor write SetColor default clBtnShadow;
-    property DropMarkColor: TColor index 1 read GetColor write SetColor default clHighlight;
-    property DropTargetColor: TColor index 2 read GetColor write SetColor default clHighLight;
-    property DropTargetBorderColor: TColor index 11 read GetColor write SetColor default clHighLight;
-    property FocusedSelectionColor: TColor index 3 read GetColor write SetColor default clHighLight;
-    property FocusedSelectionBorderColor: TColor index 9 read GetColor write SetColor default clHighLight;
-    property GridLineColor: TColor index 4 read GetColor write SetColor default clBtnFace;
-    property HotColor: TColor index 8 read GetColor write SetColor default clWindowText;
-    property SelectionRectangleBlendColor: TColor index 12 read GetColor write SetColor default clHighlight;
-    property SelectionRectangleBorderColor: TColor index 13 read GetColor write SetColor default clHighlight;
-    property TreeLineColor: TColor index 5 read GetColor write SetColor default clBtnShadow;
-    property UnfocusedSelectionColor: TColor index 6 read GetColor write SetColor default clBtnFace;
-    property UnfocusedSelectionBorderColor: TColor index 10 read GetColor write SetColor default clBtnFace;
-  end;
-
-  // For painting a node and its columns/cells a lot of information must be passed frequently to
-  // the paint methode.
-  TVTImageInfo = record
-    Index: Integer;          // index in the associated image list
-    XPos,                    // horizontal position in the current target canvas
-    YPos: Integer;           // vertical position in the current target canvas
-    Ghosted: Boolean;        // flag to indicate that the image must be drawn slightly lighter
-  end;
-
-  TVTImageInfoIndex = (
-    iiNormal,
-    iiState,
-    iiCheck
-  );
-
-  // Options which are used when modifying the scroll offsets.
-  TScrollUpdateOptions = set of (
-    suoRepaintHeader,        // if suoUpdateNCArea is also set then invalidate the header
-    suoRepaintScrollbars,    // if suoUpdateNCArea is also set then repaint both scrollbars after updating them
-    suoScrollClientArea,     // scroll and invalidate the proper part of the client area
-    suoUpdateNCArea          // update non-client area (scrollbars, header)
-  );
-
-  // Determines the look of a tree's buttons.
-  TVTButtonStyle = (
-    bsRectangle,             // traditional Windows look (plus/minus buttons)
-    bsTriangle               // traditional Macintosh look
-  );
-
-  // TButtonFillMode is only used when the button style is bsRectangle and determines how to fill the interior.
-  TVTButtonFillMode = (
-    fmTreeColor,             // solid color, uses the tree's background color
-    fmWindowColor,           // solid color, uses clWindow
-    fmShaded,                // color gradient, Windows XP style (legacy code, use toThemeAware on Windows XP instead)
-    fmTransparent            // transparent color, use the item's background color
-  );
-
-  TVTPaintInfo = record
-    Canvas: TCanvas;           // the canvas to paint on
-    PaintOptions: TVTInternalPaintOptions;  // a copy of the paint options passed to PaintTree
-    Node: PVirtualNode;        // the node to paint
-    Column: TColumnIndex;      // the node's column index to paint
-    Position: TColumnPosition; // the column position of the node
-    CellRect,                  // the node cell
-    ContentRect: TRect;        // the area of the cell used for the node's content
-    NodeWidth: Integer;        // the actual node width
-    Alignment: TAlignment;     // how to align within the node rectangle
-    BidiMode: TBidiMode;       // directionality to be used for painting
-    BrushOrigin: TPoint;       // the alignment for the brush used to draw dotted lines
-    ImageInfo: array[TVTImageInfoIndex] of TVTImageInfo; // info about each possible node image
-  end;
-
-  // Method called by the Animate routine for each animation step. 
-  TVTAnimationCallback = function(Step, StepSize: Integer; Data: Pointer): Boolean of object;
-
-  TVTIncrementalSearch = (
-    isAll,                   // search every node in tree, initialize if necessary
-    isNone,                  // disable incremental search
-    isInitializedOnly,       // search only initialized nodes, skip others
-    isVisibleOnly            // search only visible nodes, initialize if necessary
-  );
-
-  // Determines which direction to use when advancing nodes during an incremental search.
-  TVTSearchDirection = (
-    sdForward,
-    sdBackward
-  );
-
-  // Determines where to start incremental searching for each key press.
-  TVTSearchStart = (
-    ssAlwaysStartOver,       // always use the first/last node (depending on direction) to search from
-    ssLastHit,               // use the last found node
-    ssFocusedNode            // use the currently focused node
-  );
-
-  // Determines how to use the align member of a node.
-  TVTNodeAlignment = (
-    naFromBottom,            // the align member specifies amount of units (usually pixels) from top border of the node
-    naFromTop,               // align is to be measured from bottom
-    naProportional           // align is to be measure in percent of the entire node height and relative to top
-  );
-
-  // Determines how to draw the selection rectangle used for draw selection.
-  TVTDrawSelectionMode = (
-    smDottedRectangle,       // same as DrawFocusRect
-    smBlendedRectangle       // alpha blending, uses special colors (see TVTColors)
-  );
-
-  TClipboardFormats = class(TStringList)
-  private
-    FOwner: TBaseVirtualTree;
-  public
-    constructor Create(AOwner: TBaseVirtualTree); virtual;
-
-    function Add(const S: string): Integer; override;
-    procedure Insert(Index: Integer; const S: string); override;
-    property Owner: TBaseVirtualTree read FOwner;
-  end;
-
-  // ----- Event prototypes:
-  
-  // node enumeration
-  TVTGetNodeProc = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Data: Pointer; var Abort: Boolean) of object;
-
-  // node events            
-  TVTChangingEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; var Allowed: Boolean) of object;
-  TVTCheckChangingEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; var NewState: TCheckState;
-    var Allowed: Boolean) of object;
-  TVTChangeEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode) of object;
-  TVTStructureChangeEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Reason: TChangeReason) of object;
-  TVTEditCancelEvent = procedure(Sender: TBaseVirtualTree; Column: TColumnIndex) of object;
-  TVTEditChangingEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex;
-    var Allowed: Boolean) of object;
-  TVTEditChangeEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex) of object;
-  TVTFreeNodeEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode) of object;
-  TVTFocusChangingEvent = procedure(Sender: TBaseVirtualTree; OldNode, NewNode: PVirtualNode; OldColumn,
-    NewColumn: TColumnIndex; var Allowed: Boolean) of object;
-  TVTFocusChangeEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex) of object;
-  TVTGetImageEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex;
-    var Ghosted: Boolean; var ImageIndex: Integer) of object;
-  TVTHotNodeChangeEvent = procedure(Sender: TBaseVirtualTree; OldNode, NewNode: PVirtualNode) of object;
-  TVTInitChildrenEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; var ChildCount: Cardinal) of object;
-  TVTInitNodeEvent = procedure(Sender: TBaseVirtualTree; ParentNode, Node: PVirtualNode;
-    var InitialStates: TVirtualNodeInitStates) of object;
-  TVTPopupEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex; const P: TPoint;
-    var AskParent: Boolean; var PopupMenu: TPopupMenu) of object;
-  TVTHelpContextEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex;
-    var HelpContext: Integer) of object;
-  TVTCreateEditorEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex;
-    out EditLink: IVTEditLink) of object;
-  TVTSaveNodeEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Stream: TStream) of object;
-
-  // header/column events
-  TVTHeaderClickEvent = procedure(Sender: TVTHeader; Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X,
-    Y: Integer) of object;
-  TVTHeaderMouseEvent = procedure(Sender: TVTHeader; Button: TMouseButton; Shift: TShiftState; X, Y: Integer) of object;
-  TVTHeaderMouseMoveEvent = procedure(Sender: TVTHeader; Shift: TShiftState; X, Y: Integer) of object;
-  TVTHeaderNotifyEvent = procedure(Sender: TVTHeader; Column: TColumnIndex) of object;
-  TVTHeaderDraggingEvent = procedure(Sender: TVTHeader; Column: TColumnIndex; var Allowed: Boolean) of object;
-  TVTHeaderDraggedEvent = procedure(Sender: TVTHeader; Column: TColumnIndex; OldPosition: Integer) of object;
-  TVTHeaderDraggedOutEvent = procedure(Sender: TVTHeader; Column: TColumnIndex; DropPosition: TPoint) of object;
-  TVTHeaderPaintEvent = procedure(Sender: TVTHeader; HeaderCanvas: TCanvas; Column: TVirtualTreeColumn; R: TRect; Hover,
-    Pressed: Boolean; DropMark: TVTDropMarkMode) of object;
-  TVTHeaderPaintQueryElementsEvent = procedure(Sender: TVTHeader; var PaintInfo: THeaderPaintInfo;
-    var Elements: THeaderPaintElements) of object;
-  TVTAdvancedHeaderPaintEvent = procedure(Sender: TVTHeader; var PaintInfo: THeaderPaintInfo;
-    const Elements: THeaderPaintElements) of object;
-  TVTColumnClickEvent = procedure (Sender: TBaseVirtualTree; Column: TColumnIndex; Shift: TShiftState) of object;
-  TVTColumnDblClickEvent = procedure (Sender: TBaseVirtualTree; Column: TColumnIndex; Shift: TShiftState) of object;
-  TVTGetHeaderCursorEvent = procedure(Sender: TVTHeader; var Cursor: HCURSOR) of object;
-
-  // move and copy events
-  TVTNodeMovedEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode) of object;
-  TVTNodeMovingEvent = procedure(Sender: TBaseVirtualTree; Node, Target: PVirtualNode;
-    var Allowed: Boolean) of object;
-  TVTNodeCopiedEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode) of object;
-  TVTNodeCopyingEvent = procedure(Sender: TBaseVirtualTree; Node, Target: PVirtualNode;
-    var Allowed: Boolean) of object;
-
-  // drag'n drop/OLE events
-  TVTCreateDragManagerEvent = procedure(Sender: TBaseVirtualTree; out DragManager: IVTDragManager) of object;
-  TVTCreateDataObjectEvent = procedure(Sender: TBaseVirtualTree; out IDataObject: IDataObject) of object;
-  TVTDragAllowedEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex;
-    var Allowed: Boolean) of object;
-  TVTDragOverEvent = procedure(Sender: TBaseVirtualTree; Source: TObject; Shift: TShiftState; State: TDragState;
-    Pt: TPoint; Mode: TDropMode; var Effect: Integer; var Accept: Boolean) of object;
-  TVTDragDropEvent = procedure(Sender: TBaseVirtualTree; Source: TObject; DataObject: IDataObject;
-    Formats: TFormatArray; Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode) of object;
-  TVTRenderOLEDataEvent = procedure(Sender: TBaseVirtualTree; const FormatEtcIn: TFormatEtc; out Medium: TStgMedium;
-    ForClipboard: Boolean; var Result: HRESULT) of object;
-  TVTGetUserClipboardFormatsEvent = procedure(Sender: TBaseVirtualTree; var Formats: TFormatEtcArray) of object;
-
-  // paint events
-  TVTBeforeItemEraseEvent = procedure(Sender: TBaseVirtualTree; TargetCanvas: TCanvas; Node: PVirtualNode; ItemRect: TRect;
-    var ItemColor: TColor; var EraseAction: TItemEraseAction) of object;
-  TVTAfterItemEraseEvent = procedure(Sender: TBaseVirtualTree; TargetCanvas: TCanvas; Node: PVirtualNode;
-    ItemRect: TRect) of object;
-  TVTBeforeItemPaintEvent = procedure(Sender: TBaseVirtualTree; TargetCanvas: TCanvas; Node: PVirtualNode;
-    ItemRect: TRect; var CustomDraw: Boolean) of object;
-  TVTAfterItemPaintEvent = procedure(Sender: TBaseVirtualTree; TargetCanvas: TCanvas; Node: PVirtualNode;
-    ItemRect: TRect) of object;
-  TVTBeforeCellPaintEvent = procedure(Sender: TBaseVirtualTree; TargetCanvas: TCanvas; Node: PVirtualNode;
-    Column: TColumnIndex; CellRect: TRect) of object;
-  TVTAfterCellPaintEvent = procedure(Sender: TBaseVirtualTree; TargetCanvas: TCanvas; Node: PVirtualNode;
-    Column: TColumnIndex; CellRect: TRect) of object;
-  TVTPaintEvent = procedure(Sender: TBaseVirtualTree; TargetCanvas: TCanvas) of object;
-  TVTBackgroundPaintEvent = procedure(Sender: TBaseVirtualTree; TargetCanvas: TCanvas; R: TRect;
-    var Handled: Boolean) of object;
-  TVTGetLineStyleEvent = procedure(Sender: TBaseVirtualTree; var Bits: Pointer) of object;
-
-  // search, sort
-  TVTCompareEvent = procedure(Sender: TBaseVirtualTree; Node1, Node2: PVirtualNode; Column: TColumnIndex;
-    var Result: Integer) of object;
-  TVTIncrementalSearchEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; const SearchText: WideString;
-    var Result: Integer) of object;
-
-  // miscellaneous
-  TVTGetNodeDataSizeEvent = procedure(Sender: TBaseVirtualTree; var NodeDataSize: Integer) of object;
-  TVTKeyActionEvent = procedure(Sender: TBaseVirtualTree; var CharCode: Word; var Shift: TShiftState;
-    var DoDefault: Boolean) of object;
-  TVTScrollEvent = procedure(Sender: TBaseVirtualTree; DeltaX, DeltaY: Integer) of object;
-  TVTUpdatingEvent = procedure(Sender: TBaseVirtualTree; State: TVTUpdateState) of object;
-  TVTGetCursorEvent = procedure(Sender: TBaseVirtualTree; var Cursor: TCursor) of object;
-  TVTStateChangeEvent = procedure(Sender: TBaseVirtualTree; Enter, Leave: TVirtualTreeStates) of object;
-
-  // Helper types for node iterations.
-  TGetFirstNodeProc = function: PVirtualNode of object;
-  TGetNextNodeProc = function(Node: PVirtualNode): PVirtualNode of object;
-
-  // ----- TBaseVirtualTree
-  TBaseVirtualTree = class(TCustomControl)
-  private
-    FBorderStyle: TBorderStyle;
-    FHeader: TVTHeader;
-    FRoot: PVirtualNode;
-    FDefaultNodeHeight,
-    FIndent: Cardinal;
-    FOptions: TCustomVirtualTreeOptions;
-    FUpdateCount: Cardinal;                      // update stopper, updates of the tree control are only done if = 0
-    FSynchUpdateCount: Cardinal;                 // synchronizer, causes all events which are usually done via timers
-                                                 // to happen immediately, regardless of the normal update state
-    FNodeDataSize: Integer;                      // number of bytes to allocate with each node (in addition to its base
-                                                 // structure and the internal data), if -1 then do callback
-    {$ifdef UseLocalMemoryManager}
-      FNodeMemoryManager: TVTNodeMemoryManager;  // High-performance local memory manager.
-    {$endif UseLocalMemoryManager}
-    FStates: TVirtualTreeStates;                 // various active/pending states the tree needs to consider
-    FLastSelected,
-    FFocusedNode: PVirtualNode;
-    FEditColumn,                                 // column to be edited (focused node)
-    FFocusedColumn: TColumnIndex;                // NoColumn if no columns are active otherwise the last hit column of
-                                                 // the currently focused node
-    FScrollDirections: TScrollDirections;        // directions to scroll client area into depending on mouse position
-    FLastStructureChangeReason: TChangeReason;   // used for delayed structur change event
-    FLastStructureChangeNode,                    // dito
-    FLastChangedNode,                            // used for delayed change event
-    FCurrentHotNode: PVirtualNode;               // Node over which the mouse is hovering.
-    FLastSelRect,
-    FNewSelRect: TRect;                          // used while doing draw selection
-    FHotCursor: TCursor;                         // can be set to additionally indicate the current hot node
-    FAnimationType: THintAnimationType;          // none, fade in, slide in animation (just like those animations used
-                                                 // in Win98 (slide) and Windows 2000 (fade))
-    FHintMode: TVTHintMode;                      // determines the kind of the hint window
-    FHintData: TVTHintData;                      // used while preparing the hint window
-    FChangeDelay: Cardinal;                      // used to delay OnChange event
-    FEditDelay: Cardinal;                        // determines time to elapse before a node goes into edit mode
-    FPositionCache: TCache;                      // array which stores node references ordered by vertical positions
-                                                 // (see also DoValidateCache for more information)
-    FVisibleCount: Cardinal;                     // number of currently visible nodes
-    FStartIndex: Cardinal;                       // index to start validating cache from
-    FSelection: TNodeArray;                      // list of currently selected nodes
-    FSelectionCount: Integer;                    // number of currently selected nodes (size of FSelection might differ)
-    FRangeAnchor: PVirtualNode;                  // anchor node for selection with the keyboard, determines start of a
-                                                 // selection range
-    FCheckNode: PVirtualNode;                    // node which &quot;captures&quot; an check event
-    FPendingCheckState: TCheckState;             // the new state the check node will get if all wents fine
-    FLastSelectionLevel: Integer;                // keeps the last node level for constrained multiselection
-    FDrawSelShiftState: TShiftState;             // keeps the initial shift state when the user starts selection with
-                                                 // the mouse
-    FEditLink: IVTEditLink;                      // used to comunicate with an application defined editor
-    FTempNodeCache: TNodeArray;                  // used at various places to hold temporarily a bunch of node refs.
-    FTempNodeCount: Cardinal;                    // number of nodes in FTempNodeCache
-    FBackground: TPicture;                       // a background image loadable at design time
-    FMargin: Integer;                            // horizontal border distance
-    FTextMargin: Integer;                        // space between the node's text and its horizontal bounds
-    FBackgroundOffsetX,
-    FBackgroundOffsetY: Integer;                 // used to fine tune the position of the background image
-    FAnimationDuration: Cardinal;                // specifies how long an animation shall take (expanding, hint)
-    FWantTabs: Boolean;                          // If True then the tree also consumes the tab key.
-    FNodeAlignment: TVTNodeAlignment;            // determines how to interpret the align member of a node
-    FHeaderRect: TRect;                          // Space which the header currently uses in the control (window coords).
-    FLastHintRect: TRect;                        // Area which the must must leave to reshow a hint.
-    FUpdateRect: TRect;
-    FChangeLock: TCriticalSection;               // To sync the change events from both VT and the worker thread.
-
-    // paint support and images
-    FPlusBM,
-    FMinusBM: TBitmap;                           // small bitmaps used for tree buttons
-    FImages,                                     // normal images in the tree
-    FStateImages,                                // state images in the tree
-    FCustomCheckImages: TCustomImageList;        // application defined check images
-    FCheckImageKind: TCheckImageKind;            // light or dark, cross marks or tick marks
-    FCheckImages: TCustomImageList;              // Reference to global image list to be used for the check images.
-    FImageChangeLink,
-    FStateChangeLink,
-    FCustomCheckChangeLink: TChangeLink;         // connections to the image lists
-    FOldFontChange: TNotifyEvent;                // helper method pointer for tracking font changes in the off screen buffer
-    FFontChanged: Boolean;                       // flag for keeping informed about font changes in the off screen buffer
-    FColors: TVTColors;                          // class comprising all customizable colors in the tree
-    FButtonStyle: TVTButtonStyle;                // style of the tree buttons
-    FButtonFillMode: TVTButtonFillMode;          // for rectangular tree buttons only: how to fill them
-    FLineStyle: TVTLineStyle;                    // style of the tree lines
-    FLineMode: TVTLineMode;                      // tree lines or bands etc.
-    FDottedBrush: HBRUSH;                        // used to paint dotted lines without special pens
-    FSelectionCurveRadius: Cardinal;             // radius for rounded selection rectangles
-    FSelectionBlendFactor: Byte;                 // Determines the factor by which the selection rectangle is to be
-                                                 // faded if enabled.
-    FDrawSelectionMode: TVTDrawSelectionMode;    // determines the paint mode for draw selection
-
-    // alignment and directionality support
-    FAlignment: TAlignment;                      // default alignment of the tree if no columns are shown
-
-    // drag'n drop and clipboard support
-    FDragImageKind: TVTDragImageKind;            // determines whether or not and what to show in the drag image
-    FDragOperations: TDragOperations;            // determines which operations are allowed during drag'n drop
-    FDragThreshold: Integer;                     // used to determine when to actually start a drag'n drop operation
-    FDragManager: IVTDragManager;                // drag'n drop, cut'n paste
-    FDropTargetNode: PVirtualNode;               // node currently selected as drop target
-    FLastDropMode: TDropMode;                    // set while dragging and used to track changes
-    FDragSelection: TNodeArray;                  // temporary copy of FSelection used during drag'n drop
-    FDragType: TVTDragType;                      // used to switch between OLE and VCL drag'n drop
-    FDragImage: TVTDragImage;                    // drag image management
-    FDragWidth,
-    FDragHeight: Integer;                        // size of the drag image, the larger the more CPU power is needed
-    FClipboardFormats: TClipboardFormats;        // a list of clipboard format descriptions enabled for this tree
-    FLastVCLDragTarget: PVirtualNode;            // A node cache for VCL drag'n drop (keywords: DragLeave on DragDrop).
-    FVCLDragEffect: Integer;                     // A cache for VCL drag'n drop to keep the current drop effect.
-
-    // scroll support
-    FScrollBarOptions: TScrollBarOptions;        // common properties of horizontal and vertical scrollbar
-    FAutoScrollInterval: TAutoScrollInterval;    // determines speed of auto scrolling
-    FAutoScrollDelay: Cardinal;                  // amount of milliseconds to wait until autoscrolling becomes active
-    FAutoExpandDelay: Cardinal;                  // amount of milliseconds to wait until a node is expanded if it is the
-                                                 // drop target
-    FOffsetX,
-    FOffsetY: Integer;                           // determines left and top scroll offset
-    FRangeX,
-    FRangeY: Cardinal;                           // current virtual width and height of the tree
-
-    FDefaultPasteMode: TVTNodeAttachMode;        // Used to determine where to add pasted nodes to.
-    FSingletonNodeArray: TNodeArray;             // Contains only one element for quick addition of single nodes
-                                                 // to the selection.
-    FDragScrollStart: Cardinal;                  // Contains the start time when a tree does auto scrolling as drop target.
-
-    // search
-    FIncrementalSearch: TVTIncrementalSearch;    // Used to determine whether and how incremental search is to be used.
-    FSearchTimeout: Cardinal;                    // Number of milliseconds after which to stop incremental searching.
-    FSearchBuffer: WideString;                   // Collects a sequence of keypresses used to do incremental searching.
-    FLastSearchNode: PVirtualNode;               // Reference to node which was last found as search fit.
-    FSearchDirection: TVTSearchDirection;        // Direction to incrementally search the tree.
-    FSearchStart: TVTSearchStart;                // Where to start iteration on each key press.
-
-    // miscellanous
-    FTotalInternalDataSize: Cardinal;            // Cache of the sum of the necessary internal data size for all tree
-                                                 // classes derived from this base class.
-    FPanningWindow: HWND;                        // Helper window for wheel panning
-    FPanningCursor: HCURSOR;                     // Current wheel panning cursor.
-    FPanningImage: TBitmap;                      // A little 32x32 bitmap to indicate the panning reference point.
-    FLastClickPos: TPoint;                       // Used for retained drag start and wheel mouse scrolling.
-
-    // common events
-    FOnChange: TVTChangeEvent;                   // selection change
-    FOnStructureChange: TVTStructureChangeEvent; // structural change like adding nodes etc.
-    FOnInitChildren: TVTInitChildrenEvent;       // called when a node's children are needed (expanding etc.)
-    FOnInitNode: TVTInitNodeEvent;               // called when a node needs to be initialized (child count etc.)
-    FOnFreeNode: TVTFreeNodeEvent;               // called when a node is about to be destroyed, user data can and should
-                                                 // be freed in this event
-    FOnGetImage: TVTGetImageEvent;               // used to retrieve the image index of a given node
-    FOnHotChange: TVTHotNodeChangeEvent;         // called when the current &quot;hot&quot; node (that is, the node under the mouse)
-                                                 // changes and hot tracking is enabled
-    FOnExpanding,                                // called just before a node is expanded
-    FOnCollapsing: TVTChangingEvent;             // called just before a node is collapsed
-    FOnChecking: TVTCheckChangingEvent;          // called just before a node's check state is changed
-    FOnExpanded,                                 // called after a node has been expanded
-    FOnCollapsed,                                // called after a node has been collapsed
-    FOnChecked: TVTChangeEvent;                  // called after a node's check state has been changed
-    FOnResetNode: TVTChangeEvent;                // called when a node is set to be uninitialized
-    FOnNodeMoving: TVTNodeMovingEvent;           // called just before a node is moved from one parent node to another
-                                                 // (this can be cancelled)
-    FOnNodeMoved: TVTNodeMovedEvent;             // called after a node and its children have been moved to another
-                                                 // parent node (probably another tree, but within the same application)
-    FOnNodeCopying: TVTNodeCopyingEvent;         // called when an node is copied to another parent node (probably in
-                                                 // another tree, but within the same application, can be cancelled)
-    FOnNodeCopied: TVTNodeCopiedEvent;           // call after a node has been copied
-    FOnEditing: TVTEditChangingEvent;            // called just before a node goes into edit mode
-    FOnEditCancelled: TVTEditCancelEvent;        // called when editing has been cancelled
-    FOnEdited: TVTEditChangeEvent;               // called when editing has successfully been finished
-    FOnFocusChanging: TVTFocusChangingEvent;     // called when the focus is about to go to a new node and/or column
-                                                 // (can be cancelled)
-    FOnFocusChanged: TVTFocusChangeEvent;        // called when the focus goes to a new node and/or column
-    FOnGetPopupMenu: TVTPopupEvent;              // called when the popup for a node needs to be shown
-    FOnGetHelpContext: TVTHelpContextEvent;      // called when a node specific help theme should be called
-    FOnCreateEditor: TVTCreateEditorEvent;       // called when a node goes into edit mode, this allows applications
-                                                 // to supply their own editor
-    FOnLoadNode,                                 // called after a node has been loaded from a stream (file, clipboard,
-                                                 // OLE drag'n drop) to allow an application to load their own data
-                                                 // saved in OnSaveNode
-    FOnSaveNode: TVTSaveNodeEvent;               // called when a node needs to be serialized into a stream
-                                                 // (see OnLoadNode) to give the application the opportunity to save
-                                                 // their node specific, persistent data (note: never save memory
-                                                 // references)
-
-    // header/column mouse events
-    FOnHeaderClick,                              // mouse events for the header, just like those for a control
-    FOnHeaderDblClick: TVTHeaderClickEvent;
-    FOnHeaderMouseDown,
-    FOnHeaderMouseUp: TVTHeaderMouseEvent;
-    FOnHeaderMouseMove: TVTHeaderMouseMoveEvent;
-    FOnColumnClick: TVTColumnClickEvent;
-    FOnColumnDblClick: TVTColumnDblClickEvent;
-    FOnColumnResize: TVTHeaderNotifyEvent;
-    FOnGetHeaderCursor: TVTGetHeaderCursorEvent; // triggered to allow the app. to use customized cursors for the header
-
-    // paint events
-    FOnAfterPaint,                               // triggered when the tree has entirely been painted
-    FOnBeforePaint: TVTPaintEvent;               // triggered when the tree is about to be painted
-    FOnAfterItemPaint: TVTAfterItemPaintEvent;   // triggered after an item has been painted
-    FOnBeforeItemPaint: TVTBeforeItemPaintEvent; // triggered when an item is about to be painted
-    FOnBeforeItemErase: TVTBeforeItemEraseEvent; // triggered when an item's background is about to be erased
-    FOnAfterItemErase: TVTAfterItemEraseEvent;   // triggered after an item's background has been erased
-    FOnAfterCellPaint: TVTAfterCellPaintEvent;   // triggered after a column of an item has been painted
-    FOnBeforeCellPaint: TVTBeforeCellPaintEvent; // triggered when a column of an item is about to be painted
-    FOnHeaderDraw: TVTHeaderPaintEvent;          // Used when owner draw is enabled for the header and a column is set
-                                                 // to owner draw mode.
-    FOnHeaderDrawQueryElements: TVTHeaderPaintQueryElementsEvent; // Used for advanced header painting to query the
-                                                 // application for the elements, which are drawn by it and which should
-                                                 // be drawn by the tree.
-    FOnAdvancedHeaderDraw: TVTAdvancedHeaderPaintEvent; // Used when owner draw is enabled for the header and a column
-                                                 // is set to owner draw mode. But only if OnHeaderDrawQueryElements
-                                                 // returns at least one element to be drawn by the application.
-                                                 // In this case OnHeaderDraw is not used.
-    FOnGetLineStyle: TVTGetLineStyleEvent;       // triggered when a custom line style is used and the pattern brush
-                                                 // needs to be build
-    FOnPaintBackground: TVTBackgroundPaintEvent; // triggered if a part of the tree's background must be erased which is
-                                                 // not covered by any node
-
-    // drag'n drop events
-    FOnCreateDragManager: TVTCreateDragManagerEvent; // called to allow for app./descendant defined drag managers
-    FOnCreateDataObject: TVTCreateDataObjectEvent; // called to allow for app./descentant defined data objects
-    FOnDragAllowed: TVTDragAllowedEvent;         // used to get permission for manual drag in mouse down
-    FOnDragOver: TVTDragOverEvent;               // called for every mouse move
-    FOnDragDrop: TVTDragDropEvent;               // called on release of mouse button (if drop was allowed)
-    FOnHeaderDragged: TVTHeaderDraggedEvent;     // header (column) drag'n drop
-    FOnHeaderDraggedOut: TVTHeaderDraggedOutEvent; // header (column) drag'n drop, which did not result in a valid drop. 
-    FOnHeaderDragging: TVTHeaderDraggingEvent;   // header (column) drag'n drop
-    FOnRenderOLEData: TVTRenderOLEDataEvent;     // application/descendant defined clipboard formats
-    FOnGetUserClipboardFormats: TVTGetUserClipboardFormatsEvent; // gives application/descentants the opportunity to
-                                                 // add own clipboard formats on the fly
-
-    // miscellanous events
-    FOnGetNodeDataSize: TVTGetNodeDataSizeEvent; // called if NodeDataSize is -1
-    FOnKeyAction: TVTKeyActionEvent;             // used to selectively prevent key actions (full expand on Ctrl+'+' etc.)
-    FOnScroll: TVTScrollEvent;                   // called when one or both paint offsets changed
-    FOnUpdating: TVTUpdatingEvent;               // called from BeginUpdate, EndUpdate, BeginSynch and EndSynch
-    FOnGetCursor: TVTGetCursorEvent;             // called to allow the app. to set individual cursors
-    FOnStateChange: TVTStateChangeEvent;         // Called whenever a state in the tree changes.
-
-    // search, sort
-    FOnCompareNodes: TVTCompareEvent;            // used during sort
-    FOnIncrementalSearch: TVTIncrementalSearchEvent; // triggered on every key press (not key down)
-
-    procedure AdjustCoordinatesByIndent(var PaintInfo: TVTPaintInfo; Indent: Integer);
-    procedure AdjustImageBorder(Images: TCustomImageList; BidiMode: TBidiMode; VAlign: Integer; var R: TRect;
-      var ImageInfo: TVTImageInfo);
-    procedure AdjustTotalCount(Node: PVirtualNode; Value: Integer; relative: Boolean = False);
-    procedure AdjustTotalHeight(Node: PVirtualNode; Value: Integer; relative: Boolean = False);
-    function CalculateCacheEntryCount: Integer;
-    procedure CalculateVerticalAlignments(ShowImages, ShowStateImages: Boolean; Node: PVirtualNode; var VAlign,
-      VButtonAlign: Integer);
-    function ChangeCheckState(Node: PVirtualNode; Value: TCheckState): Boolean;
-    function CollectSelectedNodesLTR(MainColumn, NodeLeft, NodeRight: Integer; Alignment: TAlignment; OldRect,
-      NewRect: TRect): Boolean;
-    function CollectSelectedNodesRTL(MainColumn, NodeLeft, NodeRight: Integer; Alignment: TAlignment; OldRect,
-      NewRect: TRect): Boolean;
-    procedure ClearNodeBackground(const PaintInfo: TVTPaintInfo; UseBackground, Floating: Boolean; R: TRect);
-    function CompareNodePositions(Node1, Node2: PVirtualNode): Integer;
-    procedure DrawLineImage(const PaintInfo: TVTPaintInfo; X, Y, H, VAlign: Integer; Style: TVTLineType; Reverse: Boolean);
-    function FindInPositionCache(Node: PVirtualNode; var CurrentPos: Cardinal): PVirtualNode; overload;
-    function FindInPositionCache(Position: Cardinal; var CurrentPos: Cardinal): PVirtualNode; overload;
-    function GetCheckState(Node: PVirtualNode): TCheckState;
-    function GetCheckType(Node: PVirtualNode): TCheckType;
-    function GetChildCount(Node: PVirtualNode): Cardinal;
-    function GetChildrenInitialized(Node: PVirtualNode): Boolean;
-    function GetDisabled(Node: PVirtualNode): Boolean;
-    function GetDragManager: IVTDragManager;
-    function GetExpanded(Node: PVirtualNode): Boolean;
-    function GetFullyVisible(Node: PVirtualNode): Boolean;
-    function GetHasChildren(Node: PVirtualNode): Boolean;
-    function GetMultiline(Node: PVirtualNode): Boolean;
-    function GetNodeHeight(Node: PVirtualNode): Cardinal;
-    function GetNodeParent(Node: PVirtualNode): PVirtualNode;
-    function GetOffsetXY: TPoint;
-    function GetRootNodeCount: Cardinal;
-    function GetSelected(Node: PVirtualNode): Boolean;
-    function GetTopNode: PVirtualNode;
-    function GetTotalCount: Cardinal;
-    function GetVerticalAlignment(Node: PVirtualNode): Byte;
-    function GetVisible(Node: PVirtualNode): Boolean;
-    function GetVisiblePath(Node: PVirtualNode): Boolean;
-    procedure HandleClickSelection(LastFocused, NewNode: PVirtualNode; Shift: TShiftState);
-    function HandleDrawSelection(X, Y: Integer): Boolean;
-    function HasVisibleNextSibling(Node: PVirtualNode): Boolean;
-    procedure ImageListChange(Sender: TObject);
-    procedure InitializeFirstColumnValues(var PaintInfo: TVTPaintInfo);
-    function InitializeLineImageAndSelectLevel(Node: PVirtualNode; var LineImage: TLineImage): Integer;
-    procedure InitRootNode(OldSize: Cardinal = 0);
-    procedure InterruptValidation;
-    function IsFirstVisibleChild(Parent, Node: PVirtualNode): Boolean;
-    function IsLastVisibleChild(Parent, Node: PVirtualNode): Boolean;
-    procedure LimitPaintingToArea(Canvas: TCanvas; ClipRect: TRect; VisibleRegion: HRGN = 0);
-    function MakeNewNode: PVirtualNode;
-    procedure OriginalWMNCPaint(DC: HDC);
-    function PackArray(TheArray: TNodeArray; Count: Integer): Integer;
-    procedure PrepareBitmaps(NeedButtons, NeedLines: Boolean);
-    procedure PrepareCell(var PaintInfo: TVTPaintInfo);
-    procedure ReadOldOptions(Reader: TReader);
-    procedure SetAlignment(const Value: TAlignment);
-    procedure SetAnimationDuration(const Value: Cardinal);
-    procedure SetBackground(const Value: TPicture);
-    procedure SetBackgroundOffset(const Index, Value: Integer);
-    procedure SetBorderStyle(Value: TBorderStyle);
-    procedure SetButtonFillMode(const Value: TVTButtonFillMode);
-    procedure SetButtonStyle(const Value: TVTButtonStyle);
-    procedure SetCheckImageKind(Value: TCheckImageKind);
-    procedure SetCheckState(Node: PVirtualNode; Value: TCheckState);
-    procedure SetCheckType(Node: PVirtualNode; Value: TCheckType);
-    procedure SetChildCount(Node: PVirtualNode; NewChildCount: Cardinal);
-    procedure SetClipboardFormats(const Value: TClipboardFormats);
-    procedure SetColors(const Value: TVTColors);
-    procedure SetCustomCheckImages(const Value: TCustomImageList);
-    procedure SetDefaultNodeHeight(Value: Cardinal);
-    procedure SetDisabled(Node: PVirtualNode; Value: Boolean);
-    procedure SetExpanded(Node: PVirtualNode; Value: Boolean);
-    procedure SetFocusedColumn(Value: TColumnIndex);
-    procedure SetFocusedNode(Value: PVirtualNode);
-    procedure SetFullyVisible(Node: PVirtualNode; Value: Boolean);
-    procedure SetHasChildren(Node: PVirtualNode; Value: Boolean);
-    procedure SetHeader(const Value: TVTHeader);
-    procedure SetImages(const Value: TCustomImageList);
-    procedure SetIndent(Value: Cardinal);
-    procedure SetLineMode(const Value: TVTLineMode);
-    procedure SetLineStyle(const Value: TVTLineStyle);
-    procedure SetMargin(Value: Integer);
-    procedure SetMultiline(Node: PVirtualNode; const Value: Boolean);
-    procedure SetNodeAlignment(const Value: TVTNodeAlignment);
-    procedure SetNodeDataSize(Value: Integer);
-    procedure SetNodeHeight(Node: PVirtualNode; Value: Cardinal);
-    procedure SetNodeParent(Node: PVirtualNode; const Value: PVirtualNode);
-    procedure SetOffsetX(const Value: Integer);
-    procedure SetOffsetXY(const Value: TPoint);
-    procedure SetOffsetY(const Value: Integer);
-    procedure SetOptions(const Value: TCustomVirtualTreeOptions);
-    procedure SetRootNodeCount(Value: Cardinal);
-    procedure SetScrollBarOptions(Value: TScrollBarOptions);
-    procedure SetSearchOption(const Value: TVTIncrementalSearch);
-    procedure SetSelected(Node: PVirtualNode; Value: Boolean);
-    procedure SetSelectionCurveRadius(const Value: Cardinal);
-    procedure SetStateImages(const Value: TCustomImageList);
-    procedure SetTextMargin(Value: Integer);
-    procedure SetTopNode(Node: PVirtualNode);
-    procedure SetUpdateState(Updating: Boolean);
-    procedure SetVerticalAlignment(Node: PVirtualNode; Value: Byte);
-    procedure SetVisible(Node: PVirtualNode; Value: Boolean);
-    procedure SetVisiblePath(Node: PVirtualNode; Value: Boolean);
-    procedure StopTimer(ID: Integer);
-    procedure TileBackground(Source: TBitmap; Target: TCanvas; Offset: TPoint; R: TRect);
-    function ToggleCallback(Step, StepSize: Integer; Data: Pointer): Boolean;
-
-    procedure CMColorChange(var Message: TMessage); message CM_COLORCHANGED;
-    procedure CMCtl3DChanged(var Message: TMessage); message CM_CTL3DCHANGED;
-    procedure CMDenySubclassing(var Message: TMessage); message CM_DENYSUBCLASSING;
-    procedure CMDrag(var Message: TCMDrag); message CM_DRAG;
-    procedure CMEnabledChanged(var Message: TMessage); message CM_ENABLEDCHANGED;
-    procedure CMFontChanged(var Message: TMessage); message CM_FONTCHANGED;
-    procedure CMHintShow(var Message: TCMHintShow); message CM_HINTSHOW;
-    procedure CMHintShowPause(var Message: TCMHintShowPause); message CM_HINTSHOWPAUSE;
-    procedure CMMouseLeave(var Message: TMessage); message CM_MOUSELEAVE;
-    procedure CMMouseWheel(var Message: TCMMouseWheel); message CM_MOUSEWHEEL;
-    procedure CMSysColorChange(var Message: TMessage); message CM_SYSCOLORCHANGE;
-    procedure WMCancelMode(var Message: TWMCancelMode); message WM_CANCELMODE;
-    procedure WMChangeState(var Message: TMessage); message WM_CHANGESTATE;
-    procedure WMChar(var Message: TWMChar); message WM_CHAR;
-    procedure WMContextMenu(var Message: TWMContextMenu); message WM_CONTEXTMENU;
-    procedure WMCopy(var Message: TWMCopy); message WM_COPY;
-    procedure WMCut(var Message: TWMCut); message WM_CUT;
-    procedure WMEnable(var Message: TWMEnable); message WM_ENABLE;
-    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
-    procedure WMGetDlgCode(var Message: TWMGetDlgCode); message WM_GETDLGCODE;
-    procedure WMHScroll(var Message: TWMHScroll); message WM_HSCROLL;
-    procedure WMKeyDown(var Message: TWMKeyDown); message WM_KEYDOWN;
-    procedure WMKeyUp(var Message: TWMKeyUp); message WM_KEYUP;
-    procedure WMKillFocus(var Msg: TWMKillFocus); message WM_KILLFOCUS;
-    procedure WMLButtonDblClk(var Message: TWMLButtonDblClk); message WM_LBUTTONDBLCLK;
-    procedure WMLButtonDown(var Message: TWMLButtonDown); message WM_LBUTTONDOWN;
-    procedure WMLButtonUp(var Message: TWMLButtonUp); message WM_LBUTTONUP;
-    procedure WMMButtonDblClk(var Message: TWMMButtonDblClk); message WM_MBUTTONDBLCLK;
-    procedure WMMButtonDown(var Message: TWMMButtonDown); message WM_MBUTTONDOWN;
-    procedure WMMButtonUp(var Message: TWMMButtonUp); message WM_MBUTTONUP;
-    procedure WMNCCalcSize(var Message: TWMNCCalcSize); message WM_NCCALCSIZE;
-    procedure WMNCDestroy(var Message: TWMNCDestroy); message WM_NCDESTROY;
-    procedure WMNCHitTest(var Message: TWMNCHitTest); message WM_NCHITTEST;
-    procedure WMNCPaint(var Message: TRealWMNCPaint); message WM_NCPAINT;
-    procedure WMPaint(var Message: TWMPaint); message WM_PAINT;
-    procedure WMPaste(var Message: TWMPaste); message WM_PASTE;
-    procedure WMPrint(var Message: TWMPrint); message WM_PRINT;
-    procedure WMPrintClient(var Message: TWMPrintClient); message WM_PRINTCLIENT;
-    procedure WMRButtonDblClk(var Message: TWMRButtonDblClk); message WM_RBUTTONDBLCLK;
-    procedure WMRButtonDown(var Message: TWMRButtonDown); message WM_RBUTTONDOWN;
-    procedure WMRButtonUp(var Message: TWMRButtonUp); message WM_RBUTTONUP;
-    procedure WMReleaseEditLink(var Message: TMessage); message WM_RELEASEEDITLINK;
-    procedure WMSetCursor(var Message: TWMSetCursor); message WM_SETCURSOR;
-    procedure WMSetFocus(var Msg: TWMSetFocus); message WM_SETFOCUS;
-    procedure WMSize(var Message: TWMSize); message WM_SIZE;
-    procedure WMTimer(var Message: TWMTimer); message WM_TIMER;
-    procedure WMVScroll(var Message: TWMVScroll); message WM_VSCROLL;
-  protected
-    procedure AddToSelection(Node: PVirtualNode); overload;
-    procedure AddToSelection(const NewItems: TNodeArray; NewLength: Integer; ForceInsert: Boolean = False); overload;
-    procedure AdjustPaintCellRect(var PaintInfo: TVTPaintInfo; var NextNonEmpty: TColumnIndex); virtual;
-    procedure AdjustPanningCursor(X, Y: Integer);
-    procedure AdviseChangeEvent(StructureChange: Boolean; Node: PVirtualNode; Reason: TChangeReason);
-    function AllocateInternalDataArea(Size: Cardinal): Cardinal;
-    procedure Animate(Steps, Duration: Cardinal; Callback: TVTAnimationCallback; Data: Pointer);
-    function CalculateSelectionRect(X, Y: Integer): Boolean;
-    function CanAutoScroll: Boolean; virtual;
-    function CanEdit(Node: PVirtualNode; Column: TColumnIndex): Boolean; virtual;
-    function CanShowDragImage: Boolean; virtual;
-    procedure Change(Node: PVirtualNode);
-    procedure ChangeScale(M, D: Integer); override;
-    function CheckParentCheckState(Node: PVirtualNode; NewCheckState: TCheckState): Boolean;
-    procedure ClearTempCache;
-    function ColumnIsEmpty(Node: PVirtualNode; Column: TColumnIndex): Boolean; virtual;
-    function CountLevelDifference(Node1, Node2: PVirtualNode): Integer;
-    function CountVisibleChildren(Node: PVirtualNode): Cardinal;
-    procedure CreateParams(var Params: TCreateParams); override;
-    procedure CreateWnd; override;
-    procedure DefineProperties(Filer: TFiler); override;
-    procedure DetermineHiddenChildrenFlag(Node: PVirtualNode);
-    procedure DetermineHiddenChildrenFlagAllNodes;
-    procedure DetermineHitPositionLTR(var HitInfo: THitInfo; Offset, Right: Integer; Alignment: TAlignment); virtual;
-    procedure DetermineHitPositionRTL(var HitInfo: THitInfo; Offset, Right: Integer; Alignment: TAlignment); virtual;
-    function DetermineNextCheckState(CheckType: TCheckType; CheckState: TCheckState): TCheckState; virtual;
-    function DetermineScrollDirections(X, Y: Integer): TScrollDirections;
-    procedure DoAdvancedHeaderDraw(var PaintInfo: THeaderPaintInfo; const Elements: THeaderPaintElements); virtual;
-    procedure DoAfterCellPaint(Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex; CellRect: TRect); virtual;
-    procedure DoAfterItemErase(Canvas: TCanvas; Node: PVirtualNode; ItemRect: TRect); virtual;
-    procedure DoAfterItemPaint(Canvas: TCanvas; Node: PVirtualNode; ItemRect: TRect); virtual;
-    procedure DoAfterPaint(Canvas: TCanvas); virtual;
-    procedure DoAutoScroll(X, Y: Integer); virtual;
-    function DoBeforeDrag(Node: PVirtualNode; Column: TColumnIndex): Boolean; virtual;
-    procedure DoBeforeCellPaint(Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex; CellRect: TRect); virtual;
-    procedure DoBeforeItemErase(Canvas: TCanvas; Node: PVirtualNode; ItemRect: TRect; var Color: TColor;
-      var EraseAction: TItemEraseAction); virtual;
-    function DoBeforeItemPaint(Canvas: TCanvas; Node: PVirtualNode; ItemRect: TRect): Boolean; virtual;
-    procedure DoBeforePaint(Canvas: TCanvas); virtual;
-    function DoCancelEdit: Boolean; virtual;
-    procedure DoCanEdit(Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean); virtual;
-    procedure DoChange(Node: PVirtualNode); virtual;
-    procedure DoCheckClick(Node: PVirtualNode; NewCheckState: TCheckState); virtual;
-    procedure DoChecked(Node: PVirtualNode); virtual;
-    function DoChecking(Node: PVirtualNode; var NewCheckState: TCheckState): Boolean; virtual;
-    procedure DoCollapsed(Node: PVirtualNode); virtual;
-    function DoCollapsing(Node: PVirtualNode): Boolean; virtual;
-    procedure DoColumnClick(Column: TColumnIndex; Shift: TShiftState); virtual;
-    procedure DoColumnDblClick(Column: TColumnIndex; Shift: TShiftState); virtual;
-    procedure DoColumnResize(Column: TColumnIndex); virtual;
-    function DoCompare(Node1, Node2: PVirtualNode; Column: TColumnIndex): Integer; virtual;
-    function DoCreateDataObject: IDataObject; virtual;
-    function DoCreateDragManager: IVTDragManager; virtual;
-    function DoCreateEditor(Node: PVirtualNode; Column: TColumnIndex): IVTEditLink; virtual;
-    procedure DoDragging(P: TPoint);
-    procedure DoDragExpand;
-    function DoDragOver(Source: TObject; Shift: TShiftState; State: TDragState; Pt: TPoint; Mode: TDropMode;
-      var Effect: Integer): Boolean; virtual;
-    procedure DoDragDrop(Source: TObject; DataObject: IDataObject; Formats: TFormatArray; Shift: TShiftState; Pt: TPoint;
-      var Effect: Integer; Mode: TDropMode); virtual;
-    procedure DoEdit; virtual;
-    procedure DoEndDrag(Target: TObject; X, Y: Integer); override;
-    function DoEndEdit: Boolean; virtual;
-    procedure DoExpanded(Node: PVirtualNode); virtual;
-    function DoExpanding(Node: PVirtualNode): Boolean; virtual;
-    procedure DoFocusChange(Node: PVirtualNode; Column: TColumnIndex); virtual;
-    function DoFocusChanging(OldNode, NewNode: PVirtualNode; OldColumn, NewColumn: TColumnIndex): Boolean; virtual;
-    procedure DoFocusNode(Node: PVirtualNode; Ask: Boolean); virtual;
-    procedure DoFreeNode(Node: PVirtualNode); virtual;
-    function DoGetAnimationType: THintAnimationType; virtual;
-    procedure DoGetCursor(var Cursor: TCursor); virtual;
-    procedure DoGetHeaderCursor(var Cursor: HCURSOR); virtual;
-    procedure DoGetImageIndex(Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex;
-      var Ghosted: Boolean; var Index: Integer); virtual;
-    procedure DoGetLineStyle(var Bits: Pointer); virtual;
-    function DoGetNodeHint(Node: PVirtualNode; Column: TColumnIndex): WideString; virtual;
-    function DoGetNodeTooltip(Node: PVirtualNode; Column: TColumnIndex): WideString; virtual;
-    function DoGetNodeWidth(Node: PVirtualNode; Column: TColumnIndex; Canvas: TCanvas = nil): Integer; virtual;
-    function DoGetPopupMenu(Node: PVirtualNode; Column: TColumnIndex; Position: TPoint): TPopupMenu; virtual;
-    procedure DoGetUserClipboardFormats(var Formats: TFormatEtcArray); virtual;
-    procedure DoHeaderClick(Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); virtual;
-    procedure DoHeaderDblClick(Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); virtual;
-    procedure DoHeaderDragged(Column: TColumnIndex; OldPosition: TColumnPosition); virtual;
-    procedure DoHeaderDraggedOut(Column: TColumnIndex; DropPosition: TPoint); virtual;
-    function DoHeaderDragging(Column: TColumnIndex): Boolean; virtual;
-    procedure DoHeaderDraw(Canvas: TCanvas; Column: TVirtualTreeColumn; R: TRect; Hover, Pressed: Boolean;
-      DropMark: TVTDropMarkMode); virtual;
-    procedure DoHeaderDrawQueryElements(var PaintInfo: THeaderPaintInfo; var Elements: THeaderPaintElements); virtual;
-    procedure DoHeaderMouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); virtual;
-    procedure DoHeaderMouseMove(Shift: TShiftState; X, Y: Integer); virtual;
-    procedure DoHeaderMouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); virtual;
-    procedure DoHotChange(Old, New: PVirtualNode); virtual;
-    function DoIncrementalSearch(Node: PVirtualNode; const Text: WideString): Integer; virtual;
-    procedure DoInitChildren(Node: PVirtualNode; var ChildCount: Cardinal); virtual;
-    procedure DoInitNode(Parent, Node: PVirtualNode; var InitStates: TVirtualNodeInitStates); virtual;
-    function DoKeyAction(var CharCode: Word; var Shift: TShiftState): Boolean; virtual;
-    procedure DoLoadUserData(Node: PVirtualNode; Stream: TStream); virtual;
-    procedure DoNodeCopied(Node: PVirtualNode); virtual;
-    function DoNodeCopying(Node, NewParent: PVirtualNode): Boolean; virtual;
-    procedure DoNodeMoved(Node: PVirtualNode); virtual;
-    function DoNodeMoving(Node, NewParent: PVirtualNode): Boolean; virtual;
-    function DoPaintBackground(Canvas: TCanvas; R: TRect): Boolean; virtual;
-    procedure DoPaintDropMark(Canvas: TCanvas; Node: PVirtualNode; R: TRect); virtual;
-    procedure DoPaintNode(var PaintInfo: TVTPaintInfo); virtual;
-    procedure DoPopupMenu(Node: PVirtualNode; Column: TColumnIndex; Position: TPoint); virtual;
-    function DoRenderOLEData(const FormatEtcIn: TFormatEtc; out Medium: TStgMedium;
-      ForClipboard: Boolean): HRESULT; virtual;
-    procedure DoReset(Node: PVirtualNode); virtual;
-    procedure DoSaveUserData(Node: PVirtualNode; Stream: TStream); virtual;
-    procedure DoScroll(DeltaX, DeltaY: Integer); virtual;
-    function DoSetOffsetXY(Value: TPoint; Options: TScrollUpdateOptions; ClipRect: PRect = nil): Boolean; virtual;
-    procedure DoStartDrag(var DragObject: TDragObject); override;
-    procedure DoStateChange(Enter: TVirtualTreeStates; Leave: TVirtualTreeStates = []); virtual;
-    procedure DoStructureChange(Node: PVirtualNode; Reason: TChangeReason); virtual;
-    procedure DoTimerScroll;
-    procedure DoUpdating(State: TVTUpdateState); virtual;
-    function DoValidateCache: Boolean;
-    procedure DragCanceled; override;
-    function DragDrop(const DataObject: IDataObject; KeyState: Integer; Pt: TPoint;
-      var Effect: Integer): HResult; reintroduce; virtual;
-    function DragEnter(KeyState: Integer; Pt: TPoint; var Effect: Integer): HResult; virtual;
-    procedure DragFinished;
-    procedure DragLeave; virtual;
-    function DragOver(Source: TObject; KeyState: Integer; DragState: TDragState; Pt: TPoint;
-      var Effect: Integer): HResult; reintroduce; virtual;
-    procedure DrawDottedHLine(const PaintInfo: TVTPaintInfo; Left, Right, Top: Integer);
-    procedure DrawDottedVLine(const PaintInfo: TVTPaintInfo; Top, Bottom, Left: Integer);
-    function FindNodeInSelection(P: PVirtualNode; var Index: Integer; LowBound, HighBound: Integer): Boolean;
-    procedure FinishChunkHeader(Stream: TStream; StartPos, EndPos: Integer);
-    procedure FontChanged(AFont: TObject);
-    function GetCheckImage(Node: PVirtualNode): Integer; virtual;
-    function GetColumnClass: TVirtualTreeColumnClass; virtual;
-    function GetHeaderClass: TVTHeaderClass; virtual;
-    function GetImageIndex(Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex; var Ghosted: Boolean): Integer;
-    function GetMaxRightExtend: Cardinal;
-    procedure GetNativeClipboardFormats(var Formats: TFormatEtcArray); virtual;
-    function GetOptionsClass: TTreeOptionsClass; virtual;
-    procedure GetTextInfo(Node: PVirtualNode; Column: TColumnIndex; const AFont: TFont; var R: TRect;
-      var Text: WideString); virtual;
-    function GetTreeFromDataObject(const DataObject: IDataObject): TBaseVirtualTree;
-    procedure HandleHotTrack(X, Y: Integer);
-    procedure HandleIncrementalSearch(CharCode: Word);
-    procedure HandleMouseDblClick(var Message: TWMMouse; const HitInfo: THitInfo);
-    procedure HandleMouseDown(var Message: TWMMouse; const HitInfo: THitInfo);
-    procedure HandleMouseUp(var Message: TWMMouse; const HitInfo: THitInfo);
-    function HasPopupMenu(Node: PVirtualNode; Column: TColumnIndex; Pos: TPoint): Boolean; virtual;
-    procedure InitChildren(Node: PVirtualNode);
-    procedure InitNode(Node: PVirtualNode);
-    procedure InternalAddFromStream(Stream: TStream; Version: Integer; Node: PVirtualNode);
-    function InternalAddToSelection(Node: PVirtualNode; ForceInsert: Boolean): Boolean; overload;
-    function InternalAddToSelection(const NewItems: TNodeArray; NewLength: Integer;
-      ForceInsert: Boolean): Boolean; overload;
-    procedure InternalCacheNode(Node: PVirtualNode);
-    procedure InternalClearSelection;
-    procedure InternalConnectNode(Node, Destination: PVirtualNode; Target: TBaseVirtualTree; Mode: TVTNodeAttachMode);
-    function InternalData(Node: PVirtualNode): Pointer;
-    procedure InternalDisconnectNode(Node: PVirtualNode; KeepFocus: Boolean; Reindex: Boolean = True);
-    procedure InternalRemoveFromSelection(Node: PVirtualNode);
-    procedure InvalidateCache;
-    procedure Loaded; override;
-    procedure MainColumnChanged; virtual;
-    procedure MarkCutCopyNodes;
-    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
-    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
-    procedure Paint; override;
-    procedure PaintCheckImage(const PaintInfo: TVTPaintInfo); virtual;
-    procedure PaintImage(const PaintInfo: TVTPaintInfo; ImageInfoIndex: TVTImageInfoIndex; Images: TCustomImageList;
-      DoOverlay: Boolean); virtual;
-    procedure PaintNodeButton(Canvas: TCanvas; Node: PVirtualNode; const R: TRect; ButtonX, ButtonY: Integer;
-      BidiMode: TBiDiMode); virtual;
-    procedure PaintTreeLines(const PaintInfo: TVTPaintInfo; VAlignment, IndentSize: Integer;
-      LineImage: TLineImage); virtual;
-    procedure PaintSelectionRectangle(Target: TCanvas; WindowOrgX: Integer; const SelectionRect: TRect;
-      TargetRect: TRect);
-    procedure PanningWindowProc(var Message: TMessage);
-    function ReadChunk(Stream: TStream; Version: Integer; Node: PVirtualNode; ChunkType,
-      ChunkSize: Integer): Boolean; virtual;
-    procedure ReadNode(Stream: TStream; Version: Integer; Node: PVirtualNode); virtual;
-    procedure RedirectFontChangeEvent(Canvas: TCanvas);
-    procedure RemoveFromSelection(Node: PVirtualNode);
-    function RenderOLEData(const FormatEtcIn: TFormatEtc; out Medium: TStgMedium; ForClipboard: Boolean): HResult; virtual;
-    procedure ResetRangeAnchor;
-    procedure RestoreFontChangeEvent(Canvas: TCanvas);
-    procedure SelectNodes(StartNode, EndNode: PVirtualNode; AddOnly: Boolean);
-    procedure SetBiDiMode(Value: TBiDiMode); override;
-    procedure SkipNode(Stream: TStream); virtual;
-    procedure StartWheelPanning(Position: TPoint);
-    procedure StopWheelPanning;
-    procedure StructureChange(Node: PVirtualNode; Reason: TChangeReason);
-    function SuggestDropEffect(Source: TObject; Shift: TShiftState; Pt: TPoint; AllowedEffects: Integer): Integer; virtual;
-    procedure ToggleSelection(StartNode, EndNode: PVirtualNode);
-    procedure UnselectNodes(StartNode, EndNode: PVirtualNode);
-    procedure UpdateDesigner;
-    procedure UpdateEditBounds;
-    procedure UpdateHeaderRect;
-    procedure UpdateWindowAndDragImage(const Tree: TBaseVirtualTree; TreeRect: TRect; UpdateNCArea,
-      ReshowDragImage: Boolean);
-    procedure ValidateCache;
-    procedure ValidateNodeDataSize(var Size: Integer); virtual;
-    procedure WndProc(var Message: TMessage); override;
-    procedure WriteChunks(Stream: TStream; Node: PVirtualNode); virtual;
-    procedure WriteNode(Stream: TStream; Node: PVirtualNode);
-
-    property Alignment: TAlignment read FAlignment write SetAlignment default taLeftJustify;
-    property AnimationDuration: Cardinal read FAnimationDuration write SetAnimationDuration default 200;
-    property AutoExpandDelay: Cardinal read FAutoExpandDelay write FAutoExpandDelay default 1000;
-    property AutoScrollDelay: Cardinal read FAutoScrollDelay write FAutoScrollDelay default 1000;
-    property AutoScrollInterval: TAutoScrollInterval read FAutoScrollInterval write FAutoScrollInterval default 1;
-    property Background: TPicture read FBackground write SetBackground;
-    property BackgroundOffsetX: Integer index 0 read FBackgroundOffsetX write SetBackgroundOffset default 0;
-    property BackgroundOffsetY: Integer index 1 read FBackgroundOffsetY write SetBackgroundOffset default 0;
-    property BorderStyle: TBorderStyle read FBorderStyle write SetBorderStyle default bsSingle;
-    property ButtonFillMode: TVTButtonFillMode read FButtonFillMode write SetButtonFillMode default fmTreeColor;
-    property ButtonStyle: TVTButtonStyle read FButtonStyle write SetButtonStyle default bsRectangle;
-    property ChangeDelay: Cardinal read FChangeDelay write FChangeDelay default 0;
-    property CheckImageKind: TCheckImageKind read FCheckImageKind write SetCheckImageKind default ckLightCheck;
-    property ClipboardFormats: TClipboardFormats read FClipboardFormats write SetClipboardFormats;
-    property Colors: TVTColors read FColors write SetColors;
-    property CustomCheckImages: TCustomImageList read FCustomCheckImages write SetCustomCheckImages;
-    property DefaultNodeHeight: Cardinal read FDefaultNodeHeight write SetDefaultNodeHeight default 18;
-    property DefaultPasteMode: TVTNodeAttachMode read FDefaultPasteMode write FDefaultPasteMode default amAddChildLast;
-    property DragHeight: Integer read FDragHeight write FDragHeight default 350;
-    property DragImageKind: TVTDragImageKind read FDragImageKind write FDragImageKind default diComplete;
-    property DragOperations: TDragOperations read FDragOperations write FDragOperations default [doCopy, doMove];
-    property DragSelection: TNodeArray read FDragSelection;
-    property DragType: TVTDragType read FDragType write FDragType default dtOLE;
-    property DragWidth: Integer read FDragWidth write FDragWidth default 200;
-    property DrawSelectionMode: TVTDrawSelectionMode read FDrawSelectionMode write FDrawSelectionMode
-      default smDottedRectangle;
-    property EditDelay: Cardinal read FEditDelay write FEditDelay default 1000;
-    property Header: TVTHeader read FHeader write SetHeader;
-    property HeaderRect: TRect read FHeaderRect;
-    property HintAnimation: THintAnimationType read FAnimationType write FAnimationType default hatSystemDefault;
-    property HintMode: TVTHintMode read FHintMode write FHintMode default hmDefault;
-    property HotCursor: TCursor read FHotCursor write FHotCursor default crDefault;
-    property Images: TCustomImageList read FImages write SetImages;
-    property IncrementalSearch: TVTIncrementalSearch read FIncrementalSearch write SetSearchOption default isNone;
-    property IncrementalSearchDirection: TVTSearchDirection read FSearchDirection write FSearchDirection default sdForward;
-    property IncrementalSearchStart: TVTSearchStart read FSearchStart write FSearchStart default ssFocusedNode;
-    property IncrementalSearchTimeout: Cardinal read FSearchTimeout write FSearchTimeout default 1000;
-    property Indent: Cardinal read FIndent write SetIndent default 18;
-    property LastDropMode: TDropMode read FLastDropMode write FlastDropMode;
-    property LineMode: TVTLineMode read FLineMode write SetLineMode default lmNormal;
-    property LineStyle: TVTLineStyle read FLineStyle write SetLineStyle default lsDotted;
-    property Margin: Integer read FMargin write SetMargin default 4;
-    property NodeAlignment: TVTNodeAlignment read FNodeAlignment write SetNodeAlignment default naProportional;
-    property NodeDataSize: Integer read FNodeDataSize write SetNodeDataSize default -1;
-    property RootNodeCount: Cardinal read GetRootNodeCount write SetRootNodeCount default 0;
-    property ScrollBarOptions: TScrollBarOptions read FScrollBarOptions write SetScrollBarOptions;
-    property SelectionBlendFactor: Byte read FSelectionBlendFactor write FSelectionBlendFactor default 128;
-    property SelectionCurveRadius: Cardinal read FSelectionCurveRadius write SetSelectionCurveRadius default 0;
-    property StateImages: TCustomImageList read FStateImages write SetStateImages;
-    property TextMargin: Integer read FTextMargin write SetTextMargin default 4;
-    property TotalInternalDataSize: Cardinal read FTotalInternalDataSize;
-    property TreeOptions: TCustomVirtualTreeOptions read FOptions write SetOptions;
-    property WantTabs: Boolean read FWantTabs write FWantTabs default False;
-
-    property OnAdvancedHeaderDraw: TVTAdvancedHeaderPaintEvent read FOnAdvancedHeaderDraw write FOnAdvancedHeaderDraw; 
-    property OnAfterCellPaint: TVTAfterCellPaintEvent read FOnAfterCellPaint write FOnAfterCellPaint;
-    property OnAfterItemErase: TVTAfterItemEraseEvent read FOnAfterItemErase write FOnAfterItemErase;
-    property OnAfterItemPaint: TVTAfterItemPaintEvent read FOnAfterItemPaint write FOnAfterItemPaint;
-    property OnAfterPaint: TVTPaintEvent read FOnAfterPaint write FOnAfterPaint;
-    property OnBeforeCellPaint: TVTBeforeCellPaintEvent read FOnBeforeCellPaint write FOnBeforeCellPaint;
-    property OnBeforeItemErase: TVTBeforeItemEraseEvent read FOnBeforeItemErase write FOnBeforeItemErase;
-    property OnBeforeItemPaint: TVTBeforeItemPaintEvent read FOnBeforeItemPaint write FOnBeforeItemPaint;
-    property OnBeforePaint: TVTPaintEvent read FOnBeforePaint write FOnBeforePaint;
-    property OnChange: TVTChangeEvent read FOnChange write FOnChange;
-    property OnChecked: TVTChangeEvent read FOnChecked write FOnChecked;
-    property OnChecking: TVTCheckChangingEvent read FOnChecking write FOnChecking;
-    property OnCollapsed: TVTChangeEvent read FOnCollapsed write FOnCollapsed;
-    property OnCollapsing: TVTChangingEvent read FOnCollapsing write FOnCollapsing;
-    property OnColumnClick: TVTColumnClickEvent read FOnColumnClick write FOnColumnClick;
-    property OnColumnDblClick: TVTColumnDblClickEvent read FOnColumnDblClick write FOnColumnDblClick;
-    property OnColumnResize: TVTHeaderNotifyEvent read FOnColumnResize write FOnColumnResize;
-    property OnCompareNodes: TVTCompareEvent read FOnCompareNodes write FOnCompareNodes;
-    property OnCreateDataObject: TVTCreateDataObjectEvent read FOnCreateDataObject write FOnCreateDataObject;
-    property OnCreateDragManager: TVTCreateDragManagerEvent read FOnCreateDragManager write FOnCreateDragManager;
-    property OnCreateEditor: TVTCreateEditorEvent read FOnCreateEditor write FOnCreateEditor;
-    property OnDragAllowed: TVTDragAllowedEvent read FOnDragAllowed write FOnDragAllowed;
-    property OnDragOver: TVTDragOverEvent read FOnDragOver write FOnDragOver;
-    property OnDragDrop: TVTDragDropEvent read FOnDragDrop write FOnDragDrop;
-    property OnEditCancelled: TVTEditCancelEvent read FOnEditCancelled write FOnEditCancelled;
-    property OnEditing: TVTEditChangingEvent read FOnEditing write FOnEditing;
-    property OnEdited: TVTEditChangeEvent read FOnEdited write FOnEdited;
-    property OnExpanded: TVTChangeEvent read FOnExpanded write FOnExpanded;
-    property OnExpanding: TVTChangingEvent read FOnExpanding write FOnExpanding;
-    property OnFocusChanged: TVTFocusChangeEvent read FOnFocusChanged write FOnFocusChanged;
-    property OnFocusChanging: TVTFocusChangingEvent read FOnFocusChanging write FOnFocusChanging;
-    property OnFreeNode: TVTFreeNodeEvent read FOnFreeNode write FOnFreeNode;
-    property OnGetCursor: TVTGetCursorEvent read FOnGetCursor write FOnGetCursor;
-    property OnGetHeaderCursor: TVTGetHeaderCursorEvent read FOnGetHeaderCursor write FOnGetHeaderCursor;
-    property OnGetHelpContext: TVTHelpContextEvent read FOnGetHelpContext write FOnGetHelpContext;
-    property OnGetImageIndex: TVTGetImageEvent read FOnGetImage write FOnGetImage;
-    property OnGetLineStyle: TVTGetLineStyleEvent read FOnGetLineStyle write FOnGetLineStyle;
-    property OnGetNodeDataSize: TVTGetNodeDataSizeEvent read FOnGetNodeDataSize write FOnGetNodeDataSize;
-    property OnGetPopupMenu: TVTPopupEvent read FOnGetPopupMenu write FOnGetPopupMenu;
-    property OnGetUserClipboardFormats: TVTGetUserClipboardFormatsEvent read FOnGetUserClipboardFormats
-      write FOnGetUserClipboardFormats;
-    property OnHeaderClick: TVTHeaderClickEvent read FOnHeaderClick write FOnHeaderClick;
-    property OnHeaderDblClick: TVTHeaderClickEvent read FOnHeaderDblClick write FOnHeaderDblClick;
-    property OnHeaderDragged: TVTHeaderDraggedEvent read FOnHeaderDragged write FOnHeaderDragged;
-    property OnHeaderDraggedOut: TVTHeaderDraggedOutEvent read FOnHeaderDraggedOut write FOnHeaderDraggedOut;
-    property OnHeaderDragging: TVTHeaderDraggingEvent read FOnHeaderDragging write FOnHeaderDragging;
-    property OnHeaderDraw: TVTHeaderPaintEvent read FOnHeaderDraw write FOnHeaderDraw;
-    property OnHeaderDrawQueryElements: TVTHeaderPaintQueryElementsEvent read FOnHeaderDrawQueryElements
-      write FOnHeaderDrawQueryElements;
-    property OnHeaderMouseDown: TVTHeaderMouseEvent read FOnHeaderMouseDown write FOnHeaderMouseDown;
-    property OnHeaderMouseMove: TVTHeaderMouseMoveEvent read FOnHeaderMouseMove write FOnHeaderMouseMove;
-    property OnHeaderMouseUp: TVTHeaderMouseEvent read FOnHeaderMouseUp write FOnHeaderMouseUp;
-    property OnHotChange: TVTHotNodeChangeEvent read FOnHotChange write FOnHotChange;
-    property OnIncrementalSearch: TVTIncrementalSearchEvent read FOnIncrementalSearch write FOnIncrementalSearch;
-    property OnInitChildren: TVTInitChildrenEvent read FOnInitChildren write FOnInitChildren;
-    property OnInitNode: TVTInitNodeEvent read FOnInitNode write FOnInitNode;
-    property OnKeyAction: TVTKeyActionEvent read FOnKeyAction write FOnKeyAction;
-    property OnLoadNode: TVTSaveNodeEvent read FOnLoadNode write FOnLoadNode;
-    property OnNodeCopied: TVTNodeCopiedEvent read FOnNodeCopied write FOnNodeCopied;
-    property OnNodeCopying: TVTNodeCopyingEvent read FOnNodeCopying write FOnNodeCopying;
-    property OnNodeMoved: TVTNodeMovedEvent read FOnNodeMoved write FOnNodeMoved;
-    property OnNodeMoving: TVTNodeMovingEvent read FOnNodeMoving write FOnNodeMoving;
-    property OnPaintBackground: TVTBackgroundPaintEvent read FOnPaintBackground write FOnPaintBackground;
-    property OnRenderOLEData: TVTRenderOLEDataEvent read FOnRenderOLEData write FOnRenderOLEData;
-    property OnResetNode: TVTChangeEvent read FOnResetNode write FOnResetNode;
-    property OnSaveNode: TVTSaveNodeEvent read FOnSaveNode write FOnSaveNode;
-    property OnScroll: TVTScrollEvent read FOnScroll write FOnScroll;
-    property OnStateChange: TVTStateChangeEvent read FOnStateChange write FOnStateChange;
-    property OnStructureChange: TVTStructureChangeEvent read FOnStructureChange write FOnStructureChange;
-    property OnUpdating: TVTUpdatingEvent read FOnUpdating write FOnUpdating;
-  public
-    constructor Create(AOwner: TComponent); override;
-    destructor Destroy; override;
-
-    function AbsoluteIndex(Node: PVirtualNode): Cardinal;
-    function AddChild(Parent: PVirtualNode; UserData: Pointer = nil): PVirtualNode;
-    procedure AddFromStream(Stream: TStream; TargetNode: PVirtualNode);
-    procedure AfterConstruction; override;
-    procedure Assign(Source: TPersistent); override;
-    procedure BeginDrag(Immediate: Boolean; Threshold: Integer = -1);
-    procedure BeginSynch;
-    procedure BeginUpdate;
-    procedure CancelCutOrCopy; 
-    function CancelEditNode: Boolean;
-    function CanFocus: Boolean; {$ifdef COMPILER_5_UP} override;{$endif}
-    procedure Clear; virtual;
-    procedure ClearSelection;
-    function CopyTo(Source: PVirtualNode; Tree: TBaseVirtualTree; Mode: TVTNodeAttachMode;
-      ChildrenOnly: Boolean): PVirtualNode; overload;
-    function CopyTo(Source, Target: PVirtualNode; Mode: TVTNodeAttachMode;
-      ChildrenOnly: Boolean): PVirtualNode; overload;
-    procedure CopyToClipBoard; virtual;
-    procedure CutToClipBoard; virtual;
-    procedure DeleteChildren(Node: PVirtualNode; ResetHasChildren: Boolean = False);
-    procedure DeleteNode(Node: PVirtualNode; Reindex: Boolean = True);
-    procedure DeleteSelectedNodes; virtual;
-    function Dragging: Boolean;
-    function EditNode(Node: PVirtualNode; Column: TColumnIndex): Boolean; virtual;
-    function EndEditNode: Boolean;
-    procedure EndSynch;
-    procedure EndUpdate;
-    function ExecuteAction(Action: TBasicAction): Boolean; override;
-    procedure FinishCutOrCopy;
-    procedure FlushClipboard;
-    procedure FullCollapse(Node: PVirtualNode = nil);  virtual;
-    procedure FullExpand(Node: PVirtualNode = nil); virtual;
-    function GetControlsAlignment: TAlignment; override;
-    function GetDisplayRect(Node: PVirtualNode; Column: TColumnIndex; TextOnly: Boolean; Unclipped: Boolean = False): TRect;
-    function GetFirst: PVirtualNode;
-    function GetFirstChild(Node: PVirtualNode): PVirtualNode;
-    function GetFirstCutCopy: PVirtualNode;
-    function GetFirstInitialized: PVirtualNode;
-    function GetFirstNoInit: PVirtualNode;
-    function GetFirstSelected: PVirtualNode;
-    function GetFirstVisible: PVirtualNode;
-    function GetFirstVisibleChild(Node: PVirtualNode): PVirtualNode;
-    function GetFirstVisibleChildNoInit(Node: PVirtualNode): PVirtualNode;
-    function GetFirstVisibleNoInit: PVirtualNode;
-    procedure GetHitTestInfoAt(X, Y: Integer; Relative: Boolean; var HitInfo: THitInfo);
-    function GetLast(Node: PVirtualNode = nil): PVirtualNode;
-    function GetLastInitialized(Node: PVirtualNode = nil): PVirtualNode;
-    function GetLastNoInit(Node: PVirtualNode = nil): PVirtualNode;
-    function GetLastChild(Node: PVirtualNode): PVirtualNode;
-    function GetLastChildNoInit(Node: PVirtualNode): PVirtualNode;
-    function GetLastVisible(Node: PVirtualNode = nil): PVirtualNode;
-    function GetLastVisibleChild(Node: PVirtualNode): PVirtualNode;
-    function GetLastVisibleChildNoInit(Node: PVirtualNode): PVirtualNode;
-    function GetLastVisibleNoInit(Node: PVirtualNode = nil): PVirtualNode;
-    function GetMaxColumnWidth(Column: TColumnIndex): Integer;
-    function GetNext(Node: PVirtualNode): PVirtualNode;
-    function GetNextCutCopy(Node: PVirtualNode): PVirtualNode;
-    function GetNextInitialized(Node: PVirtualNode): PVirtualNode;
-    function GetNextNoInit(Node: PVirtualNode): PVirtualNode;
-    function GetNextSelected(Node: PVirtualNode): PVirtualNode;
-    function GetNextSibling(Node: PVirtualNode): PVirtualNode;
-    function GetNextVisible(Node: PVirtualNode): PVirtualNode;
-    function GetNextVisibleNoInit(Node: PVirtualNode): PVirtualNode;
-    function GetNextVisibleSibling(Node: PVirtualNode): PVirtualNode;
-    function GetNextVisibleSiblingNoInit(Node: PVirtualNode): PVirtualNode;
-    function GetNodeAt(X, Y: Integer): PVirtualNode; overload;
-    function GetNodeAt(X, Y: Integer; Relative: Boolean; var NodeTop: Integer): PVirtualNode; overload;
-    function GetNodeData(Node: PVirtualNode): Pointer;
-    function GetNodeLevel(Node: PVirtualNode): Cardinal;
-    function GetPrevious(Node: PVirtualNode): PVirtualNode;
-    function GetPreviousInitialized(Node: PVirtualNode): PVirtualNode;
-    function GetPreviousNoInit(Node: PVirtualNode): PVirtualNode;
-    function GetPreviousSibling(Node: PVirtualNode): PVirtualNode;
-    function GetPreviousVisible(Node: PVirtualNode): PVirtualNode;
-    function GetPreviousVisibleNoInit(Node: PVirtualNode): PVirtualNode;
-    function GetPreviousVisibleSibling(Node: PVirtualNode): PVirtualNode;
-    function GetPreviousVisibleSiblingNoInit(Node: PVirtualNode): PVirtualNode;
-    function GetSortedCutCopySet(Resolve: Boolean): TNodeArray;
-    function GetSortedSelection(Resolve: Boolean): TNodeArray;
-    function GetTreeRect: TRect;
-    function GetVisibleParent(Node: PVirtualNode): PVirtualNode;
-    function HasAsParent(Node, PotentialParent: PVirtualNode): Boolean;
-    function InsertNode(Node: PVirtualNode; Mode: TVTNodeAttachMode; UserData: Pointer = nil): PVirtualNode;
-    procedure InvalidateChildren(Node: PVirtualNode; Recursive: Boolean);
-    procedure InvalidateColumn(Column: TColumnIndex);
-    function InvalidateNode(Node: PVirtualNode): TRect; virtual;
-    procedure InvalidateToBottom(Node: PVirtualNode);
-    procedure InvertSelection(VisibleOnly: Boolean);
-    function IsEditing: Boolean;
-    function IsMouseSelecting: Boolean;
-    function IterateSubtree(Node: PVirtualNode; Callback: TVTGetNodeProc; Data: Pointer; Filter: TVirtualNodeStates = [];
-      DoInit: Boolean = False; ChildNodesOnly: Boolean = False): PVirtualNode;
-    procedure LoadFromFile(const FileName: TFileName); virtual;
-    procedure LoadFromStream(Stream: TStream); virtual;
-    procedure MoveTo(Source, Target: PVirtualNode; Mode: TVTNodeAttachMode; ChildrenOnly: Boolean); overload;
-    procedure MoveTo(Node: PVirtualNode; Tree: TBaseVirtualTree; Mode: TVTNodeAttachMode;
-      ChildrenOnly: Boolean); overload;
-    procedure PaintTree(TargetCanvas: TCanvas; Window: TRect; Target: TPoint; PaintOptions: TVTInternalPaintOptions);
-    function PasteFromClipboard: Boolean; virtual;
-    procedure PrepareDragImage(HotSpot: TPoint; const DataObject: IDataObject);
-    procedure Print(Printer: TPrinter; PrintHeader: Boolean);
-    function ProcessDrop(DataObject: IDataObject; TargetNode: PVirtualNode; var Effect: Integer; Mode:
-      TVTNodeAttachMode): Boolean;
-    function ProcessOLEData(Source: TBaseVirtualTree; DataObject: IDataObject; TargetNode: PVirtualNode;
-      Mode: TVTNodeAttachMode; Optimized: Boolean): Boolean;
-    procedure RepaintNode(Node: PVirtualNode);
-    procedure ReinitChildren(Node: PVirtualNode; Recursive: Boolean); virtual;
-    procedure ReinitNode(Node: PVirtualNode; Recursive: Boolean); virtual;
-    procedure ResetNode(Node: PVirtualNode); virtual;
-    procedure SaveToFile(const FileName: TFileName);
-    procedure SaveToStream(Stream: TStream; Node: PVirtualNode = nil); virtual;
-    function ScrollIntoView(Node: PVirtualNode; Center: Boolean; Horizontally: Boolean = False): Boolean;
-    procedure SelectAll(VisibleOnly: Boolean);
-    procedure Sort(Node: PVirtualNode; Column: TColumnIndex; Direction: TSortDirection; DoInit: Boolean = True); virtual;
-    procedure SortTree(Column: TColumnIndex; Direction: TSortDirection; DoInit: Boolean = True);
-    procedure ToggleNode(Node: PVirtualNode);
-    function UpdateAction(Action: TBasicAction): Boolean; override;
-    procedure UpdateHorizontalScrollBar(DoRepaint: Boolean);
-    procedure UpdateScrollBars(DoRepaint: Boolean); virtual;
-    procedure UpdateVerticalScrollBar(DoRepaint: Boolean);
-    function UseRightToLeftReading: Boolean;
-    procedure ValidateChildren(Node: PVirtualNode; Recursive: Boolean);
-    procedure ValidateNode(Node: PVirtualNode; Recursive: Boolean);
-
-    property CheckState[Node: PVirtualNode]: TCheckState read GetCheckState write SetCheckState;
-    property CheckType[Node: PVirtualNode]: TCheckType read GetCheckType write SetCheckType;
-    property ChildCount[Node: PVirtualNode]: Cardinal read GetChildCount write SetChildCount;
-    property ChildrenInitialized[Node: PVirtualNode]: Boolean read GetChildrenInitialized;
-    property DragImage: TVTDragImage read FDragImage;
-    property DragManager: IVTDragManager read GetDragManager;
-    property DropTargetNode: PVirtualNode read FDropTargetNode;
-    property EditLink: IVTEditLink read FEditLink;
-    property Expanded[Node: PVirtualNode]: Boolean read GetExpanded write SetExpanded;
-    property FocusedColumn: TColumnIndex read FFocusedColumn write SetFocusedColumn default InvalidColumn;
-    property FocusedNode: PVirtualNode read FFocusedNode write SetFocusedNode;
-    property Font;
-    property FullyVisible[Node: PVirtualNode]: Boolean read GetFullyVisible write SetFullyVisible;
-    property HasChildren[Node: PVirtualNode]: Boolean read GetHasChildren write SetHasChildren;
-    property HotNode: PVirtualNode read FCurrentHotNode;
-    property IsDisabled[Node: PVirtualNode]: Boolean read GetDisabled write SetDisabled;
-    property IsVisible[Node: PVirtualNode]: Boolean read GetVisible write SetVisible;
-    property MultiLine[Node: PVirtualNode]: Boolean read GetMultiline write SetMultiline;
-    property NodeHeight[Node: PVirtualNode]: Cardinal read GetNodeHeight write SetNodeHeight;
-    property NodeParent[Node: PVirtualNode]: PVirtualNode read GetNodeParent write SetNodeParent;
-    property OffsetX: Integer read FOffsetX write SetOffsetX;
-    property OffsetXY: TPoint read GetOffsetXY write SetOffsetXY;
-    property OffsetY: Integer read FOffsetY write SetOffsetY;
-    property RootNode: PVirtualNode read FRoot;
-    property SearchBuffer: WideString read FSearchBuffer;
-    property Selected[Node: PVirtualNode]: Boolean read GetSelected write SetSelected;
-    property TotalCount: Cardinal read GetTotalCount;
-    property TreeStates: TVirtualTreeStates read FStates write FStates;
-    property SelectedCount: Integer read FSelectionCount;
-    property TopNode: PVirtualNode read GetTopNode write SetTopNode;
-    property VerticalAlignment[Node: PVirtualNode]: Byte read GetVerticalAlignment write SetVerticalAlignment;
-    property VisibleCount: Cardinal read FVisibleCount;
-    property VisiblePath[Node: PVirtualNode]: Boolean read GetVisiblePath write SetVisiblePath;
-  end;
-
-
-  // --------- TCustomVirtualStringTree
-
-  // Options regarding strings (useful only for the string tree and descentants):
-  TVTStringOption = (
-    toSaveCaptions,          // If set then the caption is automatically saved with the tree node, regardless of what is
-                             // saved in the user data.
-    toShowStaticText,        // Show static text in a caption which can be differently formatted than the caption
-                             // but cannot be edited.
-    toAutoAcceptEditChange   // Automatically accept changes during edit if the user finishes editing other then
-                             // VK_RETURN or ESC. If not set then changes are cancelled.
-  );
-  TVTStringOptions = set of TVTStringOption;
-
-const
-  DefaultStringOptions = [toSaveCaptions, toAutoAcceptEditChange];
-
-type
-  TCustomStringTreeOptions = class(TCustomVirtualTreeOptions)
-  private
-    FStringOptions: TVTStringOptions;
-    procedure SetStringOptions(const Value: TVTStringOptions);
-  protected
-    property StringOptions: TVTStringOptions read FStringOptions write SetStringOptions default DefaultStringOptions;
-  public
-    constructor Create(AOwner: TBaseVirtualTree); override;
-
-    procedure AssignTo(Dest: TPersistent); override;
-  end;
-
-  TStringTreeOptions = class(TCustomStringTreeOptions)
-  published
-    property AnimationOptions;
-    property AutoOptions;
-    property MiscOptions;
-    property PaintOptions;
-    property SelectionOptions;
-    property StringOptions;
-  end;
-
-  TCustomVirtualStringTree = class;
-
-  // Edit support classes.
-  TStringEditLink = class;
-
-  {$ifdef TntSupport}
-    TVTEdit = class(TTntEdit)
-  {$else}
-    TVTEdit = class(TCustomEdit)
-  {$endif TntSupport}
-  private
-    FLink: TStringEditLink;
-    procedure CMAutoAdjust(var Message: TMessage); message CM_AUTOADJUST;
-    procedure CMExit(var Message: TMessage); message CM_EXIT;
-    procedure CNCommand(var Message: TWMCommand); message CN_COMMAND;
-    procedure WMChar(var Message: TWMChar); message WM_CHAR;
-    procedure WMDestroy(var Message: TWMDestroy); message WM_DESTROY;
-    procedure WMGetDlgCode(var Message: TWMGetDlgCode); message WM_GETDLGCODE;
-    procedure WMKeyDown(var Message: TWMKeyDown); message WM_KEYDOWN;
-  protected
-    procedure AutoAdjustSize;
-    procedure CreateParams(var Params: TCreateParams); override;
-  public
-    constructor Create(Link: TStringEditLink); reintroduce;
-
-    property AutoSelect;
-    property AutoSize;
-    property BorderStyle;
-    property CharCase;
-    property HideSelection;
-    property MaxLength;
-    property OEMConvert;
-    property PasswordChar;
-  end;
-
-  TStringEditLink = class(TInterfacedObject, IVTEditLink)
-  private
-    FEdit: TVTEdit;                  // A normal custom edit control.
-    FTree: TCustomVirtualStringTree; // A back reference to the tree calling.
-    FNode: PVirtualNode;             // The node to be edited.
-    FColumn: TColumnIndex;           // The column of the node.
-    FAlignment: TAlignment;
-    FTextBounds: TRect;              // Smallest rectangle around the text.
-    FStopping: Boolean;              // Set to True when the edit link requests stopping the edit action.
-    procedure SetEdit(const Value: TVTEdit);
-  protected
-    property Edit: TVTEdit read FEdit write SetEdit;
-  public
-    constructor Create;
-    destructor Destroy; override;
-
-    function BeginEdit: Boolean; virtual; stdcall;
-    function CancelEdit: Boolean; virtual; stdcall;
-    function EndEdit: Boolean; virtual; stdcall;
-    function GetBounds: TRect; virtual; stdcall;
-    function PrepareEdit(Tree: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex): Boolean; virtual; stdcall;
-    procedure ProcessMessage(var Message: TMessage); virtual; stdcall;
-    procedure SetBounds(R: TRect); virtual; stdcall;
-  end;
-
-  // Describes the type of text to return in the text and draw info retrival events.
-  TVSTTextType = (
-    ttNormal,      // normal label of the node, this is also the text which can be edited
-    ttStatic       // static (non-editable) text after the normal text
-  );
-
-  // Describes the source to use when converting a string tree into a string for clipboard etc.
-  TVSTTextSourceType = (
-    tstAll,             // All nodes are rendered. Initialization is done on the fly.
-    tstInitialized,     // Only initialized nodes are rendered.
-    tstSelected,        // Only selected nodes are rendered.
-    tstCutCopySet,      // Only nodes currently marked as being in the cut/copy clipboard set are rendered.
-    tstVisible          // Only visible nodes are rendered.
-  );
-
-  TVTPaintText = procedure(Sender: TBaseVirtualTree; const TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
-    TextType: TVSTTextType) of object;
-  TVSTGetTextEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex;
-    TextType: TVSTTextType; var CellText: WideString) of object;
-  // New text can only be set for variable caption.
-  TVSTNewTextEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex;
-    NewText: WideString) of object;
-  TVSTShortenStringEvent = procedure(Sender: TBaseVirtualTree; TargetCanvas: TCanvas; Node: PVirtualNode;
-    Column: TColumnIndex; const S: WideString; TextSpace: Integer; RightToLeft: Boolean; var Result: WideString;
-    var Done: Boolean) of object;
-
-  TCustomVirtualStringTree = class(TBaseVirtualTree)
-  private
-    FDefaultText: WideString;                    // text to show if there's no OnGetText event handler (e.g. at design time)
-    FTextHeight: Integer;                        // true size of the font
-    FEllipsisWidth: Integer;                     // width of '...' for the current font
-    FInternalDataOffset: Cardinal;               // offset to the internal data of the string tree
-
-    FOnPaintText: TVTPaintText;                  // triggered before either normal or fixed text is painted to allow
-                                                 // even finer customization (kind of sub cell painting)
-    FOnGetText,                                  // used to retrieve the string to be displayed for a specific node
-    FOnGetHint: TVSTGetTextEvent;                // used to retrieve the hint to be displayed for a specific node
-    FOnNewText: TVSTNewTextEvent;                // used to notify the application about an edited node caption
-    FOnShortenString: TVSTShortenStringEvent;    // used to allow the application a customized string shortage
-
-    procedure GetRenderStartValues(Source: TVSTTextSourceType; var Node: PVirtualNode;
-      var NextNodeProc: TGetNextNodeProc);
-    function GetOptions: TCustomStringTreeOptions;
-    function GetText(Node: PVirtualNode; Column: TColumnIndex): WideString;
-    procedure InitializeTextProperties(const Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex);
-    procedure PaintNormalText(var PaintInfo: TVTPaintInfo; TextOutFlags: Integer; Text: WideString);
-    procedure PaintStaticText(const PaintInfo: TVTPaintInfo; TextOutFlags: Integer; const Text: WideString);
-    procedure ReadText(Reader: TReader);
-    procedure SetDefaultText(const Value: WideString);
-    procedure SetOptions(const Value: TCustomStringTreeOptions);
-    procedure SetText(Node: PVirtualNode; Column: TColumnIndex; const Value: WideString);
-    procedure WriteText(Writer: TWriter);
-
-    procedure WMSetFont(var Msg: TWMSetFont); message WM_SETFONT;
-  protected
-    procedure AdjustPaintCellRect(var PaintInfo: TVTPaintInfo; var NextNonEmpty: TColumnIndex); override;
-    function CalculateTextWidth(Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex; Text: WideString): Integer; virtual;
-    function ColumnIsEmpty(Node: PVirtualNode; Column: TColumnIndex): Boolean; override;
-    procedure DefineProperties(Filer: TFiler); override;
-    function DoCreateEditor(Node: PVirtualNode; Column: TColumnIndex): IVTEditLink; override;
-    function DoGetNodeHint(Node: PVirtualNode; Column: TColumnIndex): WideString; override;
-    function DoGetNodeTooltip(Node: PVirtualNode; Column: TColumnIndex): WideString; override;
-    function DoGetNodeWidth(Node: PVirtualNode; Column: TColumnIndex; Canvas: TCanvas = nil): Integer; override;
-    procedure DoGetText(Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
-      var Text: WideString); virtual;
-    function DoIncrementalSearch(Node: PVirtualNode; const Text: WideString): Integer; override;
-    procedure DoNewText(Node: PVirtualNode; Column: TColumnIndex; Text: WideString); virtual;
-    procedure DoPaintNode(var PaintInfo: TVTPaintInfo); override;
-    procedure DoPaintText(Node: PVirtualNode; const Canvas: TCanvas; Column: TColumnIndex;
-      TextType: TVSTTextType); virtual;
-    function DoShortenString(Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex; const S: WideString; Width: Integer;
-      RightToLeft: Boolean; EllipsisWidth: Integer = 0): WideString; virtual;
-    function GetOptionsClass: TTreeOptionsClass; override;
-    procedure GetTextInfo(Node: PVirtualNode; Column: TColumnIndex; const AFont: TFont; var R: TRect;
-      var Text: WideString); override;
-    function InternalData(Node: PVirtualNode): Pointer;
-    procedure MainColumnChanged; override;
-    function ReadChunk(Stream: TStream; Version: Integer; Node: PVirtualNode; ChunkType,
-      ChunkSize: Integer): Boolean; override;
-    procedure ReadOldStringOptions(Reader: TReader);
-    function RenderOLEData(const FormatEtcIn: TFormatEtc; out Medium: TStgMedium; ForClipboard: Boolean): HResult; override;
-    procedure WriteChunks(Stream: TStream; Node: PVirtualNode); override;
-
-    property DefaultText: WideString read FDefaultText write SetDefaultText stored False;
-    property EllipsisWidth: Integer read FEllipsisWidth;
-    property TreeOptions: TCustomStringTreeOptions read GetOptions write SetOptions;
-
-    property OnGetHint: TVSTGettextEvent read FOnGetHint write FOnGetHint;
-    property OnGetText: TVSTGetTextEvent read FOnGetText write FOnGetText;
-    property OnNewText: TVSTNewTextEvent read FOnNewText write FOnNewText;
-    property OnPaintText: TVTPaintText read FOnPaintText write FOnPaintText;
-    property OnShortenString: TVSTShortenStringEvent read FOnShortenString write FOnShortenString;
-  public
-    constructor Create(AOwner: TComponent); override;
-
-    function ContentToClipboard(Format: Word; Source: TVSTTextSourceType): HGLOBAL;
-    function ContentToHTML(Source: TVSTTextSourceType; Caption: WideString = ''): string;
-    function ContentToRTF(Source: TVSTTextSourceType): string;
-    function ContentToText(Source: TVSTTextSourceType; Separator: Char): string;
-    function ContentToUnicode(Source: TVSTTextSourceType; Separator: WideChar): WideString;
-    function InvalidateNode(Node: PVirtualNode): TRect; override;
-    function Path(Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType; Delimiter: WideChar): WideString;
-    procedure ReinitNode(Node: PVirtualNode; Recursive: Boolean); override;
-
-    property Text[Node: PVirtualNode; Column: TColumnIndex]: WideString read GetText write SetText;
-  end;
-
-  TVirtualStringTree = class(TCustomVirtualStringTree)
-  private
-    function GetOptions: TStringTreeOptions;
-    procedure SetOptions(const Value: TStringTreeOptions);
-  protected
-    function GetOptionsClass: TTreeOptionsClass; override;
-  public
-    property Canvas;
-  published
-    property Action;
-    property Align;
-    property Alignment;
-    property Anchors;
-    property AnimationDuration;
-    property AutoExpandDelay;
-    property AutoScrollDelay;
-    property AutoScrollInterval;
-    property Background;
-    property BackgroundOffsetX;
-    property BackgroundOffsetY;
-    property BiDiMode;
-    property BevelEdges;
-    property BevelInner;
-    property BevelOuter;
-    property BevelKind;
-    property BevelWidth;
-    property BorderStyle;
-    property ButtonFillMode;
-    property ButtonStyle;
-    property BorderWidth;
-    property ChangeDelay;
-    property CheckImageKind;
-    property ClipboardFormats;
-    property Color;
-    property Colors;
-    property Constraints;
-    property Ctl3D;
-    property CustomCheckImages;
-    property DefaultNodeHeight;
-    property DefaultPasteMode;
-    property DefaultText;
-    property DragCursor;
-    property DragHeight;
-    property DragKind;
-    property DragImageKind;
-    property DragMode;
-    property DragOperations;
-    property DragType;
-    property DragWidth;
-    property DrawSelectionMode;
-    property EditDelay;
-    property Enabled;
-    property Font;
-    property Header;
-    property HintAnimation;
-    property HintMode;
-    property HotCursor;
-    property Images;
-    property IncrementalSearch;
-    property IncrementalSearchDirection;
-    property IncrementalSearchStart;
-    property IncrementalSearchTimeout;
-    property Indent;
-    property LineMode;
-    property LineStyle;
-    property Margin;
-    property NodeAlignment;
-    property NodeDataSize;
-    property ParentBiDiMode;
-    property ParentColor default False;
-    property ParentCtl3D;
-    property ParentFont;
-    property ParentShowHint;
-    property PopupMenu;
-    property RootNodeCount;
-    property ScrollBarOptions;
-    property SelectionBlendFactor;
-    property SelectionCurveRadius;
-    property ShowHint;
-    property StateImages;
-    property TabOrder;
-    property TabStop default True;
-    property TextMargin;
-    property TreeOptions: TStringTreeOptions read GetOptions write SetOptions;
-    property Visible;
-    property WantTabs;
-
-    property OnAdvancedHeaderDraw;
-    property OnAfterCellPaint;
-    property OnAfterItemErase;
-    property OnAfterItemPaint;
-    property OnAfterPaint;
-    property OnBeforeCellPaint;
-    property OnBeforeItemErase;
-    property OnBeforeItemPaint;
-    property OnBeforePaint;
-    property OnChange;
-    property OnChecked;
-    property OnChecking;
-    property OnClick;
-    property OnCollapsed;
-    property OnCollapsing;
-    property OnColumnClick;
-    property OnColumnDblClick;
-    property OnColumnResize;
-    property OnCompareNodes;
-    {$ifdef COMPILER_5_UP}
-      property OnContextPopup;
-    {$endif COMPILER_5_UP}
-    property OnCreateDataObject;
-    property OnCreateDragManager;
-    property OnCreateEditor;
-    property OnDblClick;
-    property OnDragAllowed;
-    property OnDragOver;
-    property OnDragDrop;
-    property OnEditCancelled;
-    property OnEdited;
-    property OnEditing;
-    property OnEndDock;
-    property OnEndDrag;
-    property OnEnter;
-    property OnExit;
-    property OnExpanded;
-    property OnExpanding;
-    property OnFocusChanged;
-    property OnFocusChanging;
-    property OnFreeNode;
-    property OnGetCursor;
-    property OnGetHeaderCursor;
-    property OnGetText;
-    property OnPaintText;
-    property OnGetHelpContext;
-    property OnGetImageIndex;
-    property OnGetHint;
-    property OnGetLineStyle;
-    property OnGetNodeDataSize;
-    property OnGetPopupMenu;
-    property OnGetUserClipboardFormats;
-    property OnHeaderClick;
-    property OnHeaderDblClick;
-    property OnHeaderDragged;
-    property OnHeaderDraggedOut;
-    property OnHeaderDragging;
-    property OnHeaderDraw;
-    property OnHeaderDrawQueryElements;
-    property OnHeaderMouseDown;
-    property OnHeaderMouseMove;
-    property OnHeaderMouseUp;
-    property OnHotChange;
-    property OnIncrementalSearch;
-    property OnInitChildren;
-    property OnInitNode;
-    property OnKeyAction;
-    property OnKeyDown;
-    property OnKeyPress;
-    property OnKeyUp;
-    property OnLoadNode;
-    property OnMouseDown;
-    property OnMouseMove;
-    property OnMouseUp;
-    property OnNewText;
-    property OnNodeCopied;
-    property OnNodeCopying;
-    property OnNodeMoved;
-    property OnNodeMoving;
-    property OnPaintBackground;
-    property OnRenderOLEData;
-    property OnResetNode;
-    property OnResize;
-    property OnSaveNode;
-    property OnScroll;
-    property OnShortenString;
-    property OnStartDock;
-    property OnStartDrag;
-    property OnStateChange;
-    property OnStructureChange;
-    property OnUpdating;
-  end;
-
-  TVTDrawHintEvent = procedure(Sender: TBaseVirtualTree; HintCanvas: TCanvas; Node: PVirtualNode; R: TRect;
-    Column: TColumnIndex) of object;
-  TVTDrawNodeEvent = procedure(Sender: TBaseVirtualTree; const PaintInfo: TVTPaintInfo) of object;
-  TVTGetNodeWidthEvent = procedure(Sender: TBaseVirtualTree; HintCanvas: TCanvas; Node: PVirtualNode;
-    Column: TColumnIndex; var NodeWidth: Integer) of object;
-  TVTGetHintSizeEvent = procedure(Sender: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex;
-    var R: TRect) of object;
-
-  // Tree descendant to let an application draw its stuff itself.
-  TCustomVirtualDrawTree = class(TBaseVirtualTree)
-  private
-    FOnDrawNode: TVTDrawNodeEvent;
-    FOnGetNodeWidth: TVTGetNodeWidthEvent;
-    FOnGetHintSize: TVTGetHintSizeEvent;
-    FOnDrawHint: TVTDrawHintEvent;
-  protected
-    procedure DoDrawHint(Canvas: TCanvas; Node: PVirtualNode; R: TRect; Column: TColumnIndex);
-    procedure DoGetHintSize(Node: PVirtualNode; Column: TColumnIndex; var R: TRect); virtual;
-    function DoGetNodeWidth(Node: PVirtualNode; Column: TColumnIndex; Canvas: TCanvas = nil): Integer; override;
-    procedure DoPaintNode(var PaintInfo: TVTPaintInfo); override;
-
-    property OnDrawHint: TVTDrawHintEvent read FOnDrawHint write FOnDrawHint;
-    property OnDrawNode: TVTDrawNodeEvent read FOnDrawNode write FOnDrawNode;
-    property OnGetHintSize: TVTGetHintSizeEvent read FOnGetHintSize write FOnGetHintSize;
-    property OnGetNodeWidth: TVTGetNodeWidthEvent read FOnGetNodeWidth write FOnGetNodeWidth;
-  end;
-
-  TVirtualDrawTree = class(TCustomVirtualDrawTree)
-  private
-    function GetOptions: TVirtualTreeOptions;
-    procedure SetOptions(const Value: TVirtualTreeOptions);
-  protected
-    function GetOptionsClass: TTreeOptionsClass; override;
-  public
-    property Canvas;
-  published
-    property Action;
-    property Align;
-    property Alignment;
-    property Anchors;
-    property AnimationDuration;
-    property AutoExpandDelay;
-    property AutoScrollDelay;
-    property AutoScrollInterval;
-    property Background;
-    property BackgroundOffsetX;
-    property BackgroundOffsetY;
-    property BiDiMode;
-    property BevelEdges;
-    property BevelInner;
-    property BevelOuter;
-    property BevelKind;
-    property BevelWidth;
-    property BorderStyle;
-    property ButtonFillMode;
-    property ButtonStyle;
-    property BorderWidth;
-    property ChangeDelay;
-    property CheckImageKind;
-    property ClipboardFormats;
-    property Color;
-    property Colors;
-    property Constraints;
-    property Ctl3D;
-    property CustomCheckImages;
-    property DefaultNodeHeight;
-    property DefaultPasteMode;
-    property DragCursor;
-    property DragHeight;
-    property DragKind;
-    property DragImageKind;
-    property DragMode;
-    property DragOperations;
-    property DragType;
-    property DragWidth;
-    property DrawSelectionMode;
-    property EditDelay;
-    property Enabled;
-    property Font;
-    property Header;
-    property HintAnimation;
-    property HintMode;
-    property HotCursor;
-    property Images;
-    property IncrementalSearch;
-    property IncrementalSearchDirection;
-    property IncrementalSearchStart;
-    property IncrementalSearchTimeout;
-    property Indent;
-    property LineMode;
-    property LineStyle;
-    property Margin;
-    property NodeAlignment;
-    property NodeDataSize;
-    property ParentBiDiMode;
-    property ParentColor default False;
-    property ParentCtl3D;
-    property ParentFont;
-    property ParentShowHint;
-    property PopupMenu;
-    property RootNodeCount;
-    property ScrollBarOptions;
-    property SelectionBlendFactor;
-    property SelectionCurveRadius;
-    property ShowHint;
-    property StateImages;
-    property TabOrder;
-    property TabStop default True;
-    property TextMargin;
-    property TreeOptions: TVirtualTreeOptions read GetOptions write SetOptions;
-    property Visible;
-    property WantTabs;
-
-    property OnAfterCellPaint;
-    property OnAfterItemErase;
-    property OnAfterItemPaint;
-    property OnAfterPaint;
-    property OnBeforeCellPaint;
-    property OnBeforeItemErase;
-    property OnBeforeItemPaint;
-    property OnBeforePaint;
-    property OnChange;
-    property OnChecked;
-    property OnChecking;
-    property OnClick;
-    property OnCollapsed;
-    property OnCollapsing;
-    property OnColumnClick;
-    property OnColumnDblClick;
-    property OnColumnResize;
-    property OnCompareNodes;
-    {$ifdef COMPILER_5_UP}
-      property OnContextPopup;
-    {$endif COMPILER_5_UP}
-    property OnCreateDataObject;
-    property OnCreateDragManager;
-    property OnCreateEditor;
-    property OnDblClick;
-    property OnDragAllowed;
-    property OnDragOver;
-    property OnDragDrop;
-    property OnDrawHint;
-    property OnDrawNode;
-    property OnEdited;
-    property OnEditing;
-    property OnEndDock;
-    property OnEndDrag;
-    property OnEnter;
-    property OnExit;
-    property OnExpanded;
-    property OnExpanding;
-    property OnFocusChanged;
-    property OnFocusChanging;
-    property OnFreeNode;
-    property OnGetCursor;
-    property OnGetHeaderCursor;
-    property OnGetHelpContext;
-    property OnGetHintSize;
-    property OnGetImageIndex;
-    property OnGetLineStyle;
-    property OnGetNodeDataSize;
-    property OnGetNodeWidth;
-    property OnGetPopupMenu;
-    property OnGetUserClipboardFormats;
-    property OnHeaderClick;
-    property OnHeaderDblClick;
-    property OnHeaderDragged;
-    property OnHeaderDraggedOut;
-    property OnHeaderDragging;
-    property OnHeaderDraw;
-    property OnHeaderMouseDown;
-    property OnHeaderMouseMove;
-    property OnHeaderMouseUp;
-    property OnHotChange;
-    property OnIncrementalSearch;
-    property OnInitChildren;
-    property OnInitNode;
-    property OnKeyAction;
-    property OnKeyDown;
-    property OnKeyPress;
-    property OnKeyUp;
-    property OnLoadNode;
-    property OnMouseDown;
-    property OnMouseMove;
-    property OnMouseUp;
-    property OnNodeCopied;
-    property OnNodeCopying;
-    property OnNodeMoved;
-    property OnNodeMoving;
-    property OnPaintBackground;
-    property OnRenderOLEData;
-    property OnResetNode;
-    property OnResize;
-    property OnSaveNode;
-    property OnScroll;
-    property OnStartDock;
-    property OnStateChange;
-    property OnStructureChange;
-    property OnUpdating;
-  end;
-
-type
-  // Describes the mode how to blend pixels.
-  TBlendMode = (
-    bmConstantAlpha,         // apply given constant alpha
-    bmPerPixelAlpha,         // use alpha value of the source pixel
-    bmMasterAlpha,           // use alpha value of source pixel and multiply it with the constant alpha value
-    bmConstantAlphaAndColor  // blend the destination color with the given constant color und the constant alpha value
-  );
-
-// OLE Clipboard and drag'n drop helper
-procedure EnumerateVTClipboardFormats(TreeClass: TVirtualTreeClass; const List: TStrings); overload;
-procedure EnumerateVTClipboardFormats(TreeClass: TVirtualTreeClass; var Formats: TFormatEtcArray); overload;
-function GetVTClipboardFormatDescription(AFormat: Word): string;
-procedure RegisterVTClipboardFormat(AFormat: Word; TreeClass: TVirtualTreeClass; Priority: Cardinal); overload;
-function RegisterVTClipboardFormat(Description: string; TreeClass: TVirtualTreeClass; Priority: Cardinal;
-  tymed: Integer = TYMED_HGLOBAL; ptd: PDVTargetDevice = nil; dwAspect: Integer = DVASPECT_CONTENT;
-  lindex: Integer = -1): Word; overload;
-
-// utility routines
-procedure AlphaBlend(Source, Destination: HDC; R: TRect; Target: TPoint; Mode: TBlendMode; ConstantAlpha, Bias: Integer);
-procedure DrawTextW(DC: HDC; lpString: PWideChar; nCount: Integer; var lpRect: TRect; uFormat: Cardinal;
-  AdjustRight: Boolean);
-function ShortenString(DC: HDC; const S: WideString; Width: Integer; RTL: Boolean;
-  EllipsisWidth: Integer = 0): WideString;
-function TreeFromNode(Node: PVirtualNode): TBaseVirtualTree;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-implementation
-
-{$R VirtualTrees.res}
-
-uses
-  Consts, Math,
-  AxCtrls,   // TOLEStream
-  CommCtrl,  // image list stuff
-  {$ifdef UseFlatScrollbars}
-    FlatSB,    // wrapper for systems without flat SB support
-  {$endif UseFlatScrollbars}
-  MMSystem,  // for animation timer (does not include further resources)
-  TypInfo,   // for migration stuff
-  ActnList,  
-  StdActns;  // for standard action support
-
-resourcestring
-  // Localizable strings.
-  SEditLinkIsNil = 'Edit link must not be nil.';
-  SWrongMoveError = 'Target node cannot be a child node of the node to be moved.';
-  SWrongStreamFormat = 'Unable to load tree structure, the format is wrong.';
-  SWrongStreamVersion = 'Unable to load tree structure, the version is unknown.';
-  SStreamTooSmall = 'Unable to load tree structure, not enough data available.';
-  SCorruptStream1 = 'Stream data corrupt. A node''s anchor chunk is missing.';
-  SCorruptStream2 = 'Stream data corrupt. Unexpected data after node''s end position.';
-  SClipboardFailed = 'Clipboard operation failed.';
-  SCannotSetUserData = 'Cannot set initial user data because there is not enough user data space allocated.';
-
-const
-  ClipboardStates = [tsCopyPending, tsCutPending];
-  DefaultScrollUpdateFlags = [suoRepaintHeader, suoRepaintScrollbars, suoScrollClientArea, suoUpdateNCArea];
-  MinimumTimerInterval = 1; // minimum resolution for timeGetTime
-  TreeNodeSize = (SizeOf(TVirtualNode) + 3) and not 3; // used for node allocation and access to internal data
-
-  // Lookup to quickly convert a specific check state into its pressed counterpart and vice versa. 
-  PressedState: array[TCheckState] of TCheckState = (
-    csUncheckedPressed, csUncheckedPressed, csCheckedPressed, csCheckedPressed, csMixedPressed, csMixedPressed
-  );
-  UnpressedState: array[TCheckState] of TCheckState = (
-    csUncheckedNormal, csUncheckedNormal, csCheckedNormal, csCheckedNormal, csMixedNormal, csMixedNormal
-  );
-  MouseButtonDown = [tsLeftButtonDown, tsMiddleButtonDown, tsRightButtonDown];
-
-  // Do not modify the copyright in any way! Usage of this unit is prohibited without the copyright notice
-  // in the compiled binary file.
-  Copyright: string = 'Virtual Treeview &#169; 1999, 2003 Mike Lischke';
-
-var
-  StandardOLEFormat: TFormatEtc = (
-    // Format must later be set.
-    cfFormat: 0;
-    // No specific target device to render on.
-    ptd: nil;
-    // Normal content to render.
-    dwAspect: DVASPECT_CONTENT;
-    // No specific page of multipage data (we don't use multipage data by default).
-    lindex: -1;
-    // Acceptable storage formats are IStream and global memory. The first is preferred.
-    tymed: TYMED_ISTREAM or TYMED_HGLOBAL;
-  );
-
-
-type // streaming support
-  TMagicID = array[0..5] of WideChar;
-
-  TChunkHeader = record
-    ChunkType,
-    ChunkSize: Integer;      // contains the size of the chunk excluding the header
-  end;
-
-  // base information about a node
-  TBaseChunkBody = packed record
-    ChildCount,
-    NodeHeight: Cardinal;
-    States: TVirtualNodeStates;
-    Align: Byte;
-    CheckState: TCheckState;
-    CheckType: TCheckType;
-    Reserved: Cardinal;
-  end;
-
-  TBaseChunk = packed record
-    Header: TChunkHeader;
-    Body: TBaseChunkBody;
-  end;
-
-  // Internally used data for animations.
-  TToggleAnimationData = record
-    Expand: Boolean;    // if true then expanding is in progress
-    Window: HWND;       // copy of the tree's window handle
-    DC: HDC;            // the DC of the window to erase unconvered parts
-    Brush: HBRUSH;      // the brush to be used to erase uncovered parts
-    R: TRect;           // the scroll rectangle
-  end;
-
-const
-  MagicID: TMagicID = (#$2045, 'V', 'T', WideChar(VTTreeStreamVersion), ' ', #$2046);
-
-  // chunk IDs
-  NodeChunk = 1;
-  BaseChunk = 2;        // chunk containing node state, check state, child node count etc.
-                        // this chunk is immediately followed by all child nodes
-  CaptionChunk = 3;     // used by the string tree to store a node's caption
-  UserChunk = 4;        // used for data supplied by the application
-
-  {$ifdef UseFlatScrollbars}
-    ScrollBarProp: array[TScrollBarStyle] of Integer = (
-      FSB_REGULAR_MODE,
-      FSB_FLAT_MODE,
-      FSB_ENCARTA_MODE
-    );
-  {$endif}
-  
-  RTLFlag: array[Boolean] of Integer = (0, ETO_RTLREADING);
-  AlignmentToDrawFlag: array[TAlignment] of Cardinal = (DT_LEFT, DT_RIGHT, DT_CENTER);
-
-  WideNull = WideChar(#0);
-  WideCR = WideChar(#13);
-  WideLF = WideChar(#10);
-  WideLineSeparator = WideChar(#2028);
-
-type
-  // internal worker thread
-  TWorkerThread = class(TThread)
-  private
-    FCurrentTree: TBaseVirtualTree;
-    FWaiterList: TThreadList;
-    FRefCount: Cardinal;
-  protected
-    procedure ChangeTreeStates(EnterStates, LeaveStates: TChangeStates);
-    procedure Execute; override;
-  public
-    constructor Create(CreateSuspended: Boolean);
-    destructor Destroy; override;
-
-    procedure AddTree(Tree: TBaseVirtualTree);
-    procedure RemoveTree(Tree: TBaseVirtualTree);
-  end;
-
-  // Helper classes to speed up rendering text formats for clipboard and drag'n drop transfers.
-  TBufferedString = class
-  private
-    FStart,
-    FPosition,
-    FEnd: PChar;
-    function GetAsString: string;
-  public
-    destructor Destroy; override;
-
-    procedure Add(const S: string);
-    procedure AddNewLine;
-
-    property AsString: string read GetAsString;
-  end;
-
-  TWideBufferedString = class
-  private
-    FStart,
-    FPosition,
-    FEnd: PWideChar;
-    function GetAsString: WideString;
-  public
-    destructor Destroy; override;
-
-    procedure Add(const S: WideString);
-    procedure AddNewLine;
-
-    property AsString: WideString read GetAsString;
-  end;
-
-var
-  WorkerThread: TWorkerThread;
-  WorkEvent: THandle;
-  Watcher: TCriticalSection;
-  LightCheckImages,                    // global light check images
-  DarkCheckImages,                     // global heavy check images
-  LightTickImages,                     // global light tick images
-  DarkTickImages,                      // global heavy check images
-  FlatImages,                          // global flat check images
-  XPImages,                            // global XP style check images
-  UtilityImages,                       // some small additional images (e.g for header dragging)
-  SystemCheckImages,                   // global system check images
-  SystemFlatCheckImages: TImageList;   // global flat system check images
-  IsWinNT: Boolean;                    // Necessary to fix bugs in Win95/WinME (non-client area region intersection, edit resize)
-                                       // and to allow for check of system dependent hint animation.
-  IsWin2K: Boolean;                    // Nessary to provide correct string shortage
-  IsWinXP: Boolean;
-  Initialized: Boolean;                // True if global structures have been initialized.
-  NeedToUnitialize: Boolean;           // True if the OLE subsystem could be initialized successfully.
-
-  {$ifndef COMPILER_5_UP}
-    HintFont: TFont;                   // In Delphi 4 there is no TScreen.HintFont yet.
-  {$endif COMPILER_5_UP}
-
-//----------------------------------------------------------------------------------------------------------------------
-
-{$ifndef COMPILER_6_UP}
-
-  procedure RaiseLastOSError;
-
-  begin
-    RaiseLastWin32Error;
-  end;
-
-{$endif COMPILER_6_UP}
-
-//----------------- TClipboardFormats ----------------------------------------------------------------------------------
-
-type
-  PClipboardFormatListEntry = ^TClipboardFormatListEntry;
-  TClipboardFormatListEntry = record
-    Description: string;               // The string used to register the format with Windows.
-    TreeClass: TVirtualTreeClass;      // The tree class which supports rendering this format.
-    Priority: Cardinal;                // Number which determines the order of formats used in IDataObject.
-    FormatEtc: TFormatEtc;             // The definition of the format in the IDataObject.
-  end;
-
-  TClipboardFormatList = class
-  private
-    FList: TList;
-    procedure Sort;
-  public
-    constructor Create;
-    destructor Destroy; override;
-
-    procedure Add(FormatString: string; AClass: TVirtualTreeClass; Priority: Cardinal; AFormatEtc: TFormatEtc);
-    procedure Clear;
-    procedure EnumerateFormats(TreeClass: TVirtualTreeClass; var Formats: TFormatEtcArray;
-      const AllowedFormats: TClipboardFormats = nil); overload;
-    procedure EnumerateFormats(TreeClass: TVirtualTreeClass; const Formats: TStrings); overload;
-    function FindFormat(FormatString: string): PClipboardFormatListEntry; overload;
-    function FindFormat(FormatString: string; var Fmt: Word): TVirtualTreeClass; overload;
-    function FindFormat(Fmt: Word; var Description: string): TVirtualTreeClass; overload;
-  end;
-
-var
-  InternalClipboardFormats: TClipboardFormatList;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-constructor TClipboardFormatList.Create;
-
-begin
-  FList := TList.Create;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TClipboardFormatList.Destroy;
-
-begin
-  Clear;
-  FList.Free;
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TClipboardFormatList.Sort;
-
-// Sorts all entry for priority (increasing priority value).
-
-  //--------------- local function --------------------------------------------
-
-  procedure QuickSort(L, R: Integer);
-
-  var
-    I, J: Integer;
-    P, T: PClipboardFormatListEntry;
-
-  begin
-    repeat
-      I := L;
-      J := R;
-      P := FList[(L + R) shr 1];
-      repeat
-        while PClipboardFormatListEntry(FList[I]).Priority &lt; P.Priority do
-          Inc(I);
-        while PClipboardFormatListEntry(Flist[J]).Priority &gt; P.Priority do
-          Dec(J);
-        if I &lt;= J then
-        begin
-          T := Flist[I];
-          FList[I] := FList[J];
-          FList[J] := T;
-          Inc(I);
-          Dec(J);
-        end;
-      until I &gt; J;
-      if L &lt; J then
-        QuickSort(L, J);
-      L := I;
-    until I &gt;= R;
-  end;
-
-  //--------------- end local function ----------------------------------------
-
-begin
-  if FList.Count &gt; 1 then
-    QuickSort(0, FList.Count - 1);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TClipboardFormatList.Add(FormatString: string; AClass: TVirtualTreeClass; Priority: Cardinal;
-  AFormatEtc: TFormatEtc);
-
-// Adds the given data to the internal list. The priority value is used to sort formats for importance. Larger priority
-// values mean less priority.
-
-var
-  Entry: PClipboardFormatListEntry;
-
-begin
-  New(Entry);
-  Entry.Description := FormatString;
-  Entry.TreeClass := AClass;
-  Entry.Priority := Priority;
-  Entry.FormatEtc := AFormatEtc;
-  FList.Add(Entry);
-
-  Sort;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TClipboardFormatList.Clear;
-
-var
-  I: Integer;
-
-begin
-  for I := 0 to FList.Count - 1 do
-    Dispose(PClipboardFormatListEntry(FList[I]));
-  FList.Clear;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TClipboardFormatList.EnumerateFormats(TreeClass: TVirtualTreeClass; var Formats: TFormatEtcArray;
-  const AllowedFormats: TClipboardFormats = nil);
-
-// Returns a list of format records for the given class. If assigned the AllowedFormats is used to limit the
-// enumerated formats to those described in the list.
-
-var
-  I, Count: Integer;
-  Entry: PClipboardFormatListEntry;
-
-begin
-  SetLength(Formats, FList.Count);
-  Count := 0;
-  for I := 0 to FList.Count - 1 do
-  begin
-    Entry := FList[I];
-    // Does the tree class support this clipboard format?
-    if TreeClass.InheritsFrom(Entry.TreeClass) then
-    begin
-      // Is this format allowed to be included?
-      if (AllowedFormats = nil) or (AllowedFormats.IndexOf(Entry.Description) &gt; -1) then
-      begin
-        // The list could change before we use the FormatEtc so it is best not to pass a pointer to the true FormatEtc
-        // structure. Instead make a copy and send that.
-        Formats[Count] := Entry.FormatEtc;
-        Inc(Count);
-      end;
-    end;
-  end;
-  SetLength(Formats, Count);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TClipboardFormatList.EnumerateFormats(TreeClass: TVirtualTreeClass; const Formats: TStrings); 
-
-// Returns a list of format descriptions for the given class.
-
-var
-  I: Integer;
-  Entry: PClipboardFormatListEntry;
-
-begin
-  for I := 0 to FList.Count - 1 do
-  begin
-    Entry := FList[I];
-    if TreeClass.InheritsFrom(Entry.TreeClass) then
-      Formats.Add(Entry.Description);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TClipboardFormatList.FindFormat(FormatString: string): PClipboardFormatListEntry;
-
-var
-  I: Integer;
-  Entry: PClipboardFormatListEntry;
-
-begin
-  Result := nil;
-  for I := FList.Count - 1 downto 0 do
-  begin
-    Entry := FList[I];
-    if CompareText(Entry.Description, FormatString) = 0 then
-    begin
-      Result := Entry;
-      Break;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TClipboardFormatList.FindFormat(FormatString: string; var Fmt: Word): TVirtualTreeClass;
-
-var
-  I: Integer;
-  Entry: PClipboardFormatListEntry;
-
-begin
-  Result := nil;
-  for I := FList.Count - 1 downto 0 do
-  begin
-    Entry := FList[I];
-    if CompareText(Entry.Description, FormatString) = 0 then
-    begin
-      Result := Entry.TreeClass;
-      Fmt := Entry.FormatEtc.cfFormat;
-      Break;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TClipboardFormatList.FindFormat(Fmt: Word; var Description: string): TVirtualTreeClass;
-
-var
-  I: Integer;
-  Entry: PClipboardFormatListEntry;
-
-begin
-  Result := nil;
-  for I := FList.Count - 1 downto 0 do
-  begin
-    Entry := FList[I];
-    if Entry.FormatEtc.cfFormat = Fmt then
-    begin
-      Result := Entry.TreeClass;
-      Description := Entry.Description;
-      Break;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-type
-  TClipboardFormatEntry = record
-    ID: Word;
-    Description: string;
-  end;
-
-var
-  ClipboardDescriptions: array [1..CF_MAX - 1] of TClipboardFormatEntry = (
-    (ID: CF_TEXT; Description: 'Plain text'),
-    (ID: CF_BITMAP; Description: 'Windows bitmap'),
-    (ID: CF_METAFILEPICT; Description: 'Windows metafile'),
-    (ID: CF_SYLK; Description: 'Symbolic link'),
-    (ID: CF_DIF; Description: 'Data interchange format'),
-    (ID: CF_TIFF; Description: 'Tiff image'),
-    (ID: CF_OEMTEXT; Description: 'OEM text'),
-    (ID: CF_DIB; Description: 'DIB image'),
-    (ID: CF_PALETTE; Description: 'Palette data'),
-    (ID: CF_PENDATA; Description: 'Pen data'),
-    (ID: CF_RIFF; Description: 'Riff audio data'),
-    (ID: CF_WAVE; Description: 'Wav audio data'),
-    (ID: CF_UNICODETEXT; Description: 'Unicode text'),
-    (ID: CF_ENHMETAFILE; Description: 'Enhanced metafile image'),
-    (ID: CF_HDROP; Description: 'File name(s)'),
-    (ID: CF_LOCALE; Description: 'Locale descriptor')
-  );
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure EnumerateVTClipboardFormats(TreeClass: TVirtualTreeClass; const List: TStrings);
-
-begin
-  if InternalClipboardFormats = nil then
-    InternalClipboardFormats := TClipboardFormatList.Create;
-  InternalClipboardFormats.EnumerateFormats(TreeClass, List);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure EnumerateVTClipboardFormats(TreeClass: TVirtualTreeClass; var Formats: TFormatEtcArray);
-
-begin
-  if InternalClipboardFormats = nil then
-    InternalClipboardFormats := TClipboardFormatList.Create;
-  InternalClipboardFormats.EnumerateFormats(TreeClass, Formats);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function GetVTClipboardFormatDescription(AFormat: Word): string;
-
-begin
-  if InternalClipboardFormats = nil then
-    InternalClipboardFormats := TClipboardFormatList.Create;
-  if InternalClipboardFormats.FindFormat(AFormat, Result) = nil then
-    Result := '';
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure RegisterVTClipboardFormat(AFormat: Word; TreeClass: TVirtualTreeClass; Priority: Cardinal);
-
-// Registers the given clipboard format for the given TreeClass.
-
-var
-  I: Integer;
-  Buffer: array[0..2048] of Char;
-  FormatEtc: TFormatEtc;
-
-begin
-  if InternalClipboardFormats = nil then
-    InternalClipboardFormats := TClipboardFormatList.Create;
-
-  // Assumes a HGlobal format.
-  FormatEtc.cfFormat := AFormat;
-  FormatEtc.ptd := nil;
-  FormatEtc.dwAspect := DVASPECT_CONTENT;
-  FormatEtc.lindex := -1;
-  FormatEtc.tymed := TYMED_HGLOBAL;
-
-  // Determine description string of the given format. For predefined formats we need the lookup table because they
-  // don't have a description string. For registered formats the description string is the string which was used
-  // to register them.
-  if AFormat &lt; CF_MAX then
-  begin
-    for I := 1 to High(ClipboardDescriptions) do
-      if ClipboardDescriptions[I].ID = AFormat then
-      begin
-        InternalClipboardFormats.Add(ClipboardDescriptions[I].Description, TreeClass, Priority, FormatEtc);
-        Break;
-      end;
-  end
-  else
-  begin
-    GetClipboardFormatName(AFormat, Buffer, Length(Buffer));
-    InternalClipboardFormats.Add(Buffer, TreeClass, Priority, FormatEtc);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function RegisterVTClipboardFormat(Description: string; TreeClass: TVirtualTreeClass; Priority: Cardinal;
-  tymed: Integer = TYMED_HGLOBAL; ptd: PDVTargetDevice = nil; dwAspect: Integer = DVASPECT_CONTENT;
-  lindex: Integer = -1): Word; 
-
-// Alternative method to register a certain clipboard format for a given tree class. Registration with the
-// clipboard is done here too and the assigned ID returned by the function.
-// tymed may contain or'ed TYMED constants which allows to register several storage formats for one clipboard format.
-
-var
-  FormatEtc: TFormatEtc;
-
-begin
-  if InternalClipboardFormats = nil then
-    InternalClipboardFormats := TClipboardFormatList.Create;
-  Result := RegisterClipboardFormat(PChar(Description));
-  FormatEtc.cfFormat := Result;
-  FormatEtc.ptd := ptd;
-  FormatEtc.dwAspect := dwAspect;
-  FormatEtc.lindex := lindex;
-  FormatEtc.tymed := tymed;
-  InternalClipboardFormats.Add(Description, TreeClass, Priority, FormatEtc);
-end;
-
-//----------------- utility functions ----------------------------------------------------------------------------------
-
-procedure ShowError(Msg: WideString; HelpContext: Integer);
-
-begin
-  raise EVirtualTreeError.CreateHelp(Msg, HelpContext);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TreeFromNode(Node: PVirtualNode): TBaseVirtualTree;
-
-// Returns the tree the node currently belongs to or nil if the node is not attached to a tree.
-
-begin
-  Assert(Assigned(Node), 'Node must not be nil.');
-
-  // The root node is marked by having its NextSibling (and PrevSibling) pointing to itself.
-  while Assigned(Node) and (Node.NextSibling &lt;&gt; Node) do
-    Node := Node.Parent;
-  if Assigned(Node) then
-    Result := TBaseVirtualTree(Node.Parent)
-  else
-    Result := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function OrderRect(const R: TRect): TRect;
-
-// Converts the incoming rectangle so that left and top are always less than or equal to right and bottom.
-
-begin
-  if R.Left &lt; R.Right then
-  begin
-    Result.Left := R.Left;
-    Result.Right := R.Right;
-  end
-  else
-  begin
-    Result.Left := R.Right;
-    Result.Right := R.Left;
-  end;
-  if R.Top &lt; R.Bottom then
-  begin
-    Result.Top := R.Top;
-    Result.Bottom := R.Bottom;
-  end
-  else
-  begin
-    Result.Top := R.Bottom;
-    Result.Bottom := R.Top;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure QuickSort(const TheArray: TNodeArray; L, R: Integer);
-
-var
-  I, J: Integer;
-  P, T: Pointer;
-
-begin
-  repeat
-    I := L;
-    J := R;
-    P := TheArray[(L + R) shr 1];
-    repeat
-      while Cardinal(TheArray[I]) &lt; Cardinal(P) do
-        Inc(I);
-      while Cardinal(TheArray[J]) &gt; Cardinal(P) do
-        Dec(J);
-      if I &lt;= J then
-      begin
-        T := TheArray[I];
-        TheArray[I] := TheArray[J];
-        TheArray[J] := T;
-        Inc(I);
-        Dec(J);
-      end;
-    until I &gt; J;
-    if L &lt; J then
-      QuickSort(TheArray, L, J);
-    L := I;
-  until I &gt;= R;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure DrawTextW(DC: HDC; lpString: PWideChar; nCount: Integer; var lpRect: TRect; uFormat: Cardinal;
-  AdjustRight: Boolean);
-
-// This procedure implements a subset of Window's DrawText API for Unicode which is not available for
-// Windows 9x. For a description of the parameters see DrawText in the online help.
-// Supported flags are currently:
-//   - DT_LEFT
-//   - DT_TOP
-//   - DT_CALCRECT
-//   - DT_NOCLIP
-//   - DT_RTLREADING
-//   - DT_SINGLELINE
-//   - DT_VCENTER
-// Differences to the DrawTextW Windows API:
-//   - The additional parameter AdjustRight determines whether to adjust the right border of the given rectangle to
-//     accomodate the largest line in the text. It has only a meaning if also DT_CALCRECT is specified.
-
-var
-  Head, Tail: PWideChar;
-  Size: TSize;
-  MaxWidth: Integer;
-  TextOutFlags: Integer;
-  TextAlign,
-  OldTextAlign: Cardinal;
-  TM: TTextMetric;
-  TextHeight: Integer;
-  LineRect: TRect;
-  TextPosY,
-  TextPosX: Integer;
-
-  CalculateRect: Boolean;
-
-begin
-  // Prepare some work variables.
-  MaxWidth := 0;
-  Head := lpString;
-  GetTextMetrics(DC, TM);
-  TextHeight := TM.tmHeight;
-  if uFormat and DT_SINGLELINE &lt;&gt; 0 then
-    LineRect := lpRect
-  else
-    LineRect := Rect(lpRect.Left, lpRect.Top, lpRect.Right, lpRect.Top + TextHeight);
-
-  CalculateRect := uFormat and DT_CALCRECT &lt;&gt; 0;
-
-  // Prepare text output.
-  TextOutFlags := 0;
-  if uFormat and DT_NOCLIP = 0 then
-    TextOutFlags := TextOutFlags or ETO_CLIPPED;
-  if uFormat and DT_RTLREADING &lt;&gt; 0 then
-    TextOutFlags := TextOutFlags or ETO_RTLREADING;
-
-  // Determine horizontal and vertical text alignment.
-  OldTextAlign := GetTextAlign(DC);
-  TextAlign := TA_LEFT or TA_TOP;
-  TextPosX := lpRect.Left;       
-  if uFormat and DT_RIGHT &lt;&gt; 0 then
-  begin
-    TextAlign := TextAlign or TA_RIGHT and not TA_LEFT;
-    TextPosX := lpRect.Right;
-  end
-  else
-    if uFormat and DT_CENTER &lt;&gt; 0 then
-    begin
-      TextAlign := TextAlign or TA_CENTER and not TA_LEFT;
-      TextPosX := (lpRect.Left + lpRect.Right) div 2;
-    end;
-
-  TextPosY := lpRect.Top;
-  if uFormat and DT_VCENTER &lt;&gt; 0 then
-  begin
-    // Note: vertical alignment does only work with single line text ouput!
-    TextPosY := (lpRect.Top + lpRect.Bottom - TextHeight) div 2;
-  end;
-  SetTextAlign(DC, TextAlign);
-
-  if uFormat and DT_SINGLELINE &lt;&gt; 0 then
-  begin
-    if CalculateRect then
-    begin
-      GetTextExtentPoint32W(DC, Head, nCount, Size);
-      if Size.cx &gt; MaxWidth then
-        MaxWidth := Size.cx;
-    end
-    else
-      ExtTextOutW(DC, TextPosX, TextPosY, TextOutFlags, @LineRect, Head, nCount, nil);
-    OffsetRect(LineRect, 0, TextHeight);
-  end
-  else
-  begin
-    while (nCount &gt; 0) and (Head^ &lt;&gt; WideNull) do
-    begin
-      Tail := Head;
-      // Look for the end of the current line. A line is finished either by the string end or a line break.
-      while (nCount &gt; 0) and not (Tail^ in [WideNull, WideCR, WideLF]) and (Tail^ &lt;&gt; WideLineSeparator) do
-      begin
-        Inc(Tail);
-        Dec(nCount);
-      end;
-
-      if CalculateRect then
-      begin
-        GetTextExtentPoint32W(DC, Head, Tail - Head, Size);
-        if Size.cx &gt; MaxWidth then
-          MaxWidth := Size.cx;
-      end
-      else
-        ExtTextOutW(DC, TextPosX, LineRect.Top, TextOutFlags, @LineRect, Head, Tail - Head, nil);
-      OffsetRect(LineRect, 0, TextHeight);
-
-      // Get out of the loop if the rectangle is filled up.
-      if (nCount = 0) or (not CalculateRect and (LineRect.Top &gt;= lpRect.Bottom)) then
-        Break;
-
-      if (nCount &gt; 0) and (Tail^ = WideCR) or (Tail^ = WideLineSeparator) then
-      begin
-        Inc(Tail);
-        Dec(nCount);
-      end;
-
-      if (nCount &gt; 0) and (Tail^ = WideLF) then
-      begin
-        Inc(Tail);
-        Dec(nCount);
-      end;
-      Head := Tail;
-    end;
-  end;
-
-  SetTextAlign(DC, OldTextAlign);
-  if CalculateRect then
-  begin
-    if AdjustRight then
-      lpRect.Right := lpRect.Left + MaxWidth;
-    lpRect.Bottom := LineRect.Top;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function ShortenString(DC: HDC; const S: WideString; Width: Integer; RTL: Boolean;
-  EllipsisWidth: Integer = 0): WideString;
-
-// Adjusts the given string S so that it fits into the given width. EllipsisWidth gives the width of
-// the three points to be added to the shorted string. If this value is 0 then it will be determined implicitely.
-// For higher speed (and multiple entries to be shorted) specify this value explicitely.
-// RTL determines if right-to-left reading is active, which is needed to put the ellipsisis on the correct side.
-// Note: It is assumed that the string really needs shortage. Check this in advance.
-
-var
-  Size: TSize;
-  Len: Integer;
-  L, H, N, W: Integer;
-
-begin
-  Len := Length(S);
-  if (Len = 0) or (Width &lt;= 0) then
-    Result := ''
-  else
-  begin
-    // Determine width of triple point using the current DC settings (if not already done).
-    if EllipsisWidth = 0 then
-    begin
-      GetTextExtentPoint32W(DC, '...', 3, Size);
-      EllipsisWidth := Size.cx;
-    end;
-
-    if Width &lt;= EllipsisWidth then
-      Result := ''
-    else
-    begin
-      // Do a binary search for the optimal string length which fits into the given width.
-      L := 0;
-      H := Len;
-      while L &lt; H do
-      begin
-        N := (L + H + 1) shr 1;
-        GetTextExtentPoint32W(DC, PWideChar(S), N, Size);
-        W := Size.cx + EllipsisWidth;
-        if W &lt;= Width then
-          L := N
-        else
-          H := N - 1;
-      end;
-
-      // Windows 2000/XP automatically switches the order in the string. For every other system we have to take care.
-      if IsWin2K or IsWinXP or not RTL then
-        Result := Copy(S, 1, L) + '...'
-      else
-        Result := '...' + Copy(S, 1, L);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure FillDragRectangles(DragWidth, DragHeight, DeltaX, DeltaY: Integer; var RClip, RScroll, RSamp1, RSamp2, RDraw1,
-  RDraw2: TRect);
-
-// Fills the given rectangles with values which can be used while dragging around an image
-// (used in DragMove of the drag manager and DragTo of the header columns).
-
-begin
-  // ScrollDC limits
-  RClip := Rect(0, 0, DragWidth, DragHeight);
-  if DeltaX &gt; 0 then
-  begin
-    // move to the left
-    if DeltaY = 0 then
-    begin
-      // move only to the left
-      // background movement
-      RScroll := Rect(0, 0, DragWidth - DeltaX, DragHeight);
-      RSamp1 := Rect(0, 0, DeltaX, DragHeight);
-      RDraw1 := Rect(DragWidth - DeltaX, 0, DeltaX, DragHeight);
-    end
-    else
-      if DeltaY &lt; 0 then
-      begin
-        // move to bottom left
-        RScroll := Rect(0, -DeltaY, DragWidth - DeltaX, DragHeight);
-        RSamp1 := Rect(0, 0, DeltaX, DragHeight);
-        RSamp2 := Rect(DeltaX, DragHeight + DeltaY, DragWidth - DeltaX, -DeltaY);
-        RDraw1 := Rect(0, 0, DragWidth - DeltaX, -DeltaY);
-        RDraw2 := Rect(DragWidth - DeltaX, 0, DeltaX, DragHeight);
-      end
-      else
-      begin
-        // move to upper left
-        RScroll := Rect(0, 0, DragWidth - DeltaX, DragHeight - DeltaY);
-        RSamp1 := Rect(0, 0, DeltaX, DragHeight);
-        RSamp2 := Rect(DeltaX, 0, DragWidth - DeltaX, DeltaY);
-        RDraw1 := Rect(0, DragHeight - DeltaY, DragWidth - DeltaX, DeltaY);
-        RDraw2 := Rect(DragWidth - DeltaX, 0, DeltaX, DragHeight);
-      end;
-  end
-  else
-    if DeltaX = 0 then
-    begin
-      // vertical movement only
-      if DeltaY &lt; 0 then
-      begin
-        // move downwards
-        RScroll := Rect(0, -DeltaY, DragWidth, DragHeight);
-        RSamp2 := Rect(0, DragHeight + DeltaY, DragWidth, -DeltaY);
-        RDraw2 := Rect(0, 0, DragWidth, -DeltaY);
-      end
-      else
-      begin
-        // move upwards
-        RScroll := Rect(0, 0, DragWidth, DragHeight - DeltaY);
-        RSamp2 := Rect(0, 0, DragWidth, DeltaY);
-        RDraw2 := Rect(0, DragHeight - DeltaY, DragWidth, DeltaY);
-      end;
-    end
-    else
-    begin
-      // move to the right
-      if DeltaY &gt; 0 then
-      begin
-        // move up right
-        RScroll := Rect(-DeltaX, 0, DragWidth, DragHeight);
-        RSamp1 := Rect(0, 0, DragWidth + DeltaX, DeltaY);
-        RSamp2 := Rect(DragWidth + DeltaX, 0, -DeltaX, DragHeight);
-        RDraw1 := Rect(0, 0, -DeltaX, DragHeight);
-        RDraw2 := Rect(-DeltaX, DragHeight - DeltaY, DragWidth + DeltaX, DeltaY);
-      end
-      else
-        if DeltaY = 0 then
-        begin
-          // to the right only
-          RScroll := Rect(-DeltaX, 0, DragWidth, DragHeight);
-          RSamp1 := Rect(DragWidth + DeltaX, 0, -DeltaX, DragHeight);
-          RDraw1 := Rect(0, 0, -DeltaX, DragHeight);
-        end
-        else
-        begin
-          // move down right
-          RScroll := Rect(-DeltaX, -DeltaY, DragWidth, DragHeight);
-          RSamp1 := Rect(0, DragHeight + DeltaY, DragWidth + DeltaX, -DeltaY);
-          RSamp2 := Rect(DragWidth + DeltaX, 0, -DeltaX, DragHeight);
-          RDraw1 := Rect(0, 0, -DeltaX, DragHeight);
-          RDraw2 := Rect(-DeltaX, 0, DragWidth + DeltaX, -DeltaY);
-        end;
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure AlphaBlendLineConstant(Source, Destination: Pointer; Count: Integer; ConstantAlpha, Bias: Integer);
-
-// Blends a line of Count pixels from Source to Destination using a constant alpha value.
-// The layout of a pixel must be BGRA where A is ignored (but is calculated as the other components).
-// ConstantAlpha must be in the range 0..255 where 0 means totally transparent (destination pixel only)
-// and 255 totally opaque (source pixel only).
-// Bias is an additional value which gets added to every component and must be in the range -128..127
-//
-// EAX contains Source
-// EDX contains Destination
-// ECX contains Count
-// ConstantAlpha and Bias are on the stack
-
-asm
-        PUSH    ESI                    // save used registers
-        PUSH    EDI
-
-        MOV     ESI, EAX               // ESI becomes the actual source pointer
-        MOV     EDI, EDX               // EDI becomes the actual target pointer
-
-        // Load MM6 with the constant alpha value (replicate it for every component).
-        // Expand it to word size.
-        MOV     EAX, [ConstantAlpha]
-        DB      $0F, $6E, $F0          /// MOVD      MM6, EAX
-        DB      $0F, $61, $F6          /// PUNPCKLWD MM6, MM6
-        DB      $0F, $62, $F6          /// PUNPCKLDQ MM6, MM6
-
-        // Load MM5 with the bias value.
-        MOV     EAX, [Bias]
-        DB      $0F, $6E, $E8          /// MOVD      MM5, EAX
-        DB      $0F, $61, $ED          /// PUNPCKLWD MM5, MM5
-        DB      $0F, $62, $ED          /// PUNPCKLDQ MM5, MM5
-
-        // Load MM4 with 128 to allow for saturated biasing.
-        MOV     EAX, 128
-        DB      $0F, $6E, $E0          /// MOVD      MM4, EAX
-        DB      $0F, $61, $E4          /// PUNPCKLWD MM4, MM4
-        DB      $0F, $62, $E4          /// PUNPCKLDQ MM4, MM4
-
<A HREF="https://lists.berlios.de/mailman/listinfo/wolfpack-svn">- at 1</A>:     // The pixel loop calculates an entire pixel in one run.
-        // Note: The pixel byte values are expanded into the higher bytes of a word due
-        //       to the way unpacking works. We compensate for this with an extra shift.
-        DB      $0F, $EF, $C0          /// PXOR      MM0, MM0,   clear source pixel register for unpacking
-        DB      $0F, $60, $06          /// PUNPCKLBW MM0, [ESI], unpack source pixel byte values into words
-        DB      $0F, $71, $D0, $08     /// PSRLW     MM0, 8,     move higher bytes to lower bytes
-        DB      $0F, $EF, $C9          /// PXOR      MM1, MM1,   clear target pixel register for unpacking
-        DB      $0F, $60, $0F          /// PUNPCKLBW MM1, [EDI], unpack target pixel byte values into words
-        DB      $0F, $6F, $D1          /// MOVQ      MM2, MM1,   make a copy of the shifted values, we need them again
-        DB      $0F, $71, $D1, $08     /// PSRLW     MM1, 8,     move higher bytes to lower bytes
-
-        // calculation is: target = (alpha * (source - target) + 256 * target) / 256
-        DB      $0F, $F9, $C1          /// PSUBW     MM0, MM1,   source - target
-        DB      $0F, $D5, $C6          /// PMULLW    MM0, MM6,   alpha * (source - target)
-        DB      $0F, $FD, $C2          /// PADDW     MM0, MM2,   add target (in shifted form)
-        DB      $0F, $71, $D0, $08     /// PSRLW     MM0, 8,     divide by 256
-
-        // Bias is accounted for by conversion of range 0..255 to -128..127,
-        // doing a saturated add and convert back to 0..255.
-        DB      $0F, $F9, $C4          /// PSUBW     MM0, MM4
-        DB      $0F, $ED, $C5          /// PADDSW    MM0, MM5
-        DB      $0F, $FD, $C4          /// PADDW     MM0, MM4
-        DB      $0F, $67, $C0          /// PACKUSWB  MM0, MM0,   convert words to bytes with saturation
-        DB      $0F, $7E, $07          /// MOVD      [EDI], MM0, store the result
<A HREF="https://lists.berlios.de/mailman/listinfo/wolfpack-svn">- at 3</A>:
-        ADD     ESI, 4
-        ADD     EDI, 4
-        DEC     ECX
-        JNZ     @1
-        POP     EDI
-        POP     ESI
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure AlphaBlendLinePerPixel(Source, Destination: Pointer; Count, Bias: Integer);
-
-// Blends a line of Count pixels from Source to Destination using the alpha value of the source pixels.
-// The layout of a pixel must be BGRA.
-// Bias is an additional value which gets added to every component and must be in the range -128..127
-//
-// EAX contains Source
-// EDX contains Destination
-// ECX contains Count
-// Bias is on the stack
-
-asm
-        PUSH    ESI                    // save used registers
-        PUSH    EDI
-
-        MOV     ESI, EAX               // ESI becomes the actual source pointer
-        MOV     EDI, EDX               // EDI becomes the actual target pointer
-
-        // Load MM5 with the bias value.
-        MOV     EAX, [Bias]
-        DB      $0F, $6E, $E8          /// MOVD      MM5, EAX
-        DB      $0F, $61, $ED          /// PUNPCKLWD MM5, MM5
-        DB      $0F, $62, $ED          /// PUNPCKLDQ MM5, MM5
-
-        // Load MM4 with 128 to allow for saturated biasing.
-        MOV     EAX, 128
-        DB      $0F, $6E, $E0          /// MOVD      MM4, EAX
-        DB      $0F, $61, $E4          /// PUNPCKLWD MM4, MM4
-        DB      $0F, $62, $E4          /// PUNPCKLDQ MM4, MM4
-
<A HREF="https://lists.berlios.de/mailman/listinfo/wolfpack-svn">- at 1</A>:     // The pixel loop calculates an entire pixel in one run.
-        // Note: The pixel byte values are expanded into the higher bytes of a word due
-        //       to the way unpacking works. We compensate for this with an extra shift.
-        DB      $0F, $EF, $C0          /// PXOR      MM0, MM0,   clear source pixel register for unpacking
-        DB      $0F, $60, $06          /// PUNPCKLBW MM0, [ESI], unpack source pixel byte values into words
-        DB      $0F, $71, $D0, $08     /// PSRLW     MM0, 8,     move higher bytes to lower bytes
-        DB      $0F, $EF, $C9          /// PXOR      MM1, MM1,   clear target pixel register for unpacking
-        DB      $0F, $60, $0F          /// PUNPCKLBW MM1, [EDI], unpack target pixel byte values into words
-        DB      $0F, $6F, $D1          /// MOVQ      MM2, MM1,   make a copy of the shifted values, we need them again
-        DB      $0F, $71, $D1, $08     /// PSRLW     MM1, 8,     move higher bytes to lower bytes
-
-        // Load MM6 with the source alpha value (replicate it for every component).
-        // Expand it to word size.
-        DB      $0F, $6F, $F0          /// MOVQ MM6, MM0
-        DB      $0F, $69, $F6          /// PUNPCKHWD MM6, MM6
-        DB      $0F, $6A, $F6          /// PUNPCKHDQ MM6, MM6
-
-        // calculation is: target = (alpha * (source - target) + 256 * target) / 256
-        DB      $0F, $F9, $C1          /// PSUBW     MM0, MM1,   source - target
-        DB      $0F, $D5, $C6          /// PMULLW    MM0, MM6,   alpha * (source - target)
-        DB      $0F, $FD, $C2          /// PADDW     MM0, MM2,   add target (in shifted form)
-        DB      $0F, $71, $D0, $08     /// PSRLW     MM0, 8,     divide by 256
-
-        // Bias is accounted for by conversion of range 0..255 to -128..127,
-        // doing a saturated add and convert back to 0..255.
-        DB      $0F, $F9, $C4          /// PSUBW     MM0, MM4
-        DB      $0F, $ED, $C5          /// PADDSW    MM0, MM5
-        DB      $0F, $FD, $C4          /// PADDW     MM0, MM4
-        DB      $0F, $67, $C0          /// PACKUSWB  MM0, MM0,   convert words to bytes with saturation
-        DB      $0F, $7E, $07          /// MOVD      [EDI], MM0, store the result
<A HREF="https://lists.berlios.de/mailman/listinfo/wolfpack-svn">- at 3</A>:
-        ADD     ESI, 4
-        ADD     EDI, 4
-        DEC     ECX
-        JNZ     @1
-        POP     EDI
-        POP     ESI
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure AlphaBlendLineMaster(Source, Destination: Pointer; Count: Integer; ConstantAlpha, Bias: Integer);
-
-// Blends a line of Count pixels from Source to Destination using the source pixel and a constant alpha value.
-// The layout of a pixel must be BGRA.
-// ConstantAlpha must be in the range 0..255.
-// Bias is an additional value which gets added to every component and must be in the range -128..127
-//
-// EAX contains Source
-// EDX contains Destination
-// ECX contains Count
-// ConstantAlpha and Bias are on the stack
-
-asm
-        PUSH    ESI                    // save used registers
-        PUSH    EDI
-
-        MOV     ESI, EAX               // ESI becomes the actual source pointer
-        MOV     EDI, EDX               // EDI becomes the actual target pointer
-
-        // Load MM6 with the constant alpha value (replicate it for every component).
-        // Expand it to word size.
-        MOV     EAX, [ConstantAlpha]
-        DB      $0F, $6E, $F0          /// MOVD      MM6, EAX
-        DB      $0F, $61, $F6          /// PUNPCKLWD MM6, MM6
-        DB      $0F, $62, $F6          /// PUNPCKLDQ MM6, MM6
-
-        // Load MM5 with the bias value.
-        MOV     EAX, [Bias]
-        DB      $0F, $6E, $E8          /// MOVD      MM5, EAX
-        DB      $0F, $61, $ED          /// PUNPCKLWD MM5, MM5
-        DB      $0F, $62, $ED          /// PUNPCKLDQ MM5, MM5
-
-        // Load MM4 with 128 to allow for saturated biasing.
-        MOV     EAX, 128
-        DB      $0F, $6E, $E0          /// MOVD      MM4, EAX
-        DB      $0F, $61, $E4          /// PUNPCKLWD MM4, MM4
-        DB      $0F, $62, $E4          /// PUNPCKLDQ MM4, MM4
-
<A HREF="https://lists.berlios.de/mailman/listinfo/wolfpack-svn">- at 1</A>:     // The pixel loop calculates an entire pixel in one run.
-        // Note: The pixel byte values are expanded into the higher bytes of a word due
-        //       to the way unpacking works. We compensate for this with an extra shift.
-        DB      $0F, $EF, $C0          /// PXOR      MM0, MM0,   clear source pixel register for unpacking
-        DB      $0F, $60, $06          /// PUNPCKLBW MM0, [ESI], unpack source pixel byte values into words
-        DB      $0F, $71, $D0, $08     /// PSRLW     MM0, 8,     move higher bytes to lower bytes
-        DB      $0F, $EF, $C9          /// PXOR      MM1, MM1,   clear target pixel register for unpacking
-        DB      $0F, $60, $0F          /// PUNPCKLBW MM1, [EDI], unpack target pixel byte values into words
-        DB      $0F, $6F, $D1          /// MOVQ      MM2, MM1,   make a copy of the shifted values, we need them again
-        DB      $0F, $71, $D1, $08     /// PSRLW     MM1, 8,     move higher bytes to lower bytes
-
-        // Load MM7 with the source alpha value (replicate it for every component).
-        // Expand it to word size.
-        DB      $0F, $6F, $F8          /// MOVQ      MM7, MM0
-        DB      $0F, $69, $FF          /// PUNPCKHWD MM7, MM7
-        DB      $0F, $6A, $FF          /// PUNPCKHDQ MM7, MM7
-        DB      $0F, $D5, $FE          /// PMULLW    MM7, MM6,   source alpha * master alpha
-        DB      $0F, $71, $D7, $08     /// PSRLW     MM7, 8,     divide by 256
-
-        // calculation is: target = (alpha * master alpha * (source - target) + 256 * target) / 256
-        DB      $0F, $F9, $C1          /// PSUBW     MM0, MM1,   source - target
-        DB      $0F, $D5, $C7          /// PMULLW    MM0, MM7,   alpha * (source - target)
-        DB      $0F, $FD, $C2          /// PADDW     MM0, MM2,   add target (in shifted form)
-        DB      $0F, $71, $D0, $08     /// PSRLW     MM0, 8,     divide by 256
-
-        // Bias is accounted for by conversion of range 0..255 to -128..127,
-        // doing a saturated add and convert back to 0..255.
-        DB      $0F, $F9, $C4          /// PSUBW     MM0, MM4
-        DB      $0F, $ED, $C5          /// PADDSW    MM0, MM5
-        DB      $0F, $FD, $C4          /// PADDW     MM0, MM4
-        DB      $0F, $67, $C0          /// PACKUSWB  MM0, MM0,   convert words to bytes with saturation
-        DB      $0F, $7E, $07          /// MOVD      [EDI], MM0, store the result
<A HREF="https://lists.berlios.de/mailman/listinfo/wolfpack-svn">- at 3</A>:
-        ADD     ESI, 4
-        ADD     EDI, 4
-        DEC     ECX
-        JNZ     @1
-        POP     EDI
-        POP     ESI
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure AlphaBlendLineMasterAndColor(Destination: Pointer; Count: Integer; ConstantAlpha, Color: Integer);
-
-// Blends a line of Count pixels in Destination against the given color using a constant alpha value.
-// The layout of a pixel must be BGRA and Color must be rrggbb00 (as stored by a COLORREF).
-// ConstantAlpha must be in the range 0..255.
-//
-// EAX contains Destination
-// EDX contains Count
-// ECX contains ConstantAlpha
-// Color is passed on the stack
-
-asm
-        // The used formula is: target = (alpha * color + (256 - alpha) * target) / 256.
-        // alpha * color (factor 1) and 256 - alpha (factor 2) are constant values which can be calculated in advance.
-        // The remaining calculation is therefore: target = (F1 + F2 * target) / 256
-
-        // Load MM3 with the constant alpha value (replicate it for every component).
-        // Expand it to word size. (Every calculation here works on word sized operands.)
-        DB      $0F, $6E, $D9          /// MOVD      MM3, ECX
-        DB      $0F, $61, $DB          /// PUNPCKLWD MM3, MM3
-        DB      $0F, $62, $DB          /// PUNPCKLDQ MM3, MM3
-
-        // Calculate factor 2.
-        MOV     ECX, $100
-        DB      $0F, $6E, $D1          /// MOVD      MM2, ECX
-        DB      $0F, $61, $D2          /// PUNPCKLWD MM2, MM2
-        DB      $0F, $62, $D2          /// PUNPCKLDQ MM2, MM2
-        DB      $0F, $F9, $D3          /// PSUBW     MM2, MM3             // MM2 contains now: 255 - alpha = F2
-
-        // Now calculate factor 1. Alpha is still in MM3, but the r and b components of Color must be swapped.
-        MOV     ECX, [Color]
-        BSWAP   ECX
-        ROR     ECX, 8
-        DB      $0F, $6E, $C9          /// MOVD      MM1, ECX             // Load the color and convert to word sized values.
-        DB      $0F, $EF, $E4          /// PXOR      MM4, MM4
-        DB      $0F, $60, $CC          /// PUNPCKLBW MM1, MM4
-        DB      $0F, $D5, $CB          /// PMULLW    MM1, MM3             // MM1 contains now: color * alpha = F1
-
<A HREF="https://lists.berlios.de/mailman/listinfo/wolfpack-svn">- at 1</A>:     // The pixel loop calculates an entire pixel in one run.
-        DB      $0F, $6E, $00          /// MOVD      MM0, [EAX]
-        DB      $0F, $60, $C4          /// PUNPCKLBW MM0, MM4
-
-        DB      $0F, $D5, $C2          /// PMULLW    MM0, MM2             // calculate F1 + F2 * target
-        DB      $0F, $FD, $C1          /// PADDW     MM0, MM1
-        DB      $0F, $71, $D0, $08     /// PSRLW     MM0, 8               // divide by 256
-
-        DB      $0F, $67, $C0          /// PACKUSWB  MM0, MM0             // convert words to bytes with saturation
-        DB      $0F, $7E, $00          /// MOVD      [EAX], MM0           // store the result
-
-        ADD     EAX, 4
-        DEC     EDX
-        JNZ     @1
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure EMMS;
-
-// Reset MMX state to use the FPU for other tasks again.
-
-asm
-        DB      $0F, $77               /// EMMS
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function GetBitmapBitsFromDeviceContext(DC: HDC; var Width, Height: Integer): Pointer;
-
-// Helper function used to retrieve the bitmap selected into the given device context. If there is a bitmap then
-// the function will return a pointer to its bits otherwise nil is returned.
-// Additionally the dimensions of the bitmap are returned. 
-
-var
-  Bitmap: HBITMAP;
-  DIB: TDIBSection;
-
-begin
-  Result := nil;
-  Width := 0;
-  Height := 0;
-
-  Bitmap := GetCurrentObject(DC, OBJ_BITMAP);
-  if Bitmap &lt;&gt; 0 then
-  begin
-    if GetObject(Bitmap, SizeOf(DIB), @DIB) = SizeOf(DIB) then
-    begin
-      Assert(DIB.dsBm.bmPlanes * DIB.dsBm.bmBitsPixel = 32, 'Alpha blending error: bitmap must use 32 bpp.');
-      Result := DIB.dsBm.bmBits;
-      Width := DIB.dsBmih.biWidth;
-      Height := DIB.dsBmih.biHeight;
-    end;
-  end;
-  Assert(Result &lt;&gt; nil, 'Alpha blending DC error: no bitmap available.');
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function CalculateScanline(Bits: Pointer; Width, Height, Row: Integer): Pointer;
-
-// Helper function to calculate the start address for the given row.
-
-begin
-  if Height &gt; 0 then  // bottom-up DIB
-    Row := Height - Row - 1;
-  // Return DWORD aligned address of the requested scanline.
-  Integer(Result) := Integer(Bits) + Row * ((Width * 32 + 31) and not 31) div 8;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure AlphaBlend(Source, Destination: HDC; R: TRect; Target: TPoint; Mode: TBlendMode; ConstantAlpha, Bias: Integer);
-
-// Optimized alpha blend procedure using MMX instructions to perform as quick as possible.
-// For this procedure to work properly it is important that both source and target bitmap use the 32 bit color format.
-// R describes the source rectangle to work on.
-// Target is the place (upper left corner) in the target bitmap where to blend to. Note that source width + X offset
-// must be less or equal to the target width. Similar for the height.
-// If Mode is bmConstantAlpha then the blend operation uses the given ConstantAlpha value for all pixels.
-// If Mode is bmPerPixelAlpha then each pixel is blended using its individual alpha value (the alpha value of the source).
-// If Mode is bmMasterAlpha then each pixel is blended using its individual alpha value multiplied by ConstantAlpha.
-// If Mode is bmConstantAlphaAndColor then each destination pixel is blended using ConstantAlpha but also a constant
-// color which will be obtained from Bias. In this case no offset value is added, otherwise Bias is used as offset.
-// Blending of a color into target only (bmConstantAlphaAndColor) ignores Source (the DC) and Target (the position).
-// CAUTION: This procedure does not check whether MMX instructions are actually available! Call it only if MMX is really
-//          usable.
-
-var
-  Y: Integer;
-  SourceRun,
-  TargetRun: PByte;
-
-  SourceBits,
-  DestBits: Pointer;
-  SourceWidth,
-  SourceHeight,
-  DestWidth,
-  DestHeight: Integer;
-  
-begin                              
-  if not IsRectEmpty(R) then
-  begin
-    // Note: it is tempting to optimize the special cases for constant alpha 0 and 255 by just ignoring soure
-    //       (alpha = 0) or simply do a blit (alpha = 255). But this does not take the bias into account.
-    case Mode of
-      bmConstantAlpha:
-        begin
-          // Get a pointer to the bitmap bits for the source and target device contexts.
-          // Note: this supposes that both contexts do actually have bitmaps assigned!
-          SourceBits := GetBitmapBitsFromDeviceContext(Source, SourceWidth, SourceHeight);
-          DestBits := GetBitmapBitsFromDeviceContext(Destination, DestWidth, DestHeight);
-          if Assigned(SourceBits) and Assigned(DestBits) then
-          begin
-            for Y := 0 to R.Bottom - R.Top - 1 do
-            begin
-              SourceRun := CalculateScanline(SourceBits, SourceWidth, SourceHeight, Y + R.Top);
-              Inc(SourceRun, 4 * R.Left);
-              TargetRun := CalculateScanline(DestBits, DestWidth, DestHeight, Y + Target.Y);
-              Inc(TargetRun, 4 * Target.X);
-              AlphaBlendLineConstant(SourceRun, TargetRun, R.Right - R.Left, ConstantAlpha, Bias);
-            end;
-          end;
-          EMMS;
-        end;
-      bmPerPixelAlpha:
-        begin
-          SourceBits := GetBitmapBitsFromDeviceContext(Source, SourceWidth, SourceHeight);
-          DestBits := GetBitmapBitsFromDeviceContext(Destination, DestWidth, DestHeight);
-          if Assigned(SourceBits) and Assigned(DestBits) then
-          begin
-            for Y := 0 to R.Bottom - R.Top - 1 do
-            begin
-              SourceRun := CalculateScanline(SourceBits, SourceWidth, SourceHeight, Y + R.Top);
-              Inc(SourceRun, 4 * R.Left);
-              TargetRun := CalculateScanline(DestBits, DestWidth, DestHeight, Y + Target.Y);
-              Inc(TargetRun, 4 * Target.X);
-              AlphaBlendLinePerPixel(SourceRun, TargetRun, R.Right - R.Left, Bias);
-            end;
-          end;
-          EMMS;
-        end;
-      bmMasterAlpha:
-        begin
-          SourceBits := GetBitmapBitsFromDeviceContext(Source, SourceWidth, SourceHeight);
-          DestBits := GetBitmapBitsFromDeviceContext(Destination, DestWidth, DestHeight);
-          if Assigned(SourceBits) and Assigned(DestBits) then
-          begin
-            for Y := 0 to R.Bottom - R.Top - 1 do
-            begin
-              SourceRun := CalculateScanline(SourceBits, SourceWidth, SourceHeight, Y + R.Top);
-              Inc(SourceRun, 4 * Target.X);
-              TargetRun := CalculateScanline(DestBits, DestWidth, DestHeight, Y + Target.Y);
-              AlphaBlendLineMaster(SourceRun, TargetRun, R.Right - R.Left, ConstantAlpha, Bias);
-            end;
-          end;
-          EMMS;
-        end;
-      bmConstantAlphaAndColor:
-        begin
-          // Source is ignored since there is a constant color value.
-          DestBits := GetBitmapBitsFromDeviceContext(Destination, DestWidth, DestHeight);
-          if Assigned(DestBits) then
-          begin
-            for Y := 0 to R.Bottom - R.Top - 1 do
-            begin
-              TargetRun := CalculateScanline(DestBits, DestWidth, DestHeight, Y + R.Top);
-              Inc(TargetRun, 4 * R.Left);
-              AlphaBlendLineMasterAndColor(TargetRun, R.Right - R.Left, ConstantAlpha, Bias);
-            end;
-          end;
-          EMMS;
-        end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function GetRGBColor(Value: TColor): DWORD;
-
-// Little helper to convert a Delphi color to an image list color.
-
-begin
-  Result := ColorToRGB(Value);
-  case Result of
-    clNone:
-      Result := CLR_NONE;
-    clDefault:
-      Result := CLR_DEFAULT;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-const
-  Grays: array[0..3] of TColor = (clWhite, clSilver, clGray, clBlack);
-  SysGrays: array[0..3] of TColor = (clWindow, clBtnFace, clBtnShadow, clBtnText);
-
-procedure ConvertImageList(IL: TImageList; const ImageName: string; ColorRemapping: Boolean = True); 
-
-// Loads a bunch of images given by ImageName into IL. If ColorRemapping = True then a mapping of gray values to
-// system colors is performed.
-
-var
-  Images,
-  OneImage: TBitmap;
-  I: Integer;
-  MaskColor: TColor;
-  Source,
-  Dest: TRect;
-
-begin
-  Watcher.Enter;
-  try
-    // Since we want the image list appearing in the correct system colors, we have to remap its colors.
-    Images := TBitmap.Create;
-    OneImage := TBitmap.Create;
-    if ColorRemapping then
-      Images.Handle := CreateMappedRes(FindClassHInstance(TBaseVirtualTree), PChar(ImageName), Grays, SysGrays)
-    else
-      Images.Handle := LoadBitmap(FindClassHInstance(TBaseVirtualTree), PChar(ImageName));
-
-    try
-      Assert(Images.Height &gt; 0, 'Internal image &quot;' + ImageName + '&quot; is missing or corrupt.');
-
-      // It is assumed that the image height determines also the width of one entry in the image list.
-      IL.Clear;
-      IL.Height := Images.Height;
-      IL.Width := Images.Height;
-      OneImage.Width := IL.Width;
-      OneImage.Height := IL.Height;
-      MaskColor := Images.Canvas.Pixels[0, 0]; // this is usually clFuchsia
-      Dest := Rect(0, 0, IL.Width, IL.Height);
-      for I := 0 to (Images.Width div Images.Height) - 1 do
-      begin
-        Source := Rect(I * IL.Width, 0, (I + 1) * IL.Width, IL.Height);
-        OneImage.Canvas.CopyRect(Dest, Images.Canvas, Source);
-        IL.AddMasked(OneImage, MaskColor);
-      end;
-    finally
-      Images.Free;
-      OneImage.Free;
-    end;
-  finally
-    Watcher.Leave;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure CreateSystemImageSet(var IL: TImageList; Flags: Cardinal; Flat: Boolean);
-
-// Creates a system check image set.
-// Note: the DarkCheckImages image list must already be filled, as some images from it are copied here.
-
-const
-  MaskColor: TColor = clFuchsia;
-
-  //--------------- local functions -------------------------------------------
-
-  procedure AddNodeImages(IL: TImageList);
-
-  var
-    BM: TBitmap;
-    I: Integer;
-    OffsetX,
-    OffsetY: Integer;
-    
-  begin
-    BM := TBitmap.Create;
-    // Make the bitmap the same size as the image list has to avoid problems when adding.
-    BM.Width := IL.Width;
-    BM.Height := IL.Height;
-    // The offsets are used to center the node images in case the sizes differ.
-    OffsetX := (IL.Width - DarkCheckImages.Width) div 2;
-    OffsetY := (IL.Height - DarkCheckImages.Height) div 2;
-    try
-      for I := 20 to 23 do
-      begin
-        DarkCheckImages.Draw(BM.Canvas, OffsetX, OffsetY, I);
-        IL.AddMasked(BM, DarkCheckImages.BkColor);
-      end;
-    finally
-      BM.Free;
-    end;
-  end;
-
-  //---------------------------------------------------------------------------
-
-  procedure AddSystemImage(IL: TImageList; Flat: Boolean; Index: Integer);
-
-  var
-    BM: TBitmap;
-    ButtonState: Cardinal;
-    ButtonType: Cardinal;
-
-  begin
-    BM := TBitmap.Create;
-    try
-      BM.Width := IL.Width;
-      BM.Height := IL.Height;
-      BM.Canvas.Brush.Color := MaskColor;
-      BM.Canvas.Brush.Style := bsSolid;
-      BM.Canvas.FillRect(Rect(0, 0, BM.Width, BM.Height));
-      BM.Canvas.Brush.Style := bsClear;
-      if Index &lt;= 8 then
-        ButtonType := DFCS_BUTTONRADIO
-      else
-        ButtonType := DFCS_BUTTONCHECK;
-      if Index &gt;= 17 then
-        ButtonType := ButtonType or DFCS_BUTTON3STATE or DFCS_INACTIVE;
-
-      case Index mod 4 of
-        1:
-          ButtonState := 0;
-        2:
-          ButtonState := DFCS_HOT;
-        3:
-          ButtonState := DFCS_PUSHED;
-        else
-          ButtonState := DFCS_INACTIVE;
-      end;
-      if Index in [5..8, 13..16] then
-        ButtonState := ButtonState or DFCS_CHECKED;
-      if Flat then
-        ButtonState := ButtonState or DFCS_FLAT;
-      DrawFrameControl(BM.Canvas.Handle, Rect(1, 2, BM.Width - 2, BM.Height - 1), DFC_BUTTON, ButtonType or ButtonState);
-      IL.AddMasked(BM, MaskColor);
-    finally
-      BM.Free
-    end;
-  end;
-
-  //--------------- end local functions ---------------------------------------
-
-var
-  I, Width, Height: Integer;
-
-begin
-  Width := GetSystemMetrics(SM_CXMENUCHECK) + 3;
-  Height := GetSystemMetrics(SM_CYMENUCHECK) + 3;
-  IL := TImageList.CreateSize(Width, Height);
-  with IL do
-    Handle := ImageList_Create(Width, Height, Flags, 0, AllocBy);
-  IL.Masked := True;
-  // Add the 20 system checkbox and radiobutton images.
-  for I := 0 to 19 do
-    AddSystemImage(IL, Flat, I);
-  // Add the 4 node images from the dark check set.
-  AddNodeImages(IL);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function HasMMX: Boolean;
-
-// Helper method to determine whether the current processor supports MMX.
-
-asm
-        PUSH    EBX
-        XOR     EAX, EAX     // Result := False
-        PUSHFD               // determine if the processor supports the CPUID command
-        POP     EDX
-        MOV     ECX, EDX
-        XOR     EDX, $200000
-        PUSH    EDX
-        POPFD
-        PUSHFD
-        POP     EDX
-        XOR     ECX, EDX
-        JZ      @1           // no CPUID support so we can't even get to the feature information 
-        PUSH    EDX
-        POPFD
-
-        MOV     EAX, 1
-        DW      $A20F        // CPUID, EAX contains now version info and EDX feature information
-        MOV     EBX, EAX     // free EAX to get the result value
-        XOR     EAX, EAX     // Result := False
-        CMP     EBX, $50
-        JB      @1           // if processor family is &lt; 5 then it is not a Pentium class processor
-        TEST    EDX, $800000
-        JZ      @1           // if the MMX bit is not set then we don't have MMX
-        INC     EAX          // Result := True
<A HREF="https://lists.berlios.de/mailman/listinfo/wolfpack-svn">- at 1</A>:
-        POP     EBX
-end;
- 
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure PrtStretchDrawDIB(Canvas: TCanvas; DestRect: TRect; ABitmap: TBitmap);
-
-// Stretch draw on to the new canvas.
-
-var
-  Header,
-  Bits: Pointer;
-  HeaderSize,
-  BitsSize: Cardinal;
-  
-begin
-  GetDIBSizes(ABitmap.Handle, HeaderSize, BitsSize);
-
-  GetMem(Header, HeaderSize);
-  GetMem(Bits, BitsSize);
-  try
-    GetDIB(ABitmap.Handle, ABitmap.Palette, Header^, Bits^);
-    StretchDIBits(Canvas.Handle, DestRect.Left, DestRect.Top, DestRect.Right - DestRect.Left, DestRect.Bottom -
-      DestRect.Top, 0, 0, ABitmap.Width, ABitmap.Height, Bits, TBitmapInfo(Header^), DIB_RGB_COLORS, SRCCOPY);
-  finally
-    FreeMem(Header);
-    FreeMem(Bits);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure InitializeGlobalStructures;
-
-// initialization of stuff global to the unit
-
-var
-  {$ifndef COMPILER_5_UP}
-    NonClientMetrics: TNonClientMetrics;
-  {$endif COMPILER_5_UP}
-  Flags: Cardinal;
-
-begin
-  Initialized := True;
-  
-  // For the drag image a fast MMX blend routine is used. We have to make sure MMX is available.
-  MMXAvailable := HasMMX;
-
-  // There is a bug in Win95 and WinME (and potentially in Win98 too) regarding GetDCEx which causes sometimes
-  // serious trouble within GDI (see method WMNCPaint).
-  IsWinNT := (Win32Platform and VER_PLATFORM_WIN32_NT) &lt;&gt; 0;
-  IsWin2K := (Win32MajorVersion = 5) and (Win32MinorVersion = 0);
-  IsWinXP := (Win32MajorVersion = 5) and (Win32MinorVersion = 1);
-
-  // Initialize OLE subsystem for drag'n drop and clipboard operations.
-  NeedToUnitialize := Succeeded(OleInitialize(nil));
-
-  // Register the tree reference clipboard format. Others will be handled in InternalClipboarFormats.
-  CF_VTREFERENCE := RegisterClipboardFormat(CFSTR_VTREFERENCE);
-
-  // Load all internal image lists and convert their colors to current desktop color scheme.
-  // In order to use high color images we have to create the image list handle ourselves.
-  if IsWinNT then
-    Flags := ILC_COLOR32 or ILC_MASK
-  else
-    Flags := ILC_COLOR16 or ILC_MASK;
-  LightCheckImages := TImageList.Create(nil);
-  with LightCheckImages do
-    Handle := ImageList_Create(16, 16, Flags, 0, AllocBy);
-  ConvertImageList(LightCheckImages, 'VT_CHECK_LIGHT');
-
-  DarkCheckImages := TImageList.CreateSize(16, 16);
-  with DarkCheckImages do
-    Handle := ImageList_Create(16, 16, Flags, 0, AllocBy);
-  ConvertImageList(DarkCheckImages, 'VT_CHECK_DARK');
-
-  LightTickImages := TImageList.CreateSize(16, 16);
-  with LightTickImages do
-    Handle := ImageList_Create(16, 16, Flags, 0, AllocBy);
-  ConvertImageList(LightTickImages, 'VT_TICK_LIGHT');
-
-  DarkTickImages := TImageList.CreateSize(16, 16);
-  with DarkTickImages do
-    Handle := ImageList_Create(16, 16, Flags, 0, AllocBy);
-  ConvertImageList(DarkTickImages, 'VT_TICK_DARK');
-
-  FlatImages := TImageList.CreateSize(16, 16);
-  with FlatImages do
-    Handle := ImageList_Create(16, 16, Flags, 0, AllocBy);
-  ConvertImageList(FlatImages, 'VT_FLAT');
-
-  XPImages := TImageList.CreateSize(16, 16);
-  with XPImages do
-    Handle := ImageList_Create(16, 16, Flags, 0, AllocBy);
-  ConvertImageList(XPImages, 'VT_XP', False);
-
-  UtilityImages := TImageList.CreateSize(UtilityImageSize, UtilityImageSize);
-  with UtilityImages do
-    Handle := ImageList_Create(UtilityImageSize, UtilityImageSize, Flags, 0, AllocBy);
-  ConvertImageList(UtilityImages, 'VT_UTILITIES');
-
-  CreateSystemImageSet(SystemCheckImages, Flags, False);
-  CreateSystemImageSet(SystemFlatCheckImages, Flags, True);
-
-  {$ifndef COMPILER_5_UP}
-    // In Delphi 4 there is no TScreen.HintFont hence we have to manage this manually.
-    HintFont := TFont.Create;
-    NonClientMetrics.cbSize := SizeOf(NonClientMetrics);
-    if SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, @NonClientMetrics, 0) then
-      HintFont.Handle := CreateFontIndirect(NonClientMetrics.lfStatusFont)
-    else
-      HintFont.Size := 8;
-  {$endif COMPILER_5_UP}
-
-  // Specify an useful timer resolution for timeGetTime.
-  timeBeginPeriod(MinimumTimerInterval);
-
-  // Delphi (at least version 6 and lower) does not provide a standard split cursor.
-  // Hence we have to load our own.    
-  Screen.Cursors[crHeaderSplit] := LoadCursor(HInstance, 'VT_HEADERSPLIT');
-
-  // Clipboard format registration.
-  // Native clipboard format. Needs a new identifier and has an average priority to allow other formats to take over.
-  // This format is supposed to use the IStream storage format but unfortunately this does not work when
-  // OLEFlushClipboard is used. Hence it is disabled until somebody finds a solution.
-  CF_VIRTUALTREE := RegisterVTClipboardFormat(CFSTR_VIRTUALTREE, TBaseVirtualTree, 50, TYMED_HGLOBAL {or TYMED_ISTREAM});
-  // Specialized string tree formats.
-  CF_HTML := RegisterVTClipboardFormat(CFSTR_HTML, TCustomVirtualStringTree, 80);
-  CF_VRTFNOOBJS := RegisterVTClipboardFormat(CFSTR_RTFNOOBJS, TCustomVirtualStringTree, 84);
-  CF_VRTF := RegisterVTClipboardFormat(CFSTR_RTF, TCustomVirtualStringTree, 85);
-  CF_CSV := RegisterVTClipboardFormat(CFSTR_CSV, TCustomVirtualStringTree, 90);
-  // Predefined clipboard formats. Just add them to the internal list.
-  RegisterVTClipboardFormat(CF_TEXT, TCustomVirtualStringTree, 100);
-  RegisterVTClipboardFormat(CF_UNICODETEXT, TCustomVirtualStringTree, 95);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure FinalizeGlobalStructures;
-
-var
-  HintWasEnabled: Boolean;
-
-begin
-  timeEndPeriod(MinimumTimerInterval);                        
-  {$ifndef COMPILER_5_UP}
-    HintFont.Free;
-  {$endif COMPILER_5_UP}
-
-  LightCheckImages.Free;
-  DarkCheckImages.Free;
-  LightTickImages.Free;
-  DarkTickImages.Free;
-  FlatImages.Free;
-  XPImages.Free;
-  UtilityImages.Free;
-  SystemCheckImages.Free;
-  SystemFlatCheckImages.Free;
-
-  if NeedToUnitialize then
-    OleUninitialize;
-
-  // If VT is used in a package and its special hint window was used then the last instance of this
-  // window is not freed correctly (bug in the VCL). We explicitely tell the application to free it
-  // otherwise an AV is raised due to access to an invalid memory area.
-  if ModuleIsPackage then
-  begin
-    HintWasEnabled := Application.ShowHint;
-    Application.ShowHint := False;
-    if HintWasEnabled then
-      Application.ShowHint := True;
-  end;
-end;
-
-//----------------- TWorkerThread --------------------------------------------------------------------------------------
-
-procedure AddThreadReference;
-
-begin
-  if WorkerThread = nil then
-  begin
-    // Create an event used to trigger our worker thread when something is to do.
-    WorkEvent := CreateEvent(nil, False, False, nil);
-    if WorkEvent = 0 then
-      RaiseLastOSError;
-
-    // Create worker thread, initialize it and send it to its wait loop.
-    WorkerThread := TWorkerThread.Create(False);
-  end;
-  Inc(WorkerThread.FRefCount);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure ReleaseThreadReference(Tree: TBaseVirtualTree);
-
-begin
-  if Assigned(WorkerThread) then
-  begin
-    Dec(WorkerThread.FRefCount);
-
-    // Make sure there is no reference remaining to the releasing tree.
-    Tree.InterruptValidation;
-
-    if WorkerThread.FRefCount = 0 then
-    begin
-      with WorkerThread do
-      begin
-        Terminate;
-        SetEvent(WorkEvent);
-
-        // The following work around is no longer necessary with Delphi 6 and up.
-        {$ifndef COMPILER_6_UP}
-          // There is a problem when the thread is freed in the exit code of a DLL. This can happen when a tree is
-          // destroyed on unload of a DLL (e.g. control panel applet). In this case only the main thread will get
-          // CPU time, other threads will never awake again. The VCL however waits for a thread when freeing it
-          // which will result in a deadlock (the WaitFor call does not return because the thread does not get CPU time).
-          // If a thread is however suspended then the VCL does not wait and all is fine.
-          if IsLibrary then
-            Suspend;
-        {$endif COMPILER_6_UP}
-
-        WorkerThread.Free;
-      end;
-      WorkerThread := nil;
-      CloseHandle(WorkEvent);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-constructor TWorkerThread.Create(CreateSuspended: Boolean);
-
-begin
-  inherited Create(CreateSuspended);
-  FWaiterList := TThreadList.Create;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TWorkerThread.Destroy;
-
-begin
-  FWaiterList.Free;
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TWorkerThread.ChangeTreeStates(EnterStates, LeaveStates: TChangeStates);
-
-begin
-  if Assigned(FCurrentTree) and (FCurrentTree.HandleAllocated) then
-    PostMessage(FCurrentTree.Handle, WM_CHANGESTATE, Byte(EnterStates), Byte(LeaveStates));
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TWorkerThread.Execute;
-
-// Does some background tasks, like validating tree caches.
-
-var
-  EnterStates,
-  LeaveStates: TChangeStates;
-
-begin
-  while not Terminated do
-  begin
-    WaitForSingleObject(WorkEvent, INFINITE);
-    if not Terminated then
-    begin
-      // Get the next waiting tree.
-      with FWaiterList.LockList do
-      try
-        if Count &gt; 0 then
-        begin
-          FCurrentTree := Items[0];
-          // Remove this tree from waiter list.
-          Delete(0);
-        end
-        else
-          FCurrentTree := nil;
-      finally
-        FWaiterList.UnlockList;
-      end;
-
-      // Something to do?
-      try
-        if Assigned(FCurrentTree) and not (tsStopValidation in FCurrentTree.FStates) then
-        begin
-          ChangeTreeStates([csValidating], [csUseCache]);
-          EnterStates := [];
-          if FCurrentTree.DoValidateCache then
-            EnterStates := [csUseCache];
-        end;
-      finally
-        LeaveStates := [csValidating, csStopValidation];
-        if csUseCache in EnterStates then
-          Include(LeaveStates, csValidationNeeded);
-        ChangeTreeStates(EnterStates, LeaveStates);
-        FCurrentTree := nil;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TWorkerThread.AddTree(Tree: TBaseVirtualTree);
-
-begin
-  Assert(Assigned(Tree), 'Tree must not be nil.');
-  
-  with FWaiterList.LockList do
-  try
-    if IndexOf(Tree) = -1 then
-      Add(Tree);
-  finally
-    FWaiterList.UnlockList;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TWorkerThread.RemoveTree(Tree: TBaseVirtualTree);
-
-begin
-  Assert(Assigned(Tree), 'Tree must not be nil.');
-
-  if FCurrentTree = Tree then
-    FCurrentTree := nil;
-
-  with FWaiterList.LockList do
-  try
-    Remove(Tree);
-  finally
-    FWaiterList.UnlockList;
-  end;
-end;
-
-//----------------- TBufferedString ------------------------------------------------------------------------------------
-
-const
-  AllocIncrement = 4096;
-  
-destructor TBufferedString.Destroy;
-
-begin
-  FreeMem(FStart);
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBufferedString.GetAsString: string;
-
-begin
-  SetString(Result, FStart, FPosition - FStart);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBufferedString.Add(const S: string);
-
-var
-  LastLen,
-  LastOffset,
-  Len: Integer;
-
-begin
-  Len := Length(S);
-  // Make room for the new string.
-  if FEnd - FPosition &lt;= Len then
-  begin
-    // Keep last offset to restore it correctly in the case that FStart gets a new memory block assigned.
-    LastLen := FEnd - FStart;
-    LastOffset := FPosition - FStart;
-    ReallocMem(FStart, FEnd - FStart + AllocIncrement);
-    FPosition := FStart + LastOffset;
-    FEnd := FStart + LastLen + AllocIncrement;
-  end;                     
-  Move(PChar(S)^, FPosition^, Len);
-  Inc(FPosition, Len);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBufferedString.AddNewLine;
-
-var
-  LastLen,
-  LastOffset: Integer;
-
-begin
-  // Make room for the CR/LF characters.
-  if FEnd - FPosition &lt;= 2 then
-  begin
-    // Keep last offset to restore it correctly in the case that FStart gets a new memory block assigned.
-    LastLen := FEnd - FStart;
-    LastOffset := FPosition - FStart;
-    ReallocMem(FStart, FEnd - FStart + AllocIncrement);
-    FPosition := FStart + LastOffset;
-    FEnd := FStart + LastLen + AllocIncrement;
-  end;
-  FPosition^ := #13;
-  Inc(FPosition);
-  FPosition^ := #10;
-  Inc(FPosition);
-end;
-
-//----------------- TWideBufferedString --------------------------------------------------------------------------------
-
-destructor TWideBufferedString.Destroy;
-
-begin
-  FreeMem(FStart);
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TWideBufferedString.GetAsString: WideString;
-
-begin
-  SetString(Result, FStart, FPosition - FStart);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TWideBufferedString.Add(const S: WideString);
-
-var
-  LastLen,
-  LastOffset,
-  Len: Integer;
-
-begin
-  Len := Length(S);
-  // Make room for the new string.
-  if FEnd - FPosition &lt;= Len then
-  begin
-    // Keep last offset to restore it correctly in the case that FStart gets a new memory block assigned.
-    LastLen := FEnd - FStart;
-    LastOffset := FPosition - FStart;
-    ReallocMem(FStart, 2 * (FEnd - FStart + AllocIncrement));
-    FPosition := FStart + LastOffset;
-    FEnd := FStart + LastLen + AllocIncrement;
-  end;                     
-  Move(PWideChar(S)^, FPosition^, 2 * Len);
-  Inc(FPosition, Len);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TWideBufferedString.AddNewLine;
-
-var
-  LastLen,
-  LastOffset: Integer;
-
-begin
-  // Make room for the CR/LF characters.
-  if FEnd - FPosition &lt;= 4 then
-  begin
-    // Keep last offset to restore it correctly in the case that FStart gets a new memory block assigned.
-    LastLen := FEnd - FStart;
-    LastOffset := FPosition - FStart;
-    ReallocMem(FStart, 2 * (FEnd - FStart + AllocIncrement));
-    FPosition := FStart + LastOffset;
-    FEnd := FStart + LastLen + AllocIncrement;
-  end;
-  FPosition^ := #13;
-  Inc(FPosition);
-  FPosition^ := #10;
-  Inc(FPosition);
-end;
-
-//----------------- TCustomVirtualTreeOptions --------------------------------------------------------------------------
-
-constructor TCustomVirtualTreeOptions.Create(AOwner: TBaseVirtualTree);
-
-begin
-  FOwner := AOwner;
-
-  FPaintOptions := DefaultPaintOptions;
-  FAnimationOptions := DefaultAnimationOptions;
-  FAutoOptions := DefaultAutoOptions;
-  FSelectionOptions := DefaultSelectionOptions;
-  FMiscOptions := DefaultMiscOptions;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualTreeOptions.SetAnimationOptions(const Value: TVTAnimationOptions);
-
-begin
-  FAnimationOptions := Value;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualTreeOptions.SetAutoOptions(const Value: TVTAutoOptions);
-
-var
-  ChangedOptions: TVTAutoOptions;
-
-begin
-  if FAutoOptions &lt;&gt; Value then
-  begin
-    // Exclusive ORing to get all entries wich are in either set but not in both.
-    ChangedOptions := FAutoOptions + Value - (FAutoOptions * Value);
-    FAutoOptions := Value;
-    with FOwner do
-      if (toAutoSpanColumns in ChangedOptions) and not (csLoading in ComponentState) and HandleAllocated then
-        Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualTreeOptions.SetMiscOptions(const Value: TVTMiscOptions);
-
-var
-  ToBeSet,
-  ToBeCleared: TVTMiscOptions;
-
-begin
-  if FMiscOptions &lt;&gt; Value then
-  begin
-    ToBeSet := Value - FMiscOptions;
-    ToBeCleared := FMiscOptions - Value;
-    FMiscOptions := Value;
-
-    with FOwner do
-      if not (csLoading in ComponentState) and HandleAllocated then
-      begin
-        if toCheckSupport in ToBeSet + ToBeCleared then
-          Invalidate;
-        if not (csDesigning in ComponentState) then
-        begin
-          if toFullRepaintOnResize in TobeSet + ToBeCleared then
-            RecreateWnd;
-          if toAcceptOLEDrop in ToBeSet then
-            RegisterDragDrop(Handle, DragManager as IDropTarget);
-          if toAcceptOLEDrop in ToBeCleared then
-            RevokeDragDrop(Handle);
-        end;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualTreeOptions.SetPaintOptions(const Value: TVTPaintOptions);
-
-var
-  ToBeSet,
-  ToBeCleared: TVTPaintOptions;
-
-begin
-  if FPaintOptions &lt;&gt; Value then
-  begin
-    ToBeSet := Value - FPaintOptions;
-    ToBeCleared := FPaintOptions - Value;
-    FPaintOptions := Value;
-    with FOwner do
-      if not (csLoading in ComponentState) and HandleAllocated then
-      begin
-        {$ifdef ThemeSupport}
-          if toThemeAware in ToBeSet + ToBeCleared then
-          begin
-            if (toThemeAware in ToBeSet) and ThemeServices.ThemesEnabled then
-              DoStateChange([tsUseThemes])
-            else
-              DoStateChange([], [tsUseThemes]);
-            PrepareBitmaps(True, False);
-            RedrawWindow(Handle, nil, 0, RDW_INVALIDATE or RDW_VALIDATE or RDW_FRAME);
-          end
-          else
-        {$endif ThemeSupport}
-          Invalidate;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualTreeOptions.SetSelectionOptions(const Value: TVTSelectionOptions);
-
-var
-  ToBeSet,
-  ToBeCleared: TVTSelectionOptions;
-
-begin
-  if FSelectionOptions &lt;&gt; Value then
-  begin
-    ToBeSet := Value - FSelectionOptions;
-    ToBeCleared := FSelectionOptions - Value;
-    FSelectionOptions := Value;
-
-    with FOwner do
-    begin
-      if (toMultiSelect in (ToBeCleared + ToBeSet)) or
-        ([toLevelSelectConstraint, toSiblingSelectConstraint] * ToBeSet &lt;&gt; []) then
-        ClearSelection;
-
-      if (toExtendedFocus in ToBeCleared) and (FFocusedColumn &gt; 0) and HandleAllocated then
-      begin
-        FFocusedColumn := FHeader.MainColumn;
-        Invalidate;
-      end;
-
-      if not (toExtendedFocus in FSelectionOptions) then
-        FFocusedColumn := FHeader.MainColumn;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualTreeOptions.AssignTo(Dest: TPersistent);
-
-begin
-  if Dest is TCustomVirtualTreeOptions then
-  begin
-    with Dest as TCustomVirtualTreeOptions do
-    begin
-      PaintOptions := Self.PaintOptions;
-      AnimationOptions := Self.AnimationOptions;
-      AutoOptions := Self.AutoOptions;
-      SelectionOptions := Self.SelectionOptions;
-      MiscOptions := Self.MiscOptions;
-    end;
-  end
-  else
-    inherited;
-end;
-
-//----------------- TVTNodeMemoryManager -------------------------------------------------------------------------------
-
-{$ifdef UseLocalMemoryManager}
-
-  const
-    NodeMemoryGuard: PVirtualNode = PVirtualNode($FEEFEFFE);
-
-  constructor TVTNodeMemoryManager.Create;
-
-  begin
-    FBlockList := TList.Create;
-  end;
-
-  //----------------------------------------------------------------------------------------------------------------------
-
-  destructor TVTNodeMemoryManager.Destroy;
-
-  begin
-    Clear;
-    FBlockList.Free;
-  end;
-
-  //----------------------------------------------------------------------------------------------------------------------
-
-  function TVTNodeMemoryManager.AllocNode(const Size: Cardinal): PVirtualNode;
-
-  // Allocates memory for a node using the local memory manager.
-
-  const
-    BlockSize = (16 * 1024);   // Blocks larger than 16K offer no significant performance improvement.
-  
-  begin
-    if FAllocSize = 0 then
-      // Recalculate allocation size first time after a clear.
-      FAllocSize := (Size + 3) and not 3   // Force alignment on 32-bit boundaries.
-    else
-      // Allocation size cannot be increased unless Memory Manager is explicitly cleared.
-      Assert(Size &lt;= FAllocSize, 'Node memory manager allocation size cannot be increased.');
-
-    if Assigned(FFreeSpace) then
-    begin
-      // Assign node from free-space chain.
-      Assert(FFreeSpace.NextSibling = NodeMemoryGuard, 'Memory overwrite in node memory manager free space chain.');
-      Result := FFreeSpace;                // Assign node
-      FFreeSpace := Result.PrevSibling;    // Point to prev node in free-space chain
-    end
-    else
-    begin
-      if FBytesAvailable &lt; FAllocSize then
-      begin
-        // Get another block from the Delphi memory manager.
-        GetMem(FNext, BlockSize);
-        FBytesAvailable := BlockSize;
-        FBlockList.Add(FNext);
-      end;
-      // Assign node from current block.
-      Result := FNext;
-      Inc(PChar(FNext), FAllocSize);
-      Dec(FBytesAvailable, FAllocSize);
-    end;
-
-    // Clear the memory.
-    FillChar(Result^, FAllocSize, 0);
-  end;
-
-  //----------------------------------------------------------------------------------------------------------------------
-
-  procedure TVTNodeMemoryManager.Clear;
-
-  // Releases all memory held by the local memory manager.
-
-  var
-    I: Integer;
-
-  begin
-    for I := 0 to FBlockList.Count - 1 do
-      FreeMem(FBlockList[I]);
-    FBlockList.Clear;
-    FFreeSpace := nil;
-    FBytesAvailable := 0;
-    FAllocSize := 0;
-  end;
-
-  //----------------------------------------------------------------------------------------------------------------------
-
-  procedure TVTNodeMemoryManager.FreeNode(const Node: PVirtualNode);
-
-  // Frees node memory that was allocated using the local memory manager.
-
-  begin
-    Node.PrevSibling := FFreeSpace;         // Point to previous free node.
-    Node.NextSibling := NodeMemoryGuard;    // Memory guard to detect overwrites.
-    FFreeSpace := Node;                     // Point Free chain pointer to me.
-  end;
-
-{$endif UseLocalMemoryManager}
-
-//----------------------------------------------------------------------------------------------------------------------
-
-// OLE drag and drop support classes
-// This is quite heavy stuff (compared with the VCL implementation) but is much better suited to fit the needs
-// of DD'ing various kinds of virtual data and works also between applications.
-
-//----------------- TEnumFormatEtc -------------------------------------------------------------------------------------
-
-constructor TEnumFormatEtc.Create(Tree: TBaseVirtualTree; AFormatEtcArray: TFormatEtcArray);
-
-var
-  I: Integer;
-
-begin
-  inherited Create;
-
-  FTree := Tree;
-  // Make a local copy of the format data.
-  SetLength(FFormatEtcArray, Length(AFormatEtcArray));
-  for I := 0 to High(AFormatEtcArray) do
-    FFormatEtcArray[I] := AFormatEtcArray[I];
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TEnumFormatEtc.Clone(out Enum: IEnumFormatEtc): HResult;
-
-var
-  AClone: TEnumFormatEtc;
-
-begin
-  Result := S_OK;
-  try
-    AClone := TEnumFormatEtc.Create(nil, FFormatEtcArray);
-    AClone.FCurrentIndex := FCurrentIndex;
-    Enum := AClone as IEnumFormatEtc;
-  except
-    Result := E_FAIL;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TEnumFormatEtc.Next(celt: Integer; out elt; pceltFetched: PLongint): HResult;
-
-var
-  CopyCount: Integer;
-
-begin
-  Result := S_FALSE;
-  CopyCount := Length(FFormatEtcArray) - FCurrentIndex;
-  if celt &lt; CopyCount then
-    CopyCount := celt;
-  if CopyCount &gt; 0 then
-  begin
-    Move(FFormatEtcArray[FCurrentIndex], elt, CopyCount * SizeOf(TFormatEtc));
-    Inc(FCurrentIndex, CopyCount);
-    Result := S_OK;
-  end;
-  if Assigned(pceltFetched) then
-    pceltFetched^ := CopyCount;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TEnumFormatEtc.Reset: HResult;
-
-begin
-  FCurrentIndex := 0;
-  Result := S_OK;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TEnumFormatEtc.Skip(celt: Integer): HResult;
-
-begin
-  if FCurrentIndex + celt &lt; High(FFormatEtcArray) then
-  begin
-    Inc(FCurrentIndex, celt);
-    Result := S_Ok;
-  end
-  else
-    Result := S_FALSE;
-end;
-
-//----------------- TVTDataObject --------------------------------------------------------------------------------------
-
-constructor TVTDataObject.Create(AOwner: TBaseVirtualTree; ForClipboard: Boolean);
-
-begin
-  inherited Create;
-
-  FOwner := AOwner;
-  FForClipboard := ForClipboard;
-  FOwner.GetNativeClipboardFormats(FFormatEtcArray);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TVTDataObject.Destroy;
-
-var
-  I: Integer;
-  StgMedium: PStgMedium;
-  
-begin
-  // Cancel a pending clipboard operation if this data object was created for the clipboard and
-  // is freed because something else is placed there.
-  if FForClipboard and not (tsClipboardFlushing in FOwner.FStates) then
-    FOwner.CancelCutOrCopy;
-
-  // Release any internal clipboard formats
-  for I := 0 to High(FormatEtcArray) do
-  begin
-    StgMedium := FindInternalStgMedium(FormatEtcArray[I].cfFormat);
-    if Assigned(StgMedium) then
-      ReleaseStgMedium(StgMedium^);
-  end;
-
-  FormatEtcArray := nil;
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.CanonicalIUnknown(TestUnknown: IUnknown): IUnknown;
-
-// Uses COM object identity: An explicit call to the IUnknown::QueryInterface method, requesting the IUnknown
-// interface, will always return the same pointer.
-
-begin
-  if Assigned(TestUnknown) then
-  begin
-    if TestUnknown.QueryInterface(IUnknown, Result) = 0 then
-      Result._Release // Don't actually need it just need the pointer value
-    else
-      Result := TestUnknown
-  end
-  else
-    Result := TestUnknown
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.EqualFormatEtc(FormatEtc1, FormatEtc2: TFormatEtc): Boolean;
-
-begin
-  Result := (FormatEtc1.cfFormat = FormatEtc2.cfFormat) and (FormatEtc1.ptd = FormatEtc2.ptd) and
-    (FormatEtc1.dwAspect = FormatEtc2.dwAspect) and (FormatEtc1.lindex = FormatEtc2.lindex) and
-    (FormatEtc1.tymed and FormatEtc2.tymed &lt;&gt; 0);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.FindFormatEtc(TestFormatEtc: TFormatEtc; const FormatEtcArray: TFormatEtcArray): integer;
-
-var
-  I: integer;
-
-begin
-  Result := -1;
-  for I := 0 to High(FormatEtcArray) do
-  begin
-    if EqualFormatEtc(TestFormatEtc, FormatEtcArray[I]) then
-    begin
-      Result := I;
-      Break;
-    end
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.FindInternalStgMedium(Format: TClipFormat): PStgMedium;
-
-var
-  I: integer;
-begin
-  Result := nil;
-  for I := 0 to High(InternalStgMediumArray) do
-  begin
-    if Format = InternalStgMediumArray[I].Format then
-    begin
-      Result := @InternalStgMediumArray[I].Medium;
-      Break;
-    end
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.HGlobalClone(HGlobal: THandle): THandle;
-
-// Returns a global memory block that is a copy of the passed memory block.
-
-var
-  Size: Cardinal;
-  Data,
-  NewData: PChar;
-
-begin
-  Size := GlobalSize(HGlobal);
-  Result := GlobalAlloc(GPTR, Size);
-  Data := GlobalLock(hGlobal);
-  try
-    NewData := GlobalLock(Result);
-    try
-      Move(Data^, NewData^, Size);
-    finally
-      GlobalUnLock(Result);
-    end
-  finally
-    GlobalUnLock(hGlobal);
-  end
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.RenderInternalOLEData(const FormatEtcIn: TFormatEtc; var Medium: TStgMedium;
-  var OLEResult: HResult): Boolean;
-
-// Tries to render one of the formats which have been stored via the SetData method.
-// Since this data is already there it is just copied or its reference count is increased (depending on storage medium).
-
-var
-  InternalMedium: PStgMedium;
-
-begin
-  Result := True;
-  InternalMedium := FindInternalStgMedium(FormatEtcIn.cfFormat);
-  if Assigned(InternalMedium) then
-    OLEResult := StgMediumIncRef(InternalMedium^, Medium, False, Self as IDataObject)
-  else
-    Result := False;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.StgMediumIncRef(const InStgMedium: TStgMedium; var OutStgMedium: TStgMedium;
-  CopyInMedium: Boolean; DataObject: IDataObject): HRESULT;
-
-// InStgMedium is the data that is requested, OutStgMedium is the data that we are to return either a copy of or
-// increase the IDataObject's reference and send ourselves back as the data (unkForRelease). The InStgMedium is usually
-// the result of a call to find a particular FormatEtc that has been stored locally through a call to SetData.
-// If CopyInMedium is not true we already have a local copy of the data when the SetData function was called (during
-// that call the CopyInMedium must be true). Then as the caller asks for the data through GetData we do not have to make
-// copy of the data for the caller only to have them destroy it then need us to copy it again if necessary.
-// This way we increase the reference count to ourselves and pass the STGMEDIUM structure initially stored in SetData.
-// This way when the caller frees the structure it sees the unkForRelease is not nil and calls Release on the object
-// instead of destroying the actual data.                  
-
-var
-  Len: Integer;
-  
-begin
-  Result := S_OK;
-
-  // Simply copy all fields to start with.
-  OutStgMedium := InStgMedium;
-  // The data handled here always results from a call of SetData we got. This ensures only one storage format
-  // is indicated and hence the case statement below is safe (IDataObject.GetData can optionally use several
-  // storage formats).
-  case InStgMedium.tymed of
-    TYMED_HGLOBAL:
-      begin
-        if CopyInMedium then
-        begin
-          // Generate a unique copy of the data passed                   
-          OutStgMedium.hGlobal := HGlobalClone(InStgMedium.hGlobal);
-          if OutStgMedium.hGlobal = 0 then
-            Result := E_OUTOFMEMORY
-        end
-        else
-          // Don't generate a copy just use ourselves and the copy previously saved.
-          OutStgMedium.unkForRelease := Pointer(DataObject); // Does not increase RefCount.
-      end;
-    TYMED_FILE:
-      begin
-        Len := lstrLenW(InStgMedium.lpszFileName) + 1; // Don'nt forget the terminating null character.
-        OutStgMedium.lpszFileName := CoTaskMemAlloc(2 * Len);
-        Move(InStgMedium.lpszFileName^, OutStgMedium.lpszFileName^, 2 * Len);
-      end;
-    TYMED_ISTREAM:
-      IUnknown(OutStgMedium.stm)._AddRef;
-    TYMED_ISTORAGE:
-      IUnknown(OutStgMedium.stg)._AddRef;
-    TYMED_GDI:                   
-      if not CopyInMedium then
-        // Don't generate a copy just use ourselves and the copy previously saved data.
-        OutStgMedium.unkForRelease := Pointer(DataObject) // Does not increase RefCount.
-      else
-        Result := DV_E_TYMED; // Don't know how to copy GDI objects right now.
-    TYMED_MFPICT:
-      if not CopyInMedium then
-        // Don't generate a copy just use ourselves and the copy previously saved data.
-        OutStgMedium.unkForRelease := Pointer(DataObject) // Does not increase RefCount.
-      else
-        Result := DV_E_TYMED; // Don't know how to copy MetaFile objects right now.
-    TYMED_ENHMF:
-      if not CopyInMedium then
-        // Don't generate a copy just use ourselves and the copy previously saved data.
-        OutStgMedium.unkForRelease := Pointer(DataObject) // Does not increase RefCount.
-      else
-        Result := DV_E_TYMED; // Don't know how to copy enhanced metafiles objects right now.
-  else
-    Result := DV_E_TYMED;
-  end;
-  
-  if (Result = S_OK) and Assigned(OutStgMedium.unkForRelease) then
-    IUnknown(OutStgMedium.unkForRelease)._AddRef;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.DAdvise(const FormatEtc: TFormatEtc; advf: Integer; const advSink: IAdviseSink;
-  out dwConnection: Integer): HResult;
-
-// Advise sink management is greatly simplified by the IDataAdviseHolder interface.
-// We use this interface and forward all concerning calls to it.
-
-begin
-  Result := S_OK;
-  if FAdviseHolder = nil then
-    Result := CreateDataAdviseHolder(FAdviseHolder);
-  if Result = S_OK then
-    Result := FAdviseHolder.Advise(Self as IDataObject, FormatEtc, advf, advSink, dwConnection);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.DUnadvise(dwConnection: Integer): HResult;
-
-begin
-  if FAdviseHolder = nil then
-    Result := E_NOTIMPL
-  else
-    Result := FAdviseHolder.Unadvise(dwConnection);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.EnumDAdvise(out enumAdvise: IEnumStatData): HResult;
-
-begin
-  if FAdviseHolder = nil then
-    Result := OLE_E_ADVISENOTSUPPORTED
-  else
-    Result := FAdviseHolder.EnumAdvise(enumAdvise);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.EnumFormatEtc(Direction: Integer; out EnumFormatEtc: IEnumFormatEtc): HResult;
-
-var
-  NewList: TEnumFormatEtc;
-
-begin
-  Result := E_FAIL;
-  if Direction = DATADIR_GET then
-  begin
-    NewList := TEnumFormatEtc.Create(FOwner, FormatEtcArray);
-    EnumFormatEtc := NewList as IEnumFormatEtc;
-    Result := S_OK;
-  end
-  else
-    EnumFormatEtc := nil;
-  if EnumFormatEtc = nil then
-    Result := OLE_S_USEREG;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.GetCanonicalFormatEtc(const FormatEtc: TFormatEtc; out FormatEtcOut: TFormatEtc): HResult;
-
-begin
-  Result := DATA_S_SAMEFORMATETC;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.GetData(const FormatEtcIn: TFormatEtc; out Medium: TStgMedium): HResult;
-
-// Data is requested by clipboard or drop target. This method dispatchs the call
-// depending on the data being requested.
-
-var
-  I: Integer;
-  Data: PVTReference;
-
-begin
-  // The tree reference format is always supported and returned from here.
-  if FormatEtcIn.cfFormat = CF_VTREFERENCE then
-  begin
-    // Note: this format is not used while flushing the clipboard to avoid a dangling reference
-    //       when the owner tree is destroyed before the clipboard data is replaced with something else.
-    if tsClipboardFlushing in FOwner.FStates then
-      Result := E_FAIL
-    else
-    begin
-      Medium.hGlobal := GlobalAlloc(GHND or GMEM_SHARE, SizeOf(TVTReference));
-      Data := GlobalLock(Medium.hGlobal);
-      Data.Process := GetCurrentProcessID;
-      Data.Tree := FOwner;
-      GlobalUnlock(Medium.hGlobal);
-      Medium.tymed := TYMED_HGLOBAL;
-      Medium.unkForRelease := nil;
-      Result := S_OK;
-    end;
-  end
-  else
-  begin
-    try
-      // See if we accept this type and if not get the correct return value.
-      Result := QueryGetData(FormatEtcIn);
-      if Result = S_OK then
-      begin
-        for I := 0 to High(FormatEtcArray) do
-        begin
-          if EqualFormatEtc(FormatEtcIn, FormatEtcArray[I]) then
-          begin
-            if not RenderInternalOLEData(FormatEtcIn, Medium, Result) then
-              Result := FOwner.RenderOLEData(FormatEtcIn, Medium, FForClipboard);
-            Break;
-          end;
-        end
-      end
-    except
-      FillChar(Medium, SizeOf(Medium), #0);
-      Result := E_FAIL;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.GetDataHere(const FormatEtc: TFormatEtc; out Medium: TStgMedium): HResult;
-
-begin
-  Result := E_NOTIMPL;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.QueryGetData(const FormatEtc: TFormatEtc): HResult;
-
-var
-  I: Integer;
-
-begin
-  Result := DV_E_CLIPFORMAT;
-  for I := 0 to High(FFormatEtcArray) do
-  begin
-    if FormatEtc.cfFormat = FFormatEtcArray[I].cfFormat then
-    begin
-      if (FormatEtc.tymed and FFormatEtcArray[I].tymed) &lt;&gt; 0 then
-      begin
-        if FormatEtc.dwAspect = FFormatEtcArray[I].dwAspect then
-        begin
-          if FormatEtc.lindex = FFormatEtcArray[I].lindex then
-          begin
-            Result := S_OK;
-            Break;
-          end
-          else
-            Result := DV_E_LINDEX;
-        end
-        else
-          Result := DV_E_DVASPECT;
-      end
-      else
-        Result := DV_E_TYMED;
-    end;
-  end
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDataObject.SetData(const FormatEtc: TFormatEtc; var Medium: TStgMedium; DoRelease: BOOL): HResult;
-
-// Allows dynamic adding to the IDataObject during its existance. Most noteably it is used to implement
-// IDropSourceHelper and allows to set a special format for optimized moves during a shell transfer.
-
-var
-  Index: integer;
-  LocalStgMedium: PStgMedium;
-
-begin
-  // See if we already have a format of that type available.
-  Index := FindFormatEtc(FormatEtc, FormatEtcArray);
-  if Index &gt; - 1 then
-  begin
-    // Just use the TFormatEct in the Array after releasing the data.    
-    LocalStgMedium := FindInternalStgMedium(FormatEtcArray[Index].cfFormat);
-    if Assigned(LocalStgMedium) then
-    begin
-      ReleaseStgMedium(LocalStgMedium^);
-      FillChar(LocalStgMedium^, SizeOf(LocalStgMedium^), #0);
-    end;
-  end
-  else
-  begin
-    // It is a new format so create a new TFormatCollectionItem, copy the
-    // FormatEtc parameter into the new object and and put it in the list.
-    SetLength(FFormatEtcArray, Length(FormatEtcArray) + 1);
-    FormatEtcArray[High(FormatEtcArray)] := FormatEtc;
-
-    // Create a new InternalStgMedium and initialize it and associate it with the format.
-    SetLength(FInternalStgMediumArray, Length(InternalStgMediumArray) + 1);
-    InternalStgMediumArray[High(InternalStgMediumArray)].Format := FormatEtc.cfFormat;
-    LocalStgMedium := @InternalStgMediumArray[High(InternalStgMediumArray)].Medium;
-    FillChar(LocalStgMedium^, SizeOf(LocalStgMedium^), #0);
-  end;
-
-  if DoRelease then
-  begin
-    // We are simply being given the data and we take control of it.          
-    LocalStgMedium^ := Medium;
-    Result := S_OK
-  end
-  else
-  begin
-    // We need to reference count or copy the data and keep our own references to it.
-    Result := StgMediumIncRef(Medium, LocalStgMedium^, True, Self as IDataObject);
-
-    // Can get a circular reference if the client calls GetData then calls SetData with the same StgMedium.
-    // Because the unkForRelease for the IDataObject can be marshalled it is necessary to get pointers that
-    // can be correctly compared. See the IDragSourceHelper article by Raymond Chen at MSDN.
-    if Assigned(LocalStgMedium.unkForRelease) then
-    begin
-      if CanonicalIUnknown(Self) = CanonicalIUnknown(IUnknown(LocalStgMedium.unkForRelease)) then
-        IUnknown(LocalStgMedium.unkForRelease) := nil; // release the interface
-    end;
-  end;
-
-  // Tell all registered advice sinks about the data change.
-  if Assigned(FAdviseHolder) then
-    FAdviseHolder.SendOnDataChange(Self as IDataObject, 0, 0);
-end;
-
-//----------------- TVTDragManager -------------------------------------------------------------------------------------
-
-constructor TVTDragManager.Create(AOwner: TBaseVirtualTree);
-
-begin
-  inherited Create;
-  FOwner := AOwner;
-
-  // Create an instance  of the drop target helper interface. This will fail but not harm on systems which do
-  // not support this interface (everything below Windows 2000);
-  CoCreateInstance(CLSID_DragDropHelper, nil, CLSCTX_INPROC_SERVER, IID_IDropTargetHelper, FDropTargetHelper);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TVTDragManager.Destroy;
-
-begin
-  // Set the owner's reference to us to nil otherwise it will access an invalid pointer
-  // after our desctruction is complete.  
-  Pointer(FOwner.FDragManager) := nil;
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragManager.GetDataObject: IDataObject;
-
-begin
-  // When the owner tree starts a drag operation then it gets a data object here to pass it to the OLE subsystem.
-  // In this case there is no local reference to a data object and one is created (but not stored).
-  // If there is a local reference then the owner tree is currently the drop target and the stored interface is
-  // that of the drag initiator. 
-  if Assigned(FDataObject) then
-    Result := FDataObject
-  else
-  begin
-    Result := FOwner.DoCreateDataObject;
-    if Result = nil then
-      Result := TVTDataObject.Create(FOwner, False) as IDataObject;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragManager.GetDragSource: TBaseVirtualTree;
-
-begin
-  Result := FDragSource;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragManager.GetDropTargetHelperSupported: Boolean;
-
-begin
-  Result := Assigned(FDropTargetHelper);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragManager.GetIsDropTarget: Boolean;
-
-begin
-  Result := FIsDropTarget;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragManager.DragEnter(const DataObject: IDataObject; KeyState: Integer; Pt: TPoint;
-  var Effect: Integer): HResult;
-
-begin
-  FDataObject := DataObject;
-  FIsDropTarget := True;
-
-  SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, @FFullDragging, 0);
-  // If full dragging of window contents is disabled in the system then our tree windows will be locked
-  // and cannot be updated during a drag operation. With the following call painting is again enabled.
-  if not FFullDragging then
-    LockWindowUpdate(0);
-  if Assigned(FDropTargetHelper) and FFullDragging then
-    FDropTargetHelper.DragEnter(FOwner.Handle, DataObject, Pt, Effect);
-
-  FDragSource := FOwner.GetTreeFromDataObject(DataObject);
-  Result := FOwner.DragEnter(KeyState, Pt, Effect);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragManager.DragLeave: HResult;
-
-begin
-  if Assigned(FDropTargetHelper) and FFullDragging then
-    FDropTargetHelper.DragLeave;
-
-  FOwner.DragLeave;
-  FIsDropTarget := False;
-  FDragSource := nil;
-  FDataObject := nil;
-  Result := NOERROR;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragManager.DragOver(KeyState: Integer; Pt: TPoint; var Effect: Integer): HResult;
-
-begin
-  if Assigned(FDropTargetHelper) and FFullDragging then
-    FDropTargetHelper.DragOver(Pt, Effect);
-
-  Result := FOwner.DragOver(FDragSource, KeyState, dsDragMove, Pt, Effect);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragManager.Drop(const DataObject: IDataObject; KeyState: Integer; Pt: TPoint;
-  var Effect: Integer): HResult;
-
-begin
-  if Assigned(FDropTargetHelper) and FFullDragging then
-    FDropTargetHelper.Drop(DataObject, Pt, Effect);
-
-  Result := FOwner.DragDrop(DataObject, KeyState, Pt, Effect);
-  FIsDropTarget := False;
-  FDataObject := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTDragManager.ForceDragLeave;
-
-// It has been reported that under some circumstances a drag image remains on screen. Unfortunately, nobody could
-// come up with a list of steps-to-reproduce. So we can only fix the result instead the cause.
-// This method calls the drop target helper's DragLeave method to ensure it removes the drag image from screen.
-
-begin
-  if Assigned(FDropTargetHelper) and FFullDragging then
-    FDropTargetHelper.DragLeave;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragManager.GiveFeedback(Effect: Integer): HResult;
-
-begin
-  Result := DRAGDROP_S_USEDEFAULTCURSORS;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragManager.QueryContinueDrag(EscapePressed: BOOL; KeyState: Integer): HResult;
-
-var
-  RButton,
-  LButton: Boolean;
-
-begin
-  LButton := (KeyState and MK_LBUTTON) &lt;&gt; 0;
-  RButton := (KeyState and MK_RBUTTON) &lt;&gt; 0;
-
-  // Drag'n drop canceled by pressing both mouse buttons or Esc?
-  if (LButton and RButton) or EscapePressed then
-    Result := DRAGDROP_S_CANCEL
-  else
-    // drag'n drop finished?
-    if not (LButton or RButton) then
-      Result := DRAGDROP_S_DROP
-    else
-      Result := S_OK;
-end;
-
-//----------------- TVirtualTreeHintWindow -----------------------------------------------------------------------------
-
-var
-  // This variable is necessary to coordinate the complex interaction between different hints in the application
-  // and animated hints in our own class. Under certain conditions it can happen that our hint window is destroyed
-  // while it is still in the animation loop.
-  HintWindowDestroyed: Boolean = True;
-  
-constructor TVirtualTreeHintWindow.Create(AOwner: TComponent);
-
-begin
-  inherited;
-  
-  FBackground := TBitmap.Create;
-  FBackground.PixelFormat := pf32Bit;
-  FDrawBuffer := TBitmap.Create;
-  FDrawBuffer.PixelFormat := pf32Bit;
-  FTarget := TBitmap.Create;
-  FTarget.PixelFormat := pf32Bit;
-
-  DoubleBuffered := False; // we do our own buffering
-  HintWindowDestroyed := False;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TVirtualTreeHintWindow.Destroy;
-
-begin
-  HintWindowDestroyed := True;
-
-  FTarget.Free;
-  FDrawBuffer.Free;
-  FBackground.Free;
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeHintWindow.AnimationCallback(Step, StepSize: Integer; Data: Pointer): Boolean;
-
-begin
-  Result := not HintWindowDestroyed and IsWindowVisible(Handle);
-  if Result then
-  begin
-    InternalPaint(Step, StepSize);
-    // We have to allow certain messages to be processed normally for various reasons.
-    // This introduces another problem however if this hint window is destroyed
-    // while it is still in the animation loop. A global variable keeps track of
-    // that case. This is reliable because we can only have one (internal) hint window.
-    Application.ProcessMessages;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeHintWindow.InternalPaint(Step, StepSize: Integer);
-
-  //--------------- local functions -------------------------------------------
-
-  procedure DoShadowBlend(DC: HDC; R: TRect; Alpha: Integer);
-
-  // Helper routine for shadow blending to shorten the parameter list in frequent calls.
-
-  begin
-    AlphaBlend(0, DC, R, Point(0, 0), bmConstantAlphaAndColor,  Alpha, clBlack);
-  end;
-
-  //---------------------------------------------------------------------------
-
-  procedure DrawHintShadow(Canvas: TCanvas; ShadowSize: Integer);
-
-  var
-    R: TRect;
-
-  begin
-    // Bottom shadow.
-    R := Rect(ShadowSize, Height - ShadowSize, Width, Height);
-    DoShadowBlend(Canvas.Handle, R, 5);
-    Inc(R.Left);
-    Dec(R.Right);
-    Dec(R.Bottom);
-    DoShadowBlend(Canvas.Handle, R, 10);
-    Inc(R.Left);
-    Dec(R.Right);
-    Dec(R.Bottom);
-    DoShadowBlend(Canvas.Handle, R, 20);
-    Inc(R.Left);
-    Dec(R.Right);
-    Dec(R.Bottom);
-    DoShadowBlend(Canvas.Handle, R, 35);
-    Inc(R.Left);
-    Dec(R.Right);
-    Dec(R.Bottom);
-    DoShadowBlend(Canvas.Handle, R, 50);
-    // Right shadow.
-    R := Rect(Width - ShadowSize, ShadowSize, Width, Height - ShadowSize);
-    DoShadowBlend(Canvas.Handle, R, 5);
-    Inc(R.Top);
-    Dec(R.Right);
-    DoShadowBlend(Canvas.Handle, R, 10);
-    Inc(R.Top);
-    Dec(R.Right);
-    DoShadowBlend(Canvas.Handle, R, 20);
-    Inc(R.Top);
-    Dec(R.Right);
-    DoShadowBlend(Canvas.Handle, R, 35);
-    Inc(R.Top);
-    Dec(R.Right);
-    DoShadowBlend(Canvas.Handle, R, 50);
-  end;
-
-  //--------------- end local functions ---------------------------------------
-
-var
-  R: TRect;
-  Y: Integer;
-  S: WideString;
-  DrawFormat: Cardinal;
-  Shadow: Integer;
-
-begin
-  {$ifndef COMPILER_7_UP}
-    if MMXAvailable then
-      Shadow := ShadowSize
-    else
-  {$endif COMPILER_7_UP}
-    Shadow := 0;
-
-  with FHintData, FDrawBuffer do
-  begin
-    // Do actual painting only in the very first run.
-    if Step = 0 then
-    begin
-      // If the given node is nil then we have to display a header hint.
-      if (Node = nil) or (Tree.FHintMode &lt;&gt; hmToolTip) then
-      begin
-        {$ifndef COMPILER_5_UP}
-          Canvas.Font := HintFont;
-        {$else}
-          Canvas.Font := Screen.HintFont;
-        {$endif COMPILER_5_UP}
-        Y := 2;
-      end
-      else
-      begin
-        Tree.GetTextInfo(Node, Column, Canvas.Font, R, S);
-        if vsMultiline in Node.States then
-          Y := Tree.TextMargin + 1
-        else
-          Y := (R.Top - R.Bottom - Shadow + Self.Height) div 2;
-      end;
-
-      with ClientRect do
-        R := Rect(0, 0, Width - Shadow, Height - Shadow);
-
-      if (Tree is TCustomVirtualDrawTree) and Assigned(Node) then
-      begin
-        // The draw tree has by default no hint text so let it draw the hint itself.
-        (Tree as TCustomVirtualDrawTree).DoDrawHint(Canvas, Node, R, Column);
-      end
-      else
-        with Canvas do
-        begin
-          // Still force tooltip back and text color.
-          Font.Color := clInfoText;
-          Pen.Color := clBlack;
-          Brush.Color := clInfoBk;
-          {$ifdef COMPILER_5_UP}
-            Rectangle(R);
-          {$else}
-            with R do
-              Rectangle(Left, Top, Right, Bottom);
-          {$endif COMPILER_5_UP}
-
-          // Determine text position and don't forget the border.
-          InflateRect(R, -Tree.FTextMargin - 1, -1);
-          DrawFormat := DT_TOP or DT_NOPREFIX;
-          if BidiMode &lt;&gt; bdLeftToRight then
-          begin
-            DrawFormat := DrawFormat or DT_RIGHT or DT_RTLREADING;
-            Inc(R.Right);
-          end
-          else
-            DrawFormat := DrawFormat or DT_LEFT;
-          SetBkMode(Handle, Windows.TRANSPARENT);
-          R.Top := Y;
-          if Assigned(Node) and (vsMultiline in Node.States) then
-            DrawFormat := DrawFormat or DT_WORDBREAK;
-          if IsWinNT then
-            Windows.DrawTextW(Handle, PWideChar(HintText), Length(HintText), R, DrawFormat)
-          else
-            DrawTextW(Handle, PWideChar(HintText), Length(HintText), R, DrawFormat, False);
-        end;
-    end;
-  end;
-
-  if StepSize &gt; 0 then
-  begin
-    if FHintData.Tree.DoGetAnimationType = hatFade then
-    begin
-      with FTarget do
-        BitBlt(Canvas.Handle, 0, 0, Width, Height, FBackground.Canvas.Handle, 0, 0, SRCCOPY);
-      // Main image.
-      AlphaBlend(FDrawBuffer.Canvas.Handle, FTarget.Canvas.Handle, Rect(0, 0, Width - Shadow, Height - Shadow),
-        Point(0, 0), bmConstantAlpha,  MulDiv(Step, 256, FadeAnimationStepCount), 0);
-
-      if Shadow &gt; 0 then
-        DrawHintShadow(FTarget.Canvas, Shadow);
-      BitBlt(Canvas.Handle, 0, 0, Width, Height, FTarget.Canvas.Handle, 0, 0, SRCCOPY);
-    end
-    else
-    begin
-      // Slide is done by blitting &quot;step&quot; lines of the lower part of the hint window
-      // and fill the rest with the screen background.
-
-      // 1) blit hint bitmap to the hint canvas
-      BitBlt(Canvas.Handle, 0, 0, Width - Shadow, Step, FDrawBuffer.Canvas.Handle, 0, Height - Step, SRCCOPY);
-      // 2) blit background rest to hint canvas
-      if Step &lt;= Shadow then
-        Step := 0
-      else
-        Dec(Step, Shadow);
-      BitBlt(Canvas.Handle, 0, Step, Width, Height - Step, FBackground.Canvas.Handle, 0, Step, SRCCOPY);
-    end;
-  end
-  else
-    // Last step during slide or the only step without animation.
-    if FHintData.Tree.DoGetAnimationType &lt;&gt; hatFade then
-    begin
-      if Shadow &gt; 0 then
-      begin
-        with FBackground do
-          BitBlt(Canvas.Handle, 0, 0, Width - Shadow, Height - Shadow, FDrawBuffer.Canvas.Handle, 0, 0, SRCCOPY);
-
-        DrawHintShadow(FBackground.Canvas, Shadow);
-        BitBlt(Canvas.Handle, 0, 0, Width, Height, FBackground.Canvas.Handle, 0, 0, SRCCOPY);
-      end
-      else
-        BitBlt(Canvas.Handle, 0, 0, Width, Height, FDrawBuffer.Canvas.Handle, 0, 0, SRCCOPY);
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeHintWindow.CMTextChanged(var Message: TMessage);
-
-begin
-  // swallow this message to prevent the ancestor from resizing the window (we don't use the caption anyway)
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeHintWindow.WMEraseBkgnd(var Message: TWMEraseBkgnd);
-
-// The control is fully painted by own code so don't erase its background as this causes flickering.
-
-begin
-  Message.Result := 1;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeHintWindow.WMNCPaint(var Message: TMessage);
-
-// The control is fully painted by own code so don't paint any borders.
-
-begin
-  Message.Result := 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeHintWindow.WMShowWindow(var Message: TWMShowWindow);
-
-// Clear hint data when the window becomes hidden.
-
-begin
-  if not Message.Show then
-  begin
-    Finalize(FHintData);
-    FillChar(FHintData, SizeOf(FHintData), 0);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeHintWindow.CreateParams(var Params: TCreateParams);
-
-begin
-  inherited CreateParams(Params);
-  
-  with Params do
-  begin
-    Style := WS_POPUP;
-    ExStyle := ExStyle and not WS_EX_CLIENTEDGE;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeHintWindow.Paint;
-
-begin
-  InternalPaint(0, 0);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeHintWindow.ActivateHint(Rect: TRect; const AHint: string);
-
-var
-  DC: HDC;
-
-begin
-  // Do not allow to enter the animation loop recursively.
-  if (tsInAnimation in FHintData.Tree.FStates) or IsRectEmpty(Rect) then
-    Application.CancelHint
-  else
-  begin
-    SetWindowPos(Handle, 0, Rect.Left, Rect.Top, Width, Height, SWP_HIDEWINDOW or SWP_NOACTIVATE or SWP_NOZORDER);
-    UpdateBoundsRect(Rect);
-
-    if Rect.Top + Height &gt; Screen.DesktopHeight then
-      Rect.Top := Screen.DesktopHeight - Height;
-    if Rect.Top &lt; Screen.DesktopTop then
-      Rect.Top := Screen.DesktopTop;
-    if Rect.Left + Width &gt; Screen.DesktopWidth then
-      Rect.Left := Screen.DesktopWidth - Width;
-    if Rect.Left &lt; Screen.DesktopLeft then
-      Rect.Left := Screen.DesktopLeft;
-
-    // adjust sizes of bitmaps
-    FDrawBuffer.Width := Width;
-    FDrawBuffer.Height := Height;
-    FBackground.Width := Width;
-    FBackground.Height := Height;
-    FTarget.Width := Width;
-    FTarget.Height := Height;
-
-    FHintData.Tree.Update;
-
-    // capture screen
-    DC := GetDC(0);
-    try
-      with Rect do
-        BitBlt(FBackground.Canvas.Handle, 0, 0, Width, Height, DC, Left, Top, SRCCOPY);
-    finally
-      ReleaseDC(0, DC);
-    end;
-                          
-    SetWindowPos(Handle, HWND_TOPMOST, Rect.Left, Rect.Top, Width, Height, SWP_SHOWWINDOW or SWP_NOACTIVATE);
-    with FHintData.Tree do
-      case DoGetAnimationType of
-        hatNone:
-          InvalidateRect(Self.Handle, nil, False);
-        hatFade:
-          begin
-            // Make sure the window is not drawn unanimated.
-            ValidateRect(Self.Handle, nil);
-            // Empirically determined animation duration shows that fading needs about twice as much time as
-            // sliding to show a comparable visual effect.
-            Animate(FadeAnimationStepCount, 2 * FAnimationDuration, AnimationCallback, nil);
-          end;
-        hatSlide:
-          begin
-            // Make sure the window is not drawn unanimated.
-            ValidateRect(Self.Handle, nil);
-            Animate(Self.Height, FAnimationDuration, AnimationCallback, nil);
-          end;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeHintWindow.CalcHintRect(MaxWidth: Integer; const AHint: string; AData: Pointer): TRect;
-
-var
-  TM: TTextMetric;
-  R: TRect;
-  
-begin
-  // The hint window does not need any bidi mode setting but the caller of this method (TApplication.ActivateHint)
-  // does some unneccessary actions if the hint window is not left-to-right.
-  // The text alignment is based on the bidi mode passed in the hint data, hence we can
-  // simply set the window's mode to left-to-right (it might have been modified by the caller, if the
-  // tree window is right-to-left aligned).
-  BidiMode := bdLeftToRight;
-
-  FHintData := PVTHintData(AData)^;
-
-  with FHintData do
-  begin
-    // The draw tree gets its hint size by the application (but only if not a header hint is about to show).
-    // This size has already been determined in CMHintShow.
-    if (Tree is TCustomVirtualDrawTree) and Assigned(Node) then
-      Result := HintRect 
-    else
-    begin
-      if Column &lt;= NoColumn then
-      begin
-        BidiMode := Tree.BidiMode;
-        Alignment := Tree.Alignment;
-      end
-      else
-      begin
-        BidiMode := Tree.Header.Columns[Column].BidiMode;
-        Alignment := Tree.Header.Columns[Column].Alignment;
-      end;
-
-      if BidiMode &lt;&gt; bdLeftToRight then
-        ChangeBidiModeAlignment(Alignment);
-
-      if (Node = nil) or (Tree.FHintMode &lt;&gt; hmToolTip) then
-      begin
-        {$ifndef COMPILER_5_UP}
-          Canvas.Font := HintFont
-        {$else}
-          Canvas.Font := Screen.HintFont
-        {$endif COMPILER_5_UP}
-      end
-      else
-      begin
-        Canvas.Font := Tree.Font;
-        if Tree is TCustomVirtualStringTree then
-          with TCustomVirtualStringTree(Tree) do
-            DoPaintText(Node, Self.Canvas, Column, ttNormal);
-      end;
-
-      GetTextMetrics(Canvas.Handle, TM);
-      FTextHeight := TM.tmHeight;
-
-      if Length(DefaultHint) &gt; 0 then
-        HintText := DefaultHint
-      else
-        if Tree.HintMode = hmToolTip then
-          HintText := Tree.DoGetNodeToolTip(Node, Column)
-        else
-          HintText := Tree.DoGetNodeHint(Node, Column);
-
-      if Length(HintText) = 0 then
-        Result := Rect(0, 0, 0, 0)
-      else
-      begin
-        if Assigned(Node) and (Tree.FHintMode = hmToolTip) then
-        begin
-          // Hint for a node.
-          if vsMultiline in Node.States then
-          begin
-            // Multiline tooltips use the columns width but extend the bottom border to fit the whole caption.
-            Result := Tree.GetDisplayRect(Node, Column, True, False);
-            // On Windows NT the behavior of the tooltip is slightly different to that on Windows 9x/Me.
-            // We don't have Unicode word wrap on the latter so the tooltip gets as wide as the largest line
-            // in the caption (limited by carriage return), which results in unoptimal overlay of the tooltip.
-            // On Windows NT the tooltip exactly overlays the node text.
-            if IsWinNT then
-            begin
-              // DT_CALCRECT sometimes also modifies the right border. But we are only interested in the bottom border.
-              R := Result;
-              Windows.DrawTextW(Canvas.Handle, PWideChar(HintText), Length(HintText), R, DT_CALCRECT or DT_WORDBREAK);
-              Result.Bottom := R.Bottom;
-            end
-            else
-              DrawTextW(Canvas.Handle, PWideChar(HintText), Length(HintText), Result, DT_CALCRECT, True);
-
-            // Adjust for text margin.
-            InflateRect(Result, 0, Tree.TextMargin);
-            Inc(Result.Right);
-            // If the node height is already large enough to cover the entire text, then we don't need the hint, though.
-            // However if the text is partially scrolled out of the client area then a hint is useful as well.
-            if ((Node.NodeHeight + 2) &gt;= (Result.Bottom - Result.Top)) and not
-              ((Result.Left &lt; 0) or (Result.Right &gt; Tree.ClientWidth) or
-               (Result.Top &lt; 0) or (Result.Bottom &gt; Tree.ClientHeight)) then
-            begin
-              Result := Rect(0, 0, 0, 0);
-              Exit;
-            end;
-          end
-          else
-          begin
-            Result := Tree.GetDisplayRect(Node, Column, True, True);
-            if toShowHorzGridLines in Tree.TreeOptions.PaintOptions then
-              Dec(Result.Bottom);
-          end;
-          // Include a one pixel border.
-          InflateRect(Result, 1, 1);
-          // Make the coordinates relative. They will again be offset by the caller code.
-          OffsetRect(Result, -Result.Left - 1, -Result.Top - 1);
-        end
-        else
-        begin
-          // Hint for a header.
-          // Start with the base size of the hint in client coordinates.
-          Result := Rect(0, 0, MaxWidth, FTextHeight);
-          // Calculate the true size of the text rectangle.
-          DrawTextW(Canvas.Handle, PWideChar(HintText), Length(HintText), Result, DT_CALCRECT, True);
-          // The height of the text plus 2 pixels vertical margin plus the border determine the hint window height.
-          Inc(Result.Bottom, 6);
-          // The text is centered horizontally with usual text margin for left and right borders (plus border).
-          Inc(Result.Right, 2 * Tree.FTextMargin + 2);
-        end;
-
-        {$ifndef COMPILER_7_UP}
-          // Add some pixels for the shadow if MMX is available for blending.
-          if MMXAvailable then
-          begin
-            Inc(Result.Right, ShadowSize);
-            Inc(Result.Bottom, ShadowSize);
-          end;
-        {$endif COMPILER_7_UP}
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeHintWindow.IsHintMsg(var Msg: TMsg): Boolean;
-
-// The VCL is a bit too generous when telling that an existing hint can be cancelled. Need to specify further here.
-
-begin
-  Result := inherited IsHintMsg(Msg) and HandleAllocated and IsWindowVisible(Handle);
-  if Result and (Msg.Message = WM_NCMOUSEMOVE) then
-    Result := False
-  else
-    // Work around problems with keypresses while doing hint animation.
-    if HandleAllocated and IsWindowVisible(Handle) and (Msg.Message &gt;= WM_KEYFIRST) and (Msg.Message &lt;= WM_KEYLAST) and
-      (tsInAnimation in FHintData.Tree.FStates) and TranslateMessage(Msg) then
-      DispatchMessage(Msg);
-end;
-
-//----------------- TVTDragImage ---------------------------------------------------------------------------------------
-
-constructor TVTDragImage.Create(AOwner: TBaseVirtualTree);
-
-begin
-  FOwner := AOwner;
-  FTransparency := 128;
-  FPreBlendBias := 0;
-  FPostBlendBias := 0;
-  FFade := False;
-  FRestriction := dmrNone;
-  FColorKey := clNone;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TVTDragImage.Destroy;
-
-begin
-  EndDrag;
-  
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragImage.GetVisible: Boolean;
-
-// Returns True if the internal drag image is used (i.e. the system does not natively support drag images) and
-// the internal image is currently visible on screen.
-
-begin
-  Result := FStates * [disHidden, disInDrag, disPrepared, disSystemSupport] = [disInDrag, disPrepared];
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTDragImage.InternalShowDragImage(ScreenDC: HDC);
-
-// Frequently called helper routine to actually do the blend and put it onto the screen.
-// Only used if the system does not support drag images.
-
-var
-  BlendMode: TBlendMode;
-
-begin
-  with FAlphaImage do
-    BitBlt(Canvas.Handle, 0, 0, Width, Height, FBackImage.Canvas.Handle, 0, 0, SRCCOPY);
-  if not FFade and (FColorKey = clNone) then
-    BlendMode := bmConstantAlpha
-  else
-    BlendMode := bmMasterAlpha;
-  with FDragImage do
-    AlphaBlend(Canvas.Handle, FAlphaImage.Canvas.Handle, Rect(0, 0, Width, Height), Point(0, 0), BlendMode,
-      FTransparency, FPostBlendBias);
-
-  with FAlphaImage do
-    BitBlt(ScreenDC, FImagePosition.X, FImagePosition.Y, Width, Height, Canvas.Handle, 0, 0, SRCCOPY);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTDragImage.MakeAlphaChannel(Source, Target: TBitmap);
-
-// Helper method to create a proper alpha channel in Target (which must be in 32 bit pixel format), depending
-// on the settings for the drag image and the color values in Source.
-// Only used if the system does not support drag images.
-
-type
-  PBGRA = ^TBGRA;
-  TBGRA = packed record
-    case Boolean of
-      False:
-        (Color: Cardinal);
-      True:
-        (BGR: array[0..2] of Byte;
-         Alpha: Byte);
-  end;
-
-var
-  Color,
-  ColorKeyRef: COLORREF;
-  UseColorKey: Boolean;
-  SourceRun,
-  TargetRun: PBGRA;
-  X, Y,
-  MaxDimension,
-  HalfWidth,
-  HalfHeight: Integer;
-  T: Extended;
-
-begin
-  UseColorKey := ColorKey &lt;&gt; clNone;
-  ColorKeyRef := ColorToRGB(ColorKey) and $FFFFFF;
-  // Color values are in the form BGR (red on LSB) while bitmap colors are in the form ARGB (blue on LSB)
-  // hence we have to swap red and blue in the color key.
-  with TBGRA(ColorKeyRef) do
-  begin
-    X := BGR[0];
-    BGR[0] := BGR[2];
-    BGR[2] := X;
-  end;
-
-  with Target do
-  begin
-    MaxDimension := Max(Width, Height);
-
-    HalfWidth := Width div 2;
-    HalfHeight := Height div 2;
-    for Y := 0 to Height - 1 do
-    begin
-      TargetRun := Scanline[Y];
-      SourceRun := Source.Scanline[Y];
-      for X := 0 to Width - 1 do
-      begin
-        Color := SourceRun.Color and $FFFFFF;
-        if UseColorKey and (Color = ColorKeyRef) then
-          TargetRun.Alpha := 0
-        else
-        begin
-          // If the color is not the given color key (or none is used) then do full calculation of a bell curve.
-          T := exp(-8 * Sqrt(Sqr((X - HalfWidth) / MaxDimension) + Sqr((Y - HalfHeight) / MaxDimension)));
-          TargetRun.Alpha := Round(255 * T);
-        end;
-        Inc(SourceRun);
-        Inc(TargetRun);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragImage.DragTo(P: TPoint; ForceRepaint: Boolean): Boolean;
-
-// Moves the drag image to a new position, which is determined from the passed point P and the previous
-// mouse position.
-// ForceRepaint is True if something on the screen changed and the back image must be refreshed.
-
-var
-  ScreenDC: HDC;
-  DeltaX,
-  DeltaY: Integer;
-  
-  // optimized drag image move support
-  RSamp1,
-  RSamp2,       // newly added parts from screen which will be overwritten
-  RDraw1,
-  RDraw2,       // parts to be restored to screen
-  RScroll,
-  RClip: TRect; // ScrollDC of the existent background
-
-begin 
-  // Determine distances to move the drag image. Take care for restrictions.
-  case FRestriction of
-    dmrHorizontalOnly:
-      begin
-        DeltaX := FLastPosition.X - P.X;
-        DeltaY := 0;
-      end;
-    dmrVerticalOnly:
-      begin
-        DeltaX := 0;
-        DeltaY := FLastPosition.Y - P.Y;
-      end;
-  else // dmrNone
-    DeltaX := FLastPosition.X - P.X;
-    DeltaY := FLastPosition.Y - P.Y;
-  end;
-
-  Result := (DeltaX &lt;&gt; 0) or (DeltaY &lt;&gt; 0) or ForceRepaint;
-  if Result then
-  begin
-    if Visible then
-    begin
-      // All this stuff is only called if we have to handle the drag image ourselves. If the system supports
-      // drag image then this is all never executed. 
-      ScreenDC := GetDC(0);
-      try
-        if (Abs(DeltaX) &gt;= FDragImage.Width) or (Abs(DeltaY) &gt;= FDragImage.Height) or ForceRepaint then
-        begin
-          // If moved more than image size then just restore old screen and blit image to new position.
-          BitBlt(ScreenDC, FImagePosition.X, FImagePosition.Y, FBackImage.Width, FBackImage.Height,
-            FBackImage.Canvas.Handle, 0, 0, SRCCOPY);
-
-          if ForceRepaint then
-            UpdateWindow(FOwner.Handle);
-      
-          Inc(FImagePosition.X, -DeltaX);
-          Inc(FImagePosition.Y, -DeltaY);
-
-          BitBlt(FBackImage.Canvas.Handle, 0, 0, FBackImage.Width, FBackImage.Height, ScreenDC, FImagePosition.X,
-            FImagePosition.Y, SRCCOPY);
-        end
-        else
-        begin
-          // overlapping copy
-          FillDragRectangles(FDragImage.Width, FDragImage.Height, DeltaX, DeltaY, RClip, RScroll, RSamp1, RSamp2, RDraw1,
-            RDraw2);
-
-          with FBackImage.Canvas do
-          begin
-            // restore uncovered areas of the screen
-            if DeltaX = 0 then
-            begin
-              with RDraw2 do
-                BitBlt(ScreenDC, FImagePosition.X + Left, FImagePosition.Y + Top, Right, Bottom, Handle, Left, Top,
-                  SRCCOPY);
-            end
-            else
-            begin
-              if DeltaY = 0 then
-              begin
-                with RDraw1 do
-                  BitBlt(ScreenDC, FImagePosition.X + Left, FImagePosition.Y + Top, Right, Bottom, Handle, Left, Top,
-                    SRCCOPY);
-              end
-              else
-              begin
-                with RDraw1 do
-                  BitBlt(ScreenDC, FImagePosition.X + Left, FImagePosition.Y + Top, Right, Bottom, Handle, Left, Top,
-                    SRCCOPY);
-                with RDraw2 do
-                  BitBlt(ScreenDC, FImagePosition.X + Left, FImagePosition.Y + Top, Right, Bottom, Handle, Left, Top,
-                    SRCCOPY);
-              end;
-            end;
-
-            // move existent background
-            ScrollDC(Handle, DeltaX, DeltaY, RScroll, RClip, 0, nil);
-
-            Inc(FImagePosition.X, -DeltaX);
-            Inc(FImagePosition.Y, -DeltaY);
-
-            // Get first and second additional rectangle from screen.
-            if DeltaX = 0 then
-            begin
-              with RSamp2 do
-                BitBlt(Handle, Left, Top, Right, Bottom, ScreenDC, FImagePosition.X + Left, FImagePosition.Y + Top,
-                  SRCCOPY);
-            end
-            else
-              if DeltaY = 0 then
-              begin
-                with RSamp1 do
-                  BitBlt(Handle, Left, Top, Right, Bottom, ScreenDC, FImagePosition.X + Left, FImagePosition.Y + Top,
-                    SRCCOPY);
-              end
-              else
-              begin
-                with RSamp1 do
-                  BitBlt(Handle, Left, Top, Right, Bottom, ScreenDC, FImagePosition.X + Left, FImagePosition.Y + Top,
-                    SRCCOPY);
-                with RSamp2 do
-                  BitBlt(Handle, Left, Top, Right, Bottom, ScreenDC, FImagePosition.X + Left, FImagePosition.Y + Top,
-                    SRCCOPY);
-              end;
-          end;
-        end;
-        InternalShowDragImage(ScreenDC);
-      finally
-        ReleaseDC(0, ScreenDC);
-      end;
-    end;
-    FLastPosition.X := P.X;
-    FLastPosition.Y := P.Y;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTDragImage.EndDrag;
-
-begin
-  HideDragImage;
-  FStates := FStates - [disInDrag, disPrepared];
-  
-  FBackImage.Free;
-  FBackImage := nil;
-  FDragImage.Free;
-  FDragImage := nil;
-  FAlphaImage.Free;
-  FAlphaImage := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragImage.GetDragImageRect: TRect;
-
-// Returns the current size and position of the drag image (screen coordinates).
-
-begin
-  if Visible then
-  begin
-    with FBackImage do
-      Result := Rect(FImagePosition.X, FImagePosition.Y, FImagePosition.X + Width, FImagePosition.Y + Height);
-  end
-  else
-    Result := Rect(0, 0, 0, 0);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTDragImage.HideDragImage;
-
-var
-  ScreenDC: HDC;
-
-begin
-  if Visible then
-  begin
-    Include(FStates, disHidden);
-    ScreenDC := GetDC(0);
-    try
-      // restore screen
-      with FBackImage do
-        BitBlt(ScreenDC, FImagePosition.X, FImagePosition.Y, Width, Height, Canvas.Handle, 0, 0, SRCCOPY);
-    finally
-      ReleaseDC(0, ScreenDC);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTDragImage.PrepareDrag(DragImage: TBitmap; ImagePosition, HotSpot: TPoint; const DataObject: IDataObject);
-
-// Creates all necessary structures to do alpha blended dragging using the given image.
-// ImagePostion and Hotspot are given in screen coordinates. The first determines where to place the drag image while
-// the second is the initial mouse position.
-// This method also determines whether the system supports drag images natively. If so then only minimal structures
-// are created.
-
-var
-  Width,
-  Height: Integer;
-  DragSourceHelper: IDragSourceHelper;
-  DragInfo: TSHDragImage;
-
-begin
-  Width := DragImage.Width;
-  Height := DragImage.Height;
-
-  // Determine whether the system supports the drag helper interfaces.
-  if Assigned(DataObject) and Succeeded(CoCreateInstance(CLSID_DragDropHelper, nil, CLSCTX_INPROC_SERVER,
-    IID_IDragSourceHelper, DragSourceHelper)) then
-  begin
-    Include(FStates, disSystemSupport);
-    
-    // Supply the drag source helper with our drag image.
-    DragInfo.sizeDragImage.cx := Width;
-    DragInfo.sizeDragImage.cy := Height;
-    DragInfo.ptOffset.x := Width div 2;
-    DragInfo.ptOffset.y := Height div 2;
-    DragInfo.hbmpDragImage := CopyImage(DragImage.Handle, IMAGE_BITMAP, Width, Height, LR_COPYRETURNORG);
-    DragInfo.ColorRef := ColorToRGB(FColorKey);
-    if not Succeeded(DragSourceHelper.InitializeFromBitmap(DragInfo, DataObject)) then
-    begin
-      DeleteObject(DragInfo.hbmpDragImage);
-      Exclude(FStates, disSystemSupport);
-    end;
-  end
-  else
-    Exclude(FStates, disSystemSupport);
-
-  if MMXAvailable and not (disSystemSupport in FStates) then
-  begin
-    FLastPosition := HotSpot;
-
-    FDragImage := TBitmap.Create;
-    FDragImage.PixelFormat := pf32Bit;
-    FDragImage.Width := Width;
-    FDragImage.Height := Height;
-
-    FAlphaImage := TBitmap.Create;
-    FAlphaImage.PixelFormat := pf32Bit;
-    FAlphaImage.Width := Width;
-    FAlphaImage.Height := Height;
-
-    FBackImage := TBitmap.Create;
-    FBackImage.PixelFormat := pf32Bit;
-    FBackImage.Width := Width;
-    FBackImage.Height := Height;
-
-    // Copy the given drag image and apply pre blend bias if required.
-    if FPreBlendBias = 0 then
-      with FDragImage do
-        BitBlt(Canvas.Handle, 0, 0, Width, Height, DragImage.Canvas.Handle, 0, 0, SRCCOPY)
-    else
-      AlphaBlend(DragImage.Canvas.Handle, FDragImage.Canvas.Handle, Rect(0, 0, Width, Height), Point(0, 0),
-        bmConstantAlpha, 255, FPreBlendBias);
-
-    // Create a proper alpha channel also if no fading is required (transparent parts).
-    MakeAlphaChannel(DragImage, FDragImage);
-
-    FImagePosition := ImagePosition;
-
-    // Initially the drag image is hidden and will be shown during the immediately following DragEnter event.
-    FStates := FStates + [disInDrag, disHidden, disPrepared];
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTDragImage.RecaptureBackground(Tree: TBaseVirtualTree; R: TRect; VisibleRegion: HRGN;
-  CaptureNCArea, ReshowDragImage: Boolean);
-
-// Notification by the drop target tree to update the background image because something in the tree has changed.
-// Note: The passed rectangle is given in client coordinates of the current drop target tree (given in Tree).
-//       The caller does not check if the given rectangle is actually within the drag image. Hence this method must do
-//       all the checks.
-// This method does nothing if the system manages the drag image.
-
-var
-  DragRect,
-  ClipRect: TRect;
-  PaintTarget: TPoint;
-  PaintOptions: TVTInternalPaintOptions;
-  ScreenDC: HDC;
-
-begin
-  // Recapturing means we want the tree to paint the new part into our back bitmap instead to the screen.
-  if Visible then
-  begin
-    // Create the minimum rectangle to be recaptured.
-    MapWindowPoints(Tree.Handle, 0, R, 2);
-    DragRect := GetDragImageRect;
-    IntersectRect(R, R, DragRect);
-
-    OffsetRgn(VisibleRegion, -DragRect.Left, -DragRect.Top);
-
-    // The target position for painting in the drag image is relative and can be determined from screen coordinates too.
-    PaintTarget.X := R.Left - DragRect.Left;
-    PaintTarget.Y := R.Top - DragRect.Top;
-
-    // The source rectangle is determined by the offsets in the tree.
-    MapWindowPoints(0, Tree.Handle, R, 2);
-    OffsetRect(R, -Tree.FOffsetX, -Tree.FOffsetY);
-
-    // Finally let the tree paint the relevant part and upate the drag image on screen.
-    PaintOptions := [poBackground, poColumnColor, poDrawFocusRect, poDrawDropMark, poDrawSelection, poGridLines];
-    with FBackImage do
-    begin
-      ClipRect.TopLeft := PaintTarget;
-      ClipRect.Right := ClipRect.Left + R.Right - R.Left;
-      ClipRect.Bottom := ClipRect.Top + R.Bottom - R.Top;
-      Tree.LimitPaintingToArea(Canvas, ClipRect, VisibleRegion);
-      Tree.PaintTree(Canvas, R, PaintTarget, PaintOptions);
-
-      if CaptureNCArea then
-      begin
-        // For the non-client area we only need the visible region of the window as limit for painting.
-        SelectClipRgn(Canvas.Handle, VisibleRegion);
-        // Since WM_PRINT cannot be given a position where to draw we simply move the window origin and
-        // get the same effect.
-        GetWindowRect(Tree.Handle, ClipRect);
-        SetWindowOrgEx(Canvas.Handle, DragRect.Left - ClipRect.Left, DragRect.Top - ClipRect.Top, nil);
-        Tree.Perform(WM_PRINT, Integer(Canvas.Handle), PRF_NONCLIENT);
-        SetWindowOrgEx(Canvas.Handle, 0, 0, nil);
-      end;
-      SelectClipRgn(Canvas.Handle, 0);
-      
-      if ReshowDragImage then
-      begin
-        GDIFlush;
-        ScreenDC := GetDC(0);
-        try
-          InternalShowDragImage(ScreenDC);
-        finally
-          ReleaseDC(0, ScreenDC);
-        end;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTDragImage.ShowDragImage;
-
-// Shows the drag image after it has been hidden by HideDragImage.
-// Note: there might be a new background now.
-// Also this method does nothing if the system manages the drag image.
-
-var
-  ScreenDC: HDC;
-
-begin
-  if FStates * [disInDrag, disHidden, disPrepared, disSystemSupport] = [disInDrag, disHidden, disPrepared] then
-  begin
-    Exclude(FStates, disHidden);
-
-    GDIFlush;
-    ScreenDC := GetDC(0);
-    try
-      BitBlt(FBackImage.Canvas.Handle, 0, 0, FBackImage.Width, FBackImage.Height, ScreenDC, FImagePosition.X,
-        FImagePosition.Y, SRCCOPY);
-
-      InternalShowDragImage(ScreenDC);
-    finally
-      ReleaseDC(0, ScreenDC);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTDragImage.WillMove(P: TPoint): Boolean;
-
-// This method determines whether the drag image would &quot;physically&quot; move when DragTo would be called with the same
-// target point.
-// Always returns False if the system drag image support is available.
- 
-var
-  DeltaX,
-  DeltaY: Integer;
-
-begin
-  Result := Visible;
-  if Result then
-  begin
-    // Determine distances to move the drag image. Take care for restrictions.
-    case FRestriction of
-      dmrHorizontalOnly:
-        begin
-          DeltaX := FLastPosition.X - P.X;
-          DeltaY := 0;
-        end;
-      dmrVerticalOnly:
-        begin
-          DeltaX := 0;
-          DeltaY := FLastPosition.Y - P.Y;
-        end;
-    else // dmrNone
-      DeltaX := FLastPosition.X - P.X;
-      DeltaY := FLastPosition.Y - P.Y;
-    end;
-
-    Result := (DeltaX &lt;&gt; 0) or (DeltaY &lt;&gt; 0);
-  end;
-end;
-
-//----------------- TVirtualTreeColumn ---------------------------------------------------------------------------------
-
-constructor TVirtualTreeColumn.Create(Collection: TCollection);
-
-begin
-  FWidth := 50;
-  FLastWidth := 50;
-  FMinWidth := 10;
-  FMaxWidth := 10000;
-  FImageIndex := -1;
-  FMargin := 4;
-  FSpacing := 4;
-  FText := '';
-  FOptions := DefaultColumnOptions;
-  FAlignment := taLeftJustify;
-  FBidiMode := bdLeftToRight;
-  FColor := clWindow;
-  FLayout := blGlyphLeft;
-
-  inherited Create(Collection);
-
-  FPosition := Owner.Count - 1;
-  // Read parent bidi mode and color values as default values.
-  ParentBiDiModeChanged;
-  ParentColorChanged;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TVirtualTreeColumn.Destroy;
-
-var
-  I: Integer;
-  
-begin
-  // Check if this column is somehow referenced by its collection parent or the header.
-  with Owner do
-  begin
-    // If the columns collection object is currently deleting all columns
-    // then we don't need to check the various cached indices individually.
-    if not FClearing then
-    begin
-      IndexChanged(Index, -1);
-      
-      if Index = FHoverIndex then
-        FHoverIndex := NoColumn;
-      if Index = FDownIndex then
-        FDownIndex := NoColumn;
-      if Index = FTrackIndex then
-        FTrackIndex := NoColumn;
-      if Index = FClickIndex then
-        FClickIndex := NoColumn;
-
-      with Header do
-      begin
-        if Index = FAutoSizeIndex then
-          FAutoSizeIndex := NoColumn;
-        if Index = FMainColumn then
-        begin
-          // If the current main column is about to be destroyed then we have to find a new main column.
-          FMainColumn := NoColumn;
-          for I := 0 to Count - 1 do
-            if I &lt;&gt; Index then
-            begin
-              FMainColumn := I;
-              Break;
-            end;
-        end;
-        if Index = FSortColumn then
-          FSortColumn := NoColumn;
-      end;
-    end;
-  end;
-
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumn.GetLeft: Integer;
-
-begin
-  Result := FLeft + Owner.Header.Treeview.FOffsetX;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumn.IsBiDiModeStored: Boolean;
-
-begin
-  Result := not (coParentBiDiMode in FOptions);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumn.IsColorStored: Boolean;
-
-begin
-  Result := not (coParentColor in FOptions);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetAlignment(const Value: TAlignment);
-
-begin
-  if FAlignment &lt;&gt; Value then
-  begin
-    FAlignment := Value;
-    Changed(False);
-    // Setting the alignment affects also the tree, hence invalidate it too.
-    Owner.Header.TreeView.Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetBiDiMode(Value: TBiDiMode);
-
-begin
-  if Value &lt;&gt; FBiDiMode then
-  begin
-    FBiDiMode := Value;
-    Exclude(FOptions, coParentBiDiMode);
-    Changed(False);
-    // Setting the alignment affects also the tree, hence invalidate it too.
-    Owner.Header.TreeView.Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetColor(const Value: TColor);
-
-begin
-  if FColor &lt;&gt; Value then
-  begin
-    FColor := Value;
-    Exclude(FOptions, coParentColor);
-    Changed(False);
-    Owner.Header.TreeView.Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetImageIndex(Value: TImageIndex);
-
-begin
-  if Value &lt;&gt; FImageIndex then
-  begin
-    FImageIndex := Value;
-    Changed(False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetLayout(Value: TVTHeaderColumnLayout);
-
-begin
-  if FLayout &lt;&gt; Value then
-  begin
-    FLayout := Value;
-    Changed(False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetMargin(Value: Integer);
-
-begin
-  // Compatibility setting for -1.
-  if Value &lt; 0 then
-    Value := 4;
-  if FMargin &lt;&gt; Value then
-  begin
-    FMargin := Value;
-    Changed(False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetMaxWidth(Value: Integer);
-
-begin
-  if Value &lt; FMinWidth then
-    Value := FMinWidth;
-  if Value &gt; 10000 then
-    Value := 10000;
-  FMaxWidth := Value;
-  SetWidth(FWidth);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetMinWidth(Value: Integer);
-
-begin
-  if Value &lt; 0 then
-    Value := 0;
-  if Value &gt; FMaxWidth then
-    Value := FMaxWidth;
-  FMinWidth := Value;
-  SetWidth(FWidth);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetOptions(Value: TVTColumnOptions);
-
-var
-  ToBeSet,
-  ToBeCleared: TVTColumnOptions;
-  VisibleChanged,
-  ColorChanged: Boolean;
-
-begin
-  if FOptions &lt;&gt; Value then
-  begin
-    ToBeCleared := FOptions - Value;
-    ToBeSet := Value - FOptions;
-
-    FOptions := Value;
-
-    VisibleChanged := coVisible in (ToBeSet + ToBeCleared);
-    ColorChanged := coParentColor in ToBeSet;
-
-    if coParentBidiMode in ToBeSet then
-     ParentBiDiModeChanged;
-    if ColorChanged then
-     ParentColorChanged;
-
-    Changed(False);
-    // Need to repaint and adjust the owner tree too.
-    with Owner, Header.Treeview do
-      if not (csLoading in ComponentState) and (VisibleChanged or ColorChanged) and (UpdateCount = 0) then
-      begin
-        Invalidate;
-        if VisibleChanged then
-          UpdateHorizontalScrollBar(False);
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetPosition(Value: TColumnPosition);
-
-begin
-  if csLoading in Owner.Header.Treeview.ComponentState then
-    // Only cache the position for final fixup when loading from DFM.
-    FPosition := Value
-  else
-  begin
-    if Value &gt;= TColumnPosition(Collection.Count) then
-      Value := Collection.Count - 1;
-    if FPosition &lt;&gt; Value then
-      with Owner do
-      begin
-        InitializePositionArray;
-        // need to repaint and adjust the owner tree too
-        with Header do
-        begin
-          if not (csLoading in Treeview.ComponentState) and (UpdateCount = 0) then
-          begin
-            AdjustPosition(Self, Value);
-            UpdatePositions;
-            Treeview.CancelEditNode;
-            Invalidate(Self);
-            Treeview.Invalidate;
-            Treeview.UpdateHorizontalScrollBar(False);
-          end;
-        end;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetSpacing(Value: Integer);
-
-begin
-  if FSpacing &lt;&gt; Value then
-  begin
-    FSpacing := Value;
-    Changed(False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetStyle(Value: TVirtualTreeColumnStyle);
-
-begin
-  if FStyle &lt;&gt; Value then
-  begin
-    FStyle := Value;
-    Changed(False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetText(const Value: WideString);
-
-begin
-  if FText &lt;&gt; Value then
-  begin
-    FText := Value;
-    Changed(False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetWidth(Value: Integer);
-
-begin
-  if Value &lt; FMinWidth then
-    Value := FMinWidth;
-  if Value &gt; FMaxWidth then
-    Value := FMaxWidth;
-
-  if FWidth &lt;&gt; Value then
-  begin
-    FLastWidth := FWidth;
-    with Owner, Header do
-    begin
-      if not (hoAutoResize in FOptions) or (Index &lt;&gt; FAutoSizeIndex) then
-      begin
-        FWidth := Value;
-        UpdatePositions;
-      end;
-      if not (csLoading in Treeview.ComponentState) and (UpdateCount = 0) then
-      begin
-        if hoAutoResize in FOptions then
-          AdjustAutoSize(Index);
-        Treeview.DoColumnResize(Index);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.ComputeHeaderLayout(DC: HDC; const Client: TRect; UseHeaderGlyph, UseSortGlyph: Boolean;
-  var HeaderGlyphPos, SortGlyphPos: TPoint; var TextBounds: TRect);
-
-// The layout of a column header is determined by a lot of factors. This method takes them all into account and
-// determines all necessary positions and bounds:
-// - for the header text
-// - the header glyph
-// - the sort glyph
-
-var
-  TextSize: TSize;
-  TextPos,
-  ClientSize,
-  HeaderGlyphSize,
-  SortGlyphSize: TPoint;
-  CurrentAlignment: TAlignment;
-  MinLeft,
-  MaxRight,
-  TextSpacing: Integer;
-  UseText: Boolean;
-
-begin
-  UseText := Length(FText) &gt; 0;
-  // If nothing is to show then don't waste time with useless preparation.
-  if not (UseText or UseHeaderGlyph or UseSortGlyph) then
-    Exit;
-
-  CurrentAlignment := FAlignment;
-  if FBidiMode &lt;&gt; bdLeftToRight then
-    ChangeBiDiModeAlignment(CurrentAlignment);
-
-  // Calculate sizes of the involved items.
-  ClientSize := Point(Client.Right - Client.Left, Client.Bottom - Client.Top);
-  with Owner, Header do
-  begin
-    if UseHeaderGlyph then
-      HeaderGlyphSize := Point(FImages.Width, FImages.Height)
-    else
-      HeaderGlyphSize := Point(0, 0);
-    if UseSortGlyph then
-    begin
-      SortGlyphSize := Point(UtilityImages.Width, UtilityImages.Height);
-      // In any case, the sort glyph is vertically centered.
-      SortGlyphPos.Y := (ClientSize.Y - SortGlyphSize.Y) div 2;
-    end
-    else
-      SortGlyphSize := Point(0, 0);
-  end;
-
-  if UseText then
-  begin
-    GetTextExtentPoint32W(DC, PWideChar(FText), Length(FText), TextSize);
-    Inc(TextSize.cx, 2);
-    TextBounds := Rect(0, 0, TextSize.cx, TextSize.cy);
-    TextSpacing := FSpacing;
-  end
-  else
-  begin
-    TextSpacing := 0;
-    TextSize.cx := 0;
-    TextSize.cy := 0;
-  end;
-
-  // Check first for the special case where nothing is shown except the sort glyph.
-  if UseSortGlyph and not (UseText or UseHeaderGlyph) then
-  begin
-    // Center the sort glyph in the available area if nothing else is there.
-    SortGlyphPos := Point((ClientSize.X - SortGlyphSize.X) div 2, (ClientSize.Y - SortGlyphSize.Y) div 2);
-  end
-  else
-  begin
-    // Determine extents of text and glyph and calculate positions which are clear from the layout.
-    if (Layout in [blGlyphLeft, blGlyphRight]) or not UseHeaderGlyph then
-    begin
-      HeaderGlyphPos.Y := (ClientSize.Y - HeaderGlyphSize.Y) div 2;
-      TextPos.Y := (ClientSize.Y - TextSize.cy) div 2;
-    end
-    else
-    begin
-      if Layout = blGlyphTop then
-      begin
-        HeaderGlyphPos.Y := (ClientSize.Y - HeaderGlyphSize.Y - TextSize.cy - TextSpacing) div 2;
-        TextPos.Y := HeaderGlyphPos.Y + HeaderGlyphSize.Y + TextSpacing;
-      end
-      else
-      begin
-        TextPos.Y := (ClientSize.Y - HeaderGlyphSize.Y - TextSize.cy - TextSpacing) div 2;
-        HeaderGlyphPos.Y := TextPos.Y + TextSize.cy + TextSpacing;
-      end;
-    end;
-
-    // Each alignment needs special consideration. 
-    case CurrentAlignment of
-      taLeftJustify:
-        begin
-          MinLeft := FMargin;
-          if UseSortGlyph and (FBidiMode &lt;&gt; bdLeftToRight) then
-          begin
-            // In RTL context is the sort glyph placed on the left hand side.
-            SortGlyphPos.X := MinLeft;
-            Inc(MinLeft, SortGlyphSize.X + FSpacing);
-          end;
-          if Layout in [blGlyphTop, blGlyphBottom] then
-          begin
-            // Header glyph is above or below text, so both must be considered when calculating
-            // the left positition of the sort glyph (if it is on the right hand side).
-            TextPos.X := MinLeft;
-            if UseHeaderGlyph then
-            begin
-              HeaderGlyphPos.X := (ClientSize.X - HeaderGlyphSize.X) div 2;
-              if HeaderGlyphPos.X &lt; MinLeft then
-                HeaderGlyphPos.X := MinLeft;
-              MinLeft := Max(TextPos.X + TextSize.cx + TextSpacing, HeaderGlyphPos.X + HeaderGlyphSize.X + FSpacing);
-            end
-            else
-              MinLeft := TextPos.X + TextSize.cx + TextSpacing;
-          end
-          else
-          begin
-            // Everything is lined up. TextSpacing might be 0 if there is no text.
-            // This simplifies the calculation because no extra tests are necessary.
-            if UseHeaderGlyph and (Layout = blGlyphLeft) then
-            begin
-              HeaderGlyphPos.X := MinLeft;
-              Inc(MinLeft, HeaderGlyphSize.X + FSpacing);
-            end;
-            TextPos.X := MinLeft;
-            Inc(MinLeft, TextSize.cx + TextSpacing);
-            if UseHeaderGlyph and (Layout = blGlyphRight) then
-            begin
-              HeaderGlyphPos.X := MinLeft;
-              Inc(MinLeft, HeaderGlyphSize.X + FSpacing);
-            end;
-          end;
-          if UseSortGlyph and (FBidiMode = bdLeftToRight) then
-            SortGlyphPos.X := MinLeft;
-        end;
-      taCenter:
-        begin
-          if Layout in [blGlyphTop, blGlyphBottom] then
-          begin
-            HeaderGlyphPos.X := (ClientSize.X - HeaderGlyphSize.X) div 2;
-            TextPos.X := (ClientSize.X - TextSize.cx) div 2;
-            if UseSortGlyph then
-              Dec(TextPos.X, SortGlyphSize.X div 2);
-          end
-          else
-          begin
-            MinLeft := (ClientSize.X - HeaderGlyphSize.X - TextSpacing - TextSize.cx) div 2;
-            if UseHeaderGlyph and (Layout = blGlyphLeft) then
-            begin
-              HeaderGlyphPos.X := MinLeft;
-              Inc(MinLeft, HeaderGlyphSize.X + TextSpacing);
-            end;
-            TextPos.X := MinLeft;
-            Inc(MinLeft, TextSize.cx + TextSpacing);
-            if UseHeaderGlyph and (Layout = blGlyphRight) then
-              HeaderGlyphPos.X := MinLeft;
-          end;
-          if UseHeaderGlyph then
-          begin
-            MinLeft := Min(HeaderGlyphPos.X, TextPos.X);
-            MaxRight := Max(HeaderGlyphPos.X + HeaderGlyphSize.X, TextPos.X + TextSize.cx);
-          end
-          else
-          begin
-            MinLeft := TextPos.X;
-            MaxRight := TextPos.X + TextSize.cx;
-          end;
-          // Place the sort glyph directly to the left or right of the larger item.
-          if UseSortGlyph then
-            if FBidiMode = bdLeftToRight then
-            begin
-              // Sort glyph on the right hand side.
-              SortGlyphPos.X := MaxRight + FSpacing;
-            end
-            else
-            begin
-              // Sort glyph on the left hand side.
-              SortGlyphPos.X := MinLeft - FSpacing - SortGlyphSize.X;
-            end;
-        end;
-    else
-      // taRightJustify
-      MaxRight := ClientSize.X - FMargin;
-      if UseSortGlyph and (FBidiMode = bdLeftToRight) then
-      begin
-        // In LTR context is the sort glyph placed on the right hand side.
-        Dec(MaxRight, SortGlyphSize.X);
-        SortGlyphPos.X := MaxRight;
-        Dec(MaxRight, FSpacing);
-      end;
-      if Layout in [blGlyphTop, blGlyphBottom] then
-      begin
-        TextPos.X := MaxRight - TextSize.cx;
-        if UseHeaderGlyph then
-        begin
-          HeaderGlyphPos.X := (ClientSize.X - HeaderGlyphSize.X) div 2;
-          if HeaderGlyphPos.X + HeaderGlyphSize.X + FSpacing &gt; MaxRight then
-            HeaderGlyphPos.X := MaxRight - HeaderGlyphSize.X - FSpacing;
-          MaxRight := Min(TextPos.X - TextSpacing, HeaderGlyphPos.X - FSpacing);
-        end
-        else
-          MaxRight := TextPos.X - TextSpacing;
-      end
-      else
-      begin
-        // Everything is lined up. TextSpacing might be 0 if there is no text.
-        // This simplifies the calculation because no extra tests are necessary.
-        if UseHeaderGlyph and (Layout = blGlyphRight) then
-        begin
-          HeaderGlyphPos.X := MaxRight -  HeaderGlyphSize.X;
-          MaxRight := HeaderGlyphPos.X - FSpacing;
-        end;
-        TextPos.X := MaxRight - TextSize.cx;
-        MaxRight := TextPos.X - TextSpacing;
-        if UseHeaderGlyph and (Layout = blGlyphLeft) then
-        begin
-          HeaderGlyphPos.X := MaxRight - HeaderGlyphSize.X;
-          MaxRight := HeaderGlyphPos.X - FSpacing;
-        end;
-      end;
-      if UseSortGlyph and (FBidiMode &lt;&gt; bdLeftToRight) then
-        SortGlyphPos.X := MaxRight - SortGlyphSize.X;
-    end;
-  end;
-
-  // Once the position of each element is determined there remains only one but important step.
-  // The horizontal positions of every element must be adjusted so that it always fits into the
-  // given header area. This is accomplished by shorten the text appropriately.
-
-  // These are the maximum bounds. Nothing goes beyond them.
-  MinLeft := FMargin;
-  MaxRight := ClientSize.X - FMargin;
-  if UseSortGlyph then
-  begin
-    if FBidiMode = bdLeftToRight then
-    begin
-      // Sort glyph on the right hand side. 
-      if SortGlyphPos.X + SortGlyphSize.X &gt; MaxRight then
-        SortGlyphPos.X := MaxRight - SortGlyphSize.X;
-      MaxRight := SortGlyphPos.X - FSpacing;
-    end;
-
-    // Consider also the left side of the sort glyph regardless of the bidi mode. 
-    if SortGlyphPos.X &lt; MinLeft then
-      SortGlyphPos.X := MinLeft;
-    // Left border needs only adjustment if the sort glyph marks the left border.
-    if FBidiMode &lt;&gt; bdLeftToRight then
-      MinLeft := SortGlyphPos.X + SortGlyphSize.X + FSpacing;
-
-    // Finally transform sort glyph to its actual position.
-    with SortGlyphPos do
-    begin
-      Inc(X, Client.Left);
-      Inc(Y, Client.Top);
-    end;
-  end;
-  if UseHeaderGlyph then
-  begin
-    if HeaderGlyphPos.X + HeaderGlyphSize.X &gt; MaxRight then
-      HeaderGlyphPos.X := MaxRight - HeaderGlyphSize.X;
-    if Layout = blGlyphRight then
-      MaxRight := HeaderGlyphPos.X - FSpacing;
-    if HeaderGlyphPos.X &lt; MinLeft then
-      HeaderGlyphPos.X := MinLeft;
-    if Layout = blGlyphLeft then
-      MinLeft := HeaderGlyphPos.X + HeaderGlyphSize.X + FSpacing;
-    // Finally transform header glyph to its actual position.
-    with HeaderGlyphPos do
-    begin
-      Inc(X, Client.Left);
-      Inc(Y, Client.Top);
-    end;
-  end;
-  if UseText then
-  begin
-    if TextPos.X &lt; MinLeft then
-      TextPos.X := MinLeft;
-    OffsetRect(TextBounds, TextPos.X, TextPos.Y);
-    if TextBounds.Right &gt; MaxRight then
-      TextBounds.Right := MaxRight;
-    OffsetRect(TextBounds, Client.Left, Client.Top);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.DefineProperties(Filer: TFiler);
-
-begin
-  inherited;
-
-  // Must define a new name for the properties otherwise the VCL will try to load the wide string
-  // without asking us and screws it completely up.
-  Filer.DefineProperty('WideText', ReadText, WriteText, FText &lt;&gt; '');
-  Filer.DefineProperty('WideHint', ReadHint, WriteHint, FHint &lt;&gt; '');
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.GetAbsoluteBounds(var Left, Right: Integer);
-
-// Returns the column's left and right bounds in header coordinates, that is, independant of the scrolling position.
-
-begin
-  Left := FLeft;
-  Right := FLeft + FWidth;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumn.GetDisplayName: string;
-
-// Returns the column text if it only contains ANSI characters, otherwise the column id is returned because the IDE
-// still cannot handle Unicode strings.
-
-var
-  I: Integer;
-
-begin
-  // Check if the text of the column contains characters &gt; 255
-  I := 1;
-  while I &lt;= Length(FText) do
-  begin
-    if Ord(FText[I]) &gt; 255 then
-      Break;
-    Inc(I);
-  end;
-
-  if I &gt; Length(FText) then
-    Result := FText // implicit conversion
-  else
-    Result := Format('Column %d', [Index]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumn.GetOwner: TVirtualTreeColumns;
-
-begin
-  Result := Collection as TVirtualTreeColumns;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.ReadText(Reader: TReader);
-
-begin
-  case Reader.NextValue of
-    vaLString, vaString:
-      SetText(Reader.ReadString);
-  else
-    SetText(Reader.ReadWideString);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SetIndex(Value: Integer);
-
-begin
-  if Index &lt;&gt; Value then
-  begin
-    // Tell the columns collection about the index change. Its position array must be updated.
-    Owner.IndexChanged(Index, Value);
-
-    inherited;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.ReadHint(Reader: TReader);
-
-begin
-  case Reader.NextValue of
-    vaLString, vaString:
-      FHint := Reader.ReadString;
-  else
-    FHint := Reader.ReadWideString;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.WriteHint(Writer: TWriter);
-
-begin
-  Writer.WriteWideString(FHint);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.WriteText(Writer: TWriter);
-
-begin
-  Writer.WriteWideString(FText);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.Assign(Source: TPersistent);
-
-var
-  OldOptions: TVTColumnOptions;
-  
-begin
-  if Source is TVirtualTreeColumn then
-  begin
-    OldOptions := FOptions;
-    FOptions := [];
-
-    BiDiMode := TVirtualTreeColumn(Source).BiDiMode;
-    ImageIndex := TVirtualTreeColumn(Source).ImageIndex;
-    Layout := TVirtualTreeColumn(Source).Layout;
-    Margin := TVirtualTreeColumn(Source).Margin;
-    MaxWidth := TVirtualTreeColumn(Source).MaxWidth;
-    MinWidth := TVirtualTreeColumn(Source).MinWidth;
-    Position := TVirtualTreeColumn(Source).Position;
-    Spacing := TVirtualTreeColumn(Source).Spacing;
-    Style := TVirtualTreeColumn(Source).Style;
-    Text := TVirtualTreeColumn(Source).Text;
-    Hint := TVirtualTreeColumn(Source).Hint;
-    Width := TVirtualTreeColumn(Source).Width;
-    Alignment := TVirtualTreeColumn(Source).Alignment;
-    Color := TVirtualTreeColumn(Source).Color;
-    Tag := TVirtualTreeColumn(Source).Tag;
-
-    // Order is important. Assign options last.
-    FOptions := OldOptions;
-    Options := TVirtualTreeColumn(Source).Options;
-
-    Changed(False);
-  end
-  else
-    inherited Assign(Source);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumn.Equals(OtherColumn: TVirtualTreeColumn): Boolean;
-
-begin
-  Result := (BiDiMode = OtherColumn.BiDiMode) and
-    (ImageIndex = OtherColumn.ImageIndex) and
-    (Layout = OtherColumn.Layout) and
-    (Margin = OtherColumn.Margin) and
-    (MaxWidth = OtherColumn.MaxWidth) and
-    (MinWidth = OtherColumn.MinWidth) and
-    (Position = OtherColumn.Position) and
-    (Spacing = OtherColumn.Spacing) and
-    (Style = OtherColumn.Style) and
-    (Text = OtherColumn.Text) and
-    (Hint = OtherColumn.Hint) and
-    (Width = OtherColumn.Width) and
-    (Alignment = OtherColumn.Alignment) and
-    (Color = OtherColumn.Color) and
-    (Tag = OtherColumn.Tag) and
-    (Options = OtherColumn.Options);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumn.GetRect: TRect;
-
-// Returns the rectangle this column occupies in the header (relative to (0, 0) of the non-client area).
-
-begin
-  with TVirtualTreeColumns(GetOwner).FHeader do
-    Result := Treeview.FHeaderRect;
-  Inc(Result.Left, FLeft);
-  Result.Right := Result.Left + FWidth;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.LoadFromStream(const Stream: TStream; Version: Integer);
-
-  //--------------- local function --------------------------------------------
-
-  function ConvertOptions(Value: Cardinal): TVTColumnOptions;
-
-  // Converts the given raw value which represents column options for possibly older
-  // formats to the current format.
-  
-  begin
-    if Version &gt; 1 then
-      Result := TVTColumnOptions(Byte(Value))
-    else
-    begin
-      // In version 2 coParentColor has been added. This needs an option shift for older stream formats.
-      // The first (lower) 4 options remain as they are.
-      Result := TVTColumnOptions(Byte(Value) and $F);
-      Value := (Value and not $F) shl 1;
-      Result := Result + TVTColumnOptions(Byte(Value));
-    end;
-  end;
-
-  //--------------- end local function ----------------------------------------
-
-var
-  Dummy: Integer;
-  S: WideString;
-
-begin
-  with Stream do
-  begin
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    SetLength(S, Dummy);
-    ReadBuffer(PWideChar(S)^, 2 * Dummy);
-    Text := S;
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    SetLength(FHint, Dummy);
-    ReadBuffer(PWideChar(FHint)^, 2 * Dummy);
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    Width := Dummy;
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    MinWidth := Dummy;
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    MaxWidth := Dummy;
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    Style := TVirtualTreeColumnStyle(Dummy);
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    ImageIndex := Dummy;
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    Layout := TVTHeaderColumnLayout(Dummy);
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    Margin := Dummy;
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    Spacing := Dummy;
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    BiDiMode := TBiDiMode(Dummy);
-
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    Options := ConvertOptions(Dummy);
-
-    if Version &gt; 0 then
-    begin
-      // Parts which have been introduced/changed with header stream version 1+.
-      ReadBuffer(Dummy, SizeOf(Dummy));
-      Tag := Dummy;
-      ReadBuffer(Dummy, SizeOf(Dummy));
-      Alignment := TAlignment(Dummy);
-
-      if Version &gt; 1 then
-      begin
-        ReadBuffer(Dummy, SizeOf(Dummy));
-        Color := TColor(Dummy);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.ParentBiDiModeChanged;
-
-var
-  Columns: TVirtualTreeColumns;
-
-begin
-  if coParentBiDiMode in FOptions then
-  begin
-    Columns := GetOwner as TVirtualTreeColumns;
-    if Assigned(Columns) and (FBidiMode &lt;&gt; Columns.FHeader.Treeview.BiDiMode) then
-    begin
-      FBiDiMode := Columns.FHeader.Treeview.BiDiMode;
-      Changed(False);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.ParentColorChanged;
-
-var
-  Columns: TVirtualTreeColumns;
-
-begin
-  if coParentColor in FOptions then
-  begin
-    Columns := GetOwner as TVirtualTreeColumns;
-    if Assigned(Columns) and (FColor &lt;&gt; Columns.FHeader.Treeview.Color) then
-    begin
-      FColor := Columns.FHeader.Treeview.Color;
-      Changed(False);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.RestoreLastWidth;
-
-begin
-  TVirtualTreeColumns(GetOwner).AnimatedResize(Index, FLastWidth);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumn.SaveToStream(const Stream: TStream);
-
-var
-  Dummy: Integer;
-
-begin
-  with Stream do
-  begin
-    Dummy := Length(FText);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    WriteBuffer(PWideChar(FText)^, 2 * Dummy);
-    Dummy := Length(FHint);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    WriteBuffer(PWideChar(FHint)^, 2 * Dummy);
-    WriteBuffer(FWidth, SizeOf(FWidth));
-    WriteBuffer(FMinWidth, SizeOf(FMinWidth));
-    WriteBuffer(FMaxWidth, SizeOf(FMaxWidth));
-    Dummy := Ord(FStyle);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    Dummy := FImageIndex;
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    Dummy := Ord(FLayout);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    WriteBuffer(FMargin, SizeOf(FMargin));
-    WriteBuffer(FSpacing, SizeOf(FSpacing));
-    Dummy := Ord(FBiDiMode);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    Dummy := Byte(FOptions);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-
-    // parts introduce with stream version 1
-    WriteBuffer(FTag, SizeOf(Dummy));
-    Dummy := Cardinal(FAlignment);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-
-    // parts introduce with stream version 2
-    Dummy := Integer(FColor);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumn.UseRightToLeftReading: Boolean;
-
-begin
-  Result := FBiDiMode &lt;&gt; bdLeftToRight;
-end;
-
-//----------------- TVirtualTreeColumns --------------------------------------------------------------------------------
-
-constructor TVirtualTreeColumns.Create(AOwner: TVTHeader);
-
-var
-  ColumnClass: TVirtualTreeColumnClass;
-
-begin
-  FHeader := AOwner;
-
-  // Determine column class to be used in the header.
-  ColumnClass := AOwner.FOwner.GetColumnClass;
-  // The owner tree always returns the default tree column class if not changed by application/descentants.
-  inherited Create(ColumnClass);
-
-  FHeaderBitmap := TBitmap.Create;
-  FHeaderBitmap.PixelFormat := pf32Bit;
-  
-  FHoverIndex := NoColumn;
-  FDownIndex := NoColumn;
-  FClickIndex := NoColumn;
-  FDropTarget := NoColumn;
-  FTrackIndex := NoColumn;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TVirtualTreeColumns.Destroy;
-
-begin
-  FHeaderBitmap.Free;
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.DrawButtonText(DC: HDC; Caption: WideString; Bounds: TRect; Enabled, Hot: Boolean;
-  DrawFormat: Cardinal);
-
-var
-  TextSpace: Integer;
-  Size: TSize;
-
-begin
-  // Do we need to shorten the caption due to limited space?
-  GetTextExtentPoint32W(DC, PWideChar(Caption), Length(Caption), Size);
-  TextSpace := Bounds.Right - Bounds.Left;
-  if TextSpace &lt; Size.cx then
-    Caption := ShortenString(DC, Caption, TextSpace, DT_RTLREADING and DrawFormat &lt;&gt; 0);
-
-  SetBkMode(DC, TRANSPARENT);
-  if not Enabled then
-  begin
-    OffsetRect(Bounds, 1, 1);
-    SetTextColor(DC, ColorToRGB(clBtnHighlight));
-    if IsWinNT then
-      Windows.DrawTextW(DC, PWideChar(Caption), Length(Caption), Bounds, DrawFormat)
-    else
-      DrawTextW(DC, PWideChar(Caption), Length(Caption), Bounds, DrawFormat, False);
-    OffsetRect(Bounds, -1, -1);
-    SetTextColor(DC, ColorToRGB(clBtnShadow));
-    if IsWinNT then
-      Windows.DrawTextW(DC, PWideChar(Caption), Length(Caption), Bounds, DrawFormat)
-    else
-      DrawTextW(DC, PWideChar(Caption), Length(Caption), Bounds, DrawFormat, False);
-  end
-  else
-  begin
-    if Hot then
-      SetTextColor(DC, ColorToRGB(clBtnShadow))
-    else                            
-      SetTextColor(DC, ColorToRGB(FHeader.FFont.Color));
-    if IsWinNT then
-      Windows.DrawTextW(DC, PWideChar(Caption), Length(Caption), Bounds, DrawFormat)
-    else
-      DrawTextW(DC, PWideChar(Caption), Length(Caption), Bounds, DrawFormat, False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetItem(Index: TColumnIndex): TVirtualTreeColumn;
-
-begin
-  Result := TVirtualTreeColumn(inherited GetItem(Index));
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetNewIndex(P: TPoint; var OldIndex: TColumnIndex): Boolean;
-
-var
-  NewIndex: Integer;
-
-begin
-  Result := False;
-  // convert to local coordinates
-  Inc(P.Y, FHeader.FHeight);
-  NewIndex := ColumnFromPosition(P);
-  if NewIndex &lt;&gt; OldIndex then
-  begin
-    if OldIndex &gt; NoColumn then
-      FHeader.Invalidate(Items[OldIndex]);
-    OldIndex := NewIndex;
-    if OldIndex &gt; NoColumn then
-      FHeader.Invalidate(Items[OldIndex]);
-    Result := True;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.SetItem(Index: TColumnIndex; Value: TVirtualTreeColumn);
-
-begin
-  inherited SetItem(Index, Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.AdjustAutoSize(CurrentIndex: TColumnIndex; Force: Boolean = False);
-
-// Called only if the header is in auto-size mode which means a column needs to be so large
-// that it fills all the horizontal space not occupied by the other columns.
-// CurrentIndex (if not InvalidColumn) describes which column has just been resized.
-
-var
-  NewValue,
-  AutoIndex,
-  Index,
-  RestWidth: Integer;
-
-begin
-  if Count &gt; 0 then
-  begin
-    // Determine index to be used for auto resizing. This is usually given by the owner's AutoSizeIndex, but
-    // could be different if the column whose resize caused the invokation here is either the auto column itself
-    // or visually to the right of the auto size column.
-    AutoIndex := FHeader.FAutoSizeIndex;
-    if (AutoIndex &lt; 0) or (AutoIndex &gt;= Count) then
-      AutoIndex := Count - 1;
-    if (CurrentIndex &gt; NoColumn) and
-      (Items[CurrentIndex].Position &gt;= Items[AutoIndex].Position) then
-    begin
-      // The given index is the either the auto size column itself or visually to its right.
-      // Use the next column instead if there is one.
-      AutoIndex := GetNextVisibleColumn(CurrentIndex);
-    end;
-
-    if AutoIndex &gt;= 0 then
-    begin
-      with FHeader.Treeview do
-      begin
-        if HandleAllocated then
-          RestWidth := ClientWidth
-        else
-          RestWidth := Width;
-      end;
-
-      // go through all columns and calculate the rest space remaining
-      for Index := 0 to Count - 1 do
-        if (Index &lt;&gt; AutoIndex) and (coVisible in Items[Index].FOptions) then
-          Dec(RestWidth, Items[Index].Width);
-
-      with Items[AutoIndex] do
-      begin
-        NewValue := Max(MinWidth, Min(MaxWidth, RestWidth));
-        if Force or (FWidth &lt;&gt; NewValue) then
-        begin
-          FWidth := NewValue;
-          UpdatePositions;
-          FHeader.Treeview.DoColumnResize(AutoIndex);
-        end;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.AdjustDownColumn(P: TPoint): TColumnIndex;
-
-// Determines the column from the given position and returns it. If this column is allowed to be clicked then
-// it is also kept for later use.
-
-begin
-  // Convert to local coordinates.
-  Inc(P.Y, FHeader.FHeight);
-  Result := ColumnFromPosition(P);
-  if (Result &gt; NoColumn) and (Result &lt;&gt; FDownIndex) and (coAllowClick in Items[Result].FOptions) and
-    (coEnabled in Items[Result].FOptions) then
-  begin
-    if FDownIndex &gt; NoColumn then
-      FHeader.Invalidate(Items[FDownIndex]);
-    FDownIndex := Result;
-    FHeader.Invalidate(Items[FDownIndex]);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.AdjustHoverColumn(P: TPoint): Boolean;
-
-// Determines the new hover column index and returns True if the index actually changed else False.
-
-begin
-  Result := GetNewIndex(P, FHoverIndex);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.AdjustPosition(Column: TVirtualTreeColumn; Position: Cardinal);
-
-// Reorders the column position array so that the given column gets the given position.
-
-var
-  OldPosition: Cardinal;
-
-begin
-  OldPosition := Column.Position;
-  if OldPosition &lt;&gt; Position then
-  begin
-    if OldPosition &lt; Position then
-    begin
-      // column will be moved up so move down other entries
-      Move(FPositionToIndex[OldPosition + 1], FPositionToIndex[OldPosition], (Position - OldPosition) * SizeOf(Cardinal));
-    end
-    else
-    begin
-      // column will be moved down so move up other entries
-      Move(FPositionToIndex[Position], FPositionToIndex[Position + 1], (OldPosition - Position) * SizeOf(Cardinal));
-    end;
-    FPositionToIndex[Position] := Column.Index;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.FixPositions;
-
-// Fixes column positions after loading from DFM.
-
-var
-  I: Integer;
-
-begin
-  for I := 0 to Count - 1 do
-    FPositionToIndex[Items[I].Position] := I;
-  FNeedPositionsFix := False;
-  UpdatePositions(True);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetColumnAndBounds(P: TPoint; var ColumnLeft, ColumnRight: Integer;
-  Relative: Boolean = True): Integer;
-
-// Returns the column where the mouse is currently in as well as the left and right bound of
-// this column (Left and Right are undetermined if no column is involved).
-
-var
-  I: Integer;
-
-begin
-  Result := InvalidColumn;
-  if Relative then
-    ColumnLeft := FHeader.Treeview.FOffsetX
-  else
-    ColumnLeft := 0;
-  for I := 0 to Count - 1 do
-    with Items[FPositionToIndex[I]] do
-      if coVisible in FOptions then
-      begin
-        ColumnRight := ColumnLeft + FWidth;
-        if P.X &lt; ColumnRight then
-        begin
-          Result := FPositionToIndex[I];
-          Exit;
-        end;
-        ColumnLeft := ColumnRight;
-      end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetOwner: TPersistent;
-
-begin
-  Result := FHeader;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.HandleClick(P: TPoint; Button: TMouseButton; Force, DblClick: Boolean);
-
-// Generates a click event if the mouse button has been released over the same column it was pressed first.
-// Alternatively, Force might be set to True to indicate that the down index does not matter (right, middle and
-// double click).
-
-var
-  NewClickIndex: Integer;
-  Shift: TShiftState;
-
-begin
-  // convert to local coordinates
-  Inc(P.Y, FHeader.FHeight);
-  NewClickIndex := ColumnFromPosition(P);
-  if (NewClickIndex &gt; NoColumn) and (coAllowClick in Items[NewClickIndex].FOptions) and
-    ((NewClickIndex = FDownIndex) or Force) then
-  begin
-    FClickIndex := NewClickIndex;
-    Shift := FHeader.GetShiftState;
-    if DblClick then
-      Shift := Shift + [ssDouble];
-    FHeader.Treeview.DoHeaderClick(NewClickIndex, Button, Shift, P.X, P.Y);
-    FHeader.Invalidate(Items[NewClickIndex]);
-  end
-  else
-    FClickIndex := NoColumn;
-
-  if (FClickIndex &gt; NoColumn) and (FClickIndex &lt;&gt; NewClickIndex) then
-    FHeader.Invalidate(Items[FClickIndex]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.IndexChanged(OldIndex, NewIndex: Integer);
-
-// Called by a column when its index in the collection changes. If NewIndex is -1 then the column is
-// about to be removed, otherwise it is moved to a new index.
-// The method will then update the position array to reflect the change.
-
-var
-  I: Integer;
-  Increment: Integer;
-  Lower,
-  Upper: Integer;
-
-begin
-  if NewIndex = -1 then
-  begin
-    // Find position in the array with the old index.
-    Upper := High(FPositionToIndex);
-    for I := 0 to Upper do
-    begin
-      if FPositionToIndex[I] = OldIndex then
-      begin
-        // Index found. Move all higher entries one step down and remove the last entry.
-        if I &lt; Upper then
-          Move(FPositionToIndex[I + 1], FPositionToIndex[I], (Upper - I) * SizeOf(Integer));
-      end;
-      // Decrease all indices, which are greater than the index to be deleted.
-      if FPositionToIndex[I] &gt; OldIndex then
-        Dec(FPositionToIndex[I]);
-    end;
-    SetLength(FPositionToIndex, High(FPositionToIndex));
-  end
-  else
-  begin
-    if OldIndex &lt; NewIndex then
-      Increment := -1
-    else
-      Increment := 1;
-
-    Lower := Min(OldIndex, NewIndex);
-    Upper := Max(OldIndex, NewIndex);
-    for I := 0 to High(FPositionToIndex) do
-    begin
-      if (FPositionToIndex[I] &gt;= Lower) and (FPositionToIndex[I] &lt; Upper) then
-        Inc(FPositionToIndex[I], Increment)
-      else
-        if FPositionToIndex[I] = OldIndex then
-          FPositionToIndex[I] := NewIndex;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.InitializePositionArray;
-
-// Ensures that the column position array contains as much entries as columns are defined.
-// The array is resized and initialized with default values if needed.
-
-var
-  I, OldSize: Integer;
-  Changed: Boolean;
-
-begin
-  if Count &lt;&gt; Length(FPositionToIndex) then
-  begin
-    OldSize := Length(FPositionToIndex);
-    SetLength(FPositionToIndex, Count);
-    if Count &gt; OldSize then
-    begin
-      // New items have been added, just set their position to the same as their index.
-      for I := OldSize to Count - 1 do
-        FPositionToIndex[I] := I;
-    end
-    else
-    begin
-      // Items have been deleted, so reindex remaining entries by decrementing values larger than the highest
-      // possible index until no entry is higher than this limit.
-      repeat
-        Changed := False;
-        for I := 0 to Count - 1 do
-          if FPositionToIndex[I] &gt;= Count then
-          begin
-            Dec(FPositionToIndex[I]);
-            Changed := True;
-          end;
-      until not Changed;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.Update(Item: TCollectionItem);
-
-begin
-  // This is the only place which gets notified when a new column has been added or removed
-  // and we need this event to adjust the column position array.
-  InitializePositionArray;
-  if csLoading in Header.Treeview.ComponentState then
-    FNeedPositionsFix := True
-  else
-    UpdatePositions;
-
-  // The first column which is created is by definition also the main column.
-  if (Count &gt; 0) and (Header.FMainColumn &lt; 0) then
-    FHeader.FMainColumn := 0;
-
-  if not (csLoading in Header.Treeview.ComponentState) and not (hsLoading in FHeader.FStates) then
-  begin
-    with FHeader do
-    begin
-      if hoAutoResize in FOptions then
-        AdjustAutoSize(InvalidColumn);
-      if Assigned(Item) then
-        Invalidate(Item as TVirtualTreeColumn)
-      else
-        if Treeview.HandleAllocated then
-        begin
-          Treeview.UpdateHorizontalScrollBar(False);
-          Invalidate(nil);
-          Treeview.Invalidate;
-        end;
-      // This is mainly to let the designer know when a change occurs at design time which
-      // doesn't involve the object inspector (like column resizing with the mouse).
-      // This does NOT include design time code as the comunication is done via an interface.
-      Treeview.UpdateDesigner;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.UpdatePositions(Force: Boolean = False);
-
-// Recalculates the left border of every column and updates their position property according to the
-// PostionToIndex array which primarily determines where each column is placed visually.
-
-var
-  I, LeftPos: Integer;
-
-begin
-  if not FNeedPositionsFix and (Force or (UpdateCount = 0)) then
-  begin
-    LeftPos := 0;
-    for I := 0 to High(FPositionToIndex) do
-      with Items[FPositionToIndex[I]] do
-      begin
-        FPosition := I;
-        FLeft := LeftPos;
-        if coVisible in FOptions then
-          Inc(LeftPos, FWidth);
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.Add: TVirtualTreeColumn;
-
-begin
-  Result := TVirtualTreeColumn(inherited Add);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.AnimatedResize(Column: TColumnIndex; NewWidth: Integer);
-
-// Resizes the given column animated by scrolling the window DC.
-
-var
-  OldWidth: Integer;
-  DC: HDC;
-  I,
-  Steps,
-  DX: Integer;
-  HeaderScrollRect,
-  ScrollRect,
-  R: TRect;
-
-  NewBrush,
-  LastBrush: HBRUSH;
-
-begin
-  // Make sure the width constrains are considered.
-  if NewWidth &lt; Items[Column].FMinWidth then
-     NewWidth := Items[Column].FMinWidth;
-  if NewWidth &gt; Items[Column].FMaxWidth then
-     NewWidth := Items[Column].FMaxWidth;
-
-  OldWidth := Items[Column].Width;
-  // Nothing to do if the width is the same.
-  if OldWidth &lt;&gt; NewWidth then
-  begin
-    DC := GetWindowDC(FHeader.Treeview.Handle);
-    with FHeader.Treeview do
-    try
-      Steps := 32;
-      DX := (NewWidth - OldWidth) div Steps;
-
-      // Determination of the scroll rectangle is a bit complicated since we neither want
-      // to scroll the scrollbars nor the border of the treeview window.
-      HeaderScrollRect := FHeaderRect;
-      ScrollRect := HeaderScrollRect;
-      // Exclude the header itself from scrolling.
-      ScrollRect.Top := ScrollRect.Bottom;
-      ScrollRect.Bottom := ScrollRect.Top + ClientHeight;
-      ScrollRect.Right := ScrollRect.Left + ClientWidth;
-      with Items[Column] do
-        Inc(ScrollRect.Left, FLeft + FWidth);
-      HeaderScrollRect.Left := ScrollRect.Left;
-      HeaderScrollRect.Right := ScrollRect.Right;
-
-      // When the new width is larger then avoid artefacts on the left hand side
-      // by deleting a small stripe
-      if NewWidth &gt; OldWidth then
-      begin
-        R := ScrollRect;
-        NewBrush := CreateSolidBrush(ColorToRGB(Color));
-        LastBrush := SelectObject(DC, NewBrush);
-        R.Right := R.Left + DX;
-        FillRect(DC, R, NewBrush);
-        SelectObject(DC, LastBrush);
-        DeleteObject(NewBrush);
-      end
-      else
-      begin
-        Inc(HeaderScrollRect.Left, DX);
-        Inc(ScrollRect.Left, DX);
-      end;
-
-      for I := 0 to Steps - 1 do
-      begin
-        ScrollDC(DC, DX, 0, HeaderScrollRect, HeaderScrollRect, 0, nil);
-        Inc(HeaderScrollRect.Left, DX);
-        ScrollDC(DC, DX, 0, ScrollRect, ScrollRect, 0, nil);
-        Inc(ScrollRect.Left, DX);
-        Sleep(1);
-      end;
-    finally
-      ReleaseDC(Handle, DC);
-    end;
-    Items[Column].Width := NewWidth;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.Assign(Source: TPersistent);
-
-begin
-  // Let the collection class assign the items.
-  inherited;
-
-  if Source is TVirtualTreeColumns then
-  begin
-    // Copying the position array is the only needed task here.
-    FPositionToIndex := Copy(TVirtualTreeColumns(Source).FPositionToIndex, 0, MaxInt);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.Clear;
-
-begin
-  FClearing := True;
-  try
-    // Since we're freeing all columns, the following have to be true when we're done.
-    FHoverIndex := NoColumn;
-    FDownIndex := NoColumn;
-    FTrackIndex := NoColumn;
-    FClickIndex := NoColumn;
-
-    with Header do
-      if not (hsLoading in FStates) then
-      begin
-        FAutoSizeIndex := NoColumn;
-        FMainColumn := NoColumn;
-        FSortColumn := NoColumn;
-      end;
-
-    inherited Clear;
-  finally
-    FClearing := False;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.ColumnFromPosition(P: TPoint; Relative: Boolean = True): TColumnIndex;
-
-// Determines the current column based on the position passed in P.
-
-var
-  I, Sum: Integer;
-
-begin
-  Result := InvalidColumn;
-  // The position must be within the header area, but we extend the vertical bounds to the entire treeview area.
-  if (P.X &gt;= 0) and (P.Y &gt;= 0) and (P.Y &lt;= Integer(FHeader.TreeView.Height)) then
-  begin
-    if Relative then
-      Sum := FHeader.Treeview.FOffsetX
-    else
-      Sum := 0;
-    for I := 0 to Count - 1 do
-      if coVisible in Items[FPositionToIndex[I]].FOptions then
-      begin
-        Inc(Sum, Items[FPositionToIndex[I]].Width);
-        if P.X &lt; Sum then
-        begin
-          Result := FPositionToIndex[I];
-          Break;
-        end;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.ColumnFromPosition(PositionIndex: TColumnPosition): TColumnIndex;
-
-// Returns the index of the column at the given position.
-
-begin
-  if Integer(PositionIndex) &lt; Length(FPositionToIndex) then
-    Result := FPositionToIndex[PositionIndex]
-  else
-    Result := NoColumn;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.Equals(OtherColumns: TVirtualTreeColumns): Boolean;
-
-// Compares itself with the given set of columns and returns True if all published properties are the same
-// (including column order), otherwise False is returned.
-
-var
-  I: Integer;
-
-begin
-  // Same number of columns?
-  Result := OtherColumns.Count = Count;
-  if Result then
-  begin
-    // Same order of columns?
-    Result := CompareMem(Pointer(FPositionToIndex), Pointer(OtherColumns.FPositionToIndex),
-      Length(FPositionToIndex) * SizeOf(TColumnIndex));
-    if Result then
-    begin
-      for I := 0 to Count - 1 do
-        if not Items[I].Equals(OtherColumns[I]) then
-        begin
-          Result := False;
-          Break;
-        end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.GetColumnBounds(Column: TColumnIndex; var Left, Right: Integer);
-
-// Returns the left and right bound of the given column. If Column is NoColumn then the entire client width is returned.
-
-begin
-  if Column = NoColumn then
-  begin
-    Left := 0;
-    Right := FHeader.Treeview.ClientWidth;
-  end
-  else
-  begin
-    Left := Items[Column].Left;
-    Right := Left + Items[Column].Width;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetFirstVisibleColumn: TColumnIndex;
-
-// Returns the index of the first visible column or &quot;InvalidColumn&quot; if either no columns are defined or
-// all columns are hidden.
-
-var
-  I: Integer;
-
-begin
-  Result := InvalidColumn;
-  for I := 0 to Count - 1 do
-    if coVisible in Items[FPositionToIndex[I]].FOptions then
-    begin
-      Result := FPositionToIndex[I];
-      Break;
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetLastVisibleColumn: TColumnIndex;
-
-// Returns the index of the last visible column or &quot;InvalidColumn&quot; if either no columns are defined or
-// all columns are hidden.
-
-var
-  I: Integer;
-
-begin
-  Result := InvalidColumn;
-  for I := Count - 1 downto 0 do
-    if coVisible in Items[FPositionToIndex[I]].FOptions then
-    begin
-      Result := FPositionToIndex[I];
-      Break;
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetNextColumn(Column: TColumnIndex): TColumnIndex;
-
-// Returns the next column in display order. Column is the index of an item in the collection (a column).
-
-var
-  Position: Integer;
-
-begin
-  if Column &lt; 0 then
-    Result := InvalidColumn
-  else
-  begin
-    Position := Items[Column].Position;
-    if Position &lt; Count - 1 then
-      Result := FPositionToIndex[Position + 1]
-    else
-      Result := InvalidColumn;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetNextVisibleColumn(Column: TColumnIndex): TColumnIndex;
-
-// Returns the next visible column in display order, Column is an index into the columns list.
-
-begin
-  Result := Column;
-  repeat
-    Result := GetNextColumn(Result);
-  until (Result = InvalidColumn) or (coVisible in Items[Result].FOptions);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetPreviousColumn(Column: TColumnIndex): TColumnIndex;
-
-// Returns the previous column in display order, Column is an index into the columns list.
-
-var
-  Position: Integer;
-
-begin
-  if Column &lt; 0 then
-    Result := InvalidColumn
-  else
-  begin
-    Position := Items[Column].Position;
-    if Position &gt; 0 then
-      Result := FPositionToIndex[Position - 1]
-    else
-      Result := InvalidColumn;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetPreviousVisibleColumn(Column: TColumnIndex): TColumnIndex;
-
-// Returns the previous column in display order, Column is an index into the columns list.
-
-begin
-  Result := Column;
-  repeat
-    Result := GetPreviousColumn(Result);
-  until (Result = InvalidColumn) or (coVisible in Items[Result].FOptions);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.GetVisibleColumns: TColumnsArray;
-
-// Returns a list of all currently visible columns in actual order.
-
-var
-  I, Counter: Integer;
-
-begin
-  SetLength(Result, Count);
-  Counter := 0;
-
-  for I := 0 to Count - 1 do
-    if coVisible in Items[FPositionToIndex[I]].FOptions then
-    begin
-      Result[Counter] := Items[FPositionToIndex[I]];
-      Inc(Counter);
-    end;
-  // Set result length to actual visible count.
-  SetLength(Result, Counter);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.IsValidColumn(Column: TColumnIndex): Boolean;
-
-// Determines whether the given column is valid or not, that is, whether it is one of the current columns.
-
-begin
-  Result := (Column &gt; NoColumn) and (Column &lt; Count);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.LoadFromStream(const Stream: TStream; Version: Integer);
-
-var
-  I,
-  ItemCount: Integer;
-
-begin
-  Clear;
-  Stream.ReadBuffer(ItemCount, SizeOf(ItemCount));
-  // number of columns
-  if ItemCount &gt; 0 then
-  begin
-    BeginUpdate;
-    try
-      for I := 0 to ItemCount - 1 do
-        Add.LoadFromStream(Stream, Version);
-      SetLength(FPositionToIndex, ItemCount);
-      Stream.ReadBuffer(FPositionToIndex[0], ItemCount * SizeOf(Cardinal));
-      UpdatePositions(True);
-    finally
-      EndUpdate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-// XP style header button legacy code. This procedure is only used on non-XP systems to simulate the themed
-// header style.
-// Note: the theme elements displayed here only correspond to the standard themes of Windows XP
-
-const
-  XPMainHeaderColorUp = $DBEAEB;       // Main background color of the header if drawn as being not pressed.
-  XPMainHeaderColorDown = $D8DFDE;     // Main background color of the header if drawn as being pressed.
-  XPMainHeaderColorHover = $F3F8FA;    // Main background color of the header if drawn as being under the mouse pointer.
-  XPDarkSplitBarColor = $B2C5C7;       // Dark color of the splitter bar.
-  XPLightSplitBarColor = $FFFFFF;      // Light color of the splitter bar.
-  XPDarkGradientColor = $B8C7CB;       // Darkest color in the bottom gradient. Other colors will be interpolated.
-  XPDownOuterLineColor = $97A5A5;      // Down state border color.
-  XPDownMiddleLineColor = $B8C2C1;     // Down state border color.
-  XPDownInnerLineColor = $C9D1D0;      // Down state border color.
-
-procedure DrawXPButton(DC: HDC; ButtonR: TRect; DrawSplitter, Down, Hover: Boolean);
-
-// Helper procedure to draw an Windows XP like header button.
-
-var
-  PaintBrush: HBRUSH;
-  Pen,
-  OldPen: HPEN;
-  PenColor,
-  FillColor: COLORREF;
-  dRed, dGreen, dBlue: Single;
-  Width,
-  XPos: Integer;
-
-begin
-  if Down then
-    FillColor := XPMainHeaderColorDown
-  else
-    if Hover then
-      FillColor := XPMainHeaderColorHover
-    else
-      FillColor := XPMainHeaderColorUp;
-  PaintBrush := CreateSolidBrush(FillColor);
-  FillRect(DC, ButtonR, PaintBrush);
-  DeleteObject(PaintBrush);
-
-  if DrawSplitter and not (Down or Hover) then
-  begin
-    // One solid pen for the dark line...
-    Pen := CreatePen(PS_SOLID, 1, XPDarkSplitBarColor);
-    OldPen := SelectObject(DC, Pen);
-    MoveToEx(DC, ButtonR.Right - 2, ButtonR.Top + 3, nil);       
-    LineTo(DC, ButtonR.Right - 2, ButtonR.Bottom - 5);
-    // ... and one solid pen for the light line.
-    Pen := CreatePen(PS_SOLID, 1, XPLightSplitBarColor);
-    DeleteObject(SelectObject(DC, Pen));
-    MoveToEx(DC, ButtonR.Right - 1, ButtonR.Top + 3, nil);
-    LineTo(DC, ButtonR.Right - 1, ButtonR.Bottom - 5);
-    SelectObject(DC, OldPen);
-    DeleteObject(Pen);
-  end;
-
-  if Down then
-  begin
-    // Down state. Three lines to draw.
-    // First one is the outer line, drawn at left, bottom and right.
-    Pen := CreatePen(PS_SOLID, 1, XPDownOuterLineColor);
-    OldPen := SelectObject(DC, Pen);
-    MoveToEx(DC, ButtonR.Left, ButtonR.Top, nil);       
-    LineTo(DC, ButtonR.Left, ButtonR.Bottom - 1);
-    LineTo(DC, ButtonR.Right - 1, ButtonR.Bottom - 1);
-    LineTo(DC, ButtonR.Right - 1, ButtonR.Top - 1);
-
-    // Second one is the middle line, which is a bit lighter.
-    Pen := CreatePen(PS_SOLID, 1, XPDownMiddleLineColor);
-    DeleteObject(SelectObject(DC, Pen));
-    MoveToEx(DC, ButtonR.Left + 1, ButtonR.Bottom - 2, nil);
-    LineTo(DC, ButtonR.Left + 1, ButtonR.Top);
-    LineTo(DC, ButtonR.Right - 1, ButtonR.Top);
-
-    // Third line is the inner line, which is even lighter than the middle line.
-    Pen := CreatePen(PS_SOLID, 1, XPDownInnerLineColor);
-    DeleteObject(SelectObject(DC, Pen));
-    MoveToEx(DC, ButtonR.Left + 2, ButtonR.Bottom - 2, nil);
-    LineTo(DC, ButtonR.Left + 2, ButtonR.Top + 1);
-    LineTo(DC, ButtonR.Right - 1, ButtonR.Top + 1);
-
-    // Housekeeping:
-    SelectObject(DC, OldPen);
-    DeleteObject(Pen);
-  end
-  else
-    if Hover then
-    begin
-      // Hover state. There are three lines at the bottom border, but they are rendered in a way which
-      // requires expensive construction. 
-      Width := ButtonR.Right - ButtonR.Left;
-      if Width &lt;= 32 then
-      begin
-        ImageList_DrawEx(UtilityImages.Handle, 8, DC, ButtonR.Right - 16, ButtonR.Bottom - 3, 16, 3, CLR_NONE, CLR_NONE,
-          ILD_NORMAL);
-        ImageList_DrawEx(UtilityImages.Handle, 6, DC, ButtonR.Left, ButtonR.Bottom - 3, Width div 2, 3, CLR_NONE,
-          CLR_NONE, ILD_NORMAL);
-      end
-      else
-      begin
-        ImageList_DrawEx(UtilityImages.Handle, 6, DC, ButtonR.Left, ButtonR.Bottom - 3, 16, 3, CLR_NONE, CLR_NONE,
-          ILD_NORMAL);
-        // Replicate inner part as many times as need to fill up the button rectangle.
-        XPos := ButtonR.Left + 16;
-        repeat
-          ImageList_DrawEx(UtilityImages.Handle, 7, DC, XPos, ButtonR.Bottom - 3, 16, 3, CLR_NONE, CLR_NONE, ILD_NORMAL);
-          Inc(XPos, 16);
-        until XPos + 16 &gt;= ButtonR.Right;
-        ImageList_DrawEx(UtilityImages.Handle, 8, DC, ButtonR.Right - 16, ButtonR.Bottom - 3, 16, 3, CLR_NONE, CLR_NONE,
-          ILD_NORMAL);                                 
-      end;
-    end
-    else
-    begin
-      // There is a three line gradient near the bottom border which transforms from the button color to a dark,
-      // clBtnFace like color (here XPDarkGradientColor).
-      PenColor := XPMainHeaderColorUp;
-      dRed := ((PenColor and $FF) - (XPDarkGradientColor and $FF)) / 3;
-      dGreen := (((PenColor shr 8) and $FF) - ((XPDarkGradientColor shr 8) and $FF)) / 3;
-      dBlue := (((PenColor shr 16) and $FF) - ((XPDarkGradientColor shr 16) and $FF)) / 3;
-
-      // First line:
-      PenColor := PenColor - Round(dRed) - Round(dGreen) shl 8 - Round(dBlue) shl 16;
-      Pen := CreatePen(PS_SOLID, 1, PenColor);
-      OldPen := SelectObject(DC, Pen);
-      MoveToEx(DC, ButtonR.Left, ButtonR.Bottom - 3, nil);
-      LineTo(DC, ButtonR.Right, ButtonR.Bottom - 3);
-
-      // Second line:
-      PenColor := PenColor - Round(dRed) - Round(dGreen) shl 8 - Round(dBlue) shl 16;
-      Pen := CreatePen(PS_SOLID, 1, PenColor);
-      DeleteObject(SelectObject(DC, Pen));
-      MoveToEx(DC, ButtonR.Left, ButtonR.Bottom - 2, nil);
-      LineTo(DC, ButtonR.Right, ButtonR.Bottom - 2);
-
-      // Third line:
-      Pen := CreatePen(PS_SOLID, 1, XPDarkGradientColor);
-      DeleteObject(SelectObject(DC, Pen));
-      MoveToEx(DC, ButtonR.Left, ButtonR.Bottom - 1, nil);
-      LineTo(DC, ButtonR.Right, ButtonR.Bottom - 1);
-
-      // Housekeeping:
-      DeleteObject(SelectObject(DC, OldPen));
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.PaintHeader(DC: HDC; R: TRect; HOffset: Integer; VOffset: Integer = 0);
-
-// Main paint method to draw the header.
-
-const
-  SortGlyphs: array[TSortDirection, Boolean] of Integer = ( // ascending/descending, normal/XP style
-    (3, 5) {ascending}, (2, 4) {descending}
-  );
-
-var
-  I, Y,
-  SortIndex: Integer;
-  Run: TRect;
-  RightBorderFlag,
-  NormalButtonStyle,
-  NormalButtonFlags,
-  PressedButtonStyle,
-  PressedButtonFlags,
-  RaisedButtonStyle,
-  RaisedButtonFlags: Cardinal;
-  DrawFormat: Cardinal;
-  Images: TImageList;
-  ButtonRgn: HRGN;
-  OwnerDraw,
-  AdvancedOwnerDraw: Boolean;
-  {$ifdef ThemeSupport}
-    Details: TThemedElementDetails;
-  {$endif ThemeSupport}
-
-  PaintInfo: THeaderPaintInfo;
-  RequestedElements,
-  ActualElements: THeaderPaintElements;
-
-  SavedDC: Integer;
-  
-begin
-  Run := FHeader.Treeview.FHeaderRect;
-  FHeaderBitmap.Width := Max(Run.Right, R.Right - R.Left);
-  FHeaderBitmap.Height := Run.Bottom;
-  OwnerDraw := (hoOwnerDraw in FHeader.FOptions) and Assigned(FHeader.Treeview.FOnHeaderDraw) and
-    not (csDesigning in FHeader.Treeview.ComponentState);
-  AdvancedOwnerDraw := (hoOwnerDraw in FHeader.FOptions) and Assigned(FHeader.Treeview.FOnAdvancedHeaderDraw) and
-    Assigned(FHeader.Treeview.FOnHeaderDrawQueryElements) and not (csDesigning in FHeader.Treeview.ComponentState);
-  // If both draw posibillities are specified then prefer the advanced way.
-  if AdvancedOwnerDraw then
-    OwnerDraw := False;
-
-  ZeroMemory(@PaintInfo, SizeOf(PaintInfo));
-  PaintInfo.TargetCanvas := FHeaderBitmap.Canvas;
-
-  with PaintInfo, TargetCanvas do
-  begin
-    Font := FHeader.FFont;
-
-    RaisedButtonStyle := 0;
-    RaisedButtonFlags := 0;
-    case FHeader.Style of
-      hsThickButtons:
-        begin
-          NormalButtonStyle := BDR_RAISEDINNER or BDR_RAISEDOUTER;
-          NormalButtonFlags := BF_LEFT or BF_TOP or BF_BOTTOM or BF_MIDDLE or BF_SOFT or BF_ADJUST;
-          PressedButtonStyle := BDR_RAISEDINNER or BDR_RAISEDOUTER;
-          PressedButtonFlags := NormalButtonFlags or BF_RIGHT or BF_FLAT or BF_ADJUST;
-        end;
-      hsFlatButtons:
-        begin
-          NormalButtonStyle := BDR_RAISEDINNER;
-          NormalButtonFlags := BF_LEFT or BF_TOP or BF_BOTTOM or BF_MIDDLE or BF_ADJUST;
-          PressedButtonStyle := BDR_SUNKENOUTER;
-          PressedButtonFlags := BF_RECT or BF_MIDDLE or BF_ADJUST;
-        end;
-    else
-      // hsPlates or hsXPStyle, values are not used in the latter case
-      begin
-        NormalButtonStyle := BDR_RAISEDINNER;
-        NormalButtonFlags := BF_RECT or BF_MIDDLE or BF_SOFT or BF_ADJUST;
-        PressedButtonStyle := BDR_SUNKENOUTER;
-        PressedButtonFlags := BF_RECT or BF_MIDDLE or BF_ADJUST;
-        RaisedButtonStyle := BDR_RAISEDINNER;
-        RaisedButtonFlags := BF_LEFT or BF_TOP or BF_BOTTOM or BF_MIDDLE or BF_ADJUST;
-      end;
-    end;
-
-    // Use shortcut for the images.
-    Images := FHeader.FImages;
-
-    // Consider right-to-left directionality.
-    with FHeader.Treeview do
-      if (BidiMode &lt;&gt; bdLeftToRight) and (Integer(FRangeY) &gt; ClientHeight) then
-        Inc(HOffset, GetSystemMetrics(SM_CXVSCROLL));
-
-    // Erase background of the header.
-    // See if the application wants to do that on its own.
-    RequestedElements := [];
-    if AdvancedOwnerDraw then
-    begin
-      PaintInfo.PaintRectangle := R;
-      PaintInfo.Column := nil;
-      FHeader.Treeview.DoHeaderDrawQueryElements(PaintInfo, RequestedElements);
-    end;
-
-    if hpeBackground in RequestedElements then
-    begin
-      FHeader.Treeview.DoAdvancedHeaderDraw(PaintInfo, [hpeBackground]);
-    end
-    else
-    begin
-      {$ifdef ThemeSupport}
-        if tsUseThemes in FHeader.Treeview.FStates then
-        begin
-          Details := ThemeServices.GetElementDetails(thHeaderItemRightNormal);
-          ThemeServices.DrawElement(Handle, Details, R, @R);
-        end
-        else
-      {$endif ThemeSupport}
-        if FHeader.Style = hsXPStyle then
-          DrawXPButton(Handle, Run, False, False, False)
-        else
-        begin
-          Brush.Color := FHeader.FBackground;
-          FillRect(R);
-        end;
-    end;
-    
-    Run.Top := R.Top;
-    Run.Right := R.Left + HOffset;
-    Run.Bottom := R.Bottom;
-    // Run.Left is set in the loop
-
-    ShowRightBorder := (FHeader.Style = hsThickButtons) or not (hoAutoResize in FHeader.FOptions) or
-      (FHeader.Treeview.BevelKind = bkNone);
-
-    // now go for each button
-    for I := 0 to Count - 1 do
-      with Items[FPositionToIndex[I]] do
-        if coVisible in FOptions then
-        begin
-          Run.Left := Run.Right;
-          Inc(Run.Right, Width);
-          // Skip columns which are not visible at all.
-          if Run.Right &gt; R.Left then
-          begin
-            // Stop painting if the rectangle is filled.
-            if Run.Left &gt; R.Right then
-              Break;
-
-            IsHoverIndex := (Integer(FPositionToIndex[I]) = FHoverIndex) and (hoHotTrack in FHeader.FOptions) and
-              (coEnabled in FOptions);
-            IsDownIndex := Integer(FPositionToIndex[I]) = FDownIndex;
-            if (coShowDropMark in FOptions) and (Integer(FPositionToIndex[I]) = FDropTarget) and
-              (Integer(FPositionToIndex[I]) &lt;&gt; FDragIndex) then
-            begin
-              if FDropBefore then
-                DropMark := dmmLeft
-              else
-                DropMark := dmmRight;
-            end
-            else
-              DropMark := dmmNone;
-            IsEnabled := (coEnabled in FOptions) and (FHeader.Treeview.Enabled);
-            ShowHeaderGlyph := (hoShowImages in FHeader.FOptions) and Assigned(Images) and (FImageIndex &gt; -1);
-            ShowSortGlyph := (Integer(FPositionToIndex[I]) = FHeader.FSortColumn) and (hoShowSortGlyphs in FHeader.FOptions);
-
-            PaintRectangle := Run;
-
-            // This path for text columns or advanced owner draw.
-            if (Style = vsText) or not OwnerDraw or AdvancedOwnerDraw then
-            begin
-              // See if the application wants to draw part of the header itself.
-              RequestedElements := [];
-              if AdvancedOwnerDraw then
-              begin
-                PaintInfo.Column := Items[FPositionToIndex[I]];
-                FHeader.Treeview.DoHeaderDrawQueryElements(PaintInfo, RequestedElements);
-              end;
-
-              if ShowRightBorder or (I &lt; Count - 1) then
-                RightBorderFlag := BF_RIGHT
-              else
-                RightBorderFlag := 0;
-
-              if hpeBackground in RequestedElements then
-                FHeader.Treeview.DoAdvancedHeaderDraw(PaintInfo, [hpeBackground])
-              else
-              begin
-                // Draw button first before setting the clip region.
-                {$ifdef ThemeSupport}
-                  if tsUseThemes in FHeader.Treeview.FStates then
-                  begin
-                    if IsDownIndex then
-                      Details := ThemeServices.GetElementDetails(thHeaderItemPressed)
-                    else
-                      if IsHoverIndex then
-                        Details := ThemeServices.GetElementDetails(thHeaderItemHot)
-                      else
-                        Details := ThemeServices.GetElementDetails(thHeaderItemNormal);
-                    ThemeServices.DrawElement(Handle, Details, PaintRectangle, @PaintRectangle);
-                  end
-                  else
-                {$endif ThemeSupport}
-                begin
-                  if FHeader.Style = hsXPStyle then
-                    DrawXPButton(Handle, PaintRectangle, RightBorderFlag &lt;&gt; 0, IsDownIndex, IsHoverIndex)
-                  else
-                    if IsDownIndex then
-                      DrawEdge(Handle, PaintRectangle, PressedButtonStyle, PressedButtonFlags)
-                    else
-                      // Plates have the special case of raising on mouse over.
-                      if (FHeader.Style = hsPlates) and IsHoverIndex and
-                        (coAllowClick in FOptions) and (coEnabled in FOptions) then
-                        DrawEdge(Handle, PaintRectangle, RaisedButtonStyle, RaisedButtonFlags or RightBorderFlag)
-                      else
-                        DrawEdge(Handle, PaintRectangle, NormalButtonStyle, NormalButtonFlags or RightBorderFlag);
-                end;
-              end;
-            end;
-
-            // Create a clip region to avoid overpainting any other area which does not belong to this column.
-            if PaintRectangle.Right &gt; R.Right then
-              PaintRectangle.Right := R.Right;
-            if PaintRectangle.Left &lt; R.Left then
-              PaintRectangle.Left := R.Left;
-            ButtonRgn := CreateRectRgnIndirect(PaintRectangle);
-            SelectClipRgn(Handle, ButtonRgn);
-            DeleteObject(ButtonRgn);
-
-            PaintRectangle := Run;
-            if (Style = vsText) or not OwnerDraw or AdvancedOwnerDraw then
-            begin
-              // calculate text and glyph position
-              InflateRect(PaintRectangle, -2, -2);
-              DrawFormat := DT_LEFT or DT_TOP;
-              if UseRightToLeftReading then
-                DrawFormat := DrawFormat + DT_RTLREADING;
-              ComputeHeaderLayout(Handle, PaintRectangle, ShowHeaderGlyph, ShowSortGlyph, GlyphPos, SortGlyphPos,
-                TextRectangle);
-
-              // Move glyph and text one pixel to the right and down to simulate a pressed button.
-              if IsDownIndex then
-              begin
-                OffsetRect(TextRectangle, 1, 1);
-                Inc(GlyphPos.X);
-                Inc(GlyphPos.Y);
-                Inc(SortGlyphPos.X);
-                Inc(SortGlyphPos.Y);
-              end;
-
-              // Advanced owner draw allows to paint elements, which would normally not be painted (because of space
-              // limitations, empty captions etc.).
-              ActualElements := RequestedElements * [hpeHeaderGlyph, hpeSortGlyph, hpeDropMark, hpeText];
-
-              // main glyph
-              if not (hpeHeaderGlyph in ActualElements) and ShowHeaderGlyph and
-                (not ShowSortGlyph or (FBidiMode &lt;&gt; bdLeftToRight) or (GlyphPos.X + Images.Width &lt;= SortGlyphPos.X)) then
-                Images.Draw(FHeaderBitmap.Canvas, GlyphPos.X, GlyphPos.Y, FImageIndex, IsEnabled);
-
-              // caption
-              if not (hpeText in ActualElements) and (Length(Text) &gt; 0) then
-                DrawButtonText(Handle, Text, TextRectangle, IsEnabled, IsHoverIndex and (hoHotTrack in FHeader.FOptions) and
-                not (tsUseThemes in FHeader.Treeview.FStates), DrawFormat);
-
-              // sort glyph
-              if not (hpeSortGlyph in ActualElements) and ShowSortGlyph then
-              begin
-                SortIndex := SortGlyphs[FHeader.FSortDirection, tsUseThemes in FHeader.Treeview.FStates];
-                UtilityImages.Draw(FHeaderBitmap.Canvas, SortGlyphPos.X, SortGlyphPos.Y, SortIndex);
-              end;
-
-              // Show an indication if this column is the current drop target in a header drag operation.
-              if not (hpeDropMark in ActualElements) and (DropMark &lt;&gt; dmmNone) then
-              begin
-                Y := (PaintRectangle.Top + PaintRectangle.Bottom - UtilityImages.Height) div 2;
-                if DropMark = dmmLeft then
-                  UtilityImages.Draw(FHeaderBitmap.Canvas, PaintRectangle.Left, Y, 0)
-                else
-                  UtilityImages.Draw(FHeaderBitmap.Canvas, PaintRectangle.Right - 16 , Y,  1);
-              end;
-
-              if ActualElements &lt;&gt; [] then
-              begin
-                SavedDC := SaveDC(Handle);
-                FHeader.Treeview.DoAdvancedHeaderDraw(PaintInfo, ActualElements);
-                RestoreDC(Handle, SavedDC);
-              end;
-            end
-            else // Let application draw the header.
-              FHeader.Treeview.DoHeaderDraw(FHeaderBitmap.Canvas, Items[FPositionToIndex[I]], PaintRectangle, IsHoverIndex,
-                IsDownIndex, DropMark);
-            SelectClipRgn(Handle, 0);
-          end;
-        end;
-
-    // Blit the result to target.
-    with R do
-      BitBlt(DC, Left, Top, Right - Left, Bottom - Top, Handle, Left, Top, SRCCOPY);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualTreeColumns.SaveToStream(const Stream: TStream);
-
-var
-  I: Integer;
-
-begin
-  I := Count;
-  Stream.WriteBuffer(I, SizeOf(I));
-  if I &gt; 0 then
-  begin
-    for I := 0 to Count - 1 do
-      TVirtualTreeColumn(Items[I]).SaveToStream(Stream);
-
-    Stream.WriteBuffer(FPositionToIndex[0], Count * SizeOf(Cardinal));
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualTreeColumns.TotalWidth: Integer;
-
-var
-  LastColumn: TColumnIndex;
-
-begin
-  if Count = 0 then
-    Result := 0
-  else
-  begin
-    LastColumn := FPositionToIndex[Count - 1];
-    if not (coVisible in Items[LastColumn].FOptions) then
-      LastColumn := GetPreviousVisibleColumn(LastColumn);
-    if LastColumn &gt; NoColumn then
-      with Items[LastColumn] do
-        Result := FLeft + FWidth
-    else
-      Result := 0;
-  end;
-end;
-
-//----------------- TVTHeader -----------------------------------------------------------------------------------------
-
-constructor TVTHeader.Create(AOwner: TBaseVirtualTree);
-
-begin
-  inherited Create;
-  FOwner := AOwner;
-  FColumns := GetColumnsClass.Create(Self);
-  FHeight := 17;
-  FFont := TFont.Create;
-  FFont.OnChange := FontChanged;
-  FBackground := clBtnFace;
-  FOptions := [hoColumnResize, hoDrag];
-
-  FImageChangeLink := TChangeLink.Create;
-  FImageChangeLink.OnChange := ImageListChange;
-
-  FSortColumn := NoColumn;
-  FSortDirection := sdAscending;
-  FMainColumn := NoColumn;
-
-  FDragImage := TVTDragImage.Create(AOwner);
-  with FDragImage do
-  begin
-    Fade := False;
-    PostBlendBias := 0;
-    PreBlendBias := -50;
-    Transparency := 140;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TVTHeader.Destroy;
-
-begin
-  FDragImage.Free;
-  FImageChangeLink.Free;
-  FFont.Free;
-  FColumns.Clear; // TCollection's Clear method is not virtual, so we have to call our own Clear method manually.
-  FColumns.Free;
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.FontChanged(Sender: TObject);
-
-begin
-  Invalidate(nil);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTHeader.GetMainColumn: TColumnIndex;
-
-begin
-  if FColumns.Count &gt; 0 then
-    Result := FMainColumn
-  else
-    Result := NoColumn;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTHeader.GetUseColumns: Boolean;
-
-begin
-  Result := FColumns.Count &gt; 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetAutoSizeIndex(Value: TColumnIndex);
-
-begin
-  if FAutoSizeIndex &lt;&gt; Value then
-  begin
-    FAutoSizeIndex := Value;
-    if hoAutoResize in FOptions then
-      Columns.AdjustAutoSize(InvalidColumn);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetBackground(Value: TColor);
-
-begin
-  if FBackground &lt;&gt; Value then
-  begin
-    FBackground := Value;
-    Invalidate(nil);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetColumns(Value: TVirtualTreeColumns);
-
-begin
-  FColumns.Assign(Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetFont(const Value: TFont);
-
-begin
-  FFont.Assign(Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetHeight(Value: Cardinal);
-
-begin
-  if FHeight &lt;&gt; Value then
-  begin
-    FHeight := Value;
-    if not (csLoading in Treeview.ComponentState) then
-      RecalculateHeader;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetImages(const Value: TImageList);
-
-begin
-  if FImages &lt;&gt; Value then
-  begin
-    if Assigned(FImages) then
-    begin
-      FImages.UnRegisterChanges(FImageChangeLink);
-      {$ifdef COMPILER_5_UP}
-        FImages.RemoveFreeNotification(FOwner);
-      {$endif COMPILER_5_UP}
-    end;
-    FImages := Value;
-    if Assigned(FImages) then
-    begin
-      FImages.RegisterChanges(FImageChangeLink);
-      FImages.FreeNotification(FOwner);
-    end;
-    if not (csLoading in Treeview.ComponentState) then
-      Invalidate(nil);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetMainColumn(Value: TColumnIndex);
-
-begin
-  if csLoading in Treeview.ComponentState then
-    FMainColumn := Value
-  else
-  begin
-    if Value &lt; 0 then
-      Value := 0;
-    if Value &gt; FColumns.Count - 1 then
-      Value := FColumns.Count - 1;
-    if Value &lt;&gt; FMainColumn then
-    begin
-      FMainColumn := Value;
-      if not (csLoading in Treeview.ComponentState) then
-      begin
-        Treeview.MainColumnChanged;
-        if not (toExtendedFocus in Treeview.FOptions.FSelectionOptions) then
-          Treeview.FocusedColumn := FMainColumn;
-        Treeview.Invalidate;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetOptions(Value: TVTHeaderOptions);
-
-var
-  ToBeSet,
-  ToBeCleared: TVTHeaderOptions;
-
-begin
-  ToBeSet := Value - FOptions;
-  ToBeCleared := FOptions - Value;
-  FOptions := Value;
-
-  if (hoAutoResize in (ToBeSet + ToBeCleared)) and (FColumns.Count &gt; 0) then
-  begin
-    FColumns.AdjustAutoSize(InvalidColumn);
-    if Treeview.HandleAllocated then
-    begin
-      Treeview.UpdateHorizontalScrollBar(False);
-      if hoAutoResize in ToBeSet then
-        Treeview.Invalidate;
-    end;
-  end;
-
-  if not (csLoading in Treeview.ComponentState) and Treeview.HandleAllocated then
-  begin
-    if hoVisible in (ToBeSet + ToBeCleared) then
-      RecalculateHeader;
-    Invalidate(nil);
-    Treeview.Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetSortColumn(Value: TColumnIndex);
-
-begin
-  if csLoading in Treeview.ComponentState then
-    FSortColumn := Value
-  else
-  begin
-    if Value &lt; NoColumn then
-      Value := NoColumn;
-    if Value &gt; Columns.Count - 1 then
-      Value := Columns.Count - 1;
-    if FSortColumn &lt;&gt; Value then
-    begin
-      if FSortColumn &gt; NoColumn then
-        Invalidate(Columns[FSortColumn]);
-      FSortColumn := Value;
-      if FSortColumn &gt; NoColumn then
-        Invalidate(Columns[FSortColumn]);
-      if (toAutoSort in Treeview.FOptions.FAutoOptions) and (Treeview.FUpdateCount = 0) then
-        Treeview.SortTree(FSortColumn, FSortDirection, True);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetSortDirection(const Value: TSortDirection);
-
-begin
-  if Value &lt;&gt; FSortDirection then
-  begin
-    FSortDirection := Value;
-    Invalidate(nil);
-    if (toAutoSort in Treeview.FOptions.FAutoOptions) and (Treeview.FUpdateCount = 0) then
-      Treeview.SortTree(FSortColumn, FSortDirection, True);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SetStyle(Value: TVTHeaderStyle);
-
-begin
-  if FStyle &lt;&gt; Value then
-  begin
-    FStyle := Value;
-    if not (csLoading in Treeview.ComponentState) then
-      Invalidate(nil);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTHeader.CanWriteColumns: Boolean;
-
-// Descentants may override this to optionally prevent column writing (e.g. if they are build dynamically).
-
-begin
-  Result := True;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.ChangeScale(M, D: Integer);
-
-begin
-  FFont.Size := MulDiv(FFont.Size, M, D);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTHeader.DetermineSplitterIndex(P: TPoint): Boolean;
-
-// Tries to find the index of that column whose right border corresponds to P.
-// Result is True if column border was hit (with -3..+5 pixels tolerance).
-// For continuous resizing the current track index and the column's left border are set.
-// Note: The hit test is checking from right to left to make enlarging of zero-sized columns possible.
-
-var
-  I,
-  SplitPoint: Integer;
-
-begin
-  Result := False;
-  FColumns.FTrackIndex := NoColumn;
-
-  if FColumns.Count &gt; 0 then
-  begin
-    SplitPoint := Treeview.FOffsetX + Integer(Treeview.FRangeX);
-
-    for I := FColumns.Count - 1 downto 0 do
-      with FColumns, Items[FPositionToIndex[I]] do
-        if coVisible in FOptions then
-        begin
-          if (P.X &lt; SplitPoint + 5) and (P.X &gt; SplitPoint - 3) then
-          begin
-            if coResizable in FOptions then
-            begin
-              Result := True;
-              FTrackIndex := FPositionToIndex[I];
-              FLeftTrackPos := SplitPoint - FWidth;
-            end;
-            Break;
-          end;
-          Dec(SplitPoint, FWidth);
-        end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.DragTo(P: TPoint);
-
-// Moves the drag image to a new position, which is determined from the passed point P and the previous
-// mouse position.
-
-var
-  I,
-  NewTarget: Integer;
-  // optimized drag image move support
-  ClientP: TPoint;
-  Left,
-  Right: Integer;
-  NeedRepaint: Boolean; // True if the screen needs an update (changed drop target or drop side)
-
-begin
-  // Determine new drop target and which side of it is prefered.
-  ClientP := Treeview.ScreenToClient(P);
-  // Make coordinates relative to (0, 0) of the non-client area.
-  Inc(ClientP.Y, FHeight);
-  NewTarget := FColumns.ColumnFromPosition(ClientP);
-  NeedRepaint := (NewTarget &lt;&gt; InvalidColumn) and (NewTarget &lt;&gt; FColumns.FDropTarget);
-  if NewTarget &gt;= 0 then
-  begin
-    FColumns.GetColumnBounds(NewTarget, Left, Right);
-    if (ClientP.X &lt; ((Left + Right) div 2)) &lt;&gt; FColumns.FDropBefore then
-    begin
-      NeedRepaint := True;
-      FColumns.FDropBefore := not FColumns.FDropBefore;
-    end;
-  end;
-
-  if NeedRepaint then
-  begin
-    // Invalidate columns which need a repaint.
-    if FColumns.FDropTarget &gt; NoColumn then
-    begin
-      I := FColumns.FDropTarget;
-      FColumns.FDropTarget := NoColumn;
-      Invalidate(FColumns.Items[I]);
-    end;
-    if (NewTarget &gt; NoColumn) and (NewTarget &lt;&gt; FColumns.FDropTarget) then
-    begin
-      Invalidate(FColumns.Items[NewTarget]);
-      FColumns.FDropTarget := NewTarget;
-    end;
-  end;
-
-  FDragImage.DragTo(P, NeedRepaint);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTHeader.GetColumnsClass: TVirtualTreeColumnsClass;
-
-// Returns the class to be used for the actual column implementation. Descentants may optionally override this and
-// return their own class.
-
-begin
-  Result := TVirtualTreeColumns;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTHeader.GetOwner: TPersistent;
-
-begin
-  Result := FOwner;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTHeader.GetShiftState: TShiftState;
-
-begin
-  Result := [];
-  if GetKeyState(VK_SHIFT) &lt; 0 then
-    Include(Result, ssShift);
-  if GetKeyState(VK_CONTROL) &lt; 0 then
-    Include(Result, ssCtrl);
-  if GetKeyState(VK_MENU) &lt; 0 then
-    Include(Result, ssAlt);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTHeader.HandleHeaderMouseMove(var Message: TWMMouseMove): Boolean;
-
-var
-  P: TPoint;
-  I: Integer;
-  
-begin
-  Result := False;
-  with Message do
-  begin
-    P := Point(XPos, YPos);
-    if hsTrackPending in FStates then
-    begin
-      Treeview.StopTimer(HeaderTimer);
-      FStates := FStates - [hsTrackPending] + [hsTracking];
-      HandleHeaderMouseMove := True;
-      Result := 0;
-    end
-    else
-      if hsTracking in FStates then
-      begin
-        FColumns[FColumns.FTrackIndex].Width := XPos - FLeftTrackPos;
-        HandleHeaderMouseMove := True;
-        Result := 0;
-      end
-      else
-      begin
-        if hsDragPending in FStates then
-        begin
-          P := Treeview.ClientToScreen(P);
-          // start actual dragging if allowed
-          if (hoDrag in FOptions) and Treeview.DoHeaderDragging(FColumns.FDownIndex) then
-          begin
-            if ((Abs(FDragStart.X - P.X) &gt; Mouse.DragThreshold) or
-               (Abs(FDragStart.Y - P.Y) &gt; Mouse.DragThreshold)) then
-            begin
-              Treeview.StopTimer(HeaderTimer);
-              I := FColumns.FDownIndex;
-              FColumns.FDownIndex := NoColumn;
-              FColumns.FHoverIndex := NoColumn;
-              if I &gt; NoColumn then
-                Invalidate(FColumns[I]);
-              PrepareDrag(P, FDragStart);
-              FStates := FStates - [hsDragPending] + [hsDragging];
-              HandleHeaderMouseMove := True;
-              Result := 0;
-            end;
-          end;
-        end
-        else
-          if hsDragging in FStates then
-          begin
-            DragTo(Treeview.ClientToScreen(Point(XPos, YPos)));
-            HandleHeaderMouseMove := True;
-            Result := 0;
-          end;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTHeader.HandleMessage(var Message: TMessage): Boolean;
-
-// The header gets here the opportunity to handle certain messages before they reach the tree. This is important
-// because the tree needs to handle various non-client area messages for the header as well as some dragging/tracking
-// events.
-// By returning True the message will not be handled further, otherwise the message is then dispatched
-// to the proper message handlers.
-
-var
-  P: TPoint;
-  R: TRect;
-  I: Integer;
-  OldPosition: Integer;
-  HitIndex: TColumnIndex;
-  NewCursor: HCURSOR;
-  Button: TMouseButton;
-
-begin
-  Result := False;
-  case Message.Msg of
-    WM_SIZE:
-      begin
-        if (hoAutoResize in FOptions) and not (hsAutoSizing in FStates) and
-          not (tsWindowCreating in FOwner.FStates) then
-        begin
-          FColumns.AdjustAutoSize(InvalidColumn);
-          Invalidate(nil);
-        end;
-      end;
-    CM_BIDIMODECHANGED:
-      for I := 0 to FColumns.Count - 1 do
-        if coParentBiDiMode in FColumns[I].FOptions then
-          FColumns[I].ParentBiDiModeChanged;
-    WM_NCMBUTTONDOWN:
-      begin
-        with TWMNCMButtonDown(Message) do
-          P := Treeview.ScreenToClient(Point(XCursor, YCursor));
-        if InHeader(P) then
-          FOwner.DoHeaderMouseDown(mbMiddle, GetShiftState, P.X, P.Y + Integer(FHeight));
-      end;
-    WM_NCMBUTTONUP:
-      begin
-        with TWMNCMButtonUp(Message) do
-          P := FOwner.ScreenToClient(Point(XCursor, YCursor));
-        if InHeader(P) then
-        begin
-          FColumns.HandleClick(P, mbMiddle, True, False);
-          FOwner.DoHeaderMouseUp(mbMiddle, GetShiftState, P.X, P.Y + Integer(FHeight));
-          FColumns.FDownIndex := NoColumn;
-        end;
-      end;
-    WM_NCLBUTTONDBLCLK,
-    WM_NCMBUTTONDBLCLK,
-    WM_NCRBUTTONDBLCLK:
-      begin
-        with TWMNCLButtonDblClk(Message) do
-          P := FOwner.ScreenToClient(Point(XCursor, YCursor));
-        // If the click was on a splitter then resize column do smallest width.
-        if InHeader(P) then
-        begin
-          case Message.Msg of
-            WM_NCMBUTTONDBLCLK:
-              Button := mbMiddle;
-            WM_NCRBUTTONDBLCLK:
-              Button := mbRight;
-          else
-            // WM_NCLBUTTONDBLCLK
-            Button := mbLeft;
-          end;
-          if (hoDblClickResize in FOptions) and (FColumns.FTrackIndex &gt; NoColumn) then
-          begin
-            with FColumns do
-              AnimatedResize(FTrackIndex, Max(FColumns[FTrackIndex].MinWidth, Treeview.GetMaxColumnWidth(FTrackIndex)));
-          end
-          else
-            FColumns.HandleClick(P, Button, True, True);
-          FOwner.DoHeaderDblClick(FColumns.FClickIndex, Button, GetShiftState + [ssDouble], P.X, P.Y + Integer(FHeight));
-        end;
-      end;
-    WM_NCLBUTTONDOWN:
-      begin
-        Application.CancelHint;
-
-        // make sure no auto scrolling is active...
-        Treeview.StopTimer(ScrollTimer);
-        Treeview.DoStateChange([], [tsScrollPending, tsScrolling]);
-        // ... pending editing is cancelled (actual editing remains active)
-        Treeview.StopTimer(EditTimer);
-        Treeview.DoStateChange([], [tsEditPending]);
-
-        with TWMNCLButtonDown(Message) do
-        begin
-          // want the drag start point in screen coordinates
-          FDragStart := Point(XCursor, YCursor);
-          P := Treeview.ScreenToClient(FDragStart);
-        end;
-
-        if InHeader(P) then
-        begin
-          // This is a good opportunity to notify the application.
-          FOwner.DoHeaderMouseDown(mbLeft, GetShiftState, P.X, P.Y + Integer(FHeight));
-
-          if DetermineSplitterIndex(P) and (hoColumnResize in FOptions) then
-          begin
-            FColumns.FHoverIndex := NoColumn;
-            FTrackStart := P;
-            Include(FStates, hsTrackPending);
-            SetCapture(Treeview.Handle);
-            Result := True;
-            Message.Result := 0;
-          end
-          else
-          begin
-            HitIndex := Columns.AdjustDownColumn(P);
-            if (hoDrag in FOptions) and (HitIndex &gt; NoColumn) and (coDraggable in FColumns[HitIndex].FOptions) then
-            begin
-              // Show potential drag operation.
-              // Disabled columns do not start a drag operation because they can't be clicked.
-              Include(FStates, hsDragPending);
-              SetCapture(Treeview.Handle);
-              Result := True;
-              Message.Result := 0;
-            end;
-          end;
-        end;
-      end;
-    WM_NCRBUTTONDOWN:
-      begin
-        with TWMNCRButtonDown(Message) do
-          P := FOwner.ScreenToClient(Point(XCursor, YCursor));
-        if InHeader(P) then
-          FOwner.DoHeaderMouseDown(mbRight, GetShiftState, P.X, P.Y + Integer(FHeight));
-      end;
-    WM_NCRBUTTONUP:
-      if not (csDesigning in FOwner.ComponentState) then
-        with TWMNCRButtonUp(Message) do
-        begin
-          Application.CancelHint;
-
-          P := FOwner.ScreenToClient(Point(XCursor, YCursor));
-          if InHeader(P) then
-          begin
-            FColumns.HandleClick(P, mbRight, True, False);
-            FOwner.DoHeaderMouseUp(mbRight, GetShiftState, P.X, P.Y + Integer(FHeight));
-            FColumns.FDownIndex := NoColumn;
-            FColumns.FTrackIndex := NoColumn;
-
-            // Trigger header popup if there's one.
-            if Assigned(FPopupMenu) then
-            begin
-              Treeview.StopTimer(ScrollTimer);
-              Treeview.StopTimer(HeaderTimer);
-              FColumns.FHoverIndex := NoColumn;
-              Treeview.DoStateChange([], [tsScrollPending, tsScrolling]);
-              FPopupMenu.PopupComponent := Treeview;
-              FPopupMenu.Popup(XCursor, YCursor);
-              HandleMessage := True;
-            end;
-          end;
-        end;
-    // When the tree window has an active mouse capture then we only get &quot;client-area&quot; messages.
-    WM_LBUTTONUP,
-    WM_NCLBUTTONUP:
-      begin
-        Application.CancelHint;
-
-        if FStates &lt;&gt; [] then
-        begin
-          ReleaseCapture;
-          if hsDragging in FStates then
-          begin
-            // successfull dragging moves columns
-            with TWMLButtonUp(Message) do
-              P := Treeview.ClientToScreen(Point(XPos, YPos));
-            GetWindowRect(Treeview.Handle, R);
-            with FColumns do
-            begin
-              FDragImage.EndDrag;
-              if (FDropTarget &gt; -1) and (FDropTarget &lt;&gt; FDragIndex) and PtInRect(R, P) then
-              begin
-                OldPosition := FColumns[FDragIndex].Position;
-                if FColumns.FDropBefore then
-                begin
-                  if FColumns[FDragIndex].Position &lt; FColumns[FDropTarget].Position then
-                    FColumns[FDragIndex].Position := Max(0, FColumns[FDropTarget].Position - 1)
-                  else
-                    FColumns[FDragIndex].Position := FColumns[FDropTarget].Position;
-                end
-                else
-                begin
-                  if FColumns[FDragIndex].Position &lt; FColumns[FDropTarget].Position then
-                    FColumns[FDragIndex].Position := FColumns[FDropTarget].Position
-                  else
-                    FColumns[FDragIndex].Position := FColumns[FDropTarget].Position + 1;
-                end;
-                Treeview.DoHeaderDragged(FDragIndex, OldPosition);
-              end
-              else
-                Treeview.DoHeaderDraggedOut(FDragIndex, P);
-              FDropTarget := NoColumn;
-            end;
-            Invalidate(nil);
-          end;
-          Result := True;
-          Message.Result := 0;
-        end;
-
-        case Message.Msg of
-          WM_LBUTTONUP:
-            with TWMLButtonUp(Message) do
-            begin
-              if FColumns.FDownIndex &gt; NoColumn then
-                FColumns.HandleClick(Point(XPos, YPos), mbLeft, False, False);
-              if FStates &lt;&gt; [] then
-                FOwner.DoHeaderMouseUp(mbLeft, KeysToShiftState(Keys), XPos, YPos);
-            end;
-          WM_NCLBUTTONUP:
-            with TWMNCLButtonUp(Message) do
-            begin
-              P := FOwner.ScreenToClient(Point(XCursor, YCursor));
-              FColumns.HandleClick(P, mbLeft, False, False);
-              FOwner.DoHeaderMouseUp(mbLeft, GetShiftState, P.X, P.Y + Integer(FHeight));
-            end;
-        end;
-
-        if FColumns.FTrackIndex &gt; NoColumn then
-        begin
-          Invalidate(Columns[FColumns.FTrackIndex]);
-          FColumns.FTrackIndex := NoColumn;
-        end;
-        if FColumns.FDownIndex &gt; NoColumn then
-        begin
-          Invalidate(Columns[FColumns.FDownIndex]);
-          FColumns.FDownIndex := NoColumn;
-        end;
-        FStates := FStates - [hsDragging, hsDragPending, hsTracking, hsTrackPending];
-      end;
-    // hovering, mouse leave detection
-    WM_NCMOUSEMOVE:
-      with TWMNCMouseMove(Message), FColumns do
-      begin
-        P := Treeview.ScreenToClient(Point(XCursor, YCursor));
-        Treeview.DoHeaderMouseMove(GetShiftState, P.X, P.Y + Integer(FHeight));
-        if InHeader(P) and ((AdjustHoverColumn(P)) or ((FDownIndex &gt;= 0) and (FHoverIndex &lt;&gt; FDownIndex))) then
-        begin
-          // We need a mouse leave detection from here for the non client area. The best solution available would be the
-          // TrackMouseEvent API. Unfortunately, it leaves Win95 totally and WinNT4 for non-client stuff out and
-          // currently I cannot ignore these systems. Hence I go the only other reliable way and use a timer
-          // (although, I don't like it...).
-          Treeview.StopTimer(HeaderTimer);
-          SetTimer(Treeview.Handle, HeaderTimer, 50, nil);
-          // use Delphi's internal hint handling for header hints too
-          if hoShowHint in FOptions then
-          begin
-            // client coordinates!
-            XCursor := P.x;
-            YCursor := P.y + Integer(FHeight);
-            Application.HintMouseMessage(Treeview, Message);
-          end;
-        end
-      end;
-    WM_TIMER:
-      if TWMTimer(Message).TimerID = HeaderTimer then
-      begin
-        // determine current mouse position to check if it left the window
-        GetCursorPos(P);
-        P := Treeview.ScreenToClient(P);
-        with FColumns do
-        begin
-          if not InHeader(P) or ((FDownIndex &gt; NoColumn) and (FHoverIndex &lt;&gt; FDownIndex)) then
-          begin
-            Treeview.StopTimer(HeaderTimer);
-            FHoverIndex := NoColumn;
-            FClickIndex := NoColumn;
-            FDownIndex := NoColumn;
-            Result := True;
-            Message.Result := 0;
-            Invalidate(nil);
-          end;
-        end;
-      end;
-    WM_MOUSEMOVE: // mouse capture and general message redirection
-      Result := HandleHeaderMouseMove(TWMMouseMove(Message));
-    WM_SETCURSOR:
-      if FStates = [] then
-      begin
-        // Retrieve last cursor position (GetMessagePos does not work here, I don't know why).
-        GetCursorPos(P);
-        // Is the mouse in the header rectangle?
-        P := Treeview.ScreenToClient(P);
-        if InHeader(P) then
-        begin
-          NewCursor := Screen.Cursors[crDefault];
-          if hoColumnResize in FOptions then
-          begin
-            if DetermineSplitterIndex(P) then
-              NewCursor := Screen.Cursors[crHeaderSplit];
-
-            Treeview.DoGetHeaderCursor(NewCursor);
-            Result := NewCursor &lt;&gt; Screen.Cursors[crDefault];
-            if Result then
-            begin
-              Windows.SetCursor(NewCursor);
-              Message.Result := 1;
-            end
-          end;
-        end;
-      end
-      else
-      begin
-        Message.Result := 1;
-        Result := True;
-      end;
-    WM_KEYDOWN,
-    WM_KILLFOCUS:
-      if (Message.Msg = WM_KILLFOCUS) or
-         (TWMKeyDown(Message).CharCode = VK_ESCAPE) then
-      begin
-        if hsDragging in FStates then
-        begin
-          ReleaseCapture;
-          FDragImage.EndDrag;
-          Exclude(FStates, hsDragging);
-          FColumns.FDropTarget := NoColumn;
-          Invalidate(nil);
-          Result := True;
-          Message.Result := 0;
-        end
-        else
-          if hsTracking in FStates then
-          begin
-            ReleaseCapture;
-            Exclude(FStates, hsTracking);
-            Result := True;
-            Message.Result := 0;
-          end;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.ImageListChange(Sender: TObject);
-
-begin
-  if not (csDestroying in Treeview.ComponentState) then
-    Invalidate(nil);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.PrepareDrag(P, Start: TPoint);
-
-// Initializes dragging of the header, P is the current mouse postion and Start the initial mouse position.
-
-var
-  ColumnR,
-  HeaderR: TRect;
-  Image: TBitmap;
-  ImagePos: TPoint;
-
-begin
-  // Determine initial position of drag image (screen coordinates).
-  FColumns.FDropTarget := NoColumn;
-  Start := Treeview.ScreenToClient(Start);
-  Inc(Start.Y, FHeight);
-  FColumns.FDragIndex := FColumns.ColumnFromPosition(Start);
-  ColumnR := FColumns[FColumns.FDragIndex].GetRect;
-
-  HeaderR := Treeview.FHeaderRect;
-  // Set right border of the header rectangle to the maximum extent.
-  HeaderR.Right := FColumns.TotalWidth;
-
-  // Take out influence of border since we need a seamless drag image.
-  OffsetRect(ColumnR, -HeaderR.Left + Treeview.FOffsetX, -HeaderR.Top);
-
-  Image := TBitmap.Create;
-  with Image do
-  try
-    PixelFormat := pf32Bit;
-    Width := ColumnR.Right - ColumnR.Left + HeaderR.Left;
-    Height := ColumnR.Bottom - ColumnR.Top + HeaderR.Top;
-
-    HeaderR.Left := 0;
-    HeaderR.Top := 0;
-
-    // Erase the entire image with the color key value, for the case not everything
-    // in the image is covered by the header image.
-    Canvas.Brush.Color := clBtnFace;
-    Canvas.FillRect(Rect(0, 0, Width, Height));
-
-    FColumns.PaintHeader(Canvas.Handle, HeaderR, -ColumnR.Left + Treeview.FOffsetX, -ColumnR.Top);
-
-    ImagePos := Treeview.ClientToScreen(ColumnR.TopLeft);
-    // Column rectangles are given in local window coordinates not client coordinates.
-    Dec(ImagePos.Y, FHeight);
-
-    if hoRestrictDrag in FOptions then
-      FDragImage.MoveRestriction := dmrHorizontalOnly
-    else
-      FDragImage.MoveRestriction := dmrNone;
-    FDragImage.PrepareDrag(Image, ImagePos, P, nil);
-    FDragImage.ShowDragImage;
-  finally
-    Image.Free;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.ReadColumns(Reader: TReader);
-
-begin
-  Include(FStates, hsLoading);
-  Columns.Clear;
-  Reader.ReadValue;
-  Reader.ReadCollection(Columns);
-  Exclude(FStates, hsLoading);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.RecalculateHeader;
-
-// Initiate a recalculation of the non-client area of the owner tree.
-
-begin
-  if Treeview.HandleAllocated then
-  begin
-    Treeview.UpdateHeaderRect;
-    SetWindowPos(Treeview.Handle, 0, 0, 0, 0, 0, SWP_FRAMECHANGED or SWP_NOMOVE or SWP_NOACTIVATE or SWP_NOOWNERZORDER or
-      SWP_NOSENDCHANGING or SWP_NOSIZE or SWP_NOZORDER);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.UpdateMainColumn;
-
-// Called once the load process of the owner tree is done.
-
-begin
-  if FMainColumn &lt; 0 then
-    FMainColumn := 0;
-  if FMainColumn &gt; FColumns.Count - 1 then
-    FMainColumn := FColumns.Count - 1;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.WriteColumns(Writer: TWriter);
-
-begin
-  Writer.WriteCollection(Columns);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.Assign(Source: TPersistent);
-
-begin
-  if Source is TVTHeader then
-  begin
-    AutoSizeIndex := TVTHeader(Source).AutoSizeIndex;
-    Background := TVTHeader(Source).Background;
-    Columns := TVTHeader(Source).Columns;
-    Font := TVTHeader(Source).Font;
-    Height := TVTHeader(Source).Height;
-    Options := TVTHeader(Source).Options;
-    PopupMenu := TVTHeader(Source).PopupMenu;
-    Style := TVTHeader(Source).Style;
-  end
-  else
-    inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.AutoFitColumns;
-
-var
-  I: Integer;
-  
-begin
-  with FColumns do
-    for I := 0 to Count - 1 do
-      if [coResizable, coVisible] * Items[FPositionToIndex[I]].FOptions = [coResizable, coVisible] then
-        AnimatedResize(FPositionToIndex[I], Treeview.GetMaxColumnWidth(FPositionToIndex[I]))
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTHeader.InHeader(P: TPoint): Boolean;
-
-// Determines whether the given point (client coordinates!) is within the header rectangle (non-client coordinates).
-
-var
-  R, RW: TRect;
-
-begin
-  R := Treeview.FHeaderRect;
-  // current position of the owner in screen coordinates
-  GetWindowRect(Treeview.Handle, RW);
-  // convert to client coordinates
-  MapWindowPoints(0, Treeview.Handle, RW, 2);
-  // consider the header within this rectangle
-  OffsetRect(R, RW.Left, RW.Top);
-  Result := PtInRect(R, P);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.Invalidate(Column: TVirtualTreeColumn; ExpandToRight: Boolean = False);
-
-// Because the header is in the non-client area of the tree it needs some special handling in order to initiate its
-// repainting.
-// If ExpandToRight is True then not only the given column but everything to its right will be invalidated (useful for
-// resizing). This makes only sense when a column is given.
-
-var
-  R, RW: TRect;
-
-begin
-  if (hoVisible in FOptions) and Treeview.HandleAllocated then
-  begin
-    if Column = nil then
-      R := Treeview.FHeaderRect
-    else
-    begin
-      R := Column.GetRect;
-      OffsetRect(R, Treeview.FOffsetX, 0);
-      if ExpandToRight then
-        R.Right := Treeview.FHeaderRect.Right;
-    end;
-
-    // Current position of the owner in screen coordinates.
-    GetWindowRect(Treeview.Handle, RW);
-    // Consider the header within this rectangle.
-    OffsetRect(R, RW.Left, RW.Top);
-    // Expressed in client coordinates (because RedrawWindow wants them so, they will actually become negative).
-    MapWindowPoints(0, Treeview.Handle, R, 2);
-    RedrawWindow(Treeview.Handle, @R, 0, RDW_FRAME or RDW_INVALIDATE or RDW_VALIDATE or RDW_NOINTERNALPAINT or
-      RDW_NOERASE or RDW_NOCHILDREN);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.LoadFromStream(const Stream: TStream);
-
-// restore the state of the header from the given stream
-
-var
-  Dummy,
-  Version: Integer;
-  S: string;
-  OldOptions: TVTHeaderOptions;
-
-begin
-  Include(FStates, hsLoading);
-  with Stream do
-  try
-    // switch off all options which could influence loading the columns (they will be later set again)
-    OldOptions := FOptions;
-    FOptions := [];
-
-    // determine whether the stream contains data without a version number
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    if Dummy &gt; -1 then
-    begin
-      // seek back to undo read operation if this is an old stream format
-      Seek(-SizeOf(Dummy), soFromCurrent);
-      Version := -1;
-    end
-    else // read version number if this is a &quot;versionized&quot; format
-      ReadBuffer(Version, SizeOf(Version));
-    Columns.LoadFromStream(Stream, Version);
-
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    AutoSizeIndex := Dummy;
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    Background := Dummy;
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    Height := Dummy;
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    FOptions := OldOptions;
-    Options := TVTHeaderOptions(Word(Dummy));
-    // PopupMenu is neither saved nor restored
-    ReadBuffer(Dummy, SizeOf(Dummy));
-    Style := TVTHeaderStyle(Dummy);
-    // TFont has no own save routine so we do it manually
-    with Font do
-    begin
-      ReadBuffer(Dummy, SizeOf(Dummy));
-      Color := Dummy;
-      ReadBuffer(Dummy, SizeOf(Dummy));
-      Height := Dummy;
-      ReadBuffer(Dummy, SizeOf(Dummy));
-      SetLength(S, Dummy);
-      ReadBuffer(PChar(S)^, Dummy);
-      Name := S;
-      ReadBuffer(Dummy, SizeOf(Dummy));
-      Pitch := TFontPitch(Dummy);
-      ReadBuffer(Dummy, SizeOf(Dummy));
-      Style := TFontStyles(Byte(Dummy));
-    end;
-
-    // read data introduced by stream version 1+
-    if Version &gt; 0 then
-    begin
-      ReadBuffer(Dummy, SizeOf(Dummy));
-      MainColumn := Dummy;
-      ReadBuffer(Dummy, SizeOf(Dummy));
-      SortColumn := Dummy;
-      ReadBuffer(Dummy, SizeOf(Dummy));
-      SortDirection := TSortDirection(Byte(Dummy));
-    end;
-  finally
-    Exclude(FStates, hsLoading);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.RestoreColumns;
-
-// Restores all columns to their width which they had before they have been auto fitted.
-
-var
-  I: Integer;
-
-begin
-  with FColumns do
-    for I := Count - 1 downto 0 do
-      if [coResizable, coVisible] * Items[FPositionToIndex[I]].FOptions = [coResizable, coVisible] then
-        Items[I].RestoreLastWidth;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTHeader.SaveToStream(const Stream: TStream);
-
-// Saves the complete state of the header into the provided stream.
-
-var
-  Dummy: Integer;
-
-begin
-  with Stream do
-  begin
-    // In previous version of VT was no header stream version defined.
-    // For feature enhancements it is necessary, however, to know which stream
-    // format we are trying to load.
-    // In order to distict from non-version streams an indicator is inserted.
-    Dummy := -1;
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    // Write current stream version number, nothing more is required at the time being.
-    Dummy := VTHeaderStreamVersion;
-    WriteBuffer(Dummy, SizeOf(Dummy));
-
-    // Save columns in case they depend on certain options (like auto size).
-    Columns.SaveToStream(Stream);
-
-    Dummy := FAutoSizeIndex;
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    Dummy := FBackground;
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    Dummy := FHeight;
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    Dummy := Word(FOptions);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    // PopupMenu is neither saved nor restored
-    Dummy := Ord(FStyle);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    // TFont has no own save routine so we do it manually
-    with Font do
-    begin
-      Dummy := Color;
-      WriteBuffer(Dummy, SizeOf(Dummy));
-      Dummy := Height;
-      WriteBuffer(Dummy, SizeOf(Dummy));
-      Dummy := Length(Name);
-      WriteBuffer(Dummy, SizeOf(Dummy));
-      WriteBuffer(PChar(Name)^, Dummy);
-      Dummy := Ord(Pitch);
-      WriteBuffer(Dummy, SizeOf(Dummy));
-      // need only to write one: size or height, I decided to write height
-      Dummy := Byte(Style);
-      WriteBuffer(Dummy, SizeOf(Dummy));
-    end;
-
-    // data introduced by stream version 1
-    Dummy := FMainColumn;
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    Dummy := FSortColumn;
-    WriteBuffer(Dummy, SizeOf(Dummy));
-    Dummy := Byte(FSortDirection);
-    WriteBuffer(Dummy, SizeOf(Dummy));
-  end;
-end;
-
-//----------------- TScrollBarOptions ----------------------------------------------------------------------------------
-
-constructor TScrollBarOptions.Create(AOwner: TBaseVirtualTree);
-
-begin
-  inherited Create;
-
-  FOwner := AOwner;
-  FAlwaysVisible := False;
-  FScrollBarStyle := sbmRegular;
-  FScrollBars := ssBoth;
-  FIncrementX := 20;
-  FIncrementY := 20;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TScrollBarOptions.SetAlwaysVisible(Value: Boolean);
-
-begin
-  if FAlwaysVisible &lt;&gt; Value then
-  begin
-    FAlwaysVisible := Value;
-    if not (csLoading in FOwner.ComponentState) and FOwner.HandleAllocated then
-      FOwner.RecreateWnd;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TScrollBarOptions.SetScrollBars(Value: TScrollStyle);
-
-begin
-  if FScrollbars &lt;&gt; Value then
-  begin
-    FScrollBars := Value;
-    if not (csLoading in FOwner.ComponentState) and FOwner.HandleAllocated then
-      FOwner.RecreateWnd;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TScrollBarOptions.SetScrollBarStyle(Value: TScrollBarStyle);
-
-begin
-  {$ifndef UseFlatScrollbars}
-    Assert(Value = sbmRegular, 'Flat scrollbars styles are disabled. Enable UseFlatScrollbars in VirtualTrees.pas for' +
-      'flat scrollbar support.');
-  {$endif UseFlatScrollbars}
-
-  if FScrollBarStyle &lt;&gt; Value then
-  begin
-    FScrollBarStyle := Value;
-    {$ifdef UseFlatScrollbars}
-      if FOwner.HandleAllocated then
-      begin
-        // If set to regular style then don't use the emulation mode of the FlatSB APIs but the original APIs.
-        // This is necessary because the FlatSB APIs don't respect NC paint request with limited update region
-        // (which is necessary for the transparent drag image).
-        FOwner.RecreateWnd;
-      end;
-    {$endif UseFlatScrollbars}
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TScrollBarOptions.GetOwner: TPersistent;
-
-begin
-  Result := FOwner;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TScrollBarOptions.Assign(Source: TPersistent);
-
-begin
-  if Source is TScrollBarOptions then
-  begin
-    AlwaysVisible := TScrollBarOptions(Source).AlwaysVisible;
-    HorizontalIncrement := TScrollBarOptions(Source).HorizontalIncrement;
-    ScrollBars := TScrollBarOptions(Source).ScrollBars;
-    ScrollBarStyle := TScrollBarOptions(Source).ScrollBarStyle;
-    VerticalIncrement := TScrollBarOptions(Source).VerticalIncrement;
-  end
-  else
-    inherited;
-end;
-
-//----------------- TVTColors ------------------------------------------------------------------------------------------
-
-constructor TVTColors.Create(AOwner: TBaseVirtualTree);
-
-begin
-  FOwner := AOwner;
-  FColors[0] := clBtnShadow;      // DisabledColor
-  FColors[1] := clHighlight;      // DropMarkColor
-  FColors[2] := clHighLight;      // DropTargetColor
-  FColors[3] := clHighLight;      // FocusedSelectionColor
-  FColors[4] := clBtnFace;        // GridLineColor
-  FColors[5] := clBtnShadow;      // TreeLineColor
-  FColors[6] := clBtnFace;        // UnfocusedSelectionColor
-  FColors[7] := clBtnFace;        // BorderColor   
-  FColors[8] := clWindowText;     // HotColor
-  FColors[9] := clHighLight;      // FocusedSelectionBorderColor
-  FColors[10] := clBtnFace;       // UnfocusedSelectionBorderColor
-  FColors[11] := clHighlight;     // DropTargetBorderColor
-  FColors[12] := clHighlight;     // SelectionRectangleBlendColor
-  FColors[13] := clHighlight;     // SelectionRectangleBorderColor
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVTColors.GetColor(const Index: Integer): TColor;
-
-begin
-  Result := FColors[Index];
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTColors.SetColor(const Index: Integer; const Value: TColor);
-
-begin
-  if FColors[Index] &lt;&gt; Value then
-  begin
-    FColors[Index] := Value;
-    // Cause helper bitmap rebuild for grid and tree line colors.
-    if not (csLoading in FOwner.ComponentState) and FOwner.HandleAllocated then
-    begin
-      FOwner.Invalidate;
-      if Index = 7 then
-        RedrawWindow(FOwner.Handle, nil, 0, RDW_FRAME or RDW_INVALIDATE or RDW_NOERASE or RDW_NOCHILDREN);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTColors.Assign(Source: TPersistent);
-
-begin
-  if Source is TVTColors then
-  begin
-    FColors := TVTColors(Source).FColors;
-    if FOwner.FUpdateCount = 0 then
-      FOwner.Invalidate;
-  end
-  else
-    inherited;
-end;
-
-//----------------- TClipboardFormats ----------------------------------------------------------------------------------
-
-constructor TClipboardFormats.Create(AOwner: TBaseVirtualTree);
-
-begin
-  FOwner := AOwner;
-  Sorted := True;
-  Duplicates := dupIgnore;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TClipboardFormats.Add(const S: string): Integer;
-
-// Restrict additions to the clipbard formats to only those which are registered with the owner tree or one of its
-// ancestors.
-
-var
-  Format: Word;
-  RegisteredClass: TVirtualTreeClass;
-
-begin
-  RegisteredClass := InternalClipboardFormats.FindFormat(S, Format);
-  if Assigned(RegisteredClass) and FOwner.ClassType.InheritsFrom(RegisteredClass) then
-    Result := inherited Add(S)
-  else
-    Result := -1;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TClipboardFormats.Insert(Index: Integer; const S: string);
-
-// Restrict additions to the clipbard formats to only those which are registered with the owner tree or one of its
-// ancestors.
-
-var
-  Format: Word;
-  RegisteredClass: TVirtualTreeClass;
-
-begin
-  RegisteredClass := InternalClipboardFormats.FindFormat(S, Format);
-  if Assigned(RegisteredClass) and FOwner.ClassType.InheritsFrom(RegisteredClass) then
-    inherited Insert(Index, S);
-end;
-
-//----------------- TBaseVirtualTree -----------------------------------------------------------------------------------
-
-constructor TBaseVirtualTree.Create(AOwner: TComponent);
-
-begin
-  if not Initialized then
-    InitializeGlobalStructures;
-
-  inherited;
-
-  ControlStyle := ControlStyle - [csSetCaption] + [csCaptureMouse, csOpaque, csReplicatable, csDisplayDragImage,
-    csReflector];
-  FTotalInternalDataSize := 0;
-  FNodeDataSize := -1;
-  Width := 200;
-  Height := 100;
-  TabStop := True;
-  ParentColor := False;
-  FDefaultNodeHeight := 18;
-  FDragOperations := [doCopy, doMove];
-  FHotCursor := crDefault;
-  FScrollBarOptions := TScrollBarOptions.Create(Self);
-  FFocusedColumn := NoColumn;
-  FDragImageKind := diComplete;
-  FLastSelectionLevel := -1;
-  FAnimationType := hatSystemDefault;
-  FSelectionBlendFactor := 128;
-
-  FIndent := 18;
-
-  FPlusBM := TBitmap.Create;
-  FMinusBM := TBitmap.Create;
-
-  FBorderStyle := bsSingle;
-  FButtonStyle := bsRectangle;
-  FButtonFillMode := fmTreeColor;
-
-  FHeader := GetHeaderClass.Create(Self);
-
-  // we have an own double buffer handling
-  DoubleBuffered := False;
-
-  FCheckImageKind := ckLightCheck;
-  FCheckImages := LightCheckImages;
-
-  FImageChangeLink := TChangeLink.Create;
-  FImageChangeLink.OnChange := ImageListChange;
-  FStateChangeLink := TChangeLink.Create;
-  FStateChangeLink.OnChange := ImageListChange;
-  FCustomCheckChangeLink := TChangeLink.Create;
-  FCustomCheckChangeLink.OnChange := ImageListChange;
-
-  FAutoExpandDelay := 1000;
-  FAutoScrollDelay := 1000;
-  FAutoScrollInterval := 1;
-
-  FBackground := TPicture.Create;
-
-  FDefaultPasteMode := amAddChildLast;
-  FMargin := 4;
-  FTextMargin := 4;
-  FDragType := dtOLE;
-  FDragHeight := 350;
-  FDragWidth := 200;
-
-  FColors := TVTColors.Create(Self);
-  FEditDelay := 1000;
-
-  FDragImage := TVTDragImage.Create(Self);
-  with FDragImage do
-  begin
-    Fade := True;
-    PostBlendBias := 0;
-    PreBlendBias := 0;
-    Transparency := 200;
-  end;
-
-  SetLength(FSingletonNodeArray, 1);
-  FAnimationDuration := 200;
-  FSearchTimeout := 1000;
-  FSearchStart := ssFocusedNode;
-  FNodeAlignment := naProportional;
-  FLineStyle := lsDotted;
-  FIncrementalSearch := isNone;
-  FClipboardFormats := TClipboardFormats.Create(Self);
-  FOptions := GetOptionsClass.Create(Self);
-  FChangeLock := TCriticalSection.Create;
-
-  {$ifdef UseLocalMemoryManager}
-    FNodeMemoryManager := TVTNodeMemoryManager.Create;
-  {$endif UseLocalMemoryManager}
-
-  AddThreadReference;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TBaseVirtualTree.Destroy;
-
-begin
-  Exclude(FOptions.FMiscOptions, toReadOnly);
-  InterruptValidation;
-  StopWheelPanning;
-  CancelEditNode;
-
-  // Just in case it didn't happen already release the edit link.
-  FEditLink := nil;
-  FClipboardFormats.Free;
-  // Clear will also free the drag manager if it is still alive.
-  Clear;
-  FDragImage.Free;
-  FColors.Free;
-  FBackground.Free;
-  FImageChangeLink.Free;
-  FStateChangeLink.Free;
-  FCustomCheckChangeLink.Free;
-  FScrollBarOptions.Free;
-  FOptions.Free;
-
-  // The window handle must be destroyed before the header is freed because it is needed in WM_NCDESTROY.
-  if HandleAllocated then
-    DestroyWindowHandle;
-  FHeader.Free;
-
-  FreeMem(FRoot);
-
-  {$ifdef UseLocalMemoryManager}
-    FNodeMemoryManager.Free;
-  {$endif UseLocalMemoryManager}
-  FPlusBM.Free;
-  FMinusBM.Free;
-  FChangeLock.Free;
-  ReleaseThreadReference(Self);
-
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AdjustCoordinatesByIndent(var PaintInfo: TVTPaintInfo; Indent: Integer);
-
-// During painting of the main column some coordinates must be adjusted due to the tree lines.
-// The offset resulting from the tree lines and indentation level is given in Indent.
-
-var
-  Offset: Integer;
-
-begin
-  with PaintInfo do
-  begin
-    Offset := Indent * Integer(FIndent);
-    if BidiMode = bdLeftToRight then
-    begin
-      Inc(ContentRect.Left, Offset);
-      Inc(ImageInfo[iiNormal].XPos, Offset);
-      Inc(ImageInfo[iiState].XPos, Offset);
-      Inc(ImageInfo[iiCheck].XPos, Offset);
-    end
-    else
-    begin
-      Dec(ContentRect.Right, Offset);
-      Dec(ImageInfo[iiNormal].XPos, Offset);
-      Dec(ImageInfo[iiState].XPos, Offset);
-      Dec(ImageInfo[iiCheck].XPos, Offset);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AdjustImageBorder(Images: TCustomImageList; BidiMode: TBidiMode; VAlign: Integer; var R: TRect; 
-  var ImageInfo: TVTImageInfo);
-
-// Depending on the width of the image list as well as the given bidi mode R must be adjusted.
-
-begin
-  if BidiMode = bdLeftToRight then
-  begin
-    ImageInfo.XPos := R.Left;
-    Inc(R.Left, Images.Width + 2);
-  end
-  else
-  begin
-    ImageInfo.XPos := R.Right - Images.Width;
-    Dec(R.Right, Images.Width + 2);
-  end;
-  ImageInfo.YPos := R.Top + VAlign - Images.Height div 2;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AdjustTotalCount(Node: PVirtualNode; Value: Integer; relative: Boolean = False);
-
-// Sets a node's total count to the given value and recursively adjusts the parent's total count
-// (actually, the adjustment is done iteratively to avoid function call overheads).
-
-var
-  Difference: Integer;
-  Run: PVirtualNode;
-
-begin
-  if relative then
-    Difference := Value
-  else 
-    Difference := Integer(Value) - Integer(Node.TotalCount);
-  if Difference &lt;&gt; 0 then
-  begin
-    Run := Node;
-    // root node has as parent the tree view
-    while Assigned(Run) and (Run &lt;&gt; Pointer(Self)) do
-    begin
-      Inc(Integer(Run.TotalCount), Difference);
-      Run := Run.Parent;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AdjustTotalHeight(Node: PVirtualNode; Value: Integer; relative: Boolean = False);
-
-// Sets a node's total height to the given value and recursively adjusts the parent's total height.
-
-var
-  Difference: Integer;
-  Run: PVirtualNode;
-
-begin
-  if relative then
-    Difference := Value
-  else
-    Difference := Integer(Value) - Integer(Node.TotalHeight);
-  if Difference &lt;&gt; 0 then
-  begin
-    Run := Node;
-    repeat
-      Inc(Integer(Run.TotalHeight), Difference);
-      // If the node is not visible or the parent node is not expanded or we are already at the top
-      // then nothing more remains to do.
-      if not (vsVisible in Run.States) or (Run = FRoot) or
-        (Run.Parent = nil) or not (vsExpanded in Run.Parent.States) then
-        Break;
-
-      Run := Run.Parent;
-    until False;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CalculateCacheEntryCount: Integer;
-
-// Calculates the size of the position cache.
-
-begin
-  if FVisibleCount &gt; 1 then
-    Result := Ceil(FVisibleCount / CacheThreshold)
-  else
-    Result := 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CalculateVerticalAlignments(ShowImages, ShowStateImages: Boolean; Node: PVirtualNode;
-  var VAlign, VButtonAlign: Integer);
-
-// Calculates the vertical alignment of the given node and its associated expand/collapse button during
-// a node paint cycle depending on the required node alignment style.
-
-begin
-  // For absolute alignment the caluclation is trivial.
-  case FNodeAlignment of
-    naFromTop:
-      VAlign := Node.Align;
-    naFromBottom:
-      VAlign := Node.NodeHeight - Node.Align;
-  else // naProportional
-    // Consider button and line alignment, but make sure neither the image nor the button (whichever is taller)
-    // go out of the entire node height (100% means bottom alignment to the node's bounds).
-    if ShowImages or ShowStateImages then
-    begin
-      if ShowImages then
-        VAlign := FImages.Height
-      else
-        VAlign := FStateImages.Height;
-      VAlign := MulDiv((Node.NodeHeight - VAlign), Node.Align, 100) + VAlign div 2;
-    end
-    else
-      if toShowButtons in FOptions.FPaintOptions then
-        VAlign := MulDiv((Node.NodeHeight - FPlusBM.Height), Node.Align, 100) + FPlusBM.Height div 2
-      else
-        VAlign := MulDiv(Node.NodeHeight, Node.Align, 100);
-  end;
-
-  VButtonAlign := VAlign - FPlusBM.Height div 2;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.ChangeCheckState(Node: PVirtualNode; Value: TCheckState): Boolean;
-
-// Sets the check state of the node according to the given value and the node's check type.
-// If the check state must be propagated to the parent nodes and one of them refuses to change then
-// nothing happens and False is returned, otherwise True.
-
-var
-  Run: PVirtualNode;
-  CheckCount: Cardinal;
-
-begin
-  with Node^ do
-  begin
-    Include(States, vsChecking);
-
-    // Do actions which are associated with the given check state.
-    case CheckType of
-      // Check state change with additional consequences for check states of the children.
-      ctTriStateCheckBox:
-        begin
-          // propagate state down to the children
-          if toAutoTristateTracking in FOptions.FAutoOptions then
-            case Value of
-              csUncheckedNormal:
-                begin
-                  Run := FirstChild;
-                  CheckCount := 0;
-                  while Assigned(Run) do
-                  begin
-                    if Run.CheckType in [ctCheckBox, ctTriStateCheckBox] then
-                    begin
-                      SetCheckState(Run, csUncheckedNormal);
-                      // Check if the new child state was set successfully, otherwise we have to adjust the
-                      // node's new check state accordingly.
-                      if Run.CheckState = csUncheckedNormal then
-                        Inc(CheckCount);
-                    end;
-                    Run := Run.NextSibling;
-                  end;
-                  if Node.ChildCount &gt; 0 then
-                  begin
-                    if CheckCount = 0 then
-                      Value := csCheckedNormal
-                    else
-                      if CheckCount &lt; Node.ChildCount then
-                        Value := csMixedNormal;
-                  end;
-                end;
-              csCheckedNormal:
-                begin
-                  Run := FirstChild;
-                  CheckCount := 0;
-                  while Assigned(Run) do
-                  begin
-                    if Run.CheckType in [ctCheckBox, ctTriStateCheckBox] then
-                    begin
-                      SetCheckState(Run, csCheckedNormal);
-                      // Check if the new child state was set successfully, otherwise we have to adjust the
-                      // node's new check state accordingly.
-                      if Run.CheckState = csCheckedNormal then
-                        Inc(CheckCount);
-                    end;
-                    Run := Run.NextSibling;
-                  end;
-                  if Node.ChildCount &gt; 0 then
-                  begin
-                    if CheckCount = 0 then
-                      Value := csUncheckedNormal
-                    else
-                      if CheckCount &lt; Node.ChildCount then
-                        Value := csMixedNormal;
-                  end;
-                end;
-            end;
-        end;
-      // radio button check state change
-      ctRadioButton:
-        if Value = csCheckedNormal then
-        begin
-          Value := csCheckedNormal;
-          // Make sure only this node is checked.
-          Run := Parent.FirstChild;
-          while Assigned(Run) do
-          begin
-            if Run.CheckType = ctRadioButton then
-              Run.CheckState := csUncheckedNormal;
-            Run := Run.NextSibling;
-          end;
-          Invalidate;
-        end;
-    end;
-
-    // Propagate state up to the parent.
-    if not (vsInitialized in Parent.States) then
-      InitNode(Parent);
-    if (toAutoTristateTracking in FOptions.FAutoOptions) and ([vsChecking, vsDisabled] * Parent.States = []) and
-      (CheckType in [ctCheckBox, ctTriStateCheckBox]) and (Parent &lt;&gt; FRoot) and
-      (Parent.CheckType = ctTriStateCheckBox) then
-      Result := CheckParentCheckState(Node, Value)
-    else
-      Result := True;
-
-    if Result then
-      CheckState := Value // Set new check state
-    else
-      CheckState := UnpressedState[CheckState]; // Reset dynmic check state.
-    InvalidateNode(Node);
-    Exclude(States, vsChecking);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CollectSelectedNodesLTR(MainColumn, NodeLeft, NodeRight: Integer; Alignment: TAlignment;
-  OldRect, NewRect: TRect): Boolean;
-
-// Helper routine used when a draw selection takes place. This version handles left-to-right directionality.
-// In the process of adding or removing nodes the current selection is modified which requires to pack it after
-// the function returns. Another side effect of this method is that a temporary list of nodes will be created
-// (see also InternalCacheNode) which must be inserted into the current selection by the caller.
-
-var
-  Run,
-  NextNode: PVirtualNode;
-  TextRight,
-  TextLeft,
-  CheckOffset,
-  CurrentTop,
-  CurrentRight,
-  NextTop,
-  NextColumn,
-  NodeWidth,
-  Dummy: Integer;
-  MinY, MaxY: Integer;
-  ImageOffset,
-  StateImageOffset: Integer;
-  IsInOldRect,
-  IsInNewRect: Boolean;
-
-  // quick check variables for various parameters
-  WithCheck,
-  WithImages,
-  WithStateImages,
-  DoSwitch,
-  AutoSpan,
-  Ghosted: Boolean;
-
-begin
-  // a priory nothing changes
-  Result := False;
-
-  // Determine minimum and maximum vertical coordinates to limit iteration to.
-  MinY := Min(OldRect.Top, NewRect.Top);
-  MaxY := Max(OldRect.Bottom, NewRect.Bottom);
-
-  // Initialize short hand variables to speed up tests below.
-  DoSwitch := ssCtrl in FDrawSelShiftState;
-  WithCheck := (toCheckSupport in FOptions.FMiscOptions) and Assigned(FCheckImages);
-  // Don't check the events here as descendant trees might have overriden the DoGetImageIndex method.
-  WithImages := Assigned(FImages);
-  if WithImages then
-    ImageOffset := FImages.Width + 2
-  else
-    ImageOffset := 0;
-  WithStateImages := Assigned(FStateImages);
-  if WithStateImages then
-    StateImageOffset := FStateImages.Width + 2
-  else
-    StateImageOffset := 0;
-  if WithCheck then
-    CheckOffset := FCheckImages.Width + 2
-  else
-    CheckOffset := 0;
-  AutoSpan := FHeader.UseColumns and (toAutoSpanColumns in FOptions.FAutoOptions);
-
-  // This is the node to start with.
-  Run := GetNodeAt(0, MinY, False, CurrentTop);
-
-  if Assigned(Run) then
-  begin
-    // The initial minimal left border is determined by the identation level of the node and is dynamically adjusted.
-    if toShowRoot in FOptions.FPaintOptions then
-      Inc(NodeLeft, Integer((GetNodeLevel(Run) + 1) * FIndent) + FMargin)
-    else
-      Inc(NodeLeft, Integer(GetNodeLevel(Run) * FIndent) + FMargin);
-
-    // ----- main loop
-    // Change selection depending on the node's rectangle being in the selection rectangle or not, but
-    // touch only those nodes which overlap either the old selection rectangle or the new one but not both.
-    repeat
-      // Collect offsets for check, normal and state images.
-      TextLeft := NodeLeft;
-      if WithCheck and (Run.CheckType &lt;&gt; ctNone) then
-        Inc(TextLeft, CheckOffset);
-      if WithImages and (GetImageIndex(Run, ikNormal, MainColumn, Ghosted) &gt; -1) then
-        Inc(TextLeft, ImageOffset);
-      if WithStateImages and (GetImageIndex(Run, ikState, MainColumn, Ghosted) &gt; -1) then
-        Inc(TextLeft, StateImageOffset);
-
-      NextTop := CurrentTop + Run.NodeHeight;
-
-      // The right column border might be extended if column spanning is enabled.
-      if AutoSpan then
-      begin
-        with FHeader.FColumns do
-        begin
-          NextColumn := MainColumn;
-          repeat
-            Dummy := GetNextVisibleColumn(NextColumn);
-            if (Dummy = InvalidColumn) or not ColumnIsEmpty(Run, Dummy) or
-              (Items[Dummy].BidiMode &lt;&gt; bdLeftToRight) then
-              Break;
-            NextColumn := Dummy;
-          until False;
-          if NextColumn = MainColumn then
-            CurrentRight := NodeRight
-          else
-            GetColumnBounds(NextColumn, Dummy, CurrentRight);
-        end;
-      end
-      else
-        CurrentRight := NodeRight;
-
-      // Check if we need the node's width. This is the case when the node is not left aligned or the
-      // left border of the selection rectangle is to the right of the left node border.
-      if (TextLeft &lt; OldRect.Left) or (TextLeft &lt; NewRect.Left) or (Alignment &lt;&gt; taLeftJustify) then
-      begin
-        NodeWidth := DoGetNodeWidth(Run, MainColumn);
-        if NodeWidth &gt;= (CurrentRight - TextLeft) then
-          TextRight := CurrentRight
-        else
-          case Alignment of
-            taLeftJustify:
-              TextRight := TextLeft + NodeWidth;
-            taCenter:
-              begin
-                TextLeft := (TextLeft + CurrentRight - NodeWidth) div 2;
-                TextRight := TextLeft + NodeWidth;
-              end;
-          else
-            // taRightJustify
-            TextRight := CurrentRight;
-            TextLeft := TextRight - NodeWidth;
-          end;
-      end
-      else
-        TextRight := CurrentRight;
-
-      // Now determine whether we need to change the state.
-      IsInOldRect := (OldRect.Left &lt;= TextRight) and (OldRect.Right &gt;= TextLeft) and
-        (NextTop &gt; OldRect.Top) and (CurrentTop &lt; OldRect.Bottom);
-      IsInNewRect := (NewRect.Left &lt;= TextRight) and (NewRect.Right &gt;= TextLeft) and
-        (NextTop &gt; NewRect.Top) and (CurrentTop &lt; NewRect.Bottom);
-
-      if IsInOldRect xor IsInNewRect then
-      begin
-        Result := True;
-        if DoSwitch then
-        begin
-          if vsSelected in Run.States then
-            InternalRemoveFromSelection(Run)
-          else
-            InternalCacheNode(Run);
-        end
-        else
-        begin
-          if IsInNewRect then
-            InternalCacheNode(Run)
-          else
-            InternalRemoveFromSelection(Run);
-        end;
-      end;
-
-      CurrentTop := NextTop;
-      // Get next visible node and update left node position.
-      NextNode := GetNextVisibleNoInit(Run);
-      if NextNode = nil then
-        Break;
-      Inc(NodeLeft, CountLevelDifference(Run, NextNode) * Integer(FIndent));
-      Run := NextNode;
-    until CurrentTop &gt; MaxY;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CollectSelectedNodesRTL(MainColumn, NodeLeft, NodeRight: Integer; Alignment: TAlignment;
-  OldRect, NewRect: TRect): Boolean;
-
-// Helper routine used when a draw selection takes place. This version handles right-to-left directionality.
-// See also comments in CollectSelectedNodesLTR.
-
-var
-  Run,
-  NextNode: PVirtualNode;
-  TextRight,
-  TextLeft,
-  CheckOffset,
-  CurrentTop,
-  CurrentLeft,
-  NextTop,
-  NextColumn,
-  NodeWidth,
-  Dummy: Integer;
-  MinY, MaxY: Integer;
-  ImageOffset,
-  StateImageOffset: Integer;
-  IsInOldRect,
-  IsInNewRect: Boolean;
-  
-  // quick check variables for various parameters
-  WithCheck,
-  WithImages,
-  WithStateImages,
-  DoSwitch,
-  AutoSpan,
-  Ghosted: Boolean;
-
-begin
-  // A priori nothing changes.
-  Result := False;
-  // Switch the alignment to the opposite value in RTL context.
-  ChangeBiDiModeAlignment(Alignment);
-
-  // Determine minimum and maximum vertical coordinates to limit iteration to.
-  MinY := Min(OldRect.Top, NewRect.Top);
-  MaxY := Max(OldRect.Bottom, NewRect.Bottom);
-
-  // Initialize short hand variables to speed up tests below.
-  DoSwitch := ssCtrl in FDrawSelShiftState;
-  WithCheck := (toCheckSupport in FOptions.FMiscOptions) and Assigned(FCheckImages);
-  // Don't check the events here as descendant trees might have overriden the DoGetImageIndex method.
-  WithImages := Assigned(FImages);
-  if WithImages then
-    ImageOffset := FImages.Width + 2
-  else
-    ImageOffset := 0;
-  WithStateImages := Assigned(FStateImages);
-  if WithStateImages then
-    StateImageOffset := FStateImages.Width + 2
-  else
-    StateImageOffset := 0;
-  if WithCheck then
-    CheckOffset := FCheckImages.Width + 2
-  else
-    CheckOffset := 0;
-  AutoSpan := FHeader.UseColumns and (toAutoSpanColumns in FOptions.FAutoOptions);
-
-  // This is the node to start with.
-  Run := GetNodeAt(0, MinY, False, CurrentTop);
-
-  if Assigned(Run) then
-  begin
-    // The initial minimal left border is determined by the identation level of the node and is dynamically adjusted.
-    if toShowRoot in FOptions.FPaintOptions then
-      Dec(NodeRight, Integer((GetNodeLevel(Run) + 1) * FIndent) + FMargin)
-    else
-      Dec(NodeRight, Integer(GetNodeLevel(Run) * FIndent) + FMargin);
-
-    // ----- main loop
-    // Change selection depending on the node's rectangle being in the selection rectangle or not, but
-    // touch only those nodes which overlap either the old selection rectangle or the new one but not both.
-    repeat
-      // Collect offsets for check, normal and state images.
-      TextRight := NodeRight;
-      if WithCheck and (Run.CheckType &lt;&gt; ctNone) then
-        Dec(TextRight, CheckOffset);
-      if WithImages and (GetImageIndex(Run, ikNormal, MainColumn, Ghosted) &gt; -1) then
-        Dec(TextRight, ImageOffset);
-      if WithStateImages and (GetImageIndex(Run, ikState, MainColumn, Ghosted) &gt; -1) then
-        Dec(TextRight, StateImageOffset);
-
-      NextTop := CurrentTop + Run.NodeHeight;
-
-      // The left column border might be extended if column spanning is enabled.
-      if AutoSpan then
-      begin
-        NextColumn := MainColumn;
-        repeat
-          Dummy := FHeader.FColumns.GetPreviousVisibleColumn(NextColumn);
-          if (Dummy = InvalidColumn) or not ColumnIsEmpty(Run, Dummy) or
-            (FHeader.FColumns[Dummy].BiDiMode = bdLeftToRight) then
-            Break;
-          NextColumn := Dummy;
-        until False;
-        if NextColumn = MainColumn then
-          CurrentLeft := NodeLeft
-        else
-          FHeader.FColumns.GetColumnBounds(NextColumn, CurrentLeft, Dummy);
-      end
-      else
-        CurrentLeft := NodeLeft;
-    
-      // Check if we need the node's width. This is the case when the node is not left aligned (in RTL context this
-      // means actually right aligned) or the right border of the selection rectangle is to the left
-      // of the right node border.
-      if (TextRight &gt; OldRect.Right) or (TextRight &gt; NewRect.Right) or (Alignment &lt;&gt; taRightJustify) then
-      begin
-        NodeWidth := DoGetNodeWidth(Run, MainColumn);
-        if NodeWidth &gt;= (TextRight - CurrentLeft) then
-          TextLeft := CurrentLeft
-        else
-          case Alignment of
-            taLeftJustify:
-              begin
-                TextLeft := CurrentLeft;
-                TextRight := TextLeft + NodeWidth;
-              end;
-            taCenter:
-              begin
-                TextLeft := (TextRight + CurrentLeft - NodeWidth) div 2;
-                TextRight := TextLeft + NodeWidth;
-              end;
-          else
-            // taRightJustify
-            TextLeft := TextRight - NodeWidth;
-          end;
-      end
-      else
-        TextLeft := CurrentLeft;
-
-      // Now determine whether we need to change the state.
-      IsInOldRect := (OldRect.Right &gt;= TextLeft) and (OldRect.Left &lt;= TextRight) and
-        (NextTop &gt; OldRect.Top) and (CurrentTop &lt; OldRect.Bottom);
-      IsInNewRect := (NewRect.Right &gt;= TextLeft) and (NewRect.Left &lt;= TextRight) and
-        (NextTop &gt; NewRect.Top) and (CurrentTop &lt; NewRect.Bottom);
-
-      if IsInOldRect xor IsInNewRect then
-      begin
-        Result := True;
-        if DoSwitch then
-        begin
-          if vsSelected in Run.States then
-            InternalRemoveFromSelection(Run)
-          else
-            InternalCacheNode(Run);
-        end
-        else
-        begin
-          if IsInNewRect then
-            InternalCacheNode(Run)
-          else
-            InternalRemoveFromSelection(Run);
-        end;
-      end;
-
-      CurrentTop := NextTop;
-      // Get next visible node and update left node position.
-      NextNode := GetNextVisibleNoInit(Run);
-      if NextNode = nil then
-        Break;
-      Dec(NodeRight, CountLevelDifference(Run, NextNode) * Integer(FIndent));
-      Run := NextNode;
-    until CurrentTop &gt; MaxY;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ClearNodeBackground(const PaintInfo: TVTPaintInfo; UseBackground, Floating: Boolean;
-  R: TRect);
-
-// Erases a nodes background depending on what the application decides to do.
-// UseBackground determines whether or not to use the background picture, while Floating indicates
-// that R is given in coordinates of the small node bitmap or the superordinated target bitmap used in PaintTree.
-
-var
-  BackColor: TColor;
-  EraseAction: TItemEraseAction;
-  Offset: TPoint;
-
-begin
-  with PaintInfo do
-  begin
-    EraseAction := eaDefault;
-    BackColor := Color;
-    DoBeforeItemErase(Canvas, Node, R, Backcolor, EraseAction);
-    if Floating then
-    begin
-      Offset := Point(FOffsetX, R.Top);
-      OffsetRect(R, 0, -Offset.Y);
-    end
-    else
-      Offset := Point(0, 0);
-
-    with Canvas do
-    begin
-      case EraseAction of
-        eaColor:
-          begin
-            // user has given a new background color
-            Brush.Color := BackColor;
-            FillRect(R);
-            DoAfterItemErase(Canvas, Node, R);
-          end;
-      else // eaDefault
-        if UseBackground then
-          TileBackground(FBackground.Bitmap, Canvas, Offset, R)
-        else
-        begin
-          if (poDrawSelection in PaintOptions) and (toFullRowSelect in FOptions.FSelectionOptions) and
-            (vsSelected in Node.States) then
-          begin
-            if toShowHorzGridLines in FOptions.PaintOptions then
-              Dec(R.Bottom);
-            if Focused or (toPopupMode in FOptions.FPaintOptions)then
-            begin
-              Brush.Color := FColors.FocusedSelectionColor;
-              Pen.Color := FColors.FocusedSelectionBorderColor;
-            end
-            else
-            begin
-              Brush.Color := FColors.UnfocusedSelectionColor;
-              Pen.Color := FColors.UnfocusedSelectionBorderColor;
-            end;
-            with R do
-              RoundRect(Left, Top, Right, Bottom, FSelectionCurveRadius, FSelectionCurveRadius);
-          end
-          else
-          begin
-            Brush.Color := Color;
-            FillRect(R);
-          end;
-        end;
-        DoAfterItemErase(Canvas, Node, R);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CompareNodePositions(Node1, Node2: PVirtualNode): Integer;
-
-// Tries hard and smart to quickly determine whether Node1's structural position is before Node2's position
-// Returns 0 if Node1 = Node2, &lt; 0 if Node1 is located before Node2 else &gt; 0.
-
-var
-  Run1,
-  Run2: PVirtualNode;
-  Level1,
-  Level2: Cardinal;
-
-begin
-  Assert(Assigned(Node1) and Assigned(Node2), 'Nodes must never be nil.');
-
-  if Node1 = Node2 then
-    Result := 0
-  else
-  begin
-    if HasAsParent(Node1, Node2) then
-      Result := 1
-    else
-      if HasAsParent(Node2, Node1) then
-        Result := -1
-      else
-      begin
-        // the given nodes are neither equal nor are they parents of each other, so go up to FRoot
-        // for each node and compare the child indices of the top level parents
-        // Note: neither Node1 nor Node2 can be FRoot at this point as this (a bit strange) circumstance would
-        //       be caught by the previous code.
-
-        // start lookup at the same level
-        Level1 := GetNodeLevel(Node1);
-        Level2 := GetNodeLevel(Node2);
-        Run1 := Node1;
-        while Level1 &gt; Level2 do
-        begin
-          Run1 := Run1.Parent;
-          Dec(Level1);
-        end;
-        Run2 := Node2;
-        while Level2 &gt; Level1 do
-        begin
-          Run2 := Run2.Parent;
-          Dec(Level2);
-        end;
-
-        // now go up until we find a common parent node (loop will safely stop at FRoot if the nodes
-        // don't share a common parent)
-        while Run1.Parent &lt;&gt; Run2.Parent do
-        begin
-          Run1 := Run1.Parent;
-          Run2 := Run2.Parent;
-        end;
-        Result := Integer(Run1.Index) - Integer(Run2.Index);
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DrawLineImage(const PaintInfo: TVTPaintInfo; X, Y, H, VAlign: Integer; Style: TVTLineType;
-  Reverse: Boolean);
-
-// Draws (depending on Style) one of the 5 line types of the tree.
-// If Reverse is True then a right-to-left column is being drawn, hence horizontal lines must be mirrored.
-// X and Y describe the left upper corner of the line image rectangle, while H denotes its height (and width).
-
-var
-  HalfWidth,
-  TargetX: Integer;
-
-begin
-  HalfWidth := Integer(FIndent) div 2;
-  if Reverse then
-    TargetX := 0
-  else
-    TargetX := FIndent;
-
-  with PaintInfo.Canvas do
-  begin
-    case Style of
-      ltBottomRight:
-        begin
-          DrawDottedVLine(PaintInfo, Y + VAlign, Y + H, X + HalfWidth);
-          DrawDottedHLine(PaintInfo, X + HalfWidth, X + TargetX, Y + VAlign);
-        end;
-      ltTopDown:
-        DrawDottedVLine(PaintInfo, Y, Y + H, X + HalfWidth);
-      ltTopDownRight:
-        begin
-          DrawDottedVLine(PaintInfo, Y, Y + H, X + HalfWidth);
-          DrawDottedHLine(PaintInfo, X + HalfWidth, X + TargetX, Y + VAlign);
-        end;
-      ltRight:
-        DrawDottedHLine(PaintInfo, X + HalfWidth, X + TargetX, Y + VAlign);
-      ltTopRight:
-        begin
-          DrawDottedVLine(PaintInfo, Y, Y + VAlign, X + HalfWidth);
-          DrawDottedHLine(PaintInfo, X + HalfWidth, X + TargetX, Y + VAlign);
-        end;
-      ltLeft: // left can also mean right for RTL context
-        if Reverse then
-          DrawDottedVLine(PaintInfo, Y, Y + H, X + Integer(FIndent))
-        else
-          DrawDottedVLine(PaintInfo, Y, Y + H, X);
-      ltLeftBottom:
-        if Reverse then
-        begin
-          DrawDottedVLine(PaintInfo, Y, Y + H, X + Integer(FIndent));
-          DrawDottedHLine(PaintInfo, X, X + Integer(FIndent), Y + H);
-        end
-        else
-        begin
-          DrawDottedVLine(PaintInfo, Y, Y + H, X);
-          DrawDottedHLine(PaintInfo, X, X + Integer(FIndent), Y + H);
-        end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.FindInPositionCache(Node: PVirtualNode; var CurrentPos: Cardinal): PVirtualNode;
-
-// Looks through the position cache and returns the node whose top position is the largest one which is smaller or equal
-// to the position of the given node.
-
-var
-  L, H, I: Integer;
-
-begin
-  L := 0;
-  H := High(FPositionCache);
-  while L &lt;= H do
-  begin
-    I := (L + H) shr 1;
-    if CompareNodePositions(FPositionCache[I].Node, Node) &lt;= 0 then
-      L := I + 1
-    else
-      H := I - 1;
-  end;
-  Result := FPositionCache[L - 1].Node;
-  CurrentPos := FPositionCache[L - 1].AbsoluteTop;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.FindInPositionCache(Position: Cardinal; var CurrentPos: Cardinal): PVirtualNode;
-
-// Looks through the position cache and returns the node whose top position is the largest one which is smaller or equal
-// to the given vertical position.
-// The returned node does not necessarily occupy the given position but is the nearest one to start
-// iterating from to approach the real node for a given position. CurrentPos receives the actual position of the found
-// node which is needed for further iteration.
-
-var
-  L, H, I: Integer;
-
-begin
-  L := 0;
-  H := High(FPositionCache);
-  while L &lt;= H do
-  begin
-    I := (L + H) shr 1;
-    if FPositionCache[I].AbsoluteTop &lt;= Position then
-      L := I + 1
-    else
-      H := I - 1;
-  end;
-  Result := FPositionCache[L - 1].Node;
-  CurrentPos := FPositionCache[L - 1].AbsoluteTop;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetCheckState(Node: PVirtualNode): TCheckState;
-
-begin
-  Result := Node.CheckState;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetCheckType(Node: PVirtualNode): TCheckType;
-
-begin
-  Result := Node.CheckType;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetChildCount(Node: PVirtualNode): Cardinal;
-
-begin
-  if (Node = nil) or (Node = FRoot) then
-    Result := FRoot.ChildCount
-  else
-    Result := Node.ChildCount;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetChildrenInitialized(Node: PVirtualNode): Boolean;
-
-begin
-  Result := not (vsHasChildren in Node.States) or (Node.ChildCount &gt; 0);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetDisabled(Node: PVirtualNode): Boolean;
-
-begin
-  Result := Assigned(Node) and (vsDisabled in Node.States);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetDragManager: IVTDragManager;
-
-// Returns the internal drag manager interface. If this does not yet exist then it is created here.
-
-begin
-  if FDragManager = nil then
-  begin
-    FDragManager := DoCreateDragManager;
-    if FDragManager = nil then
-      FDragManager := TVTDragManager.Create(Self);
-  end;
-
-  Result := FDragManager;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetExpanded(Node: PVirtualNode): Boolean;
-
-begin
-  if Assigned(Node) then
-    Result := vsExpanded in Node.States
-  else
-    Result := False;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFullyVisible(Node: PVirtualNode): Boolean;
-
-// Determines whether the given node has the visibility flag set as well as all its parents are expanded.
-
-begin
-  Assert(Assigned(Node), 'Invalid parameter.');
-  Result := vsVisible in Node.States;
-  if Result and (Node &lt;&gt; FRoot) then
-    Result := VisiblePath[Node];
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetHasChildren(Node: PVirtualNode): Boolean;
-
-begin
-  if Assigned(Node) then
-    Result := vsHasChildren in Node.States
-  else
-    Result := vsHasChildren in FRoot.States;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetMultiline(Node: PVirtualNode): Boolean;
-
-begin
-  Result := Assigned(Node) and (Node &lt;&gt; FRoot) and (vsMultiline in Node.States);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNodeHeight(Node: PVirtualNode): Cardinal;
-
-begin
-  if Assigned(Node) and (Node &lt;&gt; FRoot) then
-    Result := Node.NodeHeight
-  else
-    Result := 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNodeParent(Node: PVirtualNode): PVirtualNode;
-
-begin
-  if Assigned(Node) and (Node.Parent &lt;&gt; FRoot) then
-    Result := Node.Parent
-  else
-    Result := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetOffsetXY: TPoint;
-
-begin
-  Result := Point(FOffsetX, FOffsetY);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetRootNodeCount: Cardinal;
-
-begin
-  Result := FRoot.ChildCount;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetSelected(Node: PVirtualNode): Boolean;
-
-begin
-  Result := Assigned(Node) and (vsSelected in Node.States);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetTopNode: PVirtualNode;
-
-var
-  Dummy: Integer;
-
-begin
-  Result := GetNodeAt(0, 0, True, Dummy);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetTotalCount: Cardinal;
-
-begin
-  Inc(FUpdateCount);
-  try
-    ValidateNode(FRoot, True);
-  finally
-    Dec(FUpdateCount);
-  end;
-  // The root node itself doesn't count as node.
-  Result := FRoot.TotalCount - 1;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetVerticalAlignment(Node: PVirtualNode): Byte;
-
-begin
-  Result := Node.Align;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetVisible(Node: PVirtualNode): Boolean;
-
-// Determines if the given node marked as being visible.
-
-begin
-  if Node = nil then
-    Node := FRoot;
-
-  if not (vsInitialized in Node.States) then
-    InitNode(Node);
-
-  Result := vsVisible in Node.States;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetVisiblePath(Node: PVirtualNode): Boolean;
-
-// Determines if all parents of the given node are expanded and have the visibility flag set.
-
-begin
-  Assert(Assigned(Node) and (Node &lt;&gt; FRoot), 'Invalid parameters.');
-
-  // FRoot is always expanded
-  repeat
-    Node := Node.Parent;
-  until (Node = FRoot) or not (vsExpanded in Node.States) or not (vsVisible in Node.States);
-
-  Result := Node = FRoot;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.HandleClickSelection(LastFocused, NewNode: PVirtualNode; Shift: TShiftState);
-
-// Handles multi-selection with mouse click.
-
-begin
-  // Ctrl key down
-  if ssCtrl in Shift then
-  begin
-    if ssShift in Shift then
-    begin
-      SelectNodes(FRangeAnchor, NewNode, True);
-      Invalidate;
-    end
-    else
-    begin
-      if not (toSiblingSelectConstraint in FOptions.SelectionOptions) then
-        FRangeAnchor := NewNode;
-      DoStateChange([tsClearFocusedSelection])
-    end;
-  end
-  else
-    // Shift key down
-    if ssShift in Shift then
-    begin
-      if FRangeAnchor = nil then
-        FRangeAnchor := FRoot.FirstChild;
-
-      // select node range
-      if Assigned(FRangeAnchor) then
-      begin
-        SelectNodes(FRangeAnchor, NewNode, False);
-        Invalidate;
-      end;
-    end
-    else
-    begin
-      // any other case
-      if not (vsSelected in NewNode.States) then
-      begin
-        AddToSelection(NewNode);
-        InvalidateNode(NewNode);
-      end;
-      // assign new reference item
-      FRangeAnchor := NewNode;
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.HandleDrawSelection(X, Y: Integer): Boolean;
-
-// Handles multi-selection with a focus rectangle.
-// Result is True if something changed in selection.
-
-var
-  OldRect,
-  NewRect: TRect;
-  MainColumn: TColumnIndex;
-  MaxValue: Integer;
-
-  // limits of a node and its text
-  NodeLeft,
-  NodeRight: Integer;
-
-  // alignment and directionality
-  CurrentBidiMode: TBidiMode;
-  CurrentAlignment: TAlignment;
-
-begin
-  Result := False;
-
-  // Selection changes are only done if the user drew a selection rectangle large
-  // enough to exceed the threshold.
-  if (FRoot.TotalCount &gt; 1) and (tsDrawSelecting in FStates) then
-  begin
-    // Effective handling of node selection is done by using two rectangles stored in FSelectRec.
-    OldRect := OrderRect(FLastSelRect);
-    NewRect := OrderRect(FNewSelRect);
-    ClearTempCache;
-
-    MainColumn := FHeader.MainColumn;
-
-    // Alignment and bidi mode determine where the node text is located within a node.
-    if MainColumn = NoColumn then
-    begin
-      CurrentBidiMode := BidiMode;
-      CurrentAlignment := Alignment;
-    end
-    else
-    begin
-      CurrentBidiMode := FHeader.FColumns[MainColumn].BidiMode;
-      CurrentAlignment := FHeader.FColumns[MainColumn].Alignment;
-    end;
-
-    // Determine initial left border of first node (take column reordering into account).
-    if FHeader.UseColumns then
-    begin
-      // The mouse coordinates don't include any horizontal scrolling hence take this also
-      // out from the returned column position.
-      NodeLeft := FHeader.FColumns[MainColumn].Left - FOffsetX;
-      NodeRight := NodeLeft + FHeader.FColumns[MainColumn].Width;
-    end
-    else
-    begin
-      NodeLeft := 0;
-      NodeRight := ClientWidth;
-    end;
-    if CurrentBidiMode = bdLeftToRight then
-      Result := CollectSelectedNodesLTR(MainColumn, NodeLeft, NodeRight, CurrentAlignment, OldRect, NewRect)
-    else
-      Result := CollectSelectedNodesRTL(MainColumn, NodeLeft, NodeRight, CurrentAlignment, OldRect, NewRect);
-  end;
-
-  if Result then
-  begin
-    // Do some housekeeping if there was a change.
-    MaxValue := PackArray(FSelection, FSelectionCount);
-    if MaxValue &gt; -1 then
-    begin
-      FSelectionCount := MaxValue;
-      SetLength(FSelection, FSelectionCount);
-    end;
-    if FTempNodeCount &gt; 0 then
-    begin
-      AddToSelection(FTempNodeCache, FTempNodeCount);
-      ClearTempCache;
-    end;
-
-    Change(nil);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.HasVisibleNextSibling(Node: PVirtualNode): Boolean;
-
-// Helper method to determine if the given node has a visible sibling. This is needed to
-// draw correct tree lines.
-
-begin
-  // Check if there is a sibling at all.
-  Result := Assigned(Node.NextSibling);
-
-  if Result then
-  begin
-    repeat
-      Node := Node.NextSibling;
-      Result := vsVisible in Node.States;
-    until Result or (Node.NextSibling = nil);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ImageListChange(Sender: TObject);
-
-begin
-  if not (csDestroying in ComponentState) then
-    Invalidate;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InitializeFirstColumnValues(var PaintInfo: TVTPaintInfo);
-
-// Determines initial index, position and cell size of the first visible column.
-
-begin
-  PaintInfo.Column := FHeader.FColumns.GetFirstVisibleColumn;
-  with FHeader.FColumns, PaintInfo do
-  begin
-    if Column &gt; NoColumn then
-    begin
-      CellRect.Right := CellRect.Left + Items[Column].Width;
-      Position := Items[Column].Position;
-    end
-    else
-      Position := 0;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.InitializeLineImageAndSelectLevel(Node: PVirtualNode; var LineImage: TLineImage): Integer;
-
-// This method is used during paint cycles and initializes an array of line type IDs. These IDs are used to paint
-// the tree lines in front of the given node.
-// Additionally an initial count of selected parents is determined and returned which is used for specific painting.
-
-var
-  X: Integer;
-  Run: PVirtualNode;
-
-begin
-  Result := 0;
-  if toShowRoot in FOptions.FPaintOptions then
-    X := 1
-  else
-    X := 0;
-  Run := Node;
-  // Determine indentation level of top node.
-  while Run.Parent &lt;&gt; FRoot do
-  begin
-    Inc(X);
-    Run := Run.Parent;
-    // Count selected nodes (FRoot is never selected).
-    if vsSelected in Run.States then
-      Inc(Result);
-  end;
-
-  // Set initial size of line index array, this will automatically initialized all entries to ltNone. 
-  SetLength(LineImage, X);
-
-  // Only use lines if requested.
-  if toShowTreeLines in FOptions.FPaintOptions then
-  begin
-    // Start over parent traversal if necessary.
-    Run := Node;
-    if Run.Parent &lt;&gt; FRoot then
-    begin
-      // The very last image (the one immediately before the item label) is different.
-      if HasVisibleNextSibling(Run) then
-        LineImage[X - 1] := ltTopDownRight
-      else
-        LineImage[X - 1] := ltTopRight;
-      Run := Run.Parent;
-
-      // Now go up all parents.
-      repeat
-        if Run.Parent = FRoot then
-          Break;
-        Dec(X);
-        if HasVisibleNextSibling(Run) then
-          LineImage[X - 1] := ltTopDown
-        else
-          LineImage[X - 1] := ltNone;
-        Run := Run.Parent;
-      until False;
-    end;
-
-    // Prepare root level. Run points at this stage to a top level node.
-    if (toShowRoot in FOptions.FPaintOptions) and (toShowTreeLines in FOptions.FPaintOptions) then
-    begin
-      // Is the top node a root node?
-      if Run = Node then
-      begin
-        // First child gets the bottom-right bitmap if it isn't also the only child.
-        if IsFirstVisibleChild(FRoot, Run) then
-          // Is it the only child?
-          if IsLastVisibleChild(FRoot, Run) then
-            LineImage[0] := ltRight
-          else
-            LineImage[0] := ltBottomRight
-        else
-          // real last child
-          if IsLastVisibleChild(FRoot, Run) then
-            LineImage[0] := ltTopRight
-          else
-            LineImage[0] := ltTopDownRight;
-      end
-      else
-      begin
-        // No, top node is not a top level node. So we need different painting.
-        if HasVisibleNextSibling(Run) then
-          LineImage[0] := ltTopDown
-        else
-          LineImage[0] := ltNone;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InitRootNode(OldSize: Cardinal = 0);
-
-// Reinitializes the root node.
-
-var
-  NewSize: Cardinal;
-
-begin
-  NewSize := TreeNodeSize + FTotalInternalDataSize;
-  if FRoot = nil then
-    FRoot := AllocMem(NewSize)
-  else
-  begin
-    ReallocMem(FRoot, NewSize);
-    ZeroMemory(PChar(FRoot) + OldSize, NewSize - OldSize);
-  end;
-
-  with FRoot^ do
-  begin
-    // Indication that this node is the root node.
-    PrevSibling := FRoot;
-    NextSibling := FRoot;
-    Parent := Pointer(Self);
-    States := [vsInitialized, vsExpanded, vsHasChildren, vsVisible];
-    TotalHeight := FDefaultNodeHeight;
-    TotalCount := 1;
-    TotalHeight := FDefaultNodeHeight;
-    NodeHeight := FDefaultNodeHeight;
-    Align := 50;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InterruptValidation;
-
-// Waits until the worker thread has stopped validating the caches of this tree.
-
-begin
-  if tsValidating in FStates then
-  begin
-    DoStateChange([tsStopValidation], [tsUseCache]);
-    // Make a hard break until the worker thread has stopped validation.
-    while (tsValidating in FStates) and (WorkerThread.FCurrentTree = Self) and not Application.Terminated do
-        Sleep(100);
-    DoStateChange([tsValidationNeeded]);
-  end
-  else // Remove any pending validation.
-    WorkerThread.RemoveTree(Self);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.IsFirstVisibleChild(Parent, Node: PVirtualNode): Boolean;
-
-// Helper method to check if Node is the same as the first visible child of Parent.
-
-var
-  Run: PVirtualNode;
-  
-begin
-  // Find first visible child.
-  Run := Parent.FirstChild;
-  while Assigned(Run) and not (vsVisible in Run.States) do
-    Run := Run.NextSibling;
-
-  Result := Assigned(Run) and (Run = Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.IsLastVisibleChild(Parent, Node: PVirtualNode): Boolean;
-
-// Helper method to check if Node is the same as the last visible child of Parent.
-
-var
-  Run: PVirtualNode;
-  
-begin
-  // Find last visible child.
-  Run := Parent.LastChild;
-  while Assigned(Run) and not (vsVisible in Run.States) do
-    Run := Run.PrevSibling;
-
-  Result := Assigned(Run) and (Run = Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.LimitPaintingToArea(Canvas: TCanvas; ClipRect: TRect; VisibleRegion: HRGN = 0);
-
-// Limits further painting onto the given canvas to the given rectangle.
-// VisibleRegion is an optional region which can be used to limit drawing further.
-
-var
-  ClipRegion: HRGN;
-
-begin
-  // Regions expect their coordinates in device coordinates, hence we have to transform the region rectangle.
-  LPtoDP(Canvas.Handle, ClipRect, 2);
-  ClipRegion := CreateRectRgnIndirect(ClipRect);
-  if VisibleRegion &lt;&gt; 0 then
-    CombineRgn(ClipRegion, ClipRegion, VisibleRegion, RGN_AND);
-  SelectClipRgn(Canvas.Handle, ClipRegion);
-  DeleteObject(ClipRegion);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.MakeNewNode: PVirtualNode;
-
-var
-  Size: Cardinal;
-
-begin
-  Size := TreeNodeSize;
-  if not (csDesigning in ComponentState) then
-  begin
-    // Make sure FNodeDataSize is valid.
-    if FNodeDataSize = -1 then
-      ValidateNodeDataSize(FNodeDataSize);
-
-    // Take record alignment into account.
-    Inc(Size, FNodeDataSize);
-  end;
-
-  {$ifdef UseLocalMemoryManager}
-    Result := FNodeMemoryManager.AllocNode(Size + FTotalInternalDataSize);
-  {$else}
-    Result := AllocMem(Size + FTotalInternalDataSize);
-  {$endif UseLocalMemoryManager}
-
-  // Fill in some default values.
-  with Result^ do
-  begin
-    TotalCount := 1;
-    TotalHeight := FDefaultNodeHeight;
-    NodeHeight := FDefaultNodeHeight;
-    States := [vsVisible];
-    Align := 50;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.OriginalWMNCPaint(DC: HDC);
-
-// Unfortunately, the painting for the non-client area in TControl is not always correct and does also not consider
-// existing clipping regions, so it has been modified here to take this into account.
-
-const
-  InnerStyles: array[TBevelCut] of Integer = (0, BDR_SUNKENINNER, BDR_RAISEDINNER, 0);
-  OuterStyles: array[TBevelCut] of Integer = (0, BDR_SUNKENOUTER, BDR_RAISEDOUTER, 0);
-  EdgeStyles: array[TBevelKind] of Integer = (0, 0, BF_SOFT, BF_FLAT);
-  Ctl3DStyles: array[Boolean] of Integer = (BF_MONO, 0);
-
-var
-  RC, RW: TRect;
-  EdgeSize: Integer;
-  Styles: Integer;
-
-begin
-  if (BevelKind &lt;&gt; bkNone) or (BorderWidth &gt; 0) then
-  begin
-    RC := Rect(0, 0, Width, Height);
-    Styles := GetWindowLong(Handle, GWL_STYLE);
-    if (Styles and WS_BORDER) &lt;&gt; 0 then
-      InflateRect(RC, -1, -1);
-    if (Styles and WS_THICKFRAME) &lt;&gt; 0 then
-      InflateRect(RC, -3, -3);
-    Styles := GetWindowLong(Handle, GWL_EXSTYLE);
-    if (Styles and WS_EX_CLIENTEDGE) &lt;&gt; 0 then
-      InflateRect(RC, -2, -2);
-
-    RW := RC;
-
-    if BevelKind &lt;&gt; bkNone then
-    begin
-      DrawEdge(DC, RC, InnerStyles[BevelInner] or OuterStyles[BevelOuter], Byte(BevelEdges) or EdgeStyles[BevelKind] or
-        Ctl3DStyles[Ctl3D]);
-
-      EdgeSize := 0;
-      if BevelInner &lt;&gt; bvNone then
-        Inc(EdgeSize, BevelWidth);
-      if BevelOuter &lt;&gt; bvNone then
-        Inc(EdgeSize, BevelWidth);
-      with RC do
-      begin
-        if beLeft in BevelEdges then
-          Inc(Left, EdgeSize);
-        if beTop in BevelEdges then
-          Inc(Top, EdgeSize);
-        if beRight in BevelEdges then
-          Dec(Right, EdgeSize);
-        if beBottom in BevelEdges then
-          Dec(Bottom, EdgeSize);
-      end;
-    end;
-
-    // Repaint only the part in the original clipping region and not yet drawn parts.
-    IntersectClipRect(DC, RC.Left, RC.Top, RC.Right, RC.Bottom);
-
-    // Determine inner rectangle to exclude (RC corresponds then to the client area).
-    InflateRect(RC, -BorderWidth, -BorderWidth);
-
-    // Remove the inner rectangle.
-    ExcludeClipRect(DC, RC.Left, RC.Top, RC.Right, RC.Bottom);
-
-    // Erase parts not drawn.
-    Brush.Color := FColors.BorderColor;
-    Windows.FillRect(DC, RW, Brush.Handle);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.PackArray(TheArray: TNodeArray; Count: Integer): Integer; assembler;
-
-// Removes all entries from the selection array which are no longer in use. The selection array must be sorted for this
-// algo to work. Values which must be removed are marked with bit 0 (LSB) set. This little trick works because memory
-// is always allocated DWORD aligned. Since the selection array must be sorted while determining the entries to be
-// removed it is much more efficient to increment the entry in question instead of setting it to nil (which would break
-// the ordered appearance of the list).
-//
-// On enter EAX contains self reference, EDX the address to TheArray and ECX Count
-// The returned value is the number of remaining entries in the array, so the caller can reallocate (shorten)
-// the selection array if needed or -1 if nothing needs to be changed.
-
-asm
-        PUSH    EBX
-        PUSH    EDI
-        PUSH    ESI
-        MOV     ESI, EDX
-        MOV     EDX, -1
-        JCXZ    @@Finish               // Empty list?
-        INC     EDX                    // init remaining entries counter
-        MOV     EDI, ESI               // source and destination point to the list memory
-        MOV     EBX, 1                 // use a register instead of immediate operant to check against
-@@PreScan:
-        TEST    [ESI], EBX             // do the fastest scan possible to find the first entry
-                                       // which must be removed
-        JNZ     @@DoMainLoop
-        INC     EDX
-        ADD     ESI, 4
-        DEC     ECX
-        JNZ     @@PreScan
-        JMP     @@Finish
-
-@@DoMainLoop:
-        MOV     EDI, ESI
-@@MainLoop:
-        TEST    [ESI], EBX             // odd entry?
-        JNE     @@Skip                 // yes, so skip this one
-        MOVSD                          // else move the entry to new location
-        INC     EDX                    // count the moved entries
-        DEC     ECX
-        JNZ     @@MainLoop             // do it until all entries are processed
-        JMP     @@Finish
-
-@@Skip:
-        ADD     ESI, 4                 // point to the next entry
-        DEC     ECX
-        JNZ     @@MainLoop             // do it until all entries are processed
-@@Finish:
-        MOV     EAX, EDX               // prepare return value
-        POP     ESI
-        POP     EDI
-        POP     EBX
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.PrepareBitmaps(NeedButtons, NeedLines: Boolean);
-
-// initializes the contents of the internal bitmaps
-
-const
-  LineBitsDotted: array [0..8] of Word = ($55, $AA, $55, $AA, $55, $AA, $55, $AA, $55);
-  LineBitsSolid: array [0..7] of Word = (0, 0, 0, 0, 0, 0, 0, 0);
-
-var
-  PatternBitmap: HBITMAP;
-  Bits: Pointer;
-  {$ifdef ThemeSupport}
-    Details: TThemedElementDetails;
-  {$endif ThemeSupport}
-  
-begin
-  if NeedButtons then
-  begin
-    with FMinusBM, Canvas do
-    begin
-      // box is always of odd size
-      Width := 9;
-      Height := Width;
-      Transparent := True;
-      TransparentColor := clFuchsia;
-      Brush.Color := clFuchsia;
-      FillRect(Rect(0, 0, Width, Height));
-      if FButtonStyle = bsTriangle then
-      begin
-        Brush.Color := clBlack;
-        Pen.Color := clBlack;
-        Polygon([Point(0, 2), Point(8, 2), Point(4, 6)]);
-      end
-      else                                                                
-      begin
-        // Button style is rectangular. Now ButtonFillMode determines how to fill the interior.
-        if FButtonFillMode in [fmTreeColor, fmWindowColor, fmTransparent] then
-        begin
-          case FButtonFillMode of
-            fmTreeColor:
-              Brush.Color := Self.Color;
-            fmWindowColor:
-              Brush.Color := clWindow;
-          end;
-          Pen.Color := FColors.TreeLineColor;
-          Rectangle(0, 0, Width, Height);
-          Pen.Color := Self.Font.Color;
-          MoveTo(2, Width div 2);
-          LineTo(Width - 2 , Width div 2);
-        end
-        else
-          FMinusBM.Handle := LoadBitmap(HInstance, 'VT_XPBUTTONMINUS');
-      end;
-    end;
-
-    with FPlusBM, Canvas do
-    begin                                 
-      Width := 9;
-      Height := Width;
-      Transparent := True;
-      TransparentColor := clFuchsia;
-      Brush.Color := clFuchsia;
-      FillRect(Rect(0, 0, Width, Height));
-      if FButtonStyle = bsTriangle then
-      begin
-        Brush.Color := clBlack;
-        Pen.Color := clBlack;
-        Polygon([Point(2, 0), Point(6, 4), Point(2, 8)]);
-      end
-      else
-      begin
-        // Button style is rectangular. Now ButtonFillMode determines how to fill the interior.
-        if FButtonFillMode in [fmTreeColor, fmWindowColor, fmTransparent] then
-        begin
-          case FButtonFillMode of
-            fmTreeColor:
-              Brush.Color := Self.Color;
-            fmWindowColor:
-              Brush.Color := clWindow;
-          end;
-
-          Pen.Color := FColors.TreeLineColor;
-          Rectangle(0, 0, Width, Height);
-          Pen.Color := Self.Font.Color;
-          MoveTo(2, Width div 2);
-          LineTo(Width - 2 , Width div 2);
-          MoveTo(Width div 2, 2);
-          LineTo(Width div 2, Width - 2);
-        end
-        else
-          FPlusBM.Handle := LoadBitmap(HInstance, 'VT_XPBUTTONPLUS');
-      end;
-    end;
-
-    {$ifdef ThemeSupport}
-      // Overwrite glyph images if theme is active.
-      if tsUseThemes in FStates then
-      begin
-        Details := ThemeServices.GetElementDetails(ttGlyphClosed);
-        ThemeServices.DrawElement(FPlusBM.Canvas.Handle, Details, Rect(0, 0, 9, 9));
-        Details := ThemeServices.GetElementDetails(ttGlyphOpened);
-        ThemeServices.DrawElement(FMinusBM.Canvas.Handle, Details, Rect(0, 0, 9, 9));
-      end;
-    {$endif ThemeSupport}
-  end;
-
-  if NeedLines then
-  begin
-    if FDottedBrush &lt;&gt; 0 then
-      DeleteObject(FDottedBrush);
-
-    case FLineStyle of
-      lsDotted:
-        Bits := @LineBitsDotted;
-      lsSolid:
-        Bits := @LineBitsSolid;
-    else // lsCustomStyle
-      Bits := @LineBitsDotted;
-      DoGetLineStyle(Bits);
-    end;
-    PatternBitmap := CreateBitmap(8, 8, 1, 1, Bits);
-    FDottedBrush := CreatePatternBrush(PatternBitmap);
-    DeleteObject(PatternBitmap);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.PrepareCell(var PaintInfo: TVTPaintInfo);
-
-// This method is called immediately before a cell's content is drawn und is responsible to paint selection colors etc.
-
-var
-  TextColorBackup,
-  BackColorBackup: COLORREF;
-  InnerRect: TRect;
-
-begin
-  with PaintInfo, Canvas do
-  begin
-    InnerRect := ContentRect;
-
-    // Fill cell background if its color differs from tree background.
-    with FHeader.FColumns do
-      if poColumnColor in PaintOptions then
-      begin
-        Brush.Color := Items[Column].Color;
-        FillRect(CellRect);
-      end;
-
-    // Let the application customize the cell background.
-    DoBeforeCellPaint(Canvas, Node, Column, CellRect);
-
-    if (Column = FFocusedColumn) or (toFullRowSelect in FOptions.FSelectionOptions) then
-    begin
-      // The selection rectangle depends on alignment.
-      if not (toGridExtensions in FOptions.FMiscOptions) then
-      begin
-        case Alignment of
-          taLeftJustify:
-            with InnerRect do
-              if Left + NodeWidth &lt; Right then
-                Right := Left + NodeWidth;
-          taCenter:
-            with InnerRect do
-              if (Right - Left) &gt; NodeWidth then
-              begin
-                Left := (Left + Right - NodeWidth) div 2;
-                Right := Left + NodeWidth;
-              end;
-          taRightJustify:
-            with InnerRect do
-              if (Right - Left) &gt; NodeWidth then
-                Left := Right - NodeWidth;
-        end;
-      end;
-
-      // Fill the selection rectangle.
-      if poDrawSelection in PaintOptions then
-      begin
-        if Node = FDropTargetNode then
-        begin
-          if (FLastDropMode = dmOnNode) or (vsSelected in Node.States) then
-          begin
-            Brush.Color := FColors.DropTargetColor;
-            Pen.Color := FColors.DropTargetBorderColor;
-
-            if (toGridExtensions in FOptions.FMiscOptions) or
-              (toFullRowSelect in FOptions.FSelectionOptions) then
-              InnerRect := CellRect;
-            if not IsRectEmpty(InnerRect) then
-              with InnerRect do
-                RoundRect(Left, Top, Right, Bottom, FSelectionCurveRadius, FSelectionCurveRadius);
-          end
-          else
-          begin
-            Brush.Style := bsClear;
-          end;
-        end
-        else
-          if vsSelected in Node.States then
-          begin
-            if Focused or (toPopupMode in FOptions.FPaintOptions) then
-            begin
-              Brush.Color := FColors.FocusedSelectionColor;
-              Pen.Color := FColors.FocusedSelectionBorderColor;
-            end
-            else
-            begin
-              Brush.Color := FColors.UnfocusedSelectionColor;
-              Pen.Color := FColors.UnfocusedSelectionBorderColor;
-            end;
-
-            if (toGridExtensions in FOptions.FMiscOptions) or (toFullRowSelect in FOptions.FSelectionOptions) then
-              InnerRect := CellRect;
-            if not IsRectEmpty(InnerRect) then
-              with InnerRect do
-                RoundRect(Left, Top, Right, Bottom, FSelectionCurveRadius, FSelectionCurveRadius);
-          end;
-      end;
-
-      // draw focus rect
-      if (poDrawFocusRect in PaintOptions) and (Column = FFocusedColumn) and
-        (Focused or (toPopupMode in FOptions.FPaintOptions)) and (FFocusedNode = Node) then
-      begin
-        TextColorBackup := GetTextColor(Handle);
-        SetTextColor(Handle, $FFFFFF);
-        BackColorBackup := GetBkColor(Handle);
-        SetBkColor(Handle, 0);
-
-        if toGridExtensions in FOptions.FMiscOptions then
-          Windows.DrawFocusRect(Handle, CellRect)
-        else
-          Windows.DrawFocusRect(Handle, InnerRect);
-
-        SetTextColor(Handle, TextColorBackup);
-        SetBkColor(Handle, BackColorBackup);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-type
-  TOldVTOption = (voAcceptOLEDrop, voAnimatedToggle, voAutoDropExpand, voAutoExpand, voAutoScroll,
-    voAutoSort, voAutoSpanColumns, voAutoTristateTracking, voCheckSupport, voDisableDrawSelection, voEditable,
-    voExtendedFocus, voFullRowSelect, voGridExtensions, voHideFocusRect, voHideSelection, voHotTrack, voInitOnSave,
-    voLevelSelectConstraint, voMiddleClickSelect, voMultiSelect, voRightClickSelect, voPopupMode, voShowBackground,
-    voShowButtons, voShowDropmark, voShowHorzGridLines, voShowRoot, voShowTreeLines, voShowVertGridLines,
-    voSiblingSelectConstraint, voToggleOnDblClick);
-
-const
-  OptionMap: array[TOldVTOption] of Integer = (
-    Ord(toAcceptOLEDrop), Ord(toAnimatedToggle), Ord(toAutoDropExpand), Ord(toAutoExpand), Ord(toAutoScroll),
-    Ord(toAutoSort), Ord(toAutoSpanColumns), Ord(toAutoTristateTracking), Ord(toCheckSupport), Ord(toDisableDrawSelection),
-    Ord(toEditable), Ord(toExtendedFocus), Ord(toFullRowSelect), Ord(toGridExtensions), Ord(toHideFocusRect),
-    Ord(toHideSelection), Ord(toHotTrack), Ord(toInitOnSave), Ord(toLevelSelectConstraint), Ord(toMiddleClickSelect),
-    Ord(toMultiSelect), Ord(toRightClickSelect), Ord(toPopupMode), Ord(toShowBackground),
-    Ord(toShowButtons), Ord(toShowDropmark), Ord(toShowHorzGridLines), Ord(toShowRoot), Ord(toShowTreeLines),
-    Ord(toShowVertGridLines), Ord(toSiblingSelectConstraint), Ord(toToggleOnDblClick)
-  );
-
-procedure TBaseVirtualTree.ReadOldOptions(Reader: TReader);
-
-// Migration helper routine to silently convert forms containing the old tree options member into the new
-// sub-options structure.
-
-var
-  OldOption: TOldVTOption;
-  EnumName: string;
-
-begin
-  // If we are at design time currently then let the designer know we changed something.
-  UpdateDesigner;
-
-  // It should never happen at this place that there is something different than the old set.
-  if Reader.ReadValue = vaSet then
-  begin
-    // Remove all default values set by the constructor.
-    FOptions.AnimationOptions := [];
-    FOptions.AutoOptions := [];
-    FOptions.MiscOptions := [];
-    FOptions.PaintOptions := [];
-    FOptions.SelectionOptions := [];
-
-    while True do
-    begin
-      // Sets are stored with their members as simple strings. Read them one by one and map them to the new option
-      // in the correct sub-option set.
-      EnumName := Reader.ReadStr;
-      if EnumName = '' then
-        Break;
-      OldOption := TOldVTOption(GetEnumValue(TypeInfo(TOldVTOption), EnumName));
-      case OldOption of
-        voAcceptOLEDrop, voCheckSupport, voEditable, voGridExtensions, voInitOnSave, voToggleOnDblClick:
-          FOptions.MiscOptions := FOptions.FMiscOptions + [TVTMiscOption(OptionMap[OldOption])];
-        voAnimatedToggle:
-          FOptions.AnimationOptions := FOptions.FAnimationOptions + [TVTAnimationOption(OptionMap[OldOption])];
-        voAutoDropExpand, voAutoExpand, voAutoScroll, voAutoSort, voAutoSpanColumns, voAutoTristateTracking:
-          FOptions.AutoOptions := FOptions.FAutoOptions + [TVTAutoOption(OptionMap[OldOption])];
-        voDisableDrawSelection, voExtendedFocus, voFullRowSelect, voLevelSelectConstraint,
-        voMiddleClickSelect, voMultiSelect, voRightClickSelect, voSiblingSelectConstraint:
-          FOptions.SelectionOptions := FOptions.FSelectionOptions + [TVTSelectionOption(OptionMap[OldOption])];
-        voHideFocusRect, voHideSelection, voHotTrack, voPopupMode, voShowBackground, voShowButtons,
-        voShowDropmark, voShowHorzGridLines, voShowRoot, voShowTreeLines, voShowVertGridLines:
-          FOptions.PaintOptions := FOptions.FPaintOptions + [TVTPaintOption(OptionMap[OldOption])];
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetAlignment(const Value: TAlignment);
-
-begin
-  if FAlignment &lt;&gt; Value then
-  begin
-    FAlignment := Value;
-    if not (csLoading in ComponentState) then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetAnimationDuration(const Value: Cardinal);
-
-begin
-  FAnimationDuration := Value;
-  if FAnimationDuration = 0 then
-    Exclude(FOptions.FAnimationOptions, toAnimatedToggle)
-  else
-    Include(FOptions.FAnimationOptions, toAnimatedToggle);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetBackground(const Value: TPicture);
-
-begin
-  FBackground.Assign(Value);
-  Invalidate;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetBackgroundOffset(const Index, Value: Integer);
-
-begin
-  case Index of
-    0:
-      if FBackgroundOffsetX &lt;&gt; Value then
-      begin
-        FBackgroundOffsetX := Value;
-        Invalidate;
-      end;
-    1:
-      if FBackgroundOffsetY &lt;&gt; Value then
-      begin
-        FBackgroundOffsetY := Value;
-        Invalidate;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetBorderStyle(Value: TBorderStyle);
-
-begin
-  if FBorderStyle &lt;&gt; Value then
-  begin
-    FBorderStyle := Value;
-    RecreateWnd;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetButtonFillMode(const Value: TVTButtonFillMode);
-
-begin
-  if FButtonFillMode &lt;&gt; Value then
-  begin
-    FButtonFillMode := Value;
-    if not (csLoading in ComponentState) then
-    begin
-      PrepareBitmaps(True, False);
-      if HandleAllocated then
-        Invalidate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetButtonStyle(const Value: TVTButtonStyle);
-
-begin
-  if FButtonStyle &lt;&gt; Value then
-  begin
-    FButtonStyle := Value;
-    if not (csLoading in ComponentState) then
-    begin
-      PrepareBitmaps(True, False);
-      if HandleAllocated then
-        Invalidate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetCheckImageKind(Value: TCheckImageKind);
-
-begin
-  if FCheckImageKind &lt;&gt; Value then
-  begin
-    FCheckImageKind := Value;
-    case Value of
-      ckDarkCheck:
-        FCheckImages := DarkCheckImages;
-      ckLightTick:
-        FCheckImages := LightTickImages;
-      ckDarkTick:
-        FCheckImages := DarkTickImages;
-      ckLightCheck:
-        FCheckImages := LightCheckImages;
-      ckFlat:
-        FCheckImages := FlatImages;
-      ckXP:
-        FCheckImages := XPImages;
-      ckSystem:
-        FCheckImages := SystemCheckImages;
-      ckSystemFlat:
-        FCheckImages := SystemFlatCheckImages;
-    else
-      FCheckImages := FCustomCheckImages;
-    end;
-    if HandleAllocated and (FUpdateCount = 0) and not (csLoading in ComponentState) then
-      InvalidateRect(Handle, nil, False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetCheckState(Node: PVirtualNode; Value: TCheckState);
-
-begin
-  if (Node.CheckState &lt;&gt; Value) and not (vsDisabled in Node.States) and DoChecking(Node, Value) then
-    DoCheckClick(Node, Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetCheckType(Node: PVirtualNode; Value: TCheckType);
-
-begin
-  if (Node.CheckType &lt;&gt; Value) and not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    Node.CheckType := Value;
-    Node.CheckState := csUncheckedNormal;
-    // For check boxes with tri-state check box parents we have to initialize differently.
-    if (toAutoTriStateTracking in FOptions.FAutoOptions) and (Value in [ctCheckBox, ctTriStateCheckBox]) and
-      (Node.Parent &lt;&gt; FRoot) then
-    begin
-      if not (vsInitialized in Node.Parent.States) then
-        InitNode(Node.Parent);
-      if (Node.Parent.CheckType = ctTriStateCheckBox) and
-        (Node.Parent.CheckState in [csUncheckedNormal, csCheckedNormal]) then
-        CheckState[Node] := Node.Parent.CheckState;
-    end;
-    InvalidateNode(Node);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-                                         
-procedure TBaseVirtualTree.SetChildCount(Node: PVirtualNode; NewChildCount: Cardinal);
-
-// Changes a node's child structure to accomodate the new child count. This is used to add or delete
-// child nodes to/from the end of the node's child list. To insert or delete a specific node a separate
-// routine is used.
-
-var
-  Count: Integer;
-  Index: Cardinal;
-  Child: PVirtualNode;
-  C: Integer;
-  NewHeight: Integer;
-
-begin
-  if not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    if Node = nil then
-      Node := FRoot;
-    
-    if NewChildCount = 0 then
-      DeleteChildren(Node)
-    else
-    begin
-      Count := Integer(NewChildCount) - Integer(Node.ChildCount);
-
-      // If nothing changed then do nothing.
-      if Count &lt;&gt; 0 then
-      begin
-        InterruptValidation;
-
-        C := Count;
-        NewHeight := 0;
-      
-        if Count &gt; 0 then
-        begin
-          // New nodes to add.
-          if Assigned(Node.LastChild) then
-            Index := Node.LastChild.Index + 1
-          else
-          begin
-            Index := 0;
-            Include(Node.States, vsHasChildren);
-          end;
-
-          // New nodes are by default always visible, so we don't need to check the visibility.
-          while Count &gt; 0 do
-          begin
-            Child := MakeNewNode;
-            Child.Index := Index;
-            Child.PrevSibling := Node.LastChild;
-            if Assigned(Node.LastChild) then
-              Node.LastChild.NextSibling := Child;
-            Child.Parent := Node;
-            Node.LastChild := Child;
-            if Node.FirstChild = nil then
-              Node.FirstChild := Child;
-            Dec(Count);
-            Inc(Index);
-            Inc(NewHeight, Child.NodeHeight);
-          end;
-
-          if vsExpanded in Node.States then
-          begin
-            AdjustTotalHeight(Node, NewHeight, True);
-            if FullyVisible[Node] then
-              Inc(Integer(FVisibleCount), C);
-          end;
-
-          AdjustTotalCount(Node, C, True);
-          Node.ChildCount := NewChildCount;
-          if (FUpdateCount = 0) and (toAutoSort in FOptions.FAutoOptions) and (FHeader.FSortColumn &gt; InvalidColumn) then
-            Sort(Node, FHeader.FSortColumn, FHeader.FSortDirection, True);
-
-          InvalidateCache;
-        end
-        else
-        begin
-          // Nodes have to be deleted.
-          while Count &lt; 0 do
-          begin
-            DeleteNode(Node.LastChild);
-            Inc(Count);
-          end;
-        end;
-
-        if FUpdateCount = 0 then
-        begin
-          ValidateCache;
-          UpdateScrollBars(True);
-          Invalidate;
-        end;
-
-        if Node = FRoot then
-          StructureChange(nil, crChildAdded)
-        else
-          StructureChange(Node, crChildAdded);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetClipboardFormats(const Value: TClipboardFormats);
-
-var
-  I: Integer;
-
-begin
-  // Add string by string instead doing an Assign or AddStrings because the list may return -1 for
-  // invalid entries which cause trouble for the standard implementation.
-  FClipboardFormats.Clear;
-  for I := 0 to Value.Count - 1 do
-    FClipboardFormats.Add(Value[I]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetColors(const Value: TVTColors);
-
-begin
-  FColors.Assign(Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetCustomCheckImages(const Value: TCustomImageList);
-
-begin
-  if FCustomCheckImages &lt;&gt; Value then
-  begin
-    if Assigned(FCustomCheckImages) then
-    begin
-      FCustomCheckImages.UnRegisterChanges(FCustomCheckChangeLink);
-      {$ifdef COMPILER_5_UP}
-        FCustomCheckImages.RemoveFreeNotification(Self);
-      {$endif COMPILER_5_UP}
-      // Reset the internal check image list reference too, if necessary.
-      if FCheckImages = FCustomCheckImages then
-        FCheckImages := nil;
-    end;
-    FCustomCheckImages := Value;
-    if Assigned(FCustomCheckImages) then
-    begin
-      FCustomCheckImages.RegisterChanges(FCustomCheckChangeLink);
-      FCustomCheckImages.FreeNotification(Self);
-    end;
-    // Check if currently custom check images are active.
-    if FCheckImageKind = ckCustom then
-      FCheckImages := Value;
-    if not (csLoading in ComponentState) then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetDefaultNodeHeight(Value: Cardinal);
-
-begin
-  if Value = 0 then
-    Value := 18;
-  if FDefaultNodeHeight &lt;&gt; Value then
-  begin
-    DoStateChange([tsNeedScale]);
-    Inc(Integer(FRoot.TotalHeight), Integer(Value) - Integer(FDefaultNodeHeight));
-    Inc(SmallInt(FRoot.NodeHeight), Integer(Value) - Integer(FDefaultNodeHeight));
-    FDefaultNodeHeight := Value;
-    InvalidateCache;
-    if (FUpdateCount = 0) and HandleAllocated and not (csLoading in ComponentState) then
-    begin
-      ValidateCache;
-      UpdateScrollBars(True);
-      ScrollIntoView(FFocusedNode, toCenterScrollIntoView in FOptions.SelectionOptions, True);
-      Invalidate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetDisabled(Node: PVirtualNode; Value: Boolean);
-
-begin
-  if Assigned(Node) and (Value xor (vsDisabled in Node.States)) then
-  begin
-    if Value then
-      Include(Node.States, vsDisabled)
-    else
-      Exclude(Node.States, vsDisabled);
-
-    if FUpdateCount = 0 then
-      InvalidateNode(Node);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetExpanded(Node: PVirtualNode; Value: Boolean);
-
-begin
-  if Assigned(Node) and (Node &lt;&gt; FRoot) and (Value xor (vsExpanded in Node.States)) then
-    ToggleNode(Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetFocusedColumn(Value: TColumnIndex);
-
-begin
-  if (FFocusedColumn &lt;&gt; Value) and
-     DoFocusChanging(FFocusedNode, FFocusedNode, FFocusedColumn, Value) then
-  begin
-    CancelEditNode;
-    FFocusedColumn := Value;
-    if Assigned(FFocusedNode) then
-    begin
-      ScrollIntoView(FFocusedNode, toCenterScrollIntoView in FOptions.SelectionOptions,
-        not (toDisableAutoscrollOnFocus in FOptions.FAutoOptions));
-      InvalidateNode(FFocusedNode);
-    end;
-
-    DoFocusChange(FFocusedNode, FFocusedColumn);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetFocusedNode(Value: PVirtualNode);
-
-var
-  WasDifferent: Boolean;
-
-begin
-  WasDifferent := Value &lt;&gt; FFocusedNode;
-  DoFocusNode(Value, True);
-  // Do change event only if there was actually a change.
-  if WasDifferent and (FFocusedNode = Value) then
-    DoFocusChange(FFocusedNode, FFocusedColumn);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetFullyVisible(Node: PVirtualNode; Value: Boolean);
-
-// This method ensures that a node is visible and all its parent nodes are expanded and also visible
-// if Value is True. Otherwise the visibility flag of the node is reset but the expand state
-// of the parent nodes stays untouched.
-
-begin
-  Assert(Assigned(Node) and (Node &lt;&gt; FRoot), 'Invalid parameter');
-
-  IsVisible[Node] := Value;
-  if Value then
-  begin
-    repeat
-      Node := Node.Parent;
-      if Node = FRoot then
-        Break;
-      if not (vsExpanded in Node.States) then
-        ToggleNode(Node);
-      if not (vsVisible in Node.States) then
-        IsVisible[Node] := True;
-    until False;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetHasChildren(Node: PVirtualNode; Value: Boolean);
-
-begin
-  if Assigned(Node) and not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    if Value then
-      Include(Node.States, vsHasChildren)
-    else
-    begin
-      Exclude(Node.States, vsHasChildren);
-      DeleteChildren(Node);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetHeader(const Value: TVTHeader);
-
-begin
-  FHeader.Assign(Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetImages(const Value: TCustomImageList);
-
-begin
-  if FImages &lt;&gt; Value then
-  begin
-    if Assigned(FImages) then
-    begin
-      FImages.UnRegisterChanges(FImageChangeLink);
-      {$ifdef COMPILER_5_UP}
-        FImages.RemoveFreeNotification(Self);
-      {$endif COMPILER_5_UP}
-    end;
-    FImages := Value;
-    if Assigned(FImages) then
-    begin
-      FImages.RegisterChanges(FImageChangeLink);
-      FImages.FreeNotification(Self);
-    end;
-    if not (csLoading in ComponentState) then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetIndent(Value: Cardinal);
-
-begin
-  if FIndent &lt;&gt; Value then
-  begin
-    FIndent := Value;
-    if not (csLoading in ComponentState) and (FUpdateCount = 0) and HandleAllocated then
-    begin
-      UpdateScrollBars(True);
-      Invalidate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetLineMode(const Value: TVTLineMode);
-
-begin
-  if FLineMode &lt;&gt; Value then
-  begin
-    FLineMode := Value;
-    if HandleAllocated and not (csLoading in ComponentState) then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetLineStyle(const Value: TVTLineStyle);
-
-begin
-  if FLineStyle &lt;&gt; Value then
-  begin
-    FLineStyle := Value;
-    if not (csLoading in ComponentState) then
-    begin
-      PrepareBitmaps(False, True);
-      if HandleAllocated then
-        Invalidate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetMargin(Value: Integer);
-
-begin
-  if FMargin &lt;&gt; Value then
-  begin
-    FMargin := Value;
-    if HandleAllocated and not (csLoading in ComponentState) then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetMultiline(Node: PVirtualNode; const Value: Boolean);
-
-begin
-  if Assigned(Node) and (Node &lt;&gt; FRoot) then
-    if Value &lt;&gt; (vsMultiline in Node.States) then
-    begin
-      if Value then
-        Include(Node.States, vsMultiline)
-      else
-        Exclude(Node.States, vsMultiline);
-
-      if FUpdateCount = 0 then
-        InvalidateNode(Node);
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetNodeAlignment(const Value: TVTNodeAlignment);
-
-begin
-  if FNodeAlignment &lt;&gt; Value then
-  begin
-    FNodeAlignment := Value;
-    if HandleAllocated and not (csReading in ComponentState) then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetNodeDataSize(Value: Integer);
-
-var
-  LastRootCount: Cardinal;
-
-begin
-  if Value &lt; -1 then
-    Value := -1;
-  if FNodeDataSize &lt;&gt; Value then
-  begin
-    FNodeDataSize := Value;
-    if not (csLoading in ComponentState) and not (csDesigning in ComponentState) then
-    begin
-      LastRootCount := FRoot.ChildCount;
-      Clear;
-      SetRootNodeCount(LastRootCount);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetNodeHeight(Node: PVirtualNode; Value: Cardinal);
-
-var
-  Difference: Integer;
-
-begin
-  if Assigned(Node) and (Node &lt;&gt; FRoot) and (Node.NodeHeight &lt;&gt; Value) and not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    Difference := Integer(Value) - Integer(Node.NodeHeight);
-    Node.NodeHeight := Value;
-    AdjustTotalHeight(Node, Difference, True);
-    if FullyVisible[Node] then
-    begin
-      InvalidateCache;
-      if FUpdateCount = 0 then
-      begin
-        ValidateCache;
-        InvalidateToBottom(Node);
-        UpdateScrollBars(True);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetNodeParent(Node: PVirtualNode; const Value: PVirtualNode);
-
-begin
-  if Assigned(Node) and Assigned(Value) and (Node.Parent &lt;&gt; Value) then
-    MoveTo(Node, Value, amAddChildLast, False); 
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetOffsetX(const Value: Integer);
-
-begin
-  DoSetOffsetXY(Point(Value, FOffsetY), DefaultScrollUpdateFlags);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetOffsetXY(const Value: TPoint);
-
-begin
-  DoSetOffsetXY(Value, DefaultScrollUpdateFlags);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetOffsetY(const Value: Integer);
-
-begin
-  DoSetOffsetXY(Point(FOffsetX, Value), DefaultScrollUpdateFlags);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetOptions(const Value: TCustomVirtualTreeOptions);
-
-begin
-  FOptions.Assign(Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetRootNodeCount(Value: Cardinal);
-
-begin
-  // Don't set the root node count until all other properties (in particular the OnInitNode event) have been set.
-  if csLoading in ComponentState then
-  begin
-    FRoot.ChildCount := Value;
-    DoStateChange([tsNeedRootCountUpdate]);
-  end
-  else
-    if FRoot.ChildCount &lt;&gt; Value then
-    begin
-      BeginUpdate;
-      InterruptValidation;
-      SetChildCount(FRoot, Value);
-      EndUpdate;
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetScrollBarOptions(Value: TScrollBarOptions);
-
-begin
-  FScrollBarOptions.Assign(Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetSearchOption(const Value: TVTIncrementalSearch);
-
-begin
-  if FIncrementalSearch &lt;&gt; Value then
-  begin
-    FIncrementalSearch := Value;
-    if FIncrementalSearch = isNone then
-    begin
-      StopTimer(SearchTimer);
-      FSearchBuffer := '';
-      FLastSearchNode := nil;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetSelected(Node: PVirtualNode; Value: Boolean);
-
-begin
-  if Assigned(Node) and (Node &lt;&gt; FRoot) and (Value xor (vsSelected in Node.States)) then
-  begin
-    if Value then
-    begin
-      if FSelectionCount = 0 then
-        FRangeAnchor := Node
-      else
-        if not (toMultiSelect in FOptions.FSelectionOptions) then
-          ClearSelection;
-
-      AddToSelection(Node);
-
-      // Make sure there is a valid column selected (if there are columns at all).
-      if ((FFocusedColumn &lt; 0) or not (coVisible in FHeader.Columns[FFocusedColumn].Options)) and
-        (FHeader.MainColumn &gt; NoColumn) then
-        if coVisible in FHeader.Columns[FHeader.MainColumn].Options then
-          FFocusedColumn := FHeader.MainColumn
-        else
-          FFocusedColumn := FHeader.Columns.GetFirstVisibleColumn;
-      if FRangeAnchor = nil then
-        FRangeAnchor := Node;
-    end
-    else
-    begin
-      RemoveFromSelection(Node);
-      if FSelectionCount = 0 then
-        ResetRangeAnchor;
-    end;
-    if FullyVisible[Node] then
-      InvalidateNode(Node);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetSelectionCurveRadius(const Value: Cardinal);
-
-begin
-  if FSelectionCurveRadius &lt;&gt; Value then
-  begin
-    FSelectionCurveRadius := Value;
-    if HandleAllocated and not (csLoading in ComponentState) then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetStateImages(const Value: TCustomImageList);
-
-begin
-  if FStateImages &lt;&gt; Value then
-  begin
-    if Assigned(FStateImages) then
-    begin
-      FStateImages.UnRegisterChanges(FStateChangeLink);
-      {$ifdef COMPILER_5_UP}
-        FStateImages.RemoveFreeNotification(Self);
-      {$endif COMPILER_5_UP}
-    end;
-    FStateImages := Value;
-    if Assigned(FStateImages) then
-    begin
-      FStateImages.RegisterChanges(FStateChangeLink);
-      FStateImages.FreeNotification(Self);
-    end;
-    if HandleAllocated and not (csLoading in ComponentState) then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetTextMargin(Value: Integer);
-
-begin
-  if FTextMargin &lt;&gt; Value then
-  begin
-    FTextMargin := Value;
-    if not (csLoading in ComponentState) then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetTopNode(Node: PVirtualNode);
-
-var
-  R: TRect;
-  Run: PVirtualNode;
-
-begin
-  if Assigned(Node) then
-  begin
-    // make sure all parents of the node are expanded
-    Run := Node.Parent;
-    while Run &lt;&gt; FRoot do
-    begin
-      if not (vsExpanded in Run.States) then
-        ToggleNode(Run);
-      Run := Run.Parent;
-    end;
-    R := GetDisplayRect(Node, FHeader.MainColumn, True);
-    SetOffsetY(FOffsetY - R.Top);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetUpdateState(Updating: Boolean);
-
-begin
-  // The check for visibility is necessary otherwise the tree is automatically shown when
-  // updating is allowed. As this happens internally the VCL does not get notified and
-  // still assumes the control is hidden. This results in weird &quot;cannot focus invisble control&quot; errors.
-  if Visible and HandleAllocated then
-    SendMessage(Handle, WM_SETREDRAW, Ord(not Updating), 0);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetVerticalAlignment(Node: PVirtualNode; Value: Byte);
-
-begin
-  if Value &gt; 100 then
-    Value := 100;
-  if Node.Align &lt;&gt; Value then
-  begin
-    Node.Align := Value;
-    if FullyVisible[Node] and (FUpdateCount = 0) then
-      InvalidateNode(Node);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetVisible(Node: PVirtualNode; Value: Boolean);
-
-// Sets the visibility style of the given node according to Value.
-
-var
-  NeedUpdate: Boolean;
-
-begin
-  Assert(Assigned(Node) and (Node &lt;&gt; FRoot), 'Invalid parameter.');
-
-  if Value &lt;&gt; (vsVisible in Node.States) then
-  begin
-    InterruptValidation;
-    NeedUpdate := False;
-    if Value then
-    begin
-      Include(Node.States, vsVisible);
-      if vsExpanded in Node.Parent.States then
-        AdjustTotalHeight(Node.Parent, Node.TotalHeight, True);
-      if VisiblePath[Node] then
-      begin
-        Inc(FVisibleCount, 1 + CountVisibleChildren(Node));
-        NeedUpdate := True;
-      end;
-
-      // Update the hidden children flag of the parent.
-      // Since this node is now visible we simply have to remove the flag.
-      Exclude(Node.Parent.States, vsAllChildrenHidden);
-    end
-    else
-    begin
-      Exclude(Node.States, vsVisible);
-      if vsExpanded in Node.Parent.States then
-        AdjustTotalHeight(Node.Parent, -Integer(Node.TotalHeight), True);
-      if VisiblePath[Node] then
-      begin
-        Dec(FVisibleCount, 1 + CountVisibleChildren(Node));
-        NeedUpdate := True;
-      end;
-
-      if FUpdateCount = 0 then
-        DetermineHiddenChildrenFlag(Node.Parent)
-      else
-        Include(FStates, tsUpdateHiddenChildrenNeeded)
-    end;
-
-    InvalidateCache;
-    if NeedUpdate and (FUpdateCount = 0) then
-    begin
-      ValidateCache;
-      UpdateScrollBars(True);
-      Invalidate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetVisiblePath(Node: PVirtualNode; Value: Boolean);
-
-// If Value is True then all parent nodes of Node are expanded.
-
-begin
-  Assert(Assigned(Node) and (Node &lt;&gt; FRoot), 'Invalid parameter.');
-
-  if Value then
-  begin
-    repeat
-      Node := Node.Parent;
-      if Node = FRoot then
-        Break;
-      if not (vsExpanded in Node.States) then
-        ToggleNode(Node);
-    until False;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.StopTimer(ID: Integer);
-
-begin
-  if HandleAllocated then
-    KillTimer(Handle, ID);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.TileBackground(Source: TBitmap; Target: TCanvas; Offset: TPoint; R: TRect);
-
-// Draws the given source graphic so that it tiles into the given rectangle which is relative to the target bitmap.
-// The graphic is aligned so that it always starts at the upper left corner of the target canvas.
-// Offset gives the position of the target window in an possible superordinated surface.
-
-var
-  SourceX,
-  SourceY,
-  TargetX,
-
-  DeltaY: Integer;
-  
-begin
-  with Target do
-  begin
-    SourceY := (R.Top + Offset.Y + FBackgroundOffsetY) mod Source.Height;
-    // Always wrap the source coordinates into positive range.
-    if SourceY &lt; 0 then
-      SourceY := Source.Height + SourceY;
-
-    // Tile image vertically until target rect is filled.
-    while R.Top &lt; R.Bottom do
-    begin
-      SourceX := (R.Left + Offset.X + FBackgroundOffsetX) mod Source.Width;
-      // always wrap the source coordinates into positive range
-      if SourceX &lt; 0 then
-        SourceX := Source.Width + SourceX;
-
-      TargetX := R.Left;
-      // height of strip to draw
-      DeltaY := Min(R.Bottom - R.Top, Source.Height - SourceY);
-
-      // tile the image horizontally
-      while TargetX &lt; R.Right do
-      begin
-        BitBlt(Handle, TargetX, R.Top, Min(R.Right - TargetX, Source.Width - SourceX), DeltaY,
-          Source.Canvas.Handle, SourceX, SourceY, SRCCOPY);
-        Inc(TargetX, Source.Width - SourceX);
-        SourceX := 0;
-      end;
-      Inc(R.Top, Source.Height - SourceY);
-      SourceY := 0;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.ToggleCallback(Step, StepSize: Integer; Data: Pointer): Boolean;
-
-var
-  ScrollRect: TRect;
-  Column: TColumnIndex;
-  Run: TRect;
-
-  //--------------- local function --------------------------------------------
-
-  procedure EraseLine;
-
-  var
-    LocalBrush: HBRUSH;
-
-  begin
-    with TToggleAnimationData(Data^), FHeader.FColumns do
-    begin
-      // Iterate through all columns and erase background in their local color.
-      // LocalBrush is a brush in the color of the particular column.
-      Column := ColumnFromPosition(Run.TopLeft);
-      while (Column &gt; InvalidColumn) and (Run.Left &lt; ClientWidth) do
-      begin
-        GetColumnBounds(Column, Run.Left, Run.Right);
-        if coParentColor in Items[Column].FOptions then
-          FillRect(DC, Run, Brush)
-        else
-        begin
-          LocalBrush := CreateSolidBrush(ColorToRGB(Items[Column].Color));
-          FillRect(DC, Run, LocalBrush);
-          DeleteObject(LocalBrush);
-        end;
-        Column := GetNextVisibleColumn(Column);
-      end;
-    end;
-  end;
-
-  //--------------- end local function ----------------------------------------
-
-begin
-  Result := True;
-  if StepSize &gt; 0 then
-  begin
-    with TToggleAnimationData(Data^) do
-    begin
-      ScrollRect := R;
-      if Expand then
-      begin
-        ScrollDC(DC, 0, StepSize, ScrollRect, ScrollRect, 0, nil);
-
-        // In the first step the background must be cleared (only a small stripe) to avoid artefacts.
-        if Step = 0 then
-          if not FHeader.UseColumns then
-            FillRect(DC, Rect(R.Left, R.Top, R.Right, R.Top + StepSize + 1), Brush)
-          else
-          begin
-            Run := Rect(R.Left, R.Top, R.Right, R.Top + StepSize + 1);
-            EraseLine;
-          end;
-      end
-      else
-      begin
-        // Collapse branch.
-        ScrollDC(DC, 0, -StepSize, ScrollRect, ScrollRect, 0, nil);
-
-        if Step = 0 then
-          if not FHeader.UseColumns then
-            FillRect(DC, Rect(R.Left, R.Bottom - StepSize - 1, R.Right, R.Bottom), Brush)
-          else
-          begin
-            Run := Rect(R.Left, R.Bottom - StepSize - 1, R.Right, R.Bottom);
-            EraseLine;
-          end;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMColorChange(var Message: TMessage);
-
-begin
-  if not (csLoading in ComponentState) then
-  begin
-    PrepareBitmaps(True, False);
-    if HandleAllocated then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMCtl3DChanged(var Message: TMessage);
-
-begin
-  inherited;
-  if FBorderStyle = bsSingle then
-    RecreateWnd;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMDenySubclassing(var Message: TMessage);
-
-// If a Windows XP Theme Manager component is used in the application it will try to subclass all controls which do not
-// explicitly deny this. Virtual Treeview knows how to handle XP themes so it does not need subclassing.
-
-begin
-  Message.Result := 1;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMDrag(var Message: TCMDrag);
-
-var
-  S: TObject;
-  ShiftState: Integer;
-  P: TPoint;
-  Formats: TFormatArray;
-
-begin
-  with Message, DragRec^ do
-  begin
-    S := Source;
-    Formats := nil;
-
-    // Let the ancestor handle dock operations.
-    if S is TDragDockObject then
-      inherited
-    else
-    begin
-      // We need an extra check for the control drag object as there might be other objects not derived from
-      // this class (e.g. TActionDragObject).
-      if not (tsUserDragObject in FStates) and (S is TBaseDragControlObject) then
-        S := (S as TBaseDragControlObject).Control;
-      case DragMessage of
-        dmDragEnter, dmDragLeave, dmDragMove:
-          begin
-            if DragMessage = dmDragEnter then
-              DoStateChange([tsVCLDragging]);
-            if DragMessage = dmDragLeave then
-              DoStateChange([], [tsVCLDragging]);
-              
-            if DragMessage = dmDragMove then
-              with ScreenToClient(Pos) do
-                DoAutoScroll(X, Y);
-              
-            ShiftState := 0;
-            // Alt key will be queried by the KeysToShiftState function in DragOver.
-            if GetKeyState(VK_SHIFT) &lt; 0 then
-              ShiftState := ShiftState or MK_SHIFT;
-            if GetKeyState(VK_CONTROL) &lt; 0 then
-              ShiftState := ShiftState or MK_CONTROL;
-
-            // Allowed drop effects are simulated for VCL dd.
-            Result := DROPEFFECT_MOVE or DROPEFFECT_COPY;
-            DragOver(S, ShiftState, TDragState(DragMessage), Pos, Result);
-            FLastVCLDragTarget := FDropTargetNode;
-            FVCLDragEffect := Result;
-            if (DragMessage = dmDragLeave) and Assigned(FDropTargetNode) then
-            begin
-              InvalidateNode(FDropTargetNode);
-              FDropTargetNode := nil;
-            end;
-          end;
-        dmDragDrop:
-          begin
-            ShiftState := 0;
-            // Alt key will be queried by the KeysToShiftState function in DragOver
-            if GetKeyState(VK_SHIFT) &lt; 0 then
-              ShiftState := ShiftState or MK_SHIFT;
-            if GetKeyState(VK_CONTROL) &lt; 0 then
-              ShiftState := ShiftState or MK_CONTROL;
-
-            // allowed drop effects are simulated for VCL dd,
-            // replace target node with cached node from other VCL dd messages
-            if Assigned(FDropTargetNode) then
-              InvalidateNode(FDropTargetNode);
-            FDropTargetNode := FLastVCLDragTarget;
-            P := Point(Pos.X, Pos.Y);
-            P := ScreenToClient(P);
-            DoDragDrop(S, nil, Formats, KeysToShiftState(ShiftState), P, FVCLDragEffect, FLastDropMode);
-            if Assigned(FDropTargetNode) then
-            begin
-              InvalidateNode(FDropTargetNode);
-              FDropTargetNode := nil;
-            end;
-          end;
-        dmFindTarget:
-          begin
-            Result := Integer(ControlAtPos(ScreenToClient(Pos), False));
-            if Result = 0 then
-              Result := Integer(Self);
-
-            // This is a reliable place to check whether VCL drag has
-            // really begun.  
-            if tsVCLDragPending in FStates then
-              DoStateChange([tsVCLDragging], [tsVCLDragPending, tsEditPending, tsClearPending]);
-          end;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMEnabledChanged(var Message: TMessage);
-
-begin
-  inherited;
-
-  // Need to invalidate the non-client area as well, since the header must be redrawn too.
-  if csDesigning in ComponentState then
-    RedrawWindow(Handle, nil, 0, RDW_FRAME or RDW_INVALIDATE or RDW_NOERASE or RDW_NOCHILDREN); 
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMFontChanged(var Message: TMessage);
-
-begin
-  inherited;
-
-  if not (csLoading in ComponentState) then
-  begin
-    PrepareBitmaps(True, False);
-    if HandleAllocated then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMHintShow(var Message: TCMHintShow);
-
-// Determines hint message (tooltip) and out-of-hint rect.
-// Note: A special handling is needed here because we cannot pass wide strings back to the caller.
-//       I had to introduce the hint data record anyway so we can use this to pass the hint string.
-//       We still need to set a dummy hint string in the message to make the VCL showing the hint window.
-
-var
-  NodeRect: TRect;
-  SpanColumn,
-  Dummy,
-  ColLeft,
-  ColRight: Integer;
-  HitInfo: THitInfo;
-  ShowOwnHint: Boolean;
-  IsFocusedOrEditing: Boolean;
-  ParentForm: TCustomForm;
-
-begin
-  with Message do
-  begin
-    Result := 1;
-
-    if PtInRect(FLastHintRect, HintInfo.CursorPos) then
-      Exit;
-    // Determine node for which to show hint/tooltip.
-    with HintInfo^ do
-      GetHitTestInfoAt(CursorPos.X, CursorPos.Y, True, HitInfo);
-
-    // Make sure a hint is only shown if the tree or at least its parent form is active.
-    // Active editing is ok too as long as we don't want the hint for the current edit node.
-    if IsEditing then
-      IsFocusedOrEditing := HitInfo.HitNode &lt;&gt; FFocusedNode
-    else
-    begin
-      IsFocusedOrEditing := Focused;
-      ParentForm := GetParentForm(Self);
-      if Assigned(ParentForm) then
-        IsFocusedOrEditing := ParentForm.Focused or Application.Active;
-    end;
-
-    if (GetCapture = 0) and ShowHint and not (Dragging or IsMouseSelecting) and ([tsScrolling] * FStates = []) and
-      (FHeader.States = []) and IsFocusedOrEditing then
-    begin
-      with HintInfo^ do
-      begin
-        Result := 0;
-        ShowOwnHint := False;
-        // Assign a dummy string otherwise the VCL will not show the hint window.
-        HintStr := ' ';
-
-        // First check whether there is a header hint to show.
-        if FHeader.UseColumns and (hoShowHint in FHeader.FOptions) and FHeader.InHeader(CursorPos) then
-        begin
-          CursorRect := FHeaderRect;
-          // Convert the cursor rectangle into real client coordinates.
-          OffsetRect(CursorRect, 0, -Integer(FHeader.FHeight));
-          HitInfo.HitColumn := FHeader.FColumns.GetColumnAndBounds(CursorPos, CursorRect.Left, CursorRect.Right);
-          // align the vertical hint position on the bottom bound of the header, but
-          // avoid overlapping of mouse cursor and hint
-          HintPos.Y := Max(HintPos.Y, ClientToScreen(Point(0, CursorRect.Bottom)).Y);
-          // Note: the test for the left mouse button in ControlState might cause problems whenever the VCL does not
-          //       realize when the button is released. This, for instance, happens when doing OLE drag'n drop and
-          //       cancel this with ESC.
-          if (HitInfo.HitColumn &gt; -1) and not (csLButtonDown in ControlState) then
-          begin
-            FHintData.DefaultHint := FHeader.FColumns[HitInfo.HitColumn].FHint;
-            if FHintData.DefaultHint &lt;&gt; '' then
-              ShowOwnHint := True
-            else
-              Result := 1;
-          end
-          else
-            Result := 1;
-        end
-        else
-        begin
-          // Default mode is handled as would the tree be a usual VCL control (no own hint window necessary).
-          if FHintMode = hmDefault then
-            HintStr := GetShortHint(Hint)
-          else
-          begin
-            if Assigned(HitInfo.HitNode) and (HitInfo.HitColumn &gt; InvalidColumn) then
-            begin
-              // A draw tree should only display a hint when at least its OnGetHintSize
-              // event handler is assigned.
-              if Self is TCustomVirtualDrawTree then
-              begin
-                FHintData.HintRect := Rect(0, 0, 0, 0);
-                with Self as TCustomVirtualDrawTree do
-                  DoGetHintSize(HitInfo.HitNode, HitInfo.HitColumn, FHintData.HintRect);
-                ShowOwnHint := not IsRectEmpty(FHintData.HintRect);
-              end
-              else
-                // For string trees a decision about showing the hint or not is based
-                // on the hint string (if it is empty then no hint is shown).
-                ShowOwnHint := True;
-
-              if ShowOwnHint then
-              begin
-                if HitInfo.HitColumn &gt; NoColumn then
-                begin
-                  FHeader.FColumns.GetColumnBounds(HitInfo.HitColumn, ColLeft, ColRight);
-                  // The right column border might be extended if column spanning is enabled.
-                  if toAutoSpanColumns in FOptions.FAutoOptions then
-                  begin
-                    SpanColumn := HitInfo.HitColumn;
-                    repeat
-                      Dummy := FHeader.FColumns.GetNextVisibleColumn(SpanColumn);
-                      if (Dummy = InvalidColumn) or not ColumnIsEmpty(HitInfo.HitNode, Dummy) then
-                        Break;
-                      SpanColumn := Dummy;
-                    until False;
-                    if SpanColumn &lt;&gt; HitInfo.HitColumn then
-                      FHeader.FColumns.GetColumnBounds(SpanColumn, Dummy, ColRight);
-                  end;
-                end
-                else
-                begin
-                  ColLeft := 0;
-                  ColRight := ClientWidth;
-                end;
-
-                FHintData.DefaultHint :=  '';
-                if FHintMode &lt;&gt; hmTooltip then
-                begin
-                  // Node specific hint text.
-                  CursorRect := GetDisplayRect(HitInfo.HitNode, HitInfo.HitColumn, False);
-                  // Align the vertical hint position on the bottom bound of the node, but
-                  // avoid overlapping of mouse cursor and hint.
-                  HintPos.Y := Max(HintPos.Y, ClientToScreen(CursorRect.BottomRight).Y) + 2;
-                end
-                else
-                begin
-                  // Tool tip to show. This means the full caption of the node must be displayed.
-                  if vsMultiline in HitInfo.HitNode.States then
-                  begin
-                    ShowOwnHint := True;
-                    NodeRect := GetDisplayRect(HitInfo.HitNode, HitInfo.HitColumn, True, False);
-                  end
-                  else
-                  begin
-                    NodeRect := GetDisplayRect(HitInfo.HitNode, HitInfo.HitColumn, True, True);
-                    ShowOwnHint := (HitInfo.HitColumn &gt; InvalidColumn) and PtInRect(NodeRect, CursorPos) and
-                      (CursorPos.X &lt;= ColRight) and (CursorPos.X &gt;= ColLeft) and
-                      ((NodeRect.Right &gt; Min(ColRight, ClientWidth)) or (NodeRect.Left &lt; Max(ColLeft, 0)));
-                  end;
-
-                  if ShowOwnHint then
-                  begin
-                    // Node specific hint text given will be retrieved when needed.
-                    FHintData.DefaultHint := '';
-                    HintPos := ClientToScreen(Point(NodeRect.Left, NodeRect.Top));
-                    CursorRect := NodeRect;
-                  end
-                  else
-                    // nothing to show
-                    Result := 1;
-                end;
-              end
-              else
-                Result := 1; // Avoid hint if this is a draw tree returning an empty hint rectangle.
-            end
-            else
-            begin
-              // No node so fall back to control's hint (if indicated) or show nothing.
-              if FHintMode = hmHintAndDefault then
-              begin
-                FHintData.DefaultHint := GetShortHint(Hint);
-                if Length(FHintData.DefaultHint) = 0 then
-                  Result := 1
-                else
-                  ShowOwnHint := True;
-              end
-              else
-                Result := 1;
-            end;
-          end;
-        end;
-
-        // Set our own hint window class and prepare structure to be passed to the hint window.
-        if ShowOwnHint and (Result = 0) then
-        begin
-          HintWindowClass := TVirtualTreeHintWindow;
-
-          FHintData.Tree := Self;
-          FHintData.Column := HitInfo.HitColumn;
-          FHintData.Node := HitInfo.HitNode;
-          FLastHintRect := CursorRect;
-          HintData := @FHintData;
-        end
-        else
-          FLastHintRect := Rect(0, 0, 0, 0);
-      end;
-
-      // Remind that a hint is about to show.
-      if Result = 0 then
-        DoStateChange([tsHint])
-      else
-        DoStateChange([], [tsHint]);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMHintShowPause(var Message: TCMHintShowPause);
-
-// Tells the application that the tree (and only the tree) does not want a delayed tool tip.
-// Normal hints / header hints use the default delay (except the first time).
-
-var
-  P: TPoint;
-
-begin
-  // A little workaround is needed here to make the application class using the correct hint window class.
-  // Once the application gets ShowHint set to true (which is the case when we want to show hints in the tree) then
-  // an internal hint window will be created which is not our own class (because we don't set an application wide
-  // hint window class but only one for the tree). Unfortunately, this default hint window class will prevent
-  // hints for the non-client area to show up (e.g. for the header) by calling CancelHint whenever certain messages
-  // arrive. By setting the hint show pause to 0 if our hint class was not used recently we make sure
-  // that the hint timer (in Forms.pas) is not used and our class is created immediately.
-  if HintWindowDestroyed then
-  begin
-    GetCursorPos(P);
-    // Check if the mouse is in the header or tool tips are enabled, which must be shown without delay anyway.
-    if FHeader.UseColumns and (hoShowHint in FHeader.FOptions) and FHeader.InHeader(ScreenToClient(P)) or
-      (FHintMode = hmToolTip) then
-      Message.Pause^ := 0
-  end
-  else
-    if (FHintMode = hmToolTip) then
-      Message.Pause^ := 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMMouseLeave(var Message: TMessage);
-
-var
-  LeaveStates: TVirtualTreeStates;
-  
-begin
-  LeaveStates := [tsHint];
-  if [tsWheelPanning, tsWheelScrolling] * FStates = [] then
-  begin
-    StopTimer(ScrollTimer);
-    LeaveStates := LeaveStates + [tsScrollPending, tsScrolling];
-  end;
-  DoStateChange([], LeaveStates);
-  if Assigned(FCurrentHotNode) then
-  begin
-    DoHotChange(FCurrentHotNode, nil);
-    InvalidateNode(FCurrentHotNode);
-    FCurrentHotNode := nil;
-  end;
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMMouseWheel(var Message: TCMMouseWheel);
-
-var
-  ScrollCount: Integer;
-  ScrollLines: Integer;
-
-begin
-  StopWheelPanning;
-  
-  inherited;
-
-  if Message.Result = 0  then
-  begin
-    with Message do
-    begin
-      Result := 1;
-      if FRangeY &gt; Cardinal(ClientHeight) then
-      begin
-        // Scroll vertically if there's something to scroll...
-        if ssCtrl in ShiftState then
-          ScrollCount := WheelDelta div WHEEL_DELTA * (ClientHeight div Integer(FDefaultNodeHeight))
-        else
-        begin
-          SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, @ScrollLines, 0);
-          ScrollCount := ScrollLines * WheelDelta div WHEEL_DELTA;
-        end;
-        SetOffsetY(FOffsetY + ScrollCount * Integer(FDefaultNodeHeight));
-      end
-      else
-      begin
-        // ...else scroll horizontally.
-        if ssCtrl in ShiftState then
-          ScrollCount := WheelDelta div WHEEL_DELTA * ClientWidth
-        else
-          ScrollCount := WheelDelta div WHEEL_DELTA;
-        SetOffsetX(FOffsetX + ScrollCount * Integer(FIndent));
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CMSysColorChange(var Message: TMessage);
-
-begin
-  inherited;
-
-  ConvertImageList(LightCheckImages, 'VT_CHECK_LIGHT');
-  ConvertImageList(DarkCheckImages, 'VT_CHECK_DARK');
-  ConvertImageList(LightTickImages, 'VT_TICK_LIGHT');
-  ConvertImageList(DarkTickImages, 'VT_TICK_DARK');
-  ConvertImageList(FlatImages, 'VT_FLAT');
-  ConvertImageList(UtilityImages, 'VT_UTILITIES');
-  // XP images do not need to be converted.
-  // System check images do not need to be converted.
-  Message.Msg := WM_SYSCOLORCHANGE;
-  DefaultHandler(Message);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMCancelMode(var Message: TWMCancelMode);
-
-begin
-  // Clear any transient state.
-  StopTimer(ExpandTimer);
-  StopTimer(EditTimer);
-  StopTimer(HeaderTimer);
-  StopTimer(ScrollTimer);
-  StopTimer(SearchTimer);
-  FSearchBuffer := '';
-  FLastSearchNode := nil;
-
-  DoStateChange([], [tsClearPending, tsEditPending, tsOLEDragPending, tsVCLDragPending, tsDrawSelecting,
-    tsDrawSelPending, tsIncrementalSearching]);
-
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMChangeState(var Message: TMessage);
-
-var
-  EnterStates,
-  LeaveStates: TVirtualTreeStates;
-
-begin
-  EnterStates := [];
-  if csStopValidation in TChangeStates(Byte(Message.WParam)) then
-    Include(EnterStates, tsStopValidation);
-  if csUseCache in TChangeStates(Byte(Message.WParam)) then
-    Include(EnterStates, tsUseCache);
-  if csValidating in TChangeStates(Byte(Message.WParam)) then
-    Include(EnterStates, tsValidating);
-  if csValidationNeeded in TChangeStates(Byte(Message.WParam)) then
-    Include(EnterStates, tsValidationNeeded);
-
-  LeaveStates := [];
-  if csStopValidation in TChangeStates(Byte(Message.LParam)) then
-    Include(LeaveStates, tsStopValidation);
-  if csUseCache in TChangeStates(Byte(Message.LParam)) then
-    Include(LeaveStates, tsUseCache);
-  if csValidating in TChangeStates(Byte(Message.LParam)) then
-    Include(LeaveStates, tsValidating);
-  if csValidationNeeded in TChangeStates(Byte(Message.LParam)) then
-    Include(LeaveStates, tsValidationNeeded);
-
-  DoStateChange(EnterStates, LeaveStates);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMChar(var Message: TWMChar);
-
-begin
-  if tsIncrementalSearchPending in FStates then
-  begin
-    HandleIncrementalSearch(Message.CharCode);
-    DoStateChange([], [tsIncrementalSearchPending]);
-  end;
-
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMContextMenu(var Message: TWMContextMenu);
-
-// This method is called when a popup menu is about to be displayed.
-// We have to cancel some pending states here to avoid interferences.
-
-begin
-  DoStateChange([], [tsClearPending, tsEditPending, tsOLEDragPending, tsVCLDragPending]);
-
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMCopy(var Message: TWMCopy);
-
-begin
-  CopyToClipboard;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMCut(var Message: TWMCut);
-
-begin
-  CutToClipboard;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMEnable(var Message: TWMEnable);
-
-begin
-  inherited;
-  RedrawWindow(Handle, nil, 0, RDW_FRAME or RDW_INVALIDATE or RDW_NOERASE or RDW_NOCHILDREN);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMEraseBkgnd(var Message: TWMEraseBkgnd);
-
-begin
-  Message.Result := 1;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMGetDlgCode(var Message: TWMGetDlgCode);
-
-begin
-  Message.Result := DLGC_WANTCHARS or DLGC_WANTARROWS;
-  if FWantTabs then
-    Message.Result := Message.Result or DLGC_WANTTAB;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMHScroll(var Message: TWMHScroll);
-
-  //--------------- local functions -------------------------------------------
-
-  function GetRealScrollPosition: Integer;
-
-  var
-    SI: TScrollInfo;
-    Code: Integer;
-
-  begin
-    SI.cbSize := SizeOf(TScrollInfo);
-    SI.fMask := SIF_TRACKPOS;
-    Code := SB_HORZ;
-    {$ifdef UseFlatScrollbars}
-      FlatSB_GetScrollInfo(Handle, Code, SI);
-    {$else}
-      GetScrollInfo(Handle, Code, SI);
-    {$endif UseFlatScrollbars}
-    Result := SI.nTrackPos;
-  end;
-
-  //--------------- end local functions ---------------------------------------
-
-begin
-  case Message.ScrollCode of
-    SB_BOTTOM:
-      SetOffsetX(-Integer(FRangeX));
-    SB_ENDSCROLL:
-      begin
-        DoStateChange([], [tsThumbTracking]);
-        // avoiding to adjust the vertical scroll position while tracking makes it much smoother
-        // but we need to adjust the final position here then
-        UpdateHorizontalScrollBar(False);
-      end;
-    SB_LINELEFT:
-      SetOffsetX(FOffsetX + FScrollBarOptions.FIncrementX);
-    SB_LINERIGHT:
-      SetOffsetX(FOffsetX - FScrollBarOptions.FIncrementX);
-    SB_PAGELEFT:
-      SetOffsetX(FOffsetX + ClientWidth);
-    SB_PAGERIGHT:
-      SetOffsetX(FOffsetX - ClientWidth);
-    SB_THUMBPOSITION,
-    SB_THUMBTRACK:
-      begin
-        DoStateChange([tsThumbTracking]);
-        SetOffsetX(-GetRealScrollPosition);
-      end;
-    SB_TOP:
-      SetOffsetX(0);
-  end;
-
-  Message.Result := 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMKeyDown(var Message: TWMKeyDown);
-
-// Keyboard event handling for node focus, selection, node specific popup menus and help invokation.
-// For a detailed description of every action done here read the help.
-
-var
-  Shift: TShiftState;
-  Node, Temp,
-  LastFocused: PVirtualNode;
-  Offset: Integer;
-  ClearPending,
-  NeedInvalidate,
-  DoRangeSelect,
-  HandleMultiSelect: Boolean;
-  Context: Integer;
-  ParentControl: TWinControl;
-  R: TRect;
-  NewCheckState: TCheckState;
-  NewColumn: TColumnIndex;
-  ActAsGrid: Boolean;
-
-  // for tabulator handling
-  GetStartColumn: function: TColumnIndex of object;
-  GetNextColumn: function(Column: TColumnIndex): TColumnIndex of object;
-  GetNextNode: TGetNextNodeProc;
-
-  KeyState: TKeyboardState;
-  Buffer: array[0..1] of Char;
-
-begin
-  // Make form key preview work and let application modify the key if it wants this.
-  inherited;
-
-  with Message do
-  begin
-    Shift := KeyDataToShiftState(KeyData);
-    // Ask the application if the default key handling is desired.
-    if DoKeyAction(CharCode, Shift) then
-    begin         
-      if (tsKeyCheckPending in FStates) and (CharCode &lt;&gt; VK_SPACE) then
-      begin
-        DoStateChange([], [tskeyCheckPending]);
-        FCheckNode.CheckState := UnpressedState[FCheckNode.CheckState];
-        RepaintNode(FCheckNode);
-        FCheckNode := nil;
-      end;
-
-      if CharCode in [VK_HOME, VK_END, VK_PRIOR, VK_NEXT, VK_UP, VK_DOWN, VK_LEFT, VK_RIGHT, VK_BACK, VK_TAB] then
-      begin
-        HandleMultiSelect := (ssShift in Shift) and (toMultiSelect in FOptions.FSelectionOptions) and not IsEditing;
-
-        // Flag to avoid range selection in case of single node advance.
-        DoRangeSelect := (CharCode in [VK_HOME, VK_END, VK_PRIOR, VK_NEXT]) and HandleMultiSelect and not IsEditing;
-                  
-        NeedInvalidate := DoRangeSelect or (FSelectionCount &gt; 1);
-        ActAsGrid := toGridExtensions in FOptions.FMiscOptions;
-        ClearPending := (Shift = []) or (ActAsGrid and not (ssShift in Shift)) or
-          not (toMultiSelect in FOptions.FSelectionOptions) or (CharCode in [VK_TAB, VK_BACK]);
-
-        // Keep old focused node for range selection. Use a default node if none was focused until now.
-        LastFocused := FFocusedNode;
-        if (LastFocused = nil) and (Shift &lt;&gt; []) then
-          LastFocused := GetFirstVisible;
-
-        // Set an initial range anchor if there is not yet one.
-        if FRangeAnchor = nil then
-          FRangeAnchor := GetFirstSelected;
-        if FRangeAnchor = nil then
-          FRangeAnchor := GetFirst;
-
-        // Determine new focused node.
-        case CharCode of
-          VK_HOME, VK_END:
-            begin
-              if CharCode = VK_END then
-              begin
-                GetStartColumn := FHeader.FColumns.GetLastVisibleColumn;
-                GetNextColumn := FHeader.FColumns.GetPreviousVisibleColumn;
-                GetNextNode := GetPreviousVisible;
-                Node := GetLastVisible;
-              end
-              else
-              begin
-                GetStartColumn := FHeader.FColumns.GetFirstVisibleColumn;
-                GetNextColumn := FHeader.FColumns.GetNextVisibleColumn;
-                GetNextNode := GetNextVisible;
-                Node := GetFirstVisible;
-              end;
-
-              // Advance to next/previous visible column.
-              if FHeader.UseColumns then
-                NewColumn := GetStartColumn
-              else
-                NewColumn := NoColumn;
-              // Find a column for the new/current node which can be focused.
-              while (NewColumn &gt; NoColumn) and not DoFocusChanging(FFocusedNode, Node, FFocusedColumn, NewColumn) do
-                NewColumn := GetNextColumn(NewColumn);
-              if NewColumn &gt; InvalidColumn then
-              begin
-                if (Shift = [ssCtrl]) and not ActAsGrid then
-                begin
-                  ScrollIntoView(Node, toCenterScrollIntoView in FOptions.SelectionOptions,
-                    not (toDisableAutoscrollOnFocus in FOptions.FAutoOptions));
-                  if CharCode = VK_HOME then
-                    SetOffsetX(0)
-                  else
-                    SetOffsetX(-MaxInt);
-                end
-                else
-                begin
-                  if not ActAsGrid or (ssCtrl in Shift) then
-                    FocusedNode := Node;
-                  if ActAsGrid and not (toFullRowSelect in FOptions.FSelectionOptions) then
-                    FocusedColumn := NewColumn;
-                end;
-              end;
-            end;
-          VK_PRIOR:
-            if ssCtrl in Shift then
-              SetOffsetY(FOffsetY + ClientHeight)
-            else
-            begin
-              Offset := 0;
-              // If there's no focused node then just take the very first visible one.
-              if FFocusedNode = nil then
-                Node := GetFirstVisible
-              else
-              begin
-                // Go up as many nodes as comprise together a size of ClientHeight.
-                Node := FFocusedNode;
-                while Offset &lt; ClientHeight do
-                begin
-                  Temp := GetPreviousVisible(Node);
-                  if Temp = nil then
-                    Break;
-                  Node := Temp;
-                  Inc(Offset, Node.NodeHeight);
-                end;
-              end;
-              FocusedNode := Node;
-            end;
-          VK_NEXT:
-            if ssCtrl in Shift then
-              SetOffsetY(FOffsetY - ClientHeight)
-            else
-            begin
-              Offset := 0;
-              // If there's no focused node then just take the very last one.
-              if FFocusedNode = nil then
-                Node := GetLastVisible
-              else
-              begin
-                // Go up as many nodes as comprise together a size of ClientHeight.
-                Node := FFocusedNode;
-                while Offset &lt; ClientHeight do
-                begin
-                  Temp := GetNextVisible(Node);
-                  if Temp = nil then
-                    Break;
-                  Node := Temp;
-                  Inc(Offset, Node.NodeHeight);
-                end;
-              end;
-              FocusedNode := Node;
-            end;
-          VK_UP:
-            begin
-              // scrolling without selection change
-              if ssCtrl in Shift then
-                SetOffsetY(FOffsetY + Integer(FDefaultNodeHeight))
-              else
-              begin
-                if FFocusedNode = nil then
-                  Node := GetLastVisible
-                else
-                  Node := GetPreviousVisible(FFocusedNode);
-
-                if Assigned(Node) then
-                begin
-                  EndEditNode;
-                  if HandleMultiSelect and (CompareNodePositions(LastFocused, FRangeAnchor) &gt; 0) and
-                    Assigned(FFocusedNode) then
-                    RemoveFromSelection(FFocusedNode);
-                  if FFocusedColumn = NoColumn then
-                    FFocusedColumn := FHeader.MainColumn;
-                  FocusedNode := Node;
-                end
-                else
-                  if Assigned(FFocusedNode) then
-                    InvalidateNode(FFocusedNode);
-              end;
-            end;
-          VK_DOWN:
-            begin
-              // scrolling without selection change
-              if ssCtrl in Shift then
-                SetOffsetY(FOffsetY - Integer(FDefaultNodeHeight))
-              else
-              begin
-                if FFocusedNode = nil then
-                  Node := GetFirstVisible
-                else
-                  Node := GetNextVisible(FFocusedNode);
-
-                if Assigned(Node) then
-                begin
-                  EndEditNode;
-                  if HandleMultiSelect and (CompareNodePositions(LastFocused, FRangeAnchor) &lt; 0) and
-                    Assigned(FFocusedNode) then
-                    RemoveFromSelection(FFocusedNode);
-                  if FFocusedColumn = NoColumn then
-                    FFocusedColumn := FHeader.MainColumn;
-                  FocusedNode := Node;
-                end
-                else
-                  if Assigned(FFocusedNode) then
-                    InvalidateNode(FFocusedNode);
-              end;
-            end;
-          VK_LEFT:
-            begin
-              // special handling
-              if ssCtrl in Shift then
-                SetOffsetX(FOffsetX + Integer(FIndent))
-              else
-              begin
-                // other special cases
-                Context := NoColumn;
-                if (toExtendedFocus in FOptions.FSelectionOptions) and (toGridExtensions in FOptions.FMiscOptions) then
-                begin
-                  Context := FHeader.Columns.GetPreviousVisibleColumn(FFocusedColumn);
-                  if Context &gt; -1 then
-                    FocusedColumn := Context
-                end
-                else
-                  if Assigned(FFocusedNode) and (vsExpanded in FFocusedNode.States) and
-                     (Shift = []) and (vsHasChildren in FFocusedNode.States) then
-                    ToggleNode(FFocusedNode)
-                  else
-                  begin
-                    if FFocusedNode = nil then
-                      FocusedNode := GetFirstVisible
-                    else
-                    begin
-                      if FFocusedNode.Parent &lt;&gt; FRoot then
-                        Node := FFocusedNode.Parent
-                      else
-                        Node := nil;
-                      if Assigned(Node) then
-                      begin
-                        if HandleMultiSelect then
-                        begin
-                          // and a third special case
-                          if FFocusedNode.Index &gt; 0 then
-                            DoRangeSelect := True
-                          else
-                           if CompareNodePositions(Node, FRangeAnchor) &gt; 0 then
-                             RemoveFromSelection(FFocusedNode);
-                        end;
-                        FocusedNode := Node;
-                      end;
-                    end;
-                  end;
-              end;
-            end;
-          VK_RIGHT:
-            begin
-              // special handling
-              if ssCtrl in Shift then
-                SetOffsetX(FOffsetX - Integer(FIndent))
-              else
-              begin
-                // other special cases
-                Context := NoColumn;
-                if (toExtendedFocus in FOptions.FSelectionOptions) and (toGridExtensions in FOptions.FMiscOptions) then
-                begin
-                  Context := FHeader.Columns.GetNextVisibleColumn(FFocusedColumn);
-                  if Context &gt; -1 then
-                    FocusedColumn := Context;
-                end
-                else
-                  if Assigned(FFocusedNode) and not (vsExpanded in FFocusedNode.States) and
-                     (Shift = []) and (vsHasChildren in FFocusedNode.States) then
-                    ToggleNode(FFocusedNode)
-                  else
-                  begin
-                    if FFocusedNode = nil then
-                      FocusedNode := GetFirstVisible
-                    else
-                    begin
-                      Node := GetFirstVisibleChild(FFocusedNode);
-                      if Assigned(Node) then
-                      begin
-                        if HandleMultiSelect and (CompareNodePositions(Node, FRangeAnchor) &lt; 0) then
-                          RemoveFromSelection(FFocusedNode);
-                        FocusedNode := Node;
-                      end;
-                    end;
-                  end;
-              end;
-            end;
-          VK_BACK:
-            if tsIncrementalSearching in FStates then
-              DoStateChange([tsIncrementalSearchPending])
-            else
-              if Assigned(FFocusedNode) and (FFocusedNode.Parent &lt;&gt; FRoot) then
-                FocusedNode := FocusedNode.Parent;
-          VK_TAB:
-            if (toExtendedFocus in FOptions.FSelectionOptions) and FHeader.UseColumns then
-            begin
-              // In order to avoid duplicating source code just to change the direction
-              // we use function variables.
-              if ssShift in Shift then
-              begin
-                GetStartColumn := FHeader.FColumns.GetLastVisibleColumn;
-                GetNextColumn := FHeader.FColumns.GetPreviousVisibleColumn;
-                GetNextNode := GetPreviousVisible;
-              end
-              else
-              begin
-                GetStartColumn := FHeader.FColumns.GetFirstVisibleColumn;
-                GetNextColumn := FHeader.FColumns.GetNextVisibleColumn;
-                GetNextNode := GetNextVisible;
-              end;
-
-              // Advance to next/previous visible column/node.
-              Node := FFocusedNode;
-              NewColumn := GetNextColumn(FFocusedColumn);
-              repeat
-                // Find a column for the current node which can be focused.
-                while (NewColumn &gt; NoColumn) and not DoFocusChanging(FFocusedNode, Node, FFocusedColumn, NewColumn) do
-                  NewColumn := GetNextColumn(NewColumn);
-
-                if NewColumn &gt; NoColumn then
-                begin
-                  FocusedNode := Node;
-                  FocusedColumn := NewColumn;
-                  Break;
-                end;
-
-                // No next column was accepted for the current node. So advance to next node and try again.
-                Node := GetNextNode(Node);
-                NewColumn := GetStartColumn;
-              until Node = nil;
-            end;
-        end;
-
-        // Clear old selection if required but take care about change events.
-        if ClearPending then
-          if (LastFocused = FFocusedNode) and (FSelectionCount &lt;= 1) then
-            InternalClearSelection
-          else
-            ClearSelection;
-
-        // Determine new selection anchor.
-        if Shift = [] then
-        begin
-          FRangeAnchor := FFocusedNode;
-          FLastSelectionLevel := GetNodeLevel(FFocusedNode);
-        end;
-        // Finally change the selection for a specific range of nodes.
-        if DoRangeSelect then
-          ToggleSelection(LastFocused, FFocusedNode);
-
-        // Make sure the new focused node is also selected.
-        // Avoid change event if this node was already the only selected node.
-        if Assigned(FFocusedNode) then
-          if LastFocused = FFocusedNode then
-            InternalAddToSelection(FFocusedNode, False)
-          else
-            AddToSelection(FFocusedNode);
-            
-        // If a repaint is needed then paint the entire tree because of the ClearSelection call,
-        if NeedInvalidate then
-          Invalidate;
-      end
-      else
-      begin
-        // Second chance for keys not directly concerned with selection changes.
-
-        // For +, -, /, * keys on the main keyboard (not numpad) there is no virtual key code defined.
-        // We have to do special processing to get them working too.
-        GetKeyboardState(KeyState);
-        // Avoid conversion to control characters. We have captured the control key state already in Shift.
-        KeyState[VK_CONTROL] := 0;
-        if ToASCII(Message.CharCode, (Message.KeyData shr 16) and 7, KeyState, Buffer, 0) &gt; 0 then
-        begin
-          case Buffer[0] of
-            '*':
-              CharCode := VK_MULTIPLY;
-            '+':
-              CharCode := VK_ADD;
-            '/':
-              CharCode := VK_DIVIDE;
-            '-':
-              CharCode := VK_SUBTRACT;
-          end;
-        end;
-
-        case CharCode of
-          VK_F2:
-            if (Shift = []) and Assigned(FFocusedNode) and CanEdit(FFocusedNode, FFocusedColumn) then
-            begin
-              FEditColumn := FFocusedColumn;
-              DoEdit;
-            end;
-          VK_ADD:
-            if not (tsIncrementalSearching in FStates) then
-            begin
-              if ssCtrl in Shift then
-                if {$ifdef ReverseFullExpandHotKey} not {$endif ReverseFullExpandHotKey} (ssShift in Shift) then
-                  FullExpand
-                else
-                  FHeader.AutoFitColumns
-              else
-                if Assigned(FFocusedNode) and not (vsExpanded in FFocusedNode.States) then
-                  ToggleNode(FFocusedNode);
-            end
-            else
-              DoStateChange([tsIncrementalSearchPending]);
-          VK_SUBTRACT:
-            if not (tsIncrementalSearching in FStates) then
-            begin
-              if ssCtrl in Shift then
-                if {$ifdef ReverseFullExpandHotKey} not {$endif ReverseFullExpandHotKey} (ssShift in Shift) then
-                  FullCollapse
-                else
-                  FHeader.RestoreColumns
-              else
-                if Assigned(FFocusedNode) and (vsExpanded in FFocusedNode.States) then
-                  ToggleNode(FFocusedNode);
-            end
-            else
-              DoStateChange([tsIncrementalSearchPending]);
-          VK_MULTIPLY:
-            if not (tsIncrementalSearching in FStates) then
-            begin
-              if Assigned(FFocusedNode) then
-                FullExpand(FFocusedNode);
-            end
-            else
-              DoStateChange([tsIncrementalSearchPending]);
-          VK_DIVIDE:
-            if not (tsIncrementalSearching in FStates) then
-            begin
-              if Assigned(FFocusedNode) then
-                FullCollapse(FFocusedNode);
-            end
-            else
-              DoStateChange([tsIncrementalSearchPending]);
-          VK_ESCAPE: // cancel actions currently in progress
-            begin
-              if IsMouseSelecting then
-              begin
-                DoStateChange([], [tsDrawSelecting, tsDrawSelPending]);
-                Invalidate;
-              end
-              else
-                if IsEditing then
-                  CancelEditNode;
-            end;
-          VK_SPACE:
-            if (toCheckSupport in FOptions.MiscOptions) and Assigned(FFocusedNode) and
-              (FFocusedNode.CheckType &lt;&gt; ctNone) then
-            begin
-              if (FStates * [tsKeyCheckPending, tsMouseCheckPending] = []) and Assigned(FFocusedNode) and
-                not (vsDisabled in FFocusedNode.States) then
-              begin
-                with FFocusedNode^ do
-                  NewCheckState := DetermineNextCheckState(CheckType, CheckState);
-                if DoChecking(FFocusedNode, NewCheckState) then
-                begin
-                  DoStateChange([tsKeyCheckPending]);
-                  FCheckNode := FFocusedNode;
-                  FPendingCheckState := NewCheckState;
-                  FCheckNode.CheckState := PressedState[FCheckNode.CheckState];
-                  RepaintNode(FCheckNode);
-                end;
-              end;
-            end
-            else
-              DoStateChange([tsIncrementalSearchPending]);
-          VK_F1:
-            if Assigned(FOnGetHelpContext) then
-            begin
-              Context := 0;
-              if Assigned(FFocusedNode) then
-              begin
-                Node := FFocusedNode;
-                // Traverse the tree structure up to the root.
-                repeat
-                  FOnGetHelpContext(Self, Node, 0, Context);
-                  Node := Node.Parent;
-                until (Node = FRoot) or (Context &lt;&gt; 0);
-              end;
-
-              // If no help context could be found try the tree's one or its parent's contexts.
-              ParentControl := Self;
-              while Assigned(ParentControl) and (Context = 0) do
-              begin
-                Context := ParentControl.HelpContext;
-                ParentControl := ParentControl.Parent;
-              end;
-              if Context &lt;&gt; 0 then
-                Application.HelpContext(Context);
-            end;
-          VK_APPS:
-            if Assigned(FFocusedNode) then
-            begin
-              R := GetDisplayRect(FFocusedNode, FFocusedColumn, True);
-              Offset := DoGetNodeWidth(FFocusedNode, FFocusedColumn);
-              if FFocusedColumn &gt;= 0 then
-              begin
-                if Offset &gt; FHeader.Columns[FFocusedColumn].Width then
-                  Offset := FHeader.Columns[FFocusedColumn].Width;
-              end
-              else
-              begin
-                if Offset &gt; ClientWidth then
-                  Offset := ClientWidth;
-              end;
-              DoPopupMenu(FFocusedNode, FFocusedColumn, Point(R.Left + Offset div 2, (R.Top + R.Bottom) div 2));
-            end;
-          Ord('a'), Ord('A'):
-            if ssCtrl in Shift then
-              SelectAll(True)
-            else
-              DoStateChange([tsIncrementalSearchPending]);
-        else
-        begin
-          // Use the key for incremental search.
-          // Since we are dealing with Unicode all the time there should be a more sophisticated way
-          // of checking for valid characters for incremental search.
-          // This is available but would require to include a significant amount of Unicode character
-          // properties, so we stick with the simple space check.
-          if (Shift * [ssCtrl, ssAlt] = []) and (CharCode &gt;= 32) then
-            DoStateChange([tsIncrementalSearchPending]);
-          end;
-        end;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMKeyUp(var Message: TWMKeyUp);
-
-begin
-  inherited;
-
-  case Message.CharCode of
-    VK_SPACE:
-      if tsKeyCheckPending in FStates then
-      begin
-        DoStateChange([], [tskeyCheckPending]);
-        if FCheckNode = FFocusedNode then
-          DoCheckClick(FCheckNode, FPendingCheckState);
-        InvalidateNode(FCheckNode);
-        FCheckNode := nil;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMKillFocus(var Msg: TWMKillFocus);
-
-var
-  Form: TCustomForm;
-  Control: TWinControl;
-  Pos: TSmallPoint;
-  Unknown: IUnknown;
-
-begin
-  inherited;
-
-  // Stop wheel panning if active.
-  StopWheelPanning;
-
-  // Don't let any timer continue if the tree is no longer the active control (except change timers).
-  StopTimer(ExpandTimer);
-  StopTimer(EditTimer);
-  StopTimer(HeaderTimer);
-  StopTimer(ScrollTimer);
-  StopTimer(SearchTimer);
-  FSearchBuffer := '';
-  FLastSearchNode := nil;
-
-  DoStateChange([], [tsScrollPending, tsScrolling, tsEditPending, tsLeftButtonDown, tsRightButtonDown,
-    tsMiddleButtonDown, tsOLEDragPending, tsVCLDragPending, tsIncrementalSearching]);
-
-  if (FSelectionCount &gt; 0) or not (toGhostedIfUnfocused in FOptions.FPaintOptions) then
-    Invalidate
-  else
-    if Assigned(FFocusedNode) then
-      InvalidateNode(FFocusedNode);
-
-  // Workaround for wrapped non-VCL controls (like TWebBrowser), which do not use VCL mechanisms and
-  // leave the ActiveControl property in the wrong state, which causes trouble when the control is refocused.
-  Form := GetParentForm(Self);
-  if Assigned(Form) and (Form.ActiveControl = Self) then
-  begin
-    Cardinal(Pos) := GetMessagePos;
-    Control := FindVCLWindow(SmallPointToPoint(Pos));
-    // Every control derived from TOleControl has potentially the focus problem. In order to avoid including
-    // the OleCtrls unit (which will, among others, include Variants), which would allow to test for the TOleControl
-    // class, the IOleClientSite interface is used for the test, which is supported by TOleControl and a good indicator.
-    if Assigned(Control) and Control.GetInterface(IOleClientSite, Unknown) then
-      Form.ActiveControl := nil;
-
-    // For other classes the active control should not be modified. Otherwise you need two clicks to select it.
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMLButtonDblClk(var Message: TWMLButtonDblClk);
-
-var
-  HitInfo: THitInfo;
-
-begin
-  inherited;
-
-  // get information about the hit
-  GetHitTestInfoAt(Message.XPos, Message.YPos, True, HitInfo);
-  HandleMouseDblClick(Message, HitInfo);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMLButtonDown(var Message: TWMLButtonDown);
-
-var
-  HitInfo: THitInfo;
-  
-begin
-  DoStateChange([tsLeftButtonDown]);
-  inherited;
-
-  // get information about the hit
-  GetHitTestInfoAt(Message.XPos, Message.YPos, True, HitInfo);
-  HandleMouseDown(Message, HitInfo);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMLButtonUp(var Message: TWMLButtonUp);
-
-var
-  HitInfo: THitInfo;
-  
-begin
-  DoStateChange([], [tsLeftButtonDown]);
-
-  // get information about the hit
-  GetHitTestInfoAt(Message.XPos, Message.YPos, True, HitInfo);
-  HandleMouseUp(Message, HitInfo);
-
-  inherited;
-
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMMButtonDblClk(var Message: TWMMButtonDblClk);
-
-var
-  HitInfo: THitInfo;
-
-begin
-  inherited;
-
-  // get information about the hit
-  if toMiddleClickSelect in FOptions.FSelectionOptions then
-  begin
-    GetHitTestInfoAt(Message.XPos, Message.YPos, True, HitInfo);
-    HandleMouseDblClick(Message, HitInfo);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMMButtonDown(var Message: TWMMButtonDown);
-
-var
-  HitInfo: THitInfo;
-
-begin
-  DoStateChange([tsMiddleButtonDown]);
-  
-  if FHeader.FStates = [] then
-  begin
-    inherited;
-
-    // Start wheel panning or scrolling if not already active, allowed and scrolling is useful at all.
-    if (toWheelPanning in FOptions.FMiscOptions) and ([tsWheelScrolling, tsWheelPanning] * FStates = []) and
-      ((Integer(FRangeX) &gt; ClientWidth) or (Integer(FRangeY) &gt; ClientHeight)) then
-    begin
-      FLastClickPos := SmallPointToPoint(Message.Pos);
-      StartWheelPanning(FLastClickPos);
-    end
-    else
-    begin
-      StopWheelPanning;
-
-      // Get information about the hit.
-      if toMiddleClickSelect in FOptions.FSelectionOptions then
-      begin
-        GetHitTestInfoAt(Message.XPos, Message.YPos, True, HitInfo);
-        HandleMouseDown(Message, HitInfo);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMMButtonUp(var Message: TWMMButtonUp);
-
-var
-  HitInfo: THitInfo;
-
-begin
-  DoStateChange([], [tsMiddleButtonDown]);
-
-  // If wheel panning/scrolling is active and the mouse has not yet been moved then the user starts wheel auto scrolling.
-  // Indicate this by removing the panning flag. Otherwise (the mouse has moved meanwhile) stop panning.
-  if [tsWheelPanning, tsWheelScrolling] * FStates &lt;&gt; [] then
-  begin
-    if tsWheelScrolling in FStates then
-      DoStateChange([], [tsWheelPanning])
-    else
-      StopWheelPanning;
-  end
-  else
-    if FHeader.FStates = [] then
-    begin
-      inherited;
-
-      // get information about the hit
-      if toMiddleClickSelect in FOptions.FSelectionOptions then
-      begin
-        GetHitTestInfoAt(Message.XPos, Message.YPos, True, HitInfo);
-        HandleMouseUp(Message, HitInfo);
-      end;
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMNCCalcSize(var Message: TWMNCCalcSize);
-
-begin
-  inherited;
-
-  with FHeader do
-    if hoVisible in FHeader.FOptions then
-      with Message.CalcSize_Params^ do
-        Inc(rgrc[0].Top, FHeight);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMNCDestroy(var Message: TWMNCDestroy);
-
-// Used to release a reference of the drag manager. This is the only reliable way we get notified about
-// window destruction, because of the automatic release of a window if its parent window is freed.
-
-begin 
-  StopTimer(ChangeTimer);
-  StopTimer(StructureChangeTimer);
-
-  if not (csDesigning in ComponentState) and (toAcceptOLEDrop in FOptions.FMiscOptions) then
-    RevokeDragDrop(Handle);
-
-  // Clean up other stuff.
-  DeleteObject(FDottedBrush);
-  FDottedBrush := 0;
-
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMNCHitTest(var Message: TWMNCHitTest);
-
-begin
-  inherited;
-  if not (csDesigning in ComponentState) and (hoVisible in FHeader.FOptions) and
-    FHeader.InHeader(ScreenToClient(SmallPointToPoint(Message.Pos))) then
-    Message.Result := HTBORDER;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMNCPaint(var Message: TRealWMNCPaint);
-
-var
-  DC: HDC;
-  R: TRect;
-  Flags: DWORD;
-
-begin
-  DefaultHandler(Message);
-
-  // If the tree is themed then the border which is drawn by the default handler will be overpainted here.
-  // This will, when resizing columns, cause a bit flicker, but since I found nowhwere documentation about
-  // how to do it right I have to live with that for the time being.
-  Flags := DCX_CACHE or DCX_CLIPSIBLINGS or DCX_WINDOW or DCX_VALIDATE;
-
-  if True or (Message.Rgn = 1) or not IsWinNT then
-    DC := GetDCEx(Handle, 0, Flags)
-  else
-    DC := GetDCEx(Handle, Message.Rgn, Flags or DCX_INTERSECTRGN);
-
-  if DC &lt;&gt; 0 then
-  begin
-    if hoVisible in FHeader.FOptions then
-    begin
-      R := FHeaderRect;
-      FHeader.FColumns.PaintHeader(DC, R, FOffsetX);
-    end;
-    OriginalWMNCPaint(DC);
-    ReleaseDC(Handle, DC);
-  end;
-  {$ifdef ThemeSupport}
-    if tsUseThemes in FStates then
-      ThemeServices.PaintBorder(Self, False);
-  {$endif ThemeSupport}
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMPaint(var Message: TWMPaint);
-
-begin
-  if tsVCLDragging in FStates then
-    ImageList_DragShowNolock(False);
-  GetUpdateRect(Handle, FUpdateRect, True);
-  inherited;
-  if tsVCLDragging in FStates then
-    ImageList_DragShowNolock(True);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMPaste(var Message: TWMPaste);
-
-begin
-  PasteFromClipboard;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMPrint(var Message: TWMPrint);
-
-// This message is sent to request that the tree draws itself to a given device context. This includes not only
-// the client area but also the non-client area (header!).
-
-begin
-  // Draw only if the window is visible or visibility is not required.
-  if ((Message.Flags and PRF_CHECKVISIBLE) = 0) or IsWindowVisible(Handle) then
-    Header.Columns.PaintHeader(Message.DC, FHeaderRect, FOffsetX);
-
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMPrintClient(var Message: TWMPrintClient);
-
-var
-  Window: TRect;
-  Target: TPoint;
-  Canvas: TCanvas;
-
-begin  
-  // Draw only if the window is visible or visibility is not required.
-  if ((Message.Flags and PRF_CHECKVISIBLE) = 0) or IsWindowVisible(Handle) then
-  begin
-    // Determine area of the entire tree to be displayed in the control.
-    Window := ClientRect;
-    Target := Window.TopLeft;
-
-    // The Window rectangle is given in client coordinates. We have to convert it into
-    // a sliding window of the tree image.
-    OffsetRect(Window, -FOffsetX, -FOffsetY);
-
-    Canvas := TCanvas.Create;
-    try
-      Canvas.Handle := Message.DC;
-      PaintTree(Canvas, Window, Target, [poBackground, poDrawFocusRect, poDrawDropMark, poDrawSelection, poGridLines]);
-    finally
-      Canvas.Handle := 0;
-      Canvas.Free;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMRButtonDblClk(var Message: TWMRButtonDblClk);
-
-var
-  HitInfo: THitInfo;
-
-begin
-  inherited;
-
-  // get information about the hit
-  if toMiddleClickSelect in FOptions.FSelectionOptions then
-  begin
-    GetHitTestInfoAt(Message.XPos, Message.YPos, True, HitInfo);
-    HandleMouseDblClick(Message, HitInfo);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMRButtonDown(var Message: TWMRButtonDown);
-
-var
-  HitInfo: THitInfo;
-
-begin
-  DoStateChange([tsRightButtonDown]);
-
-  if FHeader.FStates = [] then
-  begin
-    inherited;
-
-    // get information about the hit
-    if toRightClickSelect in FOptions.FSelectionOptions then
-    begin
-      GetHitTestInfoAt(Message.XPos, Message.YPos, True, HitInfo);
-      HandleMouseDown(Message, HitInfo);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMRButtonUp(var Message: TWMRButtonUp);
-
-// handle right click selection and node specific popup menu
-
-var
-  HitInfo: THitInfo;
-
-begin
-  DoStateChange([], [tsRightButtonDown]);
-
-  if FHeader.FStates = [] then
-  begin
-    Application.CancelHint;
-
-    if IsMouseSelecting and Assigned(PopupMenu) then
-    begin
-      // Reset selection state already here, before the inherited handler opens the default menu.
-      DoStateChange([], [tsDrawSelecting, tsDrawSelPending]);
-      Invalidate;
-    end;
-
-    inherited;
-
-    // get information about the hit
-    GetHitTestInfoAt(Message.XPos, Message.YPos, True, HitInfo);
-
-    if toRightClickSelect in FOptions.FSelectionOptions then
-      HandleMouseUp(Message, HitInfo);
-
-    if not Assigned(PopupMenu) then
-      DoPopupMenu(HitInfo.HitNode, HitInfo.HitColumn, Point(Message.XPos, Message.YPos));
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMReleaseEditLink(var Message: TMessage);
-
-begin
-  // Finally free edit link memory after editing has been finished.
-  if not IsEditing then
-    FEditLink := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMSetCursor(var Message: TWMSetCursor);
-
-// Sets the hot node mouse cursor for the tree. Cursor changes for the header are handled in Header.HandleMessage.
-
-var
-  NewCursor: TCursor;
-
-begin
-  with Message do
-  begin
-    if (CursorWnd = Handle) and not (csDesigning in ComponentState) then
-    begin
-      if [tsWheelPanning, tsWheelScrolling] * FStates &lt;&gt; [] then
-      begin
-        Beep;
-      end
-      else
-        if not FHeader.HandleMessage(TMessage(Message)) then
-        begin
-          // Apply own cursors only if there is no global cursor set.
-          if Screen.Cursor = crDefault then
-          begin
-            if (toHotTrack in FOptions.PaintOptions) and Assigned(FCurrentHotNode) then
-              NewCursor := FHotCursor
-            else
-              NewCursor := Cursor;
-
-            DoGetCursor(NewCursor);
-            Windows.SetCursor(Screen.Cursors[NewCursor]);
-            Message.Result := 1;
-          end                          
-          else
-            inherited;
-        end;
-    end
-    else
-      inherited;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMSetFocus(var Msg: TWMSetFocus);
-
-begin
-  inherited;
-  if (FSelectionCount &gt; 0) or not (toGhostedIfUnfocused in FOptions.FPaintOptions) then
-    Invalidate;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMSize(var Message: TWMSize);
-
-begin
-  inherited;
-
-  // Need to update scroll bars here. This will cause a recursion because of the change of the client area
-  // when changing a scrollbar. Usually this is no problem since with the second level recursion no change of the
-  // window size happens (the same values for the scrollbars are set, which shouldn't cause a window size change).
-  // Appearently, this applies not to all systems, however.
-  if HandleAllocated and ([tsSizing, tsWindowCreating] * FStates = []) and (ClientHeight &gt; 0) then
-  try
-    DoStateChange([tsSizing]);
-    // This call will invalidate the entire non-client area which needs recalculation on resize.
-    FHeader.RecalculateHeader;
-    UpdateScrollBars(True);
-
-    if (tsEditing in FStates) and not FHeader.UseColumns then
-      UpdateEditBounds;
-  finally
-    DoStateChange([], [tsSizing]);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMTimer(var Message: TWMTimer);
-
-// centralized timer handling happens here
-
-begin
-  with Message do
-  begin
-    case TimerID of
-      ExpandTimer:
-        DoDragExpand;
-      EditTimer:
-        DoEdit;
-      ScrollTimer:
-        begin
-          if tsScrollPending in FStates then
-          begin  
-            Application.CancelHint;
-            // Scroll delay has elapsed, set to normal scroll interval now.
-            SetTimer(Handle, ScrollTimer, FAutoScrollInterval, nil);
-            DoStateChange([tsScrolling], [tsScrollPending]);
-          end;
-          DoTimerScroll;
-        end;
-      ChangeTimer:
-        DoChange(FLastChangedNode);
-      StructureChangeTimer:
-        DoStructureChange(FLastStructureChangeNode, FLastStructureChangeReason);
-      SearchTimer:
-        begin
-          // When this event triggers then the user did not pressed any key for the specified timeout period.
-          // Hence incremental searching is stopped.
-          DoStateChange([], [tsIncrementalSearching]);
-          StopTimer(SearchTimer);
-          FSearchBuffer := '';
-          FLastSearchNode := nil; 
-        end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WMVScroll(var Message: TWMVScroll);
-
-  //--------------- local functions -------------------------------------------
-
-  function GetRealScrollPosition: Integer;
-
-  var
-    SI: TScrollInfo;
-    Code: Integer;
-
-  begin
-    SI.cbSize := SizeOf(TScrollInfo);
-    SI.fMask := SIF_TRACKPOS;
-    Code := SB_VERT;
-    {$ifdef UseFlatScrollbars}
-      FlatSB_GetScrollInfo(Handle, Code, SI);
-    {$else}
-      GetScrollInfo(Handle, Code, SI);
-    {$endif UseFlatScrollbars}
-    Result := SI.nTrackPos;
-  end;
-
-  //--------------- end local functions ---------------------------------------
-
-begin
-  case Message.ScrollCode of
-    SB_BOTTOM:
-      SetOffsetY(-Integer(FRoot.TotalHeight));
-    SB_ENDSCROLL:
-      begin
-        DoStateChange([], [tsThumbTracking]);
-        // Avoiding to adjust the horizontal scroll position while tracking makes scrolling much smoother
-        // but we need to adjust the final position here then.
-        UpdateScrollBars(True);
-        // Really weird invalidation needed here (and I do it only because it happens so rarely), because
-        // when showing the horizontal scrollbar while scrolling down using the down arrow button,
-        // the button will be repainted on mouse up (at the wrong place in the far right lower corner)...
-        RedrawWindow(Handle, nil, 0, RDW_FRAME or RDW_INVALIDATE or RDW_NOERASE or RDW_NOCHILDREN);
-      end;
-    SB_LINEUP:
-      SetOffsetY(FOffsetY + FScrollBarOptions.FIncrementY);
-    SB_LINEDOWN:
-      SetOffsetY(FOffsetY - FScrollBarOptions.FIncrementY);
-    SB_PAGEUP:
-      SetOffsetY(FOffsetY + ClientHeight);
-    SB_PAGEDOWN:
-      SetOffsetY(FOffsetY - ClientHeight);
-
-    SB_THUMBPOSITION,
-    SB_THUMBTRACK:
-      begin
-        DoStateChange([tsThumbTracking]);
-        SetOffsetY(-GetRealScrollPosition);
-      end;
-    SB_TOP:
-      SetOffsetY(0);
-  end;
-  Message.Result := 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AddToSelection(Node: PVirtualNode);
-
-var
-  Changed: Boolean;
-
-begin
-  Assert(Assigned(Node), 'Node must not be nil!');
-  FSingletonNodeArray[0] := Node;
-  Changed := InternalAddToSelection(FSingletonNodeArray, 1, False);
-  if Changed then
-    Change(Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AddToSelection(const NewItems: TNodeArray; NewLength: Integer; ForceInsert: Boolean = False);
-
-// Adds the given items all at once into the current selection array. NewLength is the amount of
-// nodes to add (necessary to allow NewItems to be larger than the actual used entries).
-// ForceInsert is True if nodes must be inserted without consideration of level select constraint or
-// already set selected flags (e.g. when loading from stream).
-// Note: In the case ForceInsert is True the caller is responsible for making sure the new nodes aren't already in the
-//       selection array! 
-
-var
-  Changed: Boolean;
-
-begin
-  Changed := InternalAddToSelection(NewItems, NewLength, ForceInsert);
-  if Changed then
-  begin
-    if NewLength = 1 then
-      Change(NewItems[0])
-    else
-      Change(nil);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AdjustPaintCellRect(var PaintInfo: TVTPaintInfo; var NextNonEmpty: TColumnIndex);
-
-// Used in descentants to modify the clip rectangle of the current column while painting a certain node.
-
-begin
-  // Since cells are always drawn from left to right the next column index is independent of the
-  // bidi mode, but not the column borders which might change depending on the cell's content. 
-  NextNonEmpty := FHeader.FColumns.GetNextVisibleColumn(PaintInfo.Column);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AdjustPanningCursor(X, Y: Integer);
-
-// Triggered by a mouse move when wheel panning/scrolling is active.
-// Loads the proper cursor which indicates into which direction scrolling is done.
-
-var
-  Name: string;
-  NewCursor: HCURSOR;
-  ScrollHorizontal,
-  ScrollVertical: Boolean;
-
-begin
-  ScrollHorizontal := Integer(FRangeX) &gt; ClientWidth;
-  ScrollVertical := Integer(FRangeY) &gt; ClientHeight;
-
-  if (Abs(X - FLastClickPos.X) &lt; 8) and (Abs(Y - FLastClickPos.Y) &lt; 8) then
-  begin
-    // Mouse is in the neutral zone.
-    if ScrollHorizontal then
-    begin
-      if ScrollVertical then
-        Name := 'VT_MOVEALL'
-      else
-        Name := 'VT_MOVEEW'
-    end
-    else
-      Name := 'VT_MOVENS';
-  end
-  else
-  begin
-    // One of 8 directions applies: north, north-east, east, south-east, south, south-west, west and north-west.
-    // Check also if scrolling in the particular direction is possible.
-    if ScrollVertical and ScrollHorizontal then
-    begin
-      // All directions allowed.
-      if X - FlastClickPos.X &lt; -8 then
-      begin
-        // Left hand side.
-        if Y - FLastClickPos.Y &lt; -8 then
-          Name := 'VT_MOVENW'
-        else
-          if Y - FLastClickPos.Y &gt; 8 then
-            Name := 'VT_MOVESW'
-          else
-            Name := 'VT_MOVEW';
-      end
-      else
-        if X - FLastClickPos.X &gt; 8 then
-        begin
-          // Right hand side.
-          if Y - FLastClickPos.Y &lt; -8 then
-            Name := 'VT_MOVENE'
-          else
-            if Y - FLastClickPos.Y &gt; 8 then
-              Name := 'VT_MOVESE'
-            else
-              Name := 'VT_MOVEE';
-        end
-        else
-        begin
-          // Up or down.
-          if Y &lt; FLastClickPos.Y then
-            Name := 'VT_MOVEN'
-          else
-            Name := 'VT_MOVES';
-        end;
-    end
-    else
-      if ScrollHorizontal then
-      begin
-        // Only horizontal movement allowed.
-        if X &lt; FlastClickPos.X then
-          Name := 'VT_MOVEW'
-        else
-          Name := 'VT_MOVEE';
-      end
-      else
-      begin
-        // Only vertical movement allowed.
-        if Y &lt; FlastClickPos.Y then
-          Name := 'VT_MOVEN'
-        else
-          Name := 'VT_MOVES';
-      end;
-  end;
-
-  // Now load the cursor and apply it.
-  NewCursor := LoadCursor(HInstance, PChar(Name));
-  if FPanningCursor &lt;&gt; NewCursor then
-  begin
-    DeleteObject(FPanningCursor);
-    FPanningCursor := NewCursor;
-    Windows.SetCursor(FPanningCursor);
-  end
-  else
-    DeleteObject(NewCursor);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AdviseChangeEvent(StructureChange: Boolean; Node: PVirtualNode; Reason: TChangeReason);
-
-// Used to register a delayed change event. If StructureChange is False then we have a selection change event (without
-// a specific reason) otherwise it is a structure change.
-
-begin
-  if StructureChange then
-  begin
-    if tsStructureChangePending in FStates then
-      StopTimer(StructureChangeTimer)
-    else
-      DoStateChange([tsStructureChangePending]);
-
-    FLastStructureChangeNode := Node;
-    if FLastStructureChangeReason = crIgnore then
-      FLastStructureChangeReason := Reason
-    else
-      if Reason &lt;&gt; crIgnore then
-        FLastStructureChangeReason := crAccumulated;
-  end
-  else
-  begin
-    if tsChangePending in FStates then
-      StopTimer(ChangeTimer)
-    else
-      DoStateChange([tsChangePending]);
-
-    FLastChangedNode := Node;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.AllocateInternalDataArea(Size: Cardinal): Cardinal;
-
-// Simple registration method to be called by each descendant to claim their internal data area.
-// Result is the offset from the begin of the node to the internal data area of the calling tree class.
-
-begin
-  Assert((FRoot = nil) or (FRoot.ChildCount = 0), 'Internal data allocation must be done before any node is created.');
-
-  Result := TreeNodeSize + FTotalInternalDataSize;
-  Inc(FTotalInternalDataSize, (Size + 3) and not 3);
-  InitRootNode(Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.Animate(Steps, Duration: Cardinal; Callback: TVTAnimationCallback; Data: Pointer);
-
-// This method does the calculation part of an animation as used for node toggling and hint animations.
-// Steps is the maximum amount of animation steps to do and Duration determines the milliseconds the animation
-// has to run. Callback is a task specific method which is called in the loop for every step and Data is simply
-// something to pass on to the callback.
-// The callback is called with the current step, the current step size and the Data parameter. Since the step amount
-// as well as the step size are possibly adjusted during the animation, it is impossible to determine if the current
-// step is the last step, even if the original step amount is known. To solve this problem the callback will be
-// called after the loop has finished with a step size of 0 indicating so to execute any post processing.
-
-var
-  StepSize,
-  RemainingTime,
-  RemainingSteps,
-  NextTimeStep,
-  CurrentStep,
-  StartTime,
-  CurrentTime: Cardinal;
-
-begin
-  if not (tsInAnimation in FStates) and (Duration &gt; 0) then
-  begin
-    DoStateChange([tsInAnimation]);
-    try
-      RemainingTime := Duration;
-      RemainingSteps := Steps;
-
-      // Determine the initial step size which is either 1 if the needed steps are less than the number of
-      // steps possible given by the duration or &gt; 1 otherwise.
-      StepSize := Round(Max(1, RemainingSteps / Duration));
-      RemainingSteps := RemainingSteps div StepSize;
-      CurrentStep := 0;
-
-      while (RemainingSteps &gt; 0) and (RemainingTime &gt; 0) and not Application.Terminated do
-      begin
-        StartTime := timeGetTime;
-        NextTimeStep := StartTime + RemainingTime div RemainingSteps;
-        if not Callback(CurrentStep, StepSize, Data) then
-          Break;
-
-        // Keep duration for this step for rest calculation.
-        CurrentTime := timeGetTime;
-        // Wait until the calculated time has been reached.
-        while CurrentTime &lt; NextTimeStep do
-          CurrentTime := timeGetTime;
-
-        // Subtract the time this step really needed.
-        if RemainingTime &gt;= CurrentTime - StartTime then
-        begin
-          Dec(RemainingTime, CurrentTime - StartTime);
-          Dec(RemainingSteps);
-        end
-        else
-        begin
-          RemainingTime := 0;
-          RemainingSteps := 0;
-        end;
-        // If the remaining time per step is less than one time step then we have to decrease the
-        // step count and increase the step size.
-        if (RemainingSteps &gt; 0) and ((RemainingTime div RemainingSteps) &lt; 1) then
-        begin
-          repeat
-            Inc(StepSize);
-            RemainingSteps := RemainingTime div StepSize;
-          until (RemainingSteps &lt;= 0) or ((RemainingTime div RemainingSteps) &gt;= 1);
-        end;
-        CurrentStep := Cardinal(Steps) - RemainingSteps;
-      end;
-
-      if not Application.Terminated then
-        Callback(0, 0, Data);
-    finally
-      DoStateChange([], [tsInAnimation]);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CalculateSelectionRect(X, Y: Integer): Boolean;
-
-// Recalculates old and new selection rectangle given that X, Y are new mouse coordinates.
-// Returns True if there was a change since the last call.
-
-var
-  MaxValue: Integer;
-
-begin
-  if tsDrawSelecting in FStates then
-    FLastSelRect := FNewSelRect;
-  FNewSelRect.BottomRight := Point(X - FOffsetX, Y - FOffsetY);
-  if FNewSelRect.Right &lt; 0 then
-    FNewSelRect.Right := 0;
-  if FNewSelRect.Bottom &lt; 0 then
-    FNewSelRect.Bottom := 0;
-  MaxValue := ClientWidth;
-  if FRangeX &gt; Cardinal(MaxValue) then
-    MaxValue := FRangeX;
-  if FNewSelRect.Right &gt; MaxValue then
-    FNewSelRect.Right := MaxValue;
-  MaxValue := ClientHeight;
-  if FRangeY &gt; Cardinal(MaxValue) then
-    MaxValue := FRangeY;
-  if FNewSelRect.Bottom &gt; MaxValue then
-    FNewSelRect.Bottom := MaxValue;
-    
-  Result := not CompareMem(@FLastSelRect, @FNewSelRect, SizeOf(FNewSelRect));
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CanAutoScroll: Boolean;
-
-// Determines if auto scrolling is currently allowed.
-
-begin
-  // Don't scroll the client area if the header is currently doing tracking or dragging.
-  // Do auto scroll only if there is a draw selection in progress or the tree is the current drop target or
-  // wheel panning/scrolling is active.
-  Result := (toAutoScroll in FOptions.FAutoOptions) and (FHeader.FStates = []) and
-    (([tsDrawSelPending, tsDrawSelecting] * FStates &lt;&gt; []) or (Assigned(FDragManager) and DragManager.IsDropTarget) or
-    (tsVCLDragging in FStates) or
-    ([tsWheelPanning, tsWheelScrolling] * FStates &lt;&gt; []));
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CanEdit(Node: PVirtualNode; Column: TColumnIndex): Boolean;
-
-// Returns True if the given node can be edited.
-
-begin
-  Result := (toEditable in FOptions.FMiscOptions) and Enabled and not (toReadOnly in FOptions.FMiscOptions);
-  DoCanEdit(Node, Column, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CanShowDragImage: Boolean;
-
-// Determines whether a drag image should be shown.
-
-begin
-  Result := FDragImageKind &lt;&gt; diNoImage;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.Change(Node: PVirtualNode);
-
-begin
-  AdviseChangeEvent(False, Node, crIgnore);
-
-  if FUpdateCount = 0 then
-  begin
-    if (FChangeDelay &gt; 0) and not (tsSynchMode in FStates) then
-      SetTimer(Handle, ChangeTimer, FChangeDelay, nil)
-    else
-      DoChange(Node);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ChangeScale(M, D: Integer);
-
-var
-  DoScale: Boolean;
-
-begin
-  inherited;
-
-  if (M &lt;&gt; D) and (toAutoChangeScale in FOptions.FAutoOptions) then
-  begin
-    if (csLoading in ComponentState) then
-      DoScale := tsNeedScale in FStates
-    else
-      DoScale := True;
-    if DoScale then
-    begin
-      FDefaultNodeHeight := MulDiv(FDefaultNodeHeight, M, D);
-      FHeader.ChangeScale(M, D);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CheckParentCheckState(Node: PVirtualNode; NewCheckState: TCheckState): Boolean;
-
-// Checks all siblings of node to determine which check state Node's parent must get.
-
-var
-  CheckCount,
-  BoxCount: Cardinal;
-  PartialCheck: Boolean;
-  Run: PVirtualNode;
-
-begin
-  CheckCount := 0;
-  BoxCount := 0;
-  PartialCheck := False;
-  Run := Node.Parent.FirstChild;
-  while Assigned(Run) do
-  begin
-    if Run = Node then
-    begin
-      // The given node cannot be checked because it does not yet have its new check state (as this depends
-      // on the outcome of this method). Instead NewCheckState is used as this contains the new state the node
-      // will get if this method returns True.
-      if Run.CheckType in [ctCheckBox, ctTriStateCheckBox] then
-      begin
-        Inc(BoxCount);
-        if NewCheckState in [csCheckedNormal, csCheckedPressed] then
-          Inc(CheckCount);
-        PartialCheck := PartialCheck or (NewCheckState = csMixedNormal);
-      end;
-    end
-    else
-      if Run.CheckType in [ctCheckBox, ctTriStateCheckBox] then
-      begin
-        Inc(BoxCount);
-        if Run.CheckState in [csCheckedNormal, csCheckedPressed] then
-          Inc(CheckCount);
-        PartialCheck := PartialCheck or (Run.CheckState = csMixedNormal);
-      end;
-    Run := Run.NextSibling;
-  end;
-
-  if (CheckCount = 0) and not PartialCheck then
-    NewCheckState := csUncheckedNormal
-  else
-    if CheckCount &lt; BoxCount then
-      NewCheckState := csMixedNormal
-    else                                                        
-      NewCheckState := csCheckedNormal;
-
-  Node := Node.Parent;
-  Result := DoChecking(Node, NewCheckState);
-  if Result then
-  begin
-    DoCheckClick(Node, NewCheckState);
-    // Recursively adjust parent of parent.
-    with Node^ do
-    begin
-      if not (vsInitialized in Parent.States) then
-        InitNode(Parent);
-      if ([vsChecking, vsDisabled] * Parent.States = []) and (Parent &lt;&gt; FRoot) and
-        (Parent.CheckType = ctTriStateCheckBox) then
-        Result := CheckParentCheckState(Node, NewCheckState);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ClearTempCache;
-
-// make sure the temporary node cache is in a reliable state
-
-begin
-  FTempNodeCache := nil;
-  FTempNodeCount := 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.ColumnIsEmpty(Node: PVirtualNode; Column: TColumnIndex): Boolean;
-
-// Returns True if the given column is to be considered as being empty. This will usually be determined by
-// descentants as the base tree implementation has not enough information to decide.
-
-begin
-  Result := False;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CountLevelDifference(Node1, Node2: PVirtualNode): Integer;
-
-// This method counts how many indentation levels the given nodes are apart. If both nodes have the same parent then the
-// difference is 0 otherwise the result is basically GetNodeLevel(Node2) - GetNodeLevel(Node1), but with sign.
-// If the result is negative then Node2 is less intended than Node1.
-
-var
-  Level1, Level2: Integer;
-  
-begin
-  Assert(Assigned(Node1) and Assigned(Node2), 'Both nodes must be Assigned.');
-
-  Level1 := 0;
-  while Node1.Parent &lt;&gt; FRoot do
-  begin
-    Inc(Level1);
-    Node1 := Node1.Parent;
-  end;
-
-  Level2 := 0;
-  while Node2.Parent &lt;&gt; FRoot do
-  begin
-    Inc(Level2);
-    Node2 := Node2.Parent;
-  end;
-
-  Result := Level2 - Level1;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CountVisibleChildren(Node: PVirtualNode): Cardinal;
-
-// Returns the number of visible child nodes of the given node.
-
-begin
-  Result := 0;
-  // its direct children
-  if vsExpanded in Node.States then
-  begin
-    // and their children
-    Node := Node.FirstChild;
-    while Assigned(Node) do
-    begin
-      if vsVisible in Node.States then
-        Inc(Result, CountVisibleChildren(Node) + 1);
-      Node := Node.NextSibling;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CreateParams(var Params: TCreateParams);
-
-const
-  ScrollBar: array[TScrollStyle] of Cardinal = (0, WS_HSCROLL, WS_VSCROLL, WS_HSCROLL or WS_VSCROLL);
-
-begin
-  inherited CreateParams(Params);
-  
-  with Params do
-  begin
-    Style := Style or WS_CLIPCHILDREN or WS_CLIPSIBLINGS or ScrollBar[ScrollBarOptions.FScrollBars];
-    if toFullRepaintOnResize in FOptions.MiscOptions then
-      WindowClass.style := WindowClass.style or CS_HREDRAW or CS_VREDRAW
-    else
-      WindowClass.style := WindowClass.style and not (CS_HREDRAW or CS_VREDRAW);
-    if FBorderStyle = bsSingle then
-    begin
-      if Ctl3D then
-      begin
-        ExStyle := ExStyle or WS_EX_CLIENTEDGE;
-        Style := Style and not WS_BORDER;
-      end
-      else
-        Style := Style or WS_BORDER;
-    end
-    else
-      Style := Style and not WS_BORDER;
-
-    // Left scrollbars can be used with Win2K and up, regardless of the system locale.
-    if BidiMode &lt;&gt; bdLeftToRight then
-      ExStyle := ExStyle or WS_EX_LEFTSCROLLBAR;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CreateWnd;
-
-// Initializes data which depends on a valid window handle.
-
-begin
-  DoStateChange([tsWindowCreating]);
-  inherited;
-  DoStateChange([], [tsWindowCreating]);
-
-  {$ifdef ThemeSupport}
-    if ThemeServices.ThemesEnabled and (toThemeAware in TreeOptions.PaintOptions) then
-      DoStateChange([tsUseThemes])
-    else
-  {$endif ThemeSupport}
-    DoStateChange([], [tsUseThemes]);
-
-  // Because of the special recursion and update stopper when creating the window (or resizing it)
-  // we have to manually trigger the auto size calculation here.
-  if hoAutoResize in FHeader.FOptions then
-    FHeader.FColumns.AdjustAutoSize(InvalidColumn);
-
-  // Initialize flat scroll bar library if required.
-  {$ifdef UseFlatScrollbars}
-    if FScrollBarOptions.FScrollBarStyle &lt;&gt; sbmRegular then
-    begin
-      InitializeFlatSB(Handle);
-      FlatSB_SetScrollProp(Handle, WSB_PROP_HSTYLE, ScrollBarProp[FScrollBarOptions.ScrollBarStyle], False);
-      FlatSB_SetScrollProp(Handle, WSB_PROP_VSTYLE, ScrollBarProp[FScrollBarOptions.ScrollBarStyle], False);
-    end;
-  {$endif UseFlatScrollbars}
-
-  PrepareBitmaps(True, True);
-
-  // Register tree as OLE drop target.
-  if not (csDesigning in ComponentState) and (toAcceptOLEDrop in FOptions.FMiscOptions) then
-    RegisterDragDrop(Handle, DragManager as IDropTarget);
-
-  UpdateScrollBars(True);
-  UpdateHeaderRect;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DefineProperties(Filer: TFiler);
-
-// There were heavy changes in some properties during development of VT. This method helps to make migration easier
-// by reading old properties manually and put them into the new properties as appropriate.
-// Note: these old properties are never written again and silently disappear.
-// June 2002: Meanwhile another task is done here too: working around the problem that TCollection is not streamed
-//            correctly when using Visual Form Inheritance (VFI). 
-
-var
-  StoreIt: Boolean;
-
-begin
-  inherited;
-
-  // The header can prevent writing columns altogether.
-  if FHeader.CanWriteColumns then
-  begin
-    // Check if we inherit from an ancestor form (Visual Form Inheritance).
-    StoreIt := Filer.Ancestor = nil;
-    // If there is an ancestor then save columns only if they are different to the base set.
-    if not StoreIt then
-      StoreIt := not FHeader.Columns.Equals(TBaseVirtualTree(Filer.Ancestor).FHeader.Columns);
-  end
-  else
-    StoreIt := False;
-    
-  Filer.DefineProperty('Columns', FHeader.ReadColumns, FHeader.WriteColumns, StoreIt);
-  Filer.DefineProperty('Options', ReadOldOptions, nil, False);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DetermineHiddenChildrenFlag(Node: PVirtualNode);
-
-// Update the hidden children flag of the given node.
-
-var
-  Run: PVirtualNode;
-  
-begin
-  // Iterate through all siblings and stop when one visible is found.
-  Run := Node.FirstChild;
-  while Assigned(Run) and not (vsVisible in Run.States) do
-    Run := Run.NextSibling;
-  if Assigned(Run) then
-    Exclude(Node.States, vsAllChildrenHidden)
-  else
-    Include(Node.States, vsAllChildrenHidden);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DetermineHiddenChildrenFlagAllNodes;
-
-var
-  Run: PVirtualNode;
-
-begin
-  Run := GetFirstNoInit;
-  while Assigned(Run) do
-  begin
-    DetermineHiddenChildrenFlag(Run);
-    Run := GetNextNoInit(Run);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DetermineHitPositionLTR(var HitInfo: THitInfo; Offset, Right: Integer;
-  Alignment: TAlignment);
-
-// This method determines the hit position within a node with left-to-right orientation.
-
-var
-  MainColumnHit,
-  Ghosted: Boolean;
-  Run: PVirtualNode;
-  Indent,
-  TextWidth,
-  ImageOffset: Integer;
-
-begin
-  MainColumnHit := HitInfo.HitColumn = FHeader.MainColumn;
-  Indent := 0;
-
-  // If columns are not used or the main column is hit then the tree indentation must be considered too.
-  if MainColumnHit then
-  begin
-    Run := HitInfo.HitNode;
-    while (Run.Parent &lt;&gt; FRoot) do
-    begin
-      Inc(Indent, FIndent);
-      Run := Run.Parent;
-    end;
-    if toShowRoot in FOptions.FPaintOptions then
-      Inc(Indent, FIndent);
-  end;
-
-  if Offset &lt; Indent then
-  begin
-    // Position is to the left of calculated indentation which can only happen for the main column.
-    // Check whether it corresponds to a button/checkbox.
-    if (toShowButtons in FOptions.FPaintOptions) and (vsHasChildren in HitInfo.HitNode.States) then
-    begin
-      // Position of button is interpreted very generously to avoid forcing the user
-      // to click exactly into the 9x9 pixels area. The entire node height and one full
-      // indentation level is accepted as button hit.
-      if Offset &gt;= Indent - Integer(FIndent) then
-        Include(HitInfo.HitPositions, hiOnItemButton);
-    end;
-    // no button hit so position is on indent
-    if HitInfo.HitPositions = [] then
-      Include(HitInfo.HitPositions, hiOnItemIndent);
-  end
-  else
-  begin
-    // The next hit positions can be:
-    //   - on the check box
-    //   - on the state image
-    //   - on the normal image
-    //   - to the left of the text area
-    //   - on the label or
-    //   - to the right of the text area
-    // (in this order).
-
-    // In report mode no hit other than in the main column is possible.
-    if MainColumnHit or not (toReportMode in FOptions.FMiscOptions) then
-    begin
-      ImageOffset := Indent +  FMargin;
-
-      // Check support is only available for the main column.
-      if MainColumnHit and (toCheckSupport in FOptions.FMiscOptions) and Assigned(FCheckImages) and
-        (HitInfo.HitNode.CheckType &lt;&gt; ctNone) then
-        Inc(ImageOffset, FCheckImages.Width + 2);
-
-      if MainColumnHit and (Offset &lt; ImageOffset) then
-        HitInfo.HitPositions := [hiOnItem, hiOnItemCheckBox]
-      else
-      begin
-        if Assigned(FStateImages) and (GetImageIndex(HitInfo.HitNode, ikState, HitInfo.HitColumn, Ghosted) &gt; -1) then
-          Inc(ImageOffset, FStateImages.Width + 2);
-        if Offset &lt; ImageOffset then
-          Include(HitInfo.HitPositions, hiOnStateIcon)
-        else
-        begin
-          if Assigned(FImages) and (GetImageIndex(HitInfo.HitNode, ikNormal, HitInfo.HitColumn, Ghosted) &gt; -1) then
-            Inc(ImageOffset, FImages.Width + 2);
-          if Offset &lt; ImageOffset then
-            Include(HitInfo.HitPositions, hiOnNormalIcon)
-          else
-          begin
-            // ImageOffset contains now the left border of the node label area. This is used to calculate the
-            // correct alignment in the column.
-            TextWidth := DoGetNodeWidth(HitInfo.HitNode, HitInfo.HitColumn);
-
-            // Check if the text can be aligned at all. This is only possible if there is enough room
-            // in the remaining text rectangle.
-            if TextWidth &gt; Right - ImageOffset then
-              Include(HitInfo.HitPositions, hiOnItemLabel)
-            else
-            begin
-              case Alignment of
-                taCenter:
-                  begin
-                    Indent := (ImageOffset + Right - TextWidth) div 2;
-                    if Offset &lt; Indent then
-                      Include(HitInfo.HitPositions, hiOnItemLeft)
-                    else
-                      if Offset &lt; Indent + TextWidth then
-                        Include(HitInfo.HitPositions, hiOnItemLabel)
-                      else
-                        Include(HitInfo.HitPositions, hiOnItemRight)
-                  end;
-                taRightJustify:
-                  begin
-                    Indent := Right - TextWidth;
-                    if Offset &lt; Indent then
-                      Include(HitInfo.HitPositions, hiOnItemLeft)
-                    else
-                      Include(HitInfo.HitPositions, hiOnItemLabel);
-                  end;
-              else // taLeftJustify
-                if Offset &lt; ImageOffset + TextWidth then
-                  Include(HitInfo.HitPositions, hiOnItemLabel)
-                else
-                  Include(HitInfo.HitPositions, hiOnItemRight);
-              end;
-            end;
-          end;
-        end;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DetermineHitPositionRTL(var HitInfo: THitInfo; Offset, Right: Integer; Alignment: TAlignment);
-
-// This method determines the hit position within a node with right-to-left orientation.
-
-var
-  MainColumnHit,
-  Ghosted: Boolean;
-  Run: PVirtualNode;
-  Indent,
-  TextWidth,
-  ImageOffset: Integer;
-
-begin
-  MainColumnHit := HitInfo.HitColumn = FHeader.MainColumn;
-
-  // If columns are not used or the main column is hit then the tree indentation must be considered too.
-  if MainColumnHit then
-  begin
-    Run := HitInfo.HitNode;
-    while (Run.Parent &lt;&gt; FRoot) do
-    begin
-      Dec(Right, FIndent);
-      Run := Run.Parent;
-    end;
-    if toShowRoot in FOptions.FPaintOptions then
-      Dec(Right, FIndent);
-  end;
-
-  if Offset &gt;= Right then
-  begin
-    // Position is to the right of calculated indentation which can only happen for the main column.
-    // Check whether it corresponds to a button/checkbox.
-    if (toShowButtons in FOptions.FPaintOptions) and (vsHasChildren in HitInfo.HitNode.States) then
-    begin
-      // Position of button is interpreted very generously to avoid forcing the user
-      // to click exactly into the 9x9 pixels area. The entire node height and one full
-      // indentation level is accepted as button hit.
-      if Offset &lt;= Right + Integer(FIndent) then
-        Include(HitInfo.HitPositions, hiOnItemButton);
-    end;
-    // no button hit so position is on indent
-    if HitInfo.HitPositions = [] then
-      Include(HitInfo.HitPositions, hiOnItemIndent);
-  end
-  else
-  begin
-    // The next hit positions can be:
-    //   - on the check box
-    //   - on the state image
-    //   - on the normal image
-    //   - to the left of the text area
-    //   - on the label or
-    //   - to the right of the text area
-    // (in this order).
-
-    // In report mode no hit other than in the main column is possible.
-    if MainColumnHit or not (toReportMode in FOptions.FMiscOptions) then
-    begin
-      ImageOffset := Right - FMargin;
-
-      // Check support is only available for the main column.
-      if MainColumnHit and (toCheckSupport in FOptions.FMiscOptions) and Assigned(FCheckImages) and
-        (HitInfo.HitNode.CheckType &lt;&gt; ctNone) then
-        Dec(ImageOffset, FCheckImages.Width + 2);
-
-      if MainColumnHit and (Offset &gt; ImageOffset) then
-        HitInfo.HitPositions := [hiOnItem, hiOnItemCheckBox]
-      else
-      begin
-        if Assigned(FStateImages) and (GetImageIndex(HitInfo.HitNode, ikState, HitInfo.HitColumn, Ghosted) &gt; -1) then
-          Dec(ImageOffset, FStateImages.Width + 2);
-        if Offset &gt; ImageOffset then
-          Include(HitInfo.HitPositions, hiOnStateIcon)
-        else
-        begin
-          if Assigned(FImages) and (GetImageIndex(HitInfo.HitNode, ikNormal, HitInfo.HitColumn, Ghosted) &gt; -1) then
-            Dec(ImageOffset, FImages.Width + 2);
-          if Offset &gt; ImageOffset then
-            Include(HitInfo.HitPositions, hiOnNormalIcon)
-          else
-          begin
-            // ImageOffset contains now the right border of the node label area. This is used to calculate the
-            // correct alignment in the column.
-            TextWidth := DoGetNodeWidth(HitInfo.HitNode, HitInfo.HitColumn);
-
-            // Check if the text can be aligned at all. This is only possible if there is enough room
-            // in the remaining text rectangle.
-            if TextWidth &gt; ImageOffset then
-              Include(HitInfo.HitPositions, hiOnItemLabel)
-            else
-            begin
-              // Consider bidi mode here. In RTL context does left alignment actually mean right alignment
-              // and vice versa.
-              ChangeBiDiModeAlignment(Alignment);
-
-              case Alignment of
-                taCenter:
-                  begin
-                    Indent := (ImageOffset - TextWidth) div 2;
-                    if Offset &lt; Indent then
-                      Include(HitInfo.HitPositions, hiOnItemLeft)
-                    else
-                      if Offset &lt; Indent + TextWidth then
-                        Include(HitInfo.HitPositions, hiOnItemLabel)
-                      else
-                        Include(HitInfo.HitPositions, hiOnItemRight)
-                  end;
-                taRightJustify:
-                  begin
-                    Indent := ImageOffset - TextWidth;
-                    if Offset &lt; Indent then
-                      Include(HitInfo.HitPositions, hiOnItemLeft)
-                    else
-                      Include(HitInfo.HitPositions, hiOnItemLabel);
-                  end;
-              else // taLeftJustify
-                if Offset &gt; TextWidth then
-                  Include(HitInfo.HitPositions, hiOnItemRight)
-                else
-                  Include(HitInfo.HitPositions, hiOnItemLabel);
-              end;
-            end;
-          end;
-        end;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DetermineNextCheckState(CheckType: TCheckType; CheckState: TCheckState): TCheckState;
-
-// Determines the next check state in case the user click the check image or pressed the space key.
-
-begin
-  case CheckType of
-    ctTriStateCheckBox,
-    ctCheckBox:
-      if CheckState = csCheckedNormal then
-        Result := csUncheckedNormal
-      else
-        Result := csCheckedNormal;
-    ctRadioButton:
-      Result := csCheckedNormal;
-    ctButton:
-      Result := csUncheckedNormal;
-  else
-    Result := csMixedNormal;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DetermineScrollDirections(X, Y: Integer): TScrollDirections;
-
-// Determines which direction the client area must be scrolled depending on the given position.
-
-begin
-  Result:= [];
-
-  if CanAutoScroll then
-  begin
-    // Calculation for wheel panning/scrolling is a bit different to normal auto scroll.
-    if [tsWheelPanning, tsWheelScrolling] * FStates &lt;&gt; [] then
-    begin
-      if (X - FLastClickPos.X) &lt; -8 then
-        Include(Result, sdLeft);
-      if (X - FLastClickPos.X) &gt; 8 then
-        Include(Result, sdRight);
-
-      if (Y - FLastClickPos.Y) &lt; -8 then
-        Include(Result, sdUp);
-      if (Y - FLastClickPos.Y) &gt; 8 then
-        Include(Result, sdDown);
-    end
-    else
-    begin
-      if (X &lt; Integer(FDefaultNodeHeight)) and (FOffsetX &lt;&gt; 0) then
-        Include(Result, sdLeft);
-      if (ClientWidth - FOffsetX &lt; Integer(FRangeX)) and (X &gt; ClientWidth - Integer(FDefaultNodeHeight)) then
-        Include(Result, sdRight);
-
-      if (Y &lt; Integer(FDefaultNodeHeight)) and (FOffsetY &lt;&gt; 0) then
-        Include(Result, sdUp);
-      if (ClientHeight - FOffsetY &lt; Integer(FRangeY)) and (Y &gt; ClientHeight - Integer(FDefaultNodeHeight)) then
-        Include(Result, sdDown);
-
-      // Since scrolling during dragging is not handled via the timer we do a check here whether the auto
-      // scroll timeout already has elapsed or not.
-      if (Result &lt;&gt; []) and
-        ((Assigned(FDragManager) and DragManager.IsDropTarget) or
-        (FindDragTarget(Point(X, Y), False) = Self)) then
-      begin
-        if FDragScrollStart = 0 then
-          FDragScrollStart := timeGetTime;
-        // Reset any scroll direction to avoid scroll in the case the user is dragging and the auto scroll time has not
-        // yet elapsed.
-        if ((timeGetTime - FDragScrollStart) &lt; FAutoScrollDelay) then
-          Result := [];
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoAdvancedHeaderDraw(var PaintInfo: THeaderPaintInfo; const Elements: THeaderPaintElements);
-
-begin
-  if Assigned(FOnAdvancedHeaderDraw) then
-    FOnAdvancedHeaderDraw(FHeader, PaintInfo, Elements);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoAfterCellPaint(Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex; CellRect: TRect);
-
-begin
-  if Assigned(FOnAfterCellPaint) then
-    FOnAfterCellPaint(Self, Canvas, Node, Column, CellRect);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoAfterItemErase(Canvas: TCanvas; Node: PVirtualNode; ItemRect: TRect);
-
-begin
-  if Assigned(FOnAfterItemErase) then
-    FOnAfterItemErase(Self, Canvas, Node, ItemRect);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoAfterItemPaint(Canvas: TCanvas; Node: PVirtualNode; ItemRect: TRect);
-
-begin
-  if Assigned(FOnAfterItemPaint) then
-    FOnAfterItemPaint(Self, Canvas, Node, ItemRect);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoAfterPaint(Canvas: TCanvas);
-
-begin
-  if Assigned(FOnAfterPaint) then
-    FOnAfterPaint(Self, Canvas);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoAutoScroll(X, Y: Integer);
-
-begin
-  FScrollDirections := DetermineScrollDirections(X, Y);
-
-  if FStates * [tsWheelPanning, tsWheelScrolling] = [] then
-  begin
-    if FScrollDirections = [] then
-    begin
-      if ((FStates * [tsScrollPending, tsScrolling]) &lt;&gt; []) then
-      begin
-        StopTimer(ScrollTimer);
-        DoStateChange([], [tsScrollPending, tsScrolling]);
-      end;
-    end
-    else
-    begin
-      // start auto scroll if not yet done
-      if (FStates * [tsScrollPending, tsScrolling]) = [] then
-      begin
-        DoStateChange([tsScrollPending]);
-        SetTimer(Handle, ScrollTimer, FAutoScrollDelay, nil);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoBeforeDrag(Node: PVirtualNode; Column: TColumnIndex): Boolean;
-
-begin
-  Result := False;
-  if Assigned(FOnDragAllowed) then
-    FOnDragAllowed(Self, Node, Column, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoBeforeCellPaint(Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex; CellRect: TRect);
-
-begin
-  if Assigned(FOnBeforeCellPaint) then
-    FOnBeforeCellPaint(Self, Canvas, Node, Column, CellRect);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoBeforeItemErase(Canvas: TCanvas; Node: PVirtualNode; ItemRect: TRect; var Color: TColor;
-  var EraseAction: TItemEraseAction);
-
-begin
-  if Assigned(FOnBeforeItemErase) then
-    FOnBeforeItemErase(Self, Canvas, Node, ItemRect, Color, EraseAction);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoBeforeItemPaint(Canvas: TCanvas; Node: PVirtualNode; ItemRect: TRect): Boolean;
-
-begin
-  // By default custom draw will not be used, so the tree handles drawing the node.
-  Result := False;
-  if Assigned(FOnBeforeItemPaint) then
-    FOnBeforeItemPaint(Self, Canvas, Node, ItemRect, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoBeforePaint(Canvas: TCanvas);
-
-begin
-  if Assigned(FOnBeforePaint) then
-    FOnBeforePaint(Self, Canvas);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoCancelEdit: Boolean;
-
-// Called when the current edit action or a pending edit must be cancelled.
-
-begin
-  StopTimer(EditTimer);
-  DoStateChange([], [tsEditPending]);
-  Result := (tsEditing in FStates) and FEditLink.CancelEdit;
-  if Result then
-  begin
-    DoStateChange([], [tsEditing]);
-    if Assigned(FOnEditCancelled) then
-      FOnEditCancelled(Self, FEditColumn);
-    if not (csDestroying in ComponentState) then
-      // Asynchroniously release edit link.
-      PostMessage(Handle, WM_RELEASEEDITLINK, 0, 0);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoCanEdit(Node: PVirtualNode; Column: TColumnIndex; var Allowed: Boolean);
-
-begin
-  if Assigned(FOnEditing) then
-    FOnEditing(Self, Node, Column, Allowed);
-end;
- 
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoChange(Node: PVirtualNode);
-
-begin
-  StopTimer(ChangeTimer);
-  if Assigned(FOnChange) then
-    FOnChange(Self, Node);
-
-  // This is a good place to reset the cached node. This is the same as the node passed in here.
-  // This is necessary to allow descentants to override this method and get the node then.
-  DoStateChange([], [tsChangePending]);
-  FLastChangedNode := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoCheckClick(Node: PVirtualNode; NewCheckState: TCheckState);
-
-begin
-  if ChangeCheckState(Node, NewCheckState) then
-    DoChecked(Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoChecked(Node: PVirtualNode);
-
-begin
-  if Assigned(FOnChecked) then
-    FOnChecked(Self, Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoChecking(Node: PVirtualNode; var NewCheckState: TCheckState): Boolean;
-
-// Determines if a node is allowed to change its check state to NewCheckState.
-
-begin
-  if toReadOnly in FOptions.FMiscOptions then
-    Result := False
-  else
-  begin
-    Result := True;
-    if Assigned(FOnChecking) then
-      FOnChecking(Self, Node, NewCheckState, Result);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoCollapsed(Node: PVirtualNode);
-
-begin
-  if Assigned(FOnCollapsed) then
-    FOnCollapsed(Self, Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoCollapsing(Node: PVirtualNode): Boolean;
-
-begin
-  Result := True;
-  if Assigned(FOnCollapsing) then
-    FOnCollapsing(Self, Node, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoColumnClick(Column: TColumnIndex; Shift: TShiftState);
-
-begin
-  if Assigned(FOnColumnClick) then
-    FOnColumnClick(Self, Column, Shift);
-end;                                           
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoColumnDblClick(Column: TColumnIndex; Shift: TShiftState);
-
-begin
-  if Assigned(FOnColumnDblClick) then
-    FOnColumnDblClick(Self, Column, Shift);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoColumnResize(Column: TColumnIndex);
-
-var
-  R: TRect;
-
-begin
-  if not (csLoading in ComponentState) and HandleAllocated then
-  begin
-    UpdateHorizontalScrollBar(True);
-    // Invalidate client area from the current column all to the right.
-    R := ClientRect;
-    if not (toAutoSpanColumns in FOptions.FAutoOptions) then
-      R.Left := FHeader.Columns[Column].Left;
-    InvalidateRect(Handle, @R, False);
-    FHeader.Invalidate(FHeader.Columns[Column], True);
-    if hsTracking in FHeader.States then
-      UpdateWindow(Handle);
-    
-    UpdateDesigner; // design time only
-
-    if Assigned(FOnColumnResize) then
-      FOnColumnResize(FHeader, Column);
-
-    // If the tree is currently in edit state then notify edit link.
-    if tsEditing in FStates then
-      UpdateEditBounds;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoCompare(Node1, Node2: PVirtualNode; Column: TColumnIndex): Integer;
-
-begin
-  Result := 0;
-  if Assigned(FOnCompareNodes) then
-    FOnCompareNodes(Self, Node1, Node2, Column, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoCreateDataObject: IDataObject;
-
-begin
-  Result := nil;
-  if Assigned(FOnCreateDataObject) then
-    FOnCreateDataObject(Self, Result);
-end;
-                
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoCreateDragManager: IVTDragManager;
-
-begin
-  Result := nil;
-  if Assigned(FOnCreateDragManager) then
-    FOnCreateDragManager(Self, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoCreateEditor(Node: PVirtualNode; Column: TColumnIndex): IVTEditLink;
-
-begin
-  Result := nil;
-  if Assigned(FOnCreateEditor) then
-  begin
-    FOnCreateEditor(Self, Node, Column, Result);
-    if Result = nil then
-      ShowError(SEditLinkIsNil, hcTFEditLinkIsNil);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoDragging(P: TPoint);
-
-// Initiates finally the drag'n drop operation and returns after DD is finished.
-
-  //--------------- local function --------------------------------------------
-
-  function GetDragOperations: Integer;
-
-  begin
-    if FDragOperations = [] then
-      Result := DROPEFFECT_COPY or DROPEFFECT_MOVE or DROPEFFECT_LINK
-    else
-    begin
-      Result := 0;
-      if doCopy in FDragOperations then
-        Result := Result or DROPEFFECT_COPY;
-      if doLink in FDragOperations then
-        Result := Result or DROPEFFECT_LINK;
-      if doMove in FDragOperations then
-        Result := Result or DROPEFFECT_MOVE;
-    end;
-  end;
-
-  //--------------- end local function ----------------------------------------
-
-var
-  I,
-  DragEffect,
-  AllowedEffects: Integer;
-  DragObject: TDragObject;
-
-  DataObject: IDataObject;
-
-begin
-  DataObject := nil;
-  // Dragging is dragging, nothing else.
-  DoCancelEdit;
-
-  if Assigned(FCurrentHotNode) then
-  begin
-    InvalidateNode(FCurrentHotNode);
-    FCurrentHotNode := nil;
-  end;
-  // Select the focused node if not already done.
-  if Assigned(FFocusedNode) and not (vsSelected in FFocusedNode.States) then
-  begin
-    InternalAddToSelection(FFocusedNode, False);
-    InvalidateNode(FFocusedNode);
-  end;
-
-  UpdateWindow(Handle);
-
-  // Keep a list of all currently selected nodes as this list might change,
-  // but we have probably to delete currently selected nodes.
-  FDragSelection := GetSortedSelection(True);
-  try
-    DoStateChange([tsOLEDragging], [tsOLEDragPending, tsClearPending]);
-
-    // An application might create a drag object like used during VCL dd. This is not required for OLE dd but
-    // required as parameter. 
-    DragObject := nil;
-    DoStartDrag(DragObject);
-    DragObject.Free;
-
-    DataObject := DragManager.DataObject;
-    PrepareDragImage(P, DataObject);
-
-    FLastDropMode := dmOnNode;
-    // Don't forget to initialize the result. It might never be touched.
-    DragEffect := DROPEFFECT_NONE;
-    AllowedEffects := GetDragOperations;
-    try
-      ActiveX.DoDragDrop(DataObject, DragManager as IDropSource, AllowedEffects, DragEffect);
-      DragManager.ForceDragLeave;
-    finally
-      GetCursorPos(P);
-      P := ScreenToClient(P);
-      DoEndDrag(Self, P.X, P.Y);
-
-      FDragImage.EndDrag;
-
-      // Finish the operation.
-      if (DragEffect = DROPEFFECT_MOVE) and (toAutoDeleteMovedNodes in TreeOptions.AutoOptions) then
-      begin
-        // The operation was a move so delete the previously selected nodes.
-        BeginUpdate;
-        try
-          // The list of selected nodes was retrieved in resolved state. That means there can never be a node
-          // in the list whose parent (or its parent etc.) is also selected. 
-          for I := 0 to High(FDragSelection) do
-            DeleteNode(FDragSelection[I]);
-        finally
-          EndUpdate;
-        end;
-      end;
-
-      DoStateChange([], [tsOLEDragging]);
-    end;
-  finally
-    FDragSelection := nil;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoDragExpand;
-
-var
-  SourceTree: TBaseVirtualTree;
-  
-begin
-  StopTimer(ExpandTimer);
-  if Assigned(FDropTargetNode) and (vsHasChildren in FDropTargetNode.States) and
-    not (vsExpanded in FDropTargetNode.States) then
-  begin
-    if Assigned(FDragManager) then
-      SourceTree := DragManager.DragSource
-    else
-      SourceTree := nil;
-
-    if not DragManager.DropTargetHelperSupported and Assigned(SourceTree) then
-      SourceTree.FDragImage.HideDragImage;
-    ToggleNode(FDropTargetNode);
-    UpdateWindow(Handle);
-    if not DragManager.DropTargetHelperSupported and Assigned(SourceTree) then
-      SourceTree.FDragImage.ShowDragImage;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoDragOver(Source: TObject; Shift: TShiftState; State: TDragState; Pt: TPoint; Mode: TDropMode;
-  var Effect: Integer): Boolean;
-
-begin
-  Result := False;
-  if Assigned(FOnDragOver) then
-    FOnDragOver(Self, Source, Shift, State, Pt, Mode, Effect, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoDragDrop(Source: TObject; DataObject: IDataObject; Formats: TFormatArray;
-  Shift: TShiftState; Pt: TPoint; var Effect: Integer; Mode: TDropMode);
-
-begin
-  if Assigned(FOnDragDrop) then
-    FOnDragDrop(Self, Source, DataObject, Formats, Shift, Pt, Effect, Mode);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoEdit;
-
-begin
-  Application.CancelHint;                      
-  StopTimer(ScrollTimer);
-  StopTimer(EditTimer);
-  DoStateChange([], [tsEditPending]);
-  if Assigned(FFocusedNode) and not (vsDisabled in FFocusedNode.States) and
-    not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    FEditLink := DoCreateEditor(FFocusedNode, FEditColumn);
-    if Assigned(FEditLink) then
-    begin
-      DoStateChange([tsEditing], [tsDrawSelecting, tsDrawSelPending, tsClearFocusedSelection, tsOLEDragPending,
-        tsOLEDragging, tsClearPending, tsDrawSelPending, tsScrollPending, tsScrolling, tsMouseCheckPending]);
-      ScrollIntoView(FFocusedNode, toCenterScrollIntoView in FOptions.SelectionOptions, True);
-      if FEditLink.PrepareEdit(Self, FFocusedNode, FEditColumn) then
-      begin
-        UpdateEditBounds;
-        // Node needs repaint because the selection rectangle and static text must disappear.
-        InvalidateNode(FFocusedNode);
-        if not FEditLink.BeginEdit then
-          DoStateChange([], [tsEditing]);
-      end
-      else
-        DoStateChange([], [tsEditing]);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoEndDrag(Target: TObject; X, Y: Integer);
-
-// Does some housekeeping for VCL drag'n drop;
-
-begin
-  inherited;
-
-  DragFinished;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoEndEdit: Boolean;
-
-begin
-  Result := (tsEditing in FStates) and FEditLink.EndEdit;
-  if Result then
-  begin
-    DoStateChange([], [tsEditing]);
-    // Asynchronously release edit link.
-    PostMessage(Handle, WM_RELEASEEDITLINK, 0, 0);
-    if Assigned(FOnEdited) then
-      FOnEdited(Self, FFocusedNode, FEditColumn);
-  end;
-  DoStateChange([], [tsEditPending]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoExpanded(Node: PVirtualNode);
-
-begin
-  if Assigned(FOnExpanded) then
-    FOnExpanded(Self, Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoExpanding(Node: PVirtualNode): Boolean;
-
-begin
-  Result := True;
-  if Assigned(FOnExpanding) then
-    FOnExpanding(Self, Node, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoFocusChange(Node: PVirtualNode; Column: TColumnIndex);
-
-begin
-  if Assigned(FOnFocusChanged) then
-    FOnFocusChanged(Self, Node, Column);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoFocusChanging(OldNode, NewNode: PVirtualNode; OldColumn, NewColumn: TColumnIndex): Boolean;
-
-begin
-  Result := True;
-  if Assigned(FOnFocusChanging) then
-    FOnFocusChanging(Self, OldNode, NewNode, OldColumn, NewColumn, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoFocusNode(Node: PVirtualNode; Ask: Boolean);
-
-begin
-  if not (tsEditing in FStates) or EndEditNode then
-  begin
-    if Node = FRoot then
-      Node := nil;
-    if (FFocusedNode &lt;&gt; Node) and (not Ask or DoFocusChanging(FFocusedNode, Node, FFocusedColumn, FFocusedColumn)) then
-    begin
-      if Assigned(FFocusedNode) then
-      begin
-        // Do automatic collapsing of last focused node if enabled. This is however only done if
-        // old and new focused node have a common parent node.
-        if (toAutoExpand in FOptions.FAutoOptions) and Assigned(Node) and (Node.Parent = FFocusedNode.Parent) and
-          (vsExpanded in FFocusedNode.States) then
-          ToggleNode(FFocusedNode)
-        else
-          InvalidateNode(FFocusedNode);
-      end;
-      FFocusedNode := Node;
-    end;
-
-    // Have to scroll the node into view, even it is the same node as before.
-    if Assigned(FFocusedNode) then
-    begin
-      // Make sure a valid column is set if columns are used and no column has currently the focus.
-      if FHeader.UseColumns and (FFocusedColumn &lt; 0) then
-        FFocusedColumn := 0;
-      // Do automatic expansion of the newly focused node if enabled.
-      if (toAutoExpand in FOptions.FAutoOptions) and not (vsExpanded in FFocusedNode.States) then
-        ToggleNode(FFocusedNode); 
-      InvalidateNode(FFocusedNode);
-      if FUpdateCount = 0 then
-        ScrollIntoView(FFocusedNode, (toCenterScrollIntoView in FOptions.SelectionOptions) and
-          (MouseButtonDown * FStates = []), not (toDisableAutoscrollOnFocus in FOptions.FAutoOptions));
-    end;
-
-    // Reset range anchor if necessary.
-    if FSelectionCount = 0 then
-      ResetRangeAnchor; 
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoFreeNode(Node: PVirtualNode);
-
-begin
-  if Node = FCurrentHotNode then
-    FCurrentHotNode := nil;
-  if Assigned(FOnFreeNode) and ([vsInitialized, vsInitialUserData] * Node.States &lt;&gt; []) then
-    FOnFreeNode(Self, Node);
-  {$ifdef UseLocalMemoryManager}
-    FNodeMemoryManager.FreeNode(Node);
-  {$else}
-    FreeMem(Node);
-  {$endif UseLocalMemoryManager}
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-// These constants are defined in the platform SDK for W2K/XP, but not yet in Delphi.
-const
-  SPI_GETTOOLTIPANIMATION = $1016;
-  SPI_GETTOOLTIPFADE = $1018;
-
-function TBaseVirtualTree.DoGetAnimationType: THintAnimationType;
-
-// Determines (depending on the properties settings and the system) which hint
-// animation type is to be used.
-
-var
-  Animation: BOOL;
-
-begin
-  Result := FAnimationType;
-  if Result = hatSystemDefault then
-  begin
-    if not IsWinNT then
-      Result := hatSlide
-    else
-    begin
-      SystemParametersInfo(SPI_GETTOOLTIPANIMATION, 0, @Animation, 0);
-      if not Animation then
-        Result := hatNone
-      else
-      begin
-        SystemParametersInfo(SPI_GETTOOLTIPFADE, 0, @Animation, 0);
-        if Animation then
-          Result := hatFade
-        else
-          Result := hatSlide;
-      end;
-    end;
-  end;
-
-  // Check availability of MMX if fading is requested.
-  if not MMXAvailable and (Result = hatFade) then
-    Result := hatSlide;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoGetCursor(var Cursor: TCursor);
-
-begin
-  if Assigned(FOnGetCursor) then
-    FOnGetCursor(Self, Cursor);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoGetHeaderCursor(var Cursor: HCURSOR);
-
-begin
-  if Assigned(FOnGetHeaderCursor) then
-    FOnGetHeaderCursor(FHeader, Cursor);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoGetImageIndex(Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex;
-  var Ghosted: Boolean; var Index: Integer);
-
-begin
-  if Assigned(FOnGetImage) then
-    FOnGetImage(Self, Node, Kind, Column, Ghosted, Index);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoGetLineStyle(var Bits: Pointer);
-
-begin
-  if Assigned(FOnGetLineStyle) then
-    FOnGetLineStyle(Self, Bits);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoGetNodeHint(Node: PVirtualNode; Column: TColumnIndex): WideString;
-
-begin
-  Result := Hint;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoGetNodeTooltip(Node: PVirtualNode; Column: TColumnIndex): WideString;
-
-begin
-  Result := Hint;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoGetNodeWidth(Node: PVirtualNode; Column: TColumnIndex; Canvas: TCanvas = nil): Integer;
-
-begin
-  Result := 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoGetPopupMenu(Node: PVirtualNode; Column: TColumnIndex; Position: TPoint): TPopupMenu;
-
-// Queries the application whether there is a node specific popup menu.
-
-var
-  Run: PVirtualNode;
-  AskParent: Boolean;
-
-begin
-  Result := nil;
-  if Assigned(FOnGetPopupMenu) then
-  begin
-    Run := Node;
-
-    if Assigned(Run) then
-    begin
-      AskParent := True;
-      repeat
-        FOnGetPopupMenu(Self, Run, Column, Position, AskParent, Result);
-        Run := Run.Parent;
-      until (Run = FRoot) or Assigned(Result) or not AskParent;
-    end
-    else
-      FOnGetPopupMenu(Self, nil, -1, Position, AskParent, Result);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoGetUserClipboardFormats(var Formats: TFormatEtcArray);
-
-begin
-  if Assigned(FOnGetUserClipboardFormats) then
-    FOnGetUserClipboardFormats(Self, Formats);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoHeaderClick(Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-
-begin
-  if Assigned(FOnHeaderClick) then
-    FOnHeaderClick(FHeader, Column, Button, Shift, X, Y);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoHeaderDblClick(Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-
-begin
-  if Assigned(FOnHeaderDblClick) then
-    FOnHeaderDblClick(FHeader, Column, Button, Shift, X, Y);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoHeaderDragged(Column: TColumnIndex; OldPosition: TColumnPosition);
-
-begin
-  if Assigned(FOnHeaderDragged) then
-    FOnHeaderDragged(FHeader, Column, OldPosition);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoHeaderDraggedOut(Column: TColumnIndex; DropPosition: TPoint);
-
-begin
-  if Assigned(FOnHeaderDraggedOut) then
-    FOnHeaderDraggedOut(FHeader, Column, DropPosition);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoHeaderDragging(Column: TColumnIndex): Boolean;
-
-begin
-  Result := True;
-  if Assigned(FOnHeaderDragging) then
-    FOnHeaderDragging(FHeader, Column, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoHeaderDraw(Canvas: TCanvas; Column: TVirtualTreeColumn; R: TRect; Hover, Pressed: Boolean;
-  DropMark: TVTDropMarkMode);
-
-begin
-  if Assigned(FOnHeaderDraw) then
-    FOnHeaderDraw(FHeader, Canvas, Column, R, Hover, Pressed, DropMark);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoHeaderDrawQueryElements(var PaintInfo: THeaderPaintInfo; var Elements: THeaderPaintElements);
-
-begin
-  if Assigned(FOnHeaderDrawQueryElements) then
-    FOnHeaderDrawQueryElements(FHeader, PaintInfo, Elements);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoHeaderMouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-
-begin
-  if Assigned(FOnHeaderMouseDown) then
-    FOnHeaderMouseDown(FHeader, Button, Shift, X, Y);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoHeaderMouseMove(Shift: TShiftState; X, Y: Integer);
-
-begin
-  if Assigned(FOnHeaderMouseMove) then
-    FOnHeaderMouseMove(FHeader, Shift, X, Y);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoHeaderMouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-
-begin
-  if Assigned(FOnHeaderMouseUp) then
-    FOnHeaderMouseUp(FHeader, Button, Shift, X, Y);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoHotChange(Old, New: PVirtualNode);
-
-begin
-  if Assigned(FOnHotChange) then
-    FOnHotChange(Self, Old, New);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoIncrementalSearch(Node: PVirtualNode; const Text: WideString): Integer;
-
-begin
-  Result := 0;
-  if Assigned(FOnIncrementalSearch) then
-    FOnIncrementalSearch(Self, Node, Text, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoInitChildren(Node: PVirtualNode; var ChildCount: Cardinal);
-
-begin
-  if Assigned(FOnInitChildren) then
-    FOnInitChildren(Self, Node, ChildCount);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoInitNode(Parent, Node: PVirtualNode; var InitStates: TVirtualNodeInitStates);
-
-begin
-  if Assigned(FOnInitNode) then
-    FOnInitNode(Self, Parent, Node, InitStates);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoKeyAction(var CharCode: Word; var Shift: TShiftState): Boolean;
-
-begin
-  Result := True;
-  if Assigned(FOnKeyAction) then
-    FOnKeyAction(Self, CharCode, Shift, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoLoadUserData(Node: PVirtualNode; Stream: TStream);
-
-begin
-  if Assigned(FOnLoadNode) then
-    if Node = FRoot then
-      FOnLoadNode(Self, nil, Stream)
-    else
-      FOnLoadNode(Self, Node, Stream);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoNodeCopied(Node: PVirtualNode);
-
-begin
-  if Assigned(FOnNodeCopied) then
-    FOnNodeCopied(Self, Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoNodeCopying(Node, NewParent: PVirtualNode): Boolean;
-
-begin
-  Result := True;
-  if Assigned(FOnNodeCopying) then
-    FOnNodeCopying(Self, Node, NewParent, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoNodeMoved(Node: PVirtualNode);
-
-begin
-  if Assigned(FOnNodeMoved) then
-    FOnNodeMoved(Self, Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoNodeMoving(Node, NewParent: PVirtualNode): Boolean;
-
-begin
-  Result := True;
-  if Assigned(FOnNodeMoving) then
-    FOnNodeMoving(Self, Node, NewParent, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoPaintBackground(Canvas: TCanvas; R: TRect): Boolean;
-
-begin
-  Result := False;
-  if Assigned(FOnPaintBackground) then
-    FOnPaintBackground(Self, Canvas, R, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoPaintDropMark(Canvas: TCanvas; Node: PVirtualNode; R: TRect);
-
-// draws the drop mark into the given rectangle
-// Note: Changed properties of the given canvas should be reset to their previous values.
-
-var
-  SaveBrushColor: TColor;
-  SavePenStyle: TPenStyle;
-
-begin
-  if FLastDropMode in [dmAbove, dmBelow] then
-    with Canvas do
-    begin
-      SavePenStyle := Pen.Style;
-      Pen.Style := psClear;
-      SaveBrushColor := Brush.Color;
-      Brush.Color := FColors.DropMarkColor;
-
-      if FLastDropMode = dmAbove then
-      begin
-        Polygon([Point(R.Left + 2, R.Top),
-                 Point(R.Right - 2, R.Top),
-                 Point(R.Right - 2, R.Top + 6),
-                 Point(R.Right - 6, R.Top + 2),
-                 Point(R.Left + 6 , R.Top + 2),
-                 Point(R.Left + 2, R.Top + 6)
-        ]);
-      end
-      else
-        Polygon([Point(R.Left + 2, R.Bottom - 1),
-                 Point(R.Right - 2, R.Bottom - 1),
-                 Point(R.Right - 2, R.Bottom - 8),
-                 Point(R.Right - 7, R.Bottom - 3),
-                 Point(R.Left + 7 , R.Bottom - 3),
-                 Point(R.Left + 2, R.Bottom - 8)
-        ]);
-      Brush.Color := SaveBrushColor;
-      Pen.Style := SavePenStyle;
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoPaintNode(var PaintInfo: TVTPaintInfo);
-
-begin
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoPopupMenu(Node: PVirtualNode; Column: TColumnIndex; Position: TPoint);
-
-// Support for node dependent popup menus.
-
-var
-  Menu: TPopupMenu;
-
-begin
-  Menu := DoGetPopupMenu(Node, Column, Position);
-
-  if Assigned(Menu) then
-  begin
-    StopTimer(EditTimer);
-    Menu.PopupComponent := Self;
-    with ClientToScreen(Position) do
-      Menu.Popup(X, Y);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoRenderOLEData(const FormatEtcIn: TFormatEtc; out Medium: TStgMedium;
-  ForClipboard: Boolean): HRESULT;
-
-begin
-  Result := E_FAIL;
-  if Assigned(FOnRenderOLEData) then
-    FOnRenderOLEData(Self, FormatEtcIn, Medium, ForClipboard, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoReset(Node: PVirtualNode);
-
-begin
-  if Assigned(FOnResetNode) then
-    FOnResetNode(Self, Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoSaveUserData(Node: PVirtualNode; Stream: TStream);
-
-begin
-  if Assigned(FOnSaveNode) then
-    if Node = FRoot then
-      FOnSaveNode(Self, nil, Stream)
-    else
-      FOnSaveNode(Self, Node, Stream);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoScroll(DeltaX, DeltaY: Integer);
-
-begin
-  if Assigned(FOnScroll) then
-    FOnScroll(Self, DeltaX, DeltaY);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoSetOffsetXY(Value: TPoint; Options: TScrollUpdateOptions; ClipRect: PRect = nil): Boolean;
-
-// Actual offset setter used to scroll the client area, update scroll bars and invalidating the header (all optional).
-// Returns True if the offset really changed otherwise False is returned.
-
-var
-  DeltaX: Integer;
-  DeltaY: Integer;
-  DWPStructure: HDWP;
-  I: Integer;
-  P: TPoint;
-
-begin
-  // Range check, order is important here.
-  if Value.X &lt; (ClientWidth - Integer(FRangeX)) then
-    Value.X := ClientWidth - Integer(FRangeX);
-  if Value.X &gt; 0 then
-    Value.X := 0;
-  DeltaX := Value.X - FOffsetX;
-  if Value.Y &lt; (ClientHeight - Integer(FRangeY)) then
-    Value.Y := ClientHeight - Integer(FRangeY);
-  if Value.Y &gt; 0 then
-    Value.Y := 0;
-  DeltaY := Value.Y - FOffsetY;
-
-  Result := (DeltaX &lt;&gt; 0) or (DeltaY &lt;&gt; 0);
-  if Result then
-  begin
-    FOffsetX := Value.X;
-    FOffsetY := Value.Y;
-    Result := True;
-
-    if FUpdateCount = 0 then
-    begin
-      // The drag image from VCL controls need special consideration.
-      if tsVCLDragging in FStates then
-        ImageList_DragShowNolock(False);
-
-      if suoScrollClientArea in Options then
-      begin
-        // Have to invalidate the entire window if there's a background.
-        if (toShowBackground in FOptions.FPaintOptions) and (FBackground.Graphic is TBitmap) then
-        begin
-          // Since we don't use ScrollWindow here we have to move all client windows ourselves.
-          DWPStructure := BeginDeferWindowPos(ControlCount);
-          for I := 0 to ControlCount - 1 do
-            if Controls[I] is TWinControl then
-            begin
-              with Controls[I] as TWinControl do
-                DWPStructure := DeferWindowPos(DWPStructure, Handle, 0, Left + DeltaX, Top + DeltaY, 0, 0,
-                  SWP_NOZORDER or SWP_NOACTIVATE or SWP_NOSIZE);
-              if DWPStructure = 0 then
-                Break;
-            end;
-          if DWPStructure &lt;&gt; 0 then
-            EndDeferWindowPos(DWPStructure);
-          InvalidateRect(Handle, nil, False);
-        end
-        else
-          ScrollWindow(Handle, DeltaX, DeltaY, ClipRect, ClipRect);
-      end;
-
-      if suoUpdateNCArea in Options then
-      begin
-        if DeltaX &lt;&gt; 0 then
-        begin
-          if (suoRepaintHeader in Options) and (hoVisible in FHeader.FOptions) then
-            FHeader.Invalidate(nil);
-          if not (tsSizing in FStates) and (FScrollBarOptions.ScrollBars in [ssHorizontal, ssBoth]) then
-            UpdateHorizontalScrollBar(suoRepaintScrollbars in Options);
-        end;
-
-        if (DeltaY &lt;&gt; 0) and ([tsThumbTracking, tsSizing] * FStates = []) then
-        begin
-          UpdateVerticalScrollBar(suoRepaintScrollbars in Options);
-          if not (FHeader.UseColumns or IsMouseSelecting) and
-            (FScrollBarOptions.ScrollBars in [ssHorizontal, ssBoth]) then
-            UpdateHorizontalScrollBar(suoRepaintScrollbars in Options);
-        end;
-      end;
-
-      if tsVCLDragging in FStates then
-        ImageList_DragShowNolock(True);
-    end;
-
-    // Finally update &quot;hot&quot; node if hot tracking is activated
-    GetCursorPos(P);
-    P := ScreenToClient(P);
-    if PtInRect(ClientRect, P) then
-      HandleHotTrack(P.X, P.Y);
-
-    DoScroll(DeltaX, DeltaY);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoStartDrag(var DragObject: TDragObject);
-
-begin
-  inherited;
-
-  // Check if the application created an own drag object. This is needed to pass the correct source in
-  // OnDragOver and OnDragDrop.
-  if Assigned(DragObject) then
-    DoStateChange([tsUserDragObject]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoStateChange(Enter: TVirtualTreeStates; Leave: TVirtualTreeStates = []);
-
-var
-  ActualEnter,
-  ActualLeave: TVirtualTreeStates;
-  
-begin
-  if Assigned(FOnStateChange) then
-  begin
-    ActualEnter := Enter - FStates;
-    ActualLeave := FStates * Leave;
-    if (ActualEnter + ActualLeave) &lt;&gt; [] then
-      FOnStateChange(Self, Enter, Leave);
-  end;
-  FStates := FStates + Enter - Leave;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoStructureChange(Node: PVirtualNode; Reason: TChangeReason);
-
-begin
-  StopTimer(StructureChangeTimer);
-  if Assigned(FOnStructureChange) then
-    FOnStructureChange(Self, Node, Reason);
-
-  // This is a good place to reset the cached node and reason. These are the same as the values passed in here.
-  // This is necessary to allow descentants to override this method and get them.
-  DoStateChange([], [tsStructureChangePending]);
-  FLastStructureChangeNode := nil;
-  FLastStructureChangeReason := crIgnore;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoTimerScroll;
-
-var
-  P,
-  ClientP: TPoint;
-  InRect,
-  Panning: Boolean;
-  R,
-  ClipRect: TRect;
-  DeltaX,
-  DeltaY: Integer;
-
-begin
-  GetCursorPos(P);
-  R := ClientRect;
-  ClipRect := R;
-  MapWindowPoints(Handle, 0, R, 2);
-  InRect := PtInRect(R, P);
-  ClientP := ScreenToClient(P);
-  Panning := [tsWheelPanning, tsWheelScrolling] * FStates &lt;&gt; [];
-  
-  if IsMouseSelecting or InRect or ([tsWheelPanning, tsWheelScrolling] * FStates &lt;&gt; []) then
-  begin
-    DeltaX := 0;
-    DeltaY := 0;
-    if sdUp in FScrollDirections then
-    begin
-      if Panning then
-        DeltaY := FLastClickPos.Y - ClientP.Y - 8
-      else
-        if InRect then
-          DeltaY := Min(FScrollBarOptions.FIncrementY, ClientHeight)
-        else
-          DeltaY := Min(FScrollBarOptions.FIncrementY, ClientHeight) * Abs(R.Top - P.Y);
-      if FOffsetY = 0 then
-        Exclude(FScrollDirections, sdUp);
-    end;
-
-    if sdDown in FScrollDirections then
-    begin
-      if Panning then
-        DeltaY := FLastClickPos.Y - ClientP.Y + 8
-      else
-        if InRect then
-          DeltaY := -Min(FScrollBarOptions.FIncrementY, ClientHeight)
-        else
-          DeltaY := -Min(FScrollBarOptions.FIncrementY, ClientHeight) * Abs(P.Y - R.Bottom);
-      if (ClientHeight - FOffsetY) = Integer(FRangeY) then
-        Exclude(FScrollDirections, sdDown);
-    end;
-
-    if sdLeft in FScrollDirections then
-    begin
-      if Panning then
-        DeltaX := FLastClickPos.X - ClientP.X - 8
-      else
-        if InRect then
-          DeltaX := FScrollBarOptions.FIncrementX
-        else
-          DeltaX := FScrollBarOptions.FIncrementX * Abs(R.Left - P.X);
-      if FOffsetX = 0 then
-        Exclude(FScrollDirections, sdleft);
-    end;
-
-    if sdRight in FScrollDirections then
-    begin
-      if Panning then
-        DeltaX := FLastClickPos.X - ClientP.X + 8
-      else
-        if InRect then
-          DeltaX := -FScrollBarOptions.FIncrementX
-        else
-          DeltaX := -FScrollBarOptions.FIncrementX * Abs(P.X - R.Right);
-
-      if (ClientWidth - FOffsetX) = Integer(FRangeX) then
-        Exclude(FScrollDirections, sdRight);
-    end;
-
-    if IsMouseSelecting then
-    begin
-      // In order to avoid scrolling the area which needs a repaint due to the changed selection rectangle
-      // we limit the scroll area explicitely.
-      OffsetRect(ClipRect, DeltaX, DeltaY);
-      DoSetOffsetXY(Point(FOffsetX + DeltaX, FOffsetY + DeltaY), DefaultScrollUpdateFlags, @ClipRect);
-      // When selecting with the mouse then either update only the parts of the window which have been uncovered
-      // by the scroll operation if no change in the selection happend or invalidate and redraw the entire
-      // client area otherwise (to avoid the time consuming task of determining the display rectangles of every
-      // changed node).
-      if CalculateSelectionRect(ClientP.X, ClientP.Y) and HandleDrawSelection(ClientP.X, ClientP.Y) then
-        InvalidateRect(Handle, nil, False)
-      else
-      begin
-        // The selection did not change so invalidate only the part of the window which really needs an update.
-        // 1) Invalidate the parts uncovered by the scroll operation. Add another offset range, we have to
-        //    scroll only one stripe but have to update two. 
-        OffsetRect(ClipRect, DeltaX, DeltaY);
-        SubtractRect(ClipRect, ClientRect, ClipRect);
-        InvalidateRect(Handle, @ClipRect, False);
-
-        // 2) Invalidate the selection rectangles.
-        UnionRect(ClipRect, OrderRect(FNewSelRect), OrderRect(FLastSelRect));
-        OffsetRect(ClipRect, FOffsetX, FOffsetY);
-        InvalidateRect(Handle, @ClipRect, False);
-      end;
-    end
-    else
-    begin
-      // Scroll only if there is no drag'n drop in progress. Drag'n drop scrolling is handled in DragOver.
-      if ((FDragManager = nil) or not DragManager.IsDropTarget) and ((DeltaX &lt;&gt; 0) or (DeltaY &lt;&gt; 0)) then
-        DoSetOffsetXY(Point(FOffsetX + DeltaX, FOffsetY + DeltaY), DefaultScrollUpdateFlags, nil);
-    end;
-    UpdateWindow(Handle);
-
-    if (FScrollDirections = []) and ([tsWheelPanning, tsWheelScrolling] * FStates = []) then
-    begin
-      StopTimer(ScrollTimer);
-      DoStateChange([], [tsScrollPending, tsScrolling]);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DoUpdating(State: TVTUpdateState);
-
-begin
-  if Assigned(FOnUpdating) then
-    FOnUpdating(Self, State);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DoValidateCache: Boolean;
-
-// This method fills the caches used in various situations to speed up search for nodes.
-// The strategy is simple: Take the current number of visible nodes and distribute evenly a number of marks
-// (which are stored in FPositionCache) so that iterating through the tree doesn't cost too much time.
-// If there are less than 'CacheThreshold' nodes in the tree then the cache remains empty.
-// Result is True if the cache was filled without interruption, otherwise False.
-// Note: You can adjust the maximum number of nodes between two cache entries by changing CacheThreshold.
-
-var
-  EntryCount,
-  CurrentTop,
-  Index: Cardinal;
-  CurrentNode,
-  Temp: PVirtualNode;
-
-begin
-  EntryCount := 0;
-  if not (tsStopValidation in FStates) then
-  begin
-    if FStartIndex = 0 then
-      FPositionCache := nil;
-
-    if FVisibleCount &gt; CacheThreshold then
-    begin
-      EntryCount := CalculateCacheEntryCount;
-      SetLength(FPositionCache, EntryCount);
-      if FStartIndex &gt; EntryCount then
-        FStartIndex := EntryCount;
-
-      // Optimize validation by starting with FStartIndex if set.
-      if (FStartIndex &gt; 0) and Assigned(FPositionCache[FStartIndex - 1].Node) then
-      begin
-        // Index is the current entry in FPositionCache.
-        Index := FStartIndex - 1;
-        // Running term for absolute top value.
-        CurrentTop := FPositionCache[Index].AbsoluteTop;
-        // Running node pointer.
-        CurrentNode := FPositionCache[Index].Node;
-      end
-      else
-      begin
-        // Index is the current entry in FPositionCache.
-        Index := 0;
-        // Running term for absolute top value.
-        CurrentTop := 0;
-        // Running node pointer.
-        CurrentNode := GetFirstVisibleNoInit;
-      end;
-
-      // EntryCount serves as counter for processed nodes here. This value can always start at 0 as
-      // the validation either starts also at index 0 or an index which is always a multiple of CacheThreshold
-      // and EntryCount is only used with modulo CacheThreshold.
-      EntryCount := 0;
-      if Assigned(CurrentNode) then
-      begin
-        while not (tsStopValidation in FStates) do
-        begin
-          if (EntryCount mod CacheThreshold) = 0 then
-          begin
-            // New cache entry to set up.
-            with FPositionCache[Index] do
-            begin
-              Node := CurrentNode;
-              AbsoluteTop := CurrentTop;
-            end;
-            Inc(Index);
-          end;
-
-          Inc(CurrentTop, CurrentNode.NodeHeight);
-          // Advance to next visible node.
-          Temp := GetNextVisibleNoInit(CurrentNode);
-          // If there is no further node or the cache is full then stop the loop.
-          if (Temp = nil) or (Integer(Index) = Length(FPositionCache)) then
-            Break;
-
-          CurrentNode := Temp;
-          Inc(EntryCount);
-        end;
-      end;
-      // Finalize the position cache so no nil entry remains there.
-      if not (tsStopValidation in FStates) and (Integer(Index) &lt;= High(FPositionCache)) then
-      begin
-        SetLength(FPositionCache, Index + 1);
-        with FPositionCache[Index] do
-        begin
-          Node := CurrentNode;
-          AbsoluteTop := CurrentTop;
-        end;
-      end;
-    end;
-  end;
-
-  Result := EntryCount &gt; 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DragCanceled;
-
-// Does some housekeeping for VCL drag'n drop;
-
-begin
-  inherited;
-  
-  DragFinished;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DragDrop(const DataObject: IDataObject; KeyState: Integer; Pt: TPoint;
-  var Effect: Integer): HResult;
-
-var
-  Shift: TShiftState;
-  EnumFormat: IEnumFormatEtc;
-  Fetched: Integer;
-  OLEFormat: TFormatEtc;
-  Formats: TFormatArray;
-
-begin
-  StopTimer(ExpandTimer);
-  StopTimer(ScrollTimer);
-  DoStateChange([], [tsScrollPending, tsScrolling]);
-  Formats := nil;
-
-  // Ask explicitly again whether the action is allowed. Otherwise we may accept a drop which is intentionally not
-  // allowed but cannot be prevented by the application because when the tree was scrolling while dropping
-  // no DragOver event is created by the OLE subsystem.
-  Result := DragOver(DragManager.DragSource, KeyState, dsDragMove, Pt, Effect);
-  try
-    if (Result &lt;&gt;  NOERROR) or ((Effect and not DROPEFFECT_SCROLL) = DROPEFFECT_NONE) then
-      Result := E_FAIL
-    else
-    begin
-      try
-        Shift := KeysToShiftState(KeyState);
-        Pt := ScreenToClient(Pt);
-        // Determine which formats we can get and pass them along with the data object to the drop handler.
-        Result := DataObject.EnumFormatEtc(DATADIR_GET, EnumFormat);
-        if Failed(Result) then
-          Abort;
-        Result := EnumFormat.Reset;
-        if Failed(Result) then
-          Abort;
-        // create a list of available formats
-        while EnumFormat.Next(1, OLEFormat, @Fetched) = S_OK do
-        begin
-          SetLength(Formats, Length(Formats) + 1);
-          Formats[High(Formats)] := OLEFormat.cfFormat;
-        end;
-        DoDragDrop(DragManager.DragSource, DataObject, Formats, Shift, Pt, Effect, FLastDropMode);
-      except
-        Result := E_UNEXPECTED;
-        raise;
-      end;
-    end;
-  finally
-    if Assigned(FDropTargetNode) then
-    begin
-      InvalidateNode(FDropTargetNode);
-      FDropTargetNode := nil;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DragEnter(KeyState: Integer; Pt: TPoint; var Effect: Integer): HResult;
-
-// callback routine for the drop target interface
-
-var
-  Shift: TShiftState;
-  Accept: Boolean;
-  R: TRect;
-  HitInfo: THitInfo;
-
-begin
-  try
-    // Determine acceptance of drag operation and reset scroll start time.
-    FDragScrollStart := 0;
-    
-    Shift := KeysToShiftState(KeyState);
-    Pt := ScreenToClient(Pt);
-    Effect := SuggestDropEffect(DragManager.DragSource, Shift, Pt, Effect);
-    Accept := DoDragOver(DragManager.DragSource, Shift, dsDragEnter, Pt, FLastDropMode, Effect);
-    if not Accept then
-      Effect := DROPEFFECT_NONE
-    else
-    begin
-      // Set initial drop target node and drop mode.
-      GetHitTestInfoAt(Pt.X, Pt.Y, True, HitInfo);
-      if Assigned(HitInfo.HitNode) then
-      begin
-        FDropTargetNode := HitInfo.HitNode;
-        R := GetDisplayRect(HitInfo.HitNode, FHeader.MainColumn, False);
-        if hiOnItemLabel in HitInfo.HitPositions then
-          FLastDropMode := dmOnNode
-        else
-          if ((R.Top + R.Bottom) div 2) &gt; Pt.Y then
-            FLastDropMode := dmAbove
-          else
-            FLastDropMode := dmBelow;
-      end
-      else
-        FLastDropMode := dmNowhere;
-    end;
-
-    // If the drag source is a virtual tree then we know how to control the drag image
-    // and can show it even if the source is not the target tree.
-    // This is only necessary if we cannot use the drag image helper interfaces.
-    if not DragManager.DropTargetHelperSupported and Assigned(DragManager.DragSource) then
-      DragManager.DragSource.FDragImage.ShowDragImage;
-    Result :=  NOERROR;
-  except
-    Result := E_UNEXPECTED;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DragFinished;
-
-// Called by DragCancelled or EndDrag to make up for the still missing mouse button up messages.
-// These are important for such important things like popup menus.
-
-var
-  P: TPoint;
-  
-begin
-  GetCursorPos(P);
-  P := ScreenToClient(P);
-  if tsRightButtonDown in FStates then
-    Perform(WM_RBUTTONUP, 0, Longint(PointToSmallPoint(P)))
-  else
-    if tsMiddleButtonDown in FStates then
-      Perform(WM_MBUTTONUP, 0, Longint(PointToSmallPoint(P)))
-    else
-      Perform(WM_LBUTTONUP, 0, Longint(PointToSmallPoint(P)));
-  DoStateChange([], [tsVCLDragPending, tsVCLDragging, tsUserDragObject]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DragLeave;
-
-var
-  Effect: Integer;
-
-begin
-  StopTimer(ExpandTimer);
-
-  if not DragManager.DropTargetHelperSupported and Assigned(DragManager.DragSource) then
-    DragManager.DragSource.FDragImage.HideDragImage;
-
-  if Assigned(FDropTargetNode) then
-  begin
-    InvalidateNode(FDropTargetNode);
-    FDropTargetNode := nil;
-  end;
-  UpdateWindow(Handle);
-
-  Effect := 0;
-  DoDragOver(nil, [], dsDragLeave, Point(0, 0), FLastDropMode, Effect);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.DragOver(Source: TObject; KeyState: Integer; DragState: TDragState; Pt: TPoint;
-  var Effect: Integer): HResult;
-
-// callback routine for the drop target interface
-
-var
-  Shift: TShiftState;
-  Accept,
-  DragImageWillMove,
-  WindowScrolled: Boolean;
-  OldR, R: TRect;
-  NewDropMode: TDropMode;
-  HitInfo: THitInfo;
-  ImageHit: Boolean;
-  LabelHit: Boolean;
-  DragPos: TPoint;
-  Tree: TBaseVirtualTree;
-  LastNode: PVirtualNode;
-
-  DeltaX,
-  DeltaY: Integer;
-  ScrollOptions: TScrollUpdateOptions;
-
-begin
-  if not DragManager.DropTargetHelperSupported and (Source is TBaseVirtualTree) then
-  begin
-    Tree := Source as TBaseVirtualTree;
-    ScrollOptions := [suoUpdateNCArea];
-  end
-  else
-  begin
-    Tree := nil;
-    ScrollOptions := DefaultScrollUpdateFlags;
-  end;
-
-  try
-    DragPos := Pt;
-    Pt := ScreenToClient(Pt);
-
-    // Check if we have to scroll the client area.
-    FScrollDirections := DetermineScrollDirections(Pt.X, Pt.Y);
-    DeltaX := 0;
-    DeltaY := 0;
-    if FScrollDirections &lt;&gt; [] then
-    begin
-      // Determine amount to scroll.
-      if sdUp in FScrollDirections then
-      begin
-        DeltaY := Min(FScrollBarOptions.FIncrementY, ClientHeight);
-        if FOffsetY = 0 then
-          Exclude(FScrollDirections, sdUp);
-      end;
-      if sdDown in FScrollDirections then
-      begin
-        DeltaY := -Min(FScrollBarOptions.FIncrementY, ClientHeight);
-        if (ClientHeight - FOffsetY) = Integer(FRangeY) then
-          Exclude(FScrollDirections, sdDown);
-      end;
-      if sdLeft in FScrollDirections then
-      begin
-        DeltaX := FScrollBarOptions.FIncrementX;
-        if FOffsetX = 0 then
-          Exclude(FScrollDirections, sdleft);
-      end;
-      if sdRight in FScrollDirections then
-      begin
-        DeltaX := -FScrollBarOptions.FIncrementX;
-        if (ClientWidth - FOffsetX) = Integer(FRangeX) then
-          Exclude(FScrollDirections, sdRight);
-      end;
-      WindowScrolled := DoSetOffsetXY(Point(FOffsetX + DeltaX, FOffsetY + DeltaY), ScrollOptions, nil);
-    end
-    else
-      WindowScrolled := False;
-
-    // Determine acceptance of drag operation as well as drag target.
-    Shift := KeysToShiftState(KeyState);
-    GetHitTestInfoAt(Pt.X, Pt.Y, True, HitInfo);
-    ImageHit := HitInfo.HitPositions * [hiOnNormalIcon, hiOnStateIcon] &lt;&gt; [];
-    LabelHit := hiOnItemLabel in HitInfo.HitPositions;
-    // In report mode only direct hits of the node captions/images in the main column are accepted as hits.
-    if (toReportMode in FOptions.MiscOptions) and not ((LabelHit or ImageHit) and 
-      (HitInfo.HitColumn = FHeader.MainColumn)) then
-      HitInfo.HitNode := nil;
-
-    if Assigned(HitInfo.HitNode) then
-    begin
-      R := GetDisplayRect(HitInfo.HitNode, NoColumn, False);
-      if LabelHit or ImageHit or not (toShowDropmark in FOptions.FPaintOptions) then
-        NewDropMode := dmOnNode
-      else
-        if ((R.Top + R.Bottom) div 2) &gt; Pt.Y then
-          NewDropMode := dmAbove
-        else
-          NewDropMode := dmBelow;
-    end
-    else
-    begin
-      NewDropMode := dmNowhere;
-      R := Rect(0, 0, 0, 0);
-    end;
-
-    if Assigned(Tree) then
-      DragImageWillMove := Tree.FDragImage.WillMove(DragPos)
-    else
-      DragImageWillMove := False;
-
-    if (HitInfo.HitNode &lt;&gt; FDropTargetNode) or (FLastDropMode &lt;&gt; NewDropMode) then
-    begin
-      // Something in the tree will change. This requires to update the screen and/or the drag image.
-      FLastDropMode := NewDropMode;
-      if HitInfo.HitNode &lt;&gt; FDropTargetNode then
-      begin
-        StopTimer(ExpandTimer);
-        // The last target node is needed for the rectangle determination but must already be set for
-        // the recapture call, hence it must be stored somewhere.
-        LastNode := FDropTargetNode;
-        FDropTargetNode := HitInfo.HitNode;
-        // In order to show a selection rectangle a column must be focused.
-        if FFocusedColumn = NoColumn then
-          FFocusedColumn := FHeader.MainColumn;
-
-        if Assigned(LastNode) and Assigned(FDropTargetNode) then
-        begin
-          // Optimize the case that the selection moved between two nodes. 
-          OldR := GetDisplayRect(LastNode, NoColumn, False);
-          UnionRect(R, R, OldR);
-          if Assigned(Tree) then
-          begin
-            if WindowScrolled then
-              UpdateWindowAndDragImage(Tree, ClientRect, True, not DragImageWillMove)
-            else
-              UpdateWindowAndDragImage(Tree, R, False, not DragImageWillMove);
-          end
-          else
-            InvalidateRect(Handle, @R, False);
-        end
-        else
-        begin
-          if Assigned(LastNode) then
-          begin
-            // Repaint last target node.
-            OldR := GetDisplayRect(LastNode, NoColumn, False);
-            if Assigned(Tree) then
-            begin
-              if WindowScrolled then
-                UpdateWindowAndDragImage(Tree, ClientRect, WindowScrolled, not DragImageWillMove)
-              else
-                UpdateWindowAndDragImage(Tree, OldR, False, not DragImageWillMove);
-            end
-            else
-              InvalidateRect(Handle, @OldR, False);
-          end
-          else
-          begin
-            if Assigned(Tree) then
-            begin
-              if WindowScrolled then
-                UpdateWindowAndDragImage(Tree, ClientRect, WindowScrolled, not DragImageWillMove)
-              else
-                UpdateWindowAndDragImage(Tree, R, False, not DragImageWillMove);
-            end
-            else
-              InvalidateRect(Handle, @R, False);
-          end;
-        end;
-
-        // Start auto expand timer if necessary.
-        if (toAutoDropExpand in FOptions.FAutoOptions) and Assigned(FDropTargetNode) and
-          (vsHasChildren in FDropTargetNode.States) then
-          SetTimer(Handle, ExpandTimer, FAutoExpandDelay, nil);
-      end
-      else
-      begin
-        // Only the drop mark position changed so invalidate the current drop target node.
-        if Assigned(Tree) then
-        begin
-          if WindowScrolled then
-            UpdateWindowAndDragImage(Tree, ClientRect, WindowScrolled, not DragImageWillMove)
-          else
-            UpdateWindowAndDragImage(Tree, R, False, not DragImageWillMove);
-        end
-        else
-          InvalidateRect(Handle, @R, False);
-      end;
-    end
-    else
-    begin
-      // No change in the current drop target or drop mode. This might still mean horizontal or vertical scrolling.
-      if Assigned(Tree) and ((DeltaX &lt;&gt; 0) or (DeltaY &lt;&gt; 0)) then
-        UpdateWindowAndDragImage(Tree, ClientRect, WindowScrolled, not DragImageWillMove);
-    end;
-
-    Update;
-    
-    if Assigned(Tree) and DragImageWillMove then
-      Tree.FDragImage.DragTo(DragPos, False);
-
-    Effect := SuggestDropEffect(Source, Shift, Pt, Effect);
-    Accept := DoDragOver(Source, Shift, DragState, Pt, FLastDropMode, Effect);
-    if not Accept then
-      Effect := DROPEFFECT_NONE;
-    if WindowScrolled then
-      Effect := Effect or Integer(DROPEFFECT_SCROLL);
-    Result :=  NOERROR;
-  except
-    Result := E_UNEXPECTED;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DrawDottedHLine(const PaintInfo: TVTPaintInfo; Left, Right, Top: Integer);
-
-// Draws a horizontal line with alternating pixels (this style is not supported for pens under Win9x).
-
-var
-  R: TRect;
-
-begin
-  with PaintInfo, Canvas do
-  begin
-    Brush.Color := Color;
-    R := Rect(Min(Left, Right), Top, Max(Left, Right) + 1, Top + 1);
-    Windows.FillRect(Handle, R, FDottedBrush);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DrawDottedVLine(const PaintInfo: TVTPaintInfo; Top, Bottom, Left: Integer);
-
-// Draws a horizontal line with alternating pixels (this style is not supported for pens under Win9x).
-
-var
-  R: TRect;
-
-begin
-  with PaintInfo, Canvas do
-  begin
-    Brush.Color := Color;
-    R := Rect(Left, Min(Top, Bottom), Left + 1, Max(Top, Bottom) + 1);
-    Windows.FillRect(Handle, R, FDottedBrush);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.FindNodeInSelection(P: PVirtualNode; var Index: Integer; LowBound,
-  HighBound: Integer): Boolean;
-
-// Search routine to find a specific node in the selection array.
-// LowBound and HighBound determine the range in which to search the node.
-// Either value can be -1 to denote the maximum range otherwise LowBound must be less or equal HighBound.
-
-var
-  L, H,
-  I, C: Integer;
-
-begin
-  Result := False;
-  L := 0;
-  if LowBound &gt;= 0 then
-    L := LowBound;
-  H := FSelectionCount - 1;
-  if HighBound &gt;= 0 then
-    H := HighBound;
-  while L &lt;= H do
-  begin
-    I := (L + H) shr 1;
-    C := Integer(FSelection[I]) - Integer(P);
-    if C &lt; 0 then
-      L := I + 1
-    else
-    begin
-      H := I - 1;
-      if C = 0 then
-      begin
-        Result := True;
-        L := I;
-      end;
-    end;
-  end;
-  Index := L;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.FinishChunkHeader(Stream: TStream; StartPos, EndPos: Integer);
-
-// used while streaming out a node to finally write out the size of the chunk
-
-var
-  Size: Integer;
-  
-begin
-  // seek back to the second entry in the chunk header
-  Stream.Position := StartPos + SizeOf(Integer);
-  // determine size of chunk without the chunk header
-  Size := EndPos - StartPos - SizeOf(TChunkHeader);
-  // write the size...
-  Stream.Write(Size, SizeOf(Size));
-  // ... and seek to the last endposition
-  Stream.Position := EndPos;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.FontChanged(AFont: TObject);
-
-// Little helper function for font changes (as they are not tracked in TBitmap/TCanvas.OnChange).
-
-begin
-  FFontChanged := True;
-  FOldFontChange(AFont);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetCheckImage(Node: PVirtualNode): Integer;
-
-// Determines the index into the check image list for the given node depending on the check type
-// and enabled state.
-
-const
-  // Four dimensional array consisting of image indices for the check type, the check state, the enabled state and the
-  // hot state.
-  CheckStateToCheckImage: array[ctCheckBox..ctButton, csUncheckedNormal..csMixedPressed, Boolean, Boolean] of Integer = (
-    // ctCheckBox, ctTriStateCheckBox
-    (
-      // csUncheckedNormal (disabled [not hot, hot], enabled [not hot, hot])
-      ((ckCheckUncheckedDisabled, ckCheckUncheckedDisabled), (ckCheckUncheckedNormal, ckCheckUncheckedHot)),
-      // csUncheckedPressed (disabled [not hot, hot], enabled [not hot, hot])
-      ((ckCheckUncheckedDisabled, ckCheckUncheckedDisabled), (ckCheckUncheckedPressed, ckCheckUncheckedPressed)),
-      // csCheckedNormal
-      ((ckCheckCheckedDisabled, ckCheckCheckedDisabled), (ckCheckCheckedNormal, ckCheckCheckedHot)),
-      // csCheckedPressed
-      ((ckCheckCheckedDisabled, ckCheckCheckedDisabled), (ckCheckCheckedPressed, ckCheckCheckedPressed)),
-      // csMixedNormal
-      ((ckCheckMixedDisabled, ckCheckMixedDisabled), (ckCheckMixedNormal, ckCheckMixedHot)),
-      // csMixedPressed
-      ((ckCheckMixedDisabled, ckCheckMixedDisabled), (ckCheckMixedPressed, ckCheckMixedPressed))
-    ),
-    // ctRadioButton
-    (
-      // csUncheckedNormal (disabled [not hot, hot], enabled [not hot, hot])
-      ((ckRadioUncheckedDisabled, ckRadioUncheckedDisabled), (ckRadioUncheckedNormal, ckRadioUncheckedHot)),
-      // csUncheckedPressed (disabled [not hot, hot], enabled [not hot, hot])
-      ((ckRadioUncheckedDisabled, ckRadioUncheckedDisabled), (ckRadioUncheckedPressed, ckRadioUncheckedPressed)),
-      // csCheckedNormal
-      ((ckRadioCheckedDisabled, ckRadioCheckedDisabled), (ckRadioCheckedNormal, ckRadioCheckedHot)),
-      // csCheckedPressed
-      ((ckRadioCheckedDisabled, ckRadioCheckedDisabled), (ckRadioCheckedPressed, ckRadioCheckedPressed)),
-      // csMixedNormal (should never appear with ctRadioButton)
-      ((ckCheckMixedDisabled, ckCheckMixedDisabled), (ckCheckMixedNormal, ckCheckMixedHot)),
-      // csMixedPressed (should never appear with ctRadioButton)
-      ((ckCheckMixedDisabled, ckCheckMixedDisabled), (ckCheckMixedPressed, ckCheckMixedPressed))
-    ),
-    // ctButton
-    (
-      // csUncheckedNormal (disabled [not hot, hot], enabled [not hot, hot])
-      ((ckButtonDisabled, ckButtonDisabled), (ckButtonNormal, ckButtonHot)),
-      // csUncheckedPressed (disabled [not hot, hot], enabled [not hot, hot])
-      ((ckButtonDisabled, ckButtonDisabled), (ckButtonPressed, ckButtonPressed)),
-      // csCheckedNormal
-      ((ckButtonDisabled, ckButtonDisabled), (ckButtonNormal, ckButtonHot)),
-      // csCheckedPressed
-      ((ckButtonDisabled, ckButtonDisabled), (ckButtonPressed, ckButtonPressed)),
-      // csMixedNormal (should never appear with ctButton)
-      ((ckCheckMixedDisabled, ckCheckMixedDisabled), (ckCheckMixedNormal, ckCheckMixedHot)),
-      // csMixedPressed (should never appear with ctButton)
-      ((ckCheckMixedDisabled, ckCheckMixedDisabled), (ckCheckMixedPressed, ckCheckMixedPressed))
-    )
-  );
-
-var
-  AType: TCheckType;
-
-begin
-  if Node.CheckType = ctNone then
-    Result := -1
-  else
-  begin
-    AType := Node.CheckType;
-    if AType = ctTriStateCheckBox then
-      AType := ctCheckBox;
-    Result := CheckStateToCheckImage[AType, Node.CheckState, not (vsDisabled in Node.States) and Enabled,
-      Node = FCurrentHotNode];
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetColumnClass: TVirtualTreeColumnClass;
-
-begin
-  Result := TVirtualTreeColumn;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetHeaderClass: TVTHeaderClass;
-
-begin
-  Result := TVTHeader;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetImageIndex(Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex;
-  var Ghosted: Boolean): Integer;
-
-begin
-  Result := -1;
-  Ghosted := False;
-  DoGetImageIndex(Node, Kind, Column, Ghosted, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetMaxRightExtend: Cardinal;
-
-// Determines the maximum with of the currently visible part of the tree, depending on the length
-// of the node texts. This method is used for determining the horizontal scroll range if no columns are used.
-
-var
-  Node,
-  NextNode: PVirtualNode;
-  TopPosition: Integer;
-  NodeLeft,
-  CurrentWidth: Integer;
-  WithCheck: Boolean;
-  CheckOffset: Integer;
-
-begin
-  Node := GetNodeAt(0, 0, True, TopPosition);
-  Result := 0;
-  if toShowRoot in FOptions.FPaintOptions then
-    NodeLeft := (GetNodeLevel(Node) + 1) * FIndent
-  else
-    NodeLeft := GetNodeLevel(Node) * FIndent;
-    
-  if Assigned(FStateImages) then
-    Inc(NodeLeft, FStateImages.Width + 2);
-  if Assigned(FImages) then
-    Inc(NodeLeft, FImages.Width + 2);
-  WithCheck := (toCheckSupport in FOptions.FMiscOptions) and Assigned(FCheckImages);
-  if WithCheck then
-    CheckOffset := FCheckImages.Width + 2
-  else
-    CheckOffset := 0;
-
-  while Assigned(Node) do
-  begin
-    if not (vsInitialized in Node.States) then
-      InitNode(Node);
-
-    if WithCheck and (Node.CheckType &lt;&gt; ctNone) then
-      Inc(NodeLeft, CheckOffset);
-    CurrentWidth := DoGetNodeWidth(Node, NoColumn);
-    if Integer(Result) &lt; (NodeLeft + CurrentWidth) then
-      Result := NodeLeft + CurrentWidth;
-    Inc(TopPosition, Node.NodeHeight);
-    if TopPosition &gt; Height then
-      Break;
-
-    if WithCheck and (Node.CheckType &lt;&gt; ctNone) then
-      Dec(NodeLeft, CheckOffset);
-
-    // Get next visible node and update left node position.
-    NextNode := GetNextVisible(Node);
-    if NextNode = nil then
-      Break;
-    Inc(NodeLeft, CountLevelDifference(Node, NextNode) * Integer(FIndent));
-    Node := NextNode;
-  end;
-
-  Inc(Result, 2 * FMargin);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.GetNativeClipboardFormats(var Formats: TFormatEtcArray);
-
-// Returns the supported clipboard formats of the tree.
-
-begin
-  InternalClipboardFormats.EnumerateFormats(TVirtualTreeClass(ClassType), Formats, FClipboardFormats);
-  // Ask application/descentants for self defined formats.
-  DoGetUserClipboardFormats(Formats);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetOptionsClass: TTreeOptionsClass;
-
-begin
-  Result := TCustomVirtualTreeOptions;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.GetTextInfo(Node: PVirtualNode; Column: TColumnIndex; const AFont: TFont; var R: TRect;
-  var Text: WideString);
-
-// Generic base method for editors, hint windows etc. to get some info about a node.
-
-begin
-  R := Rect(0, 0, 0, 0);
-  Text := '';
-  AFont.Assign(Font);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetTreeFromDataObject(const DataObject: IDataObject): TBaseVirtualTree;
-
-// Returns the owner/sender of the given data object by means of a special clipboard format
-// or nil if the sender is in another process or no virtual tree at all.
-
-var
-  Medium: TStgMedium;
-  Data: PVTReference;
-
-begin
-  Result := nil;
-  if Assigned(DataObject) then
-  begin
-    StandardOLEFormat.cfFormat := CF_VTREFERENCE;
-    if DataObject.GetData(StandardOLEFormat, Medium) = S_OK then
-    begin
-      Data := GlobalLock(Medium.hGlobal);
-      if Assigned(Data) then
-      begin
-        if Data.Process = GetCurrentProcessID then
-          Result := Data.Tree;
-        GlobalUnlock(Medium.hGlobal);
-      end;
-      ReleaseStgMedium(Medium);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.HandleHotTrack(X, Y: Integer);
-
-// Updates the current &quot;hot&quot; node.
-
-var
-  HitInfo: THitInfo;
-  DoInvalidate: Boolean;
-
-begin
-  // Get information about the hit.
-  GetHitTestInfoAt(X, Y, True, HitInfo);
-  // Only make the new node being &quot;hot&quot; if its label is hit or full row selection is enabled.
-  if ([hiOnItemLabel, hiOnItemCheckbox] * HitInfo.HitPositions = []) and
-    not (toFullRowSelect in FOptions.FSelectionOptions) then
-    HitInfo.HitNode := nil;
-  if HitInfo.HitNode &lt;&gt; FCurrentHotNode then
-  begin
-    DoInvalidate := (toHotTrack in FOptions.PaintOptions) or (toCheckSupport in FOptions.MiscOptions);
-    DoHotChange(FCurrentHotNode, HitInfo.HitNode);
-    if Assigned(FCurrentHotNode) and DoInvalidate then
-      InvalidateNode(FCurrentHotNode);
-    FCurrentHotNode := HitInfo.HitNode;
-    if Assigned(FCurrentHotNode) and DoInvalidate then
-      InvalidateNode(FCurrentHotNode);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.HandleIncrementalSearch(CharCode: Word);
-
-var
-  Run, Stop: PVirtualNode;
-  GetNextNode: TGetNextNodeProc;
-  NewSearchText: WideString;
-  SingleLetter,
-  PreviousSearch: Boolean; // True if VK_BACK was sent.
-  SearchDirection: TVTSearchDirection;
-
-  //--------------- local functions -------------------------------------------
-
-  procedure SetupNavigation;
-
-  // If the search buffer is empty then we start searching with the next node after the last one, otherwise
-  // we continue with the last one. Node navigation function is set up too here, to avoid frequent checks.
-
-  var
-    FindNextNode: Boolean;
-
-  begin
-    FindNextNode := (Length(FSearchBuffer) = 0) or (Run = nil) or SingleLetter or PreviousSearch;
-    case FIncrementalSearch of
-      isVisibleOnly:
-        if SearchDirection = sdForward then
-        begin
-          GetNextNode := GetNextVisible;
-          if FindNextNode then
-          begin
-            if Run = nil then
-              Run := GetFirstVisible
-            else
-            begin
-              Run := GetNextVisible(Run);
-              // Do wrap around.
-              if Run = nil then
-                Run := GetFirstVisible;
-            end;
-          end;
-        end
-        else
-        begin
-          GetNextNode := GetPreviousVisible;
-          if FindNextNode then
-          begin
-            if Run = nil then
-              Run := GetLastVisible
-            else
-            begin
-              Run := GetPreviousVisible(Run);
-              // Do wrap around.
-              if Run = nil then
-                Run := GetLastVisible;
-            end;
-          end;
-        end;
-      isInitializedOnly:
-        if SearchDirection = sdForward then
-        begin
-          GetNextNode := GetNextNoInit;
-          if FindNextNode then
-          begin
-            if Run = nil then
-              Run := GetFirstNoInit
-            else
-            begin
-              Run := GetNextNoInit(Run);
-              // Do wrap around.
-              if Run = nil then
-                Run := GetFirstNoInit;
-            end;
-          end;
-        end
-        else
-        begin
-          GetNextNode := GetPreviousNoInit;
-          if FindNextNode then
-          begin
-            if Run = nil then
-              Run := GetLastNoInit
-            else
-            begin
-              Run := GetPreviousNoInit(Run);
-              // Do wrap around.
-              if Run = nil then
-                Run := GetLastNoInit;
-            end;
-          end;
-        end;
-    else
-      // isAll
-      if SearchDirection = sdForward then
-      begin
-        GetNextNode := GetNext;
-        if FindNextNode then
-        begin
-          if Run = nil then
-            Run := GetFirst
-          else
-          begin
-            Run := GetNext(Run);
-            // Do wrap around.
-            if Run = nil then
-              Run := GetFirst;
-          end;
-        end;
-      end
-      else
-      begin
-        GetNextNode := GetPrevious;
-        if FindNextNode then
-        begin
-          if Run = nil then
-            Run := GetLast
-          else
-          begin
-            Run := GetPrevious(Run);
-            // Do wrap around.
-            if Run = nil then
-              Run := GetLast;
-          end;
-        end;
-      end;
-    end;
-  end;
-
-  //---------------------------------------------------------------------------
-
-  function CodePageFromLocale(Language: LCID): Integer;
-
-  // Determines the code page for a given locale.
-  // Unfortunately there is no easier way than this, currently.
-
-  var
-    Buf: array[0..6] of Char;
-
-  begin
-    GetLocaleInfo(Language, LOCALE_IDEFAULTANSICODEPAGE, Buf, 6);
-    Result := StrToIntDef(Buf, GetACP);
-  end;
-
-  //---------------------------------------------------------------------------
-
-  function KeyUnicode(C: Char): WideChar;
-
-  // Converts the given character into its corresponding Unicode character
-  // depending on the active keyboard layout.
-
-  begin
-    MultiByteToWideChar(CodePageFromLocale(GetKeyboardLayout(0) and $FFFF),
-      MB_USEGLYPHCHARS, @C, 1, @Result, 1);
-  end;
-
-  //--------------- end local functions ---------------------------------------
-
-var
-  FoundMatch: Boolean;
-  NewChar: WideChar;
-
-begin
-  StopTimer(SearchTimer);
-
-  if FIncrementalSearch &lt;&gt; isNone then
-  begin
-    if CharCode &lt;&gt; 0 then
-    begin
-      DoStateChange([tsIncrementalSearching]);
-
-      // Convert the given virtual key code into a Unicode character based on the current locale.
-      NewChar := KeyUnicode(Char(CharCode));
-      PreviousSearch := NewChar = WideChar(VK_BACK);
-      // We cannot do a search with an empty search buffer.
-      if not PreviousSearch or (Length(FSearchBuffer) &gt; 1) then
-      begin
-        // Determine which method to use to advance nodes and the start node to search from.
-        case FSearchStart of
-          ssAlwaysStartOver:
-            Run := nil;
-          ssFocusedNode:
-            Run := FFocusedNode;
-        else // ssLastHit
-          Run := FLastSearchNode;
-        end;
-
-        // Make sure the start node corresponds to the search criterion.
-        if Assigned(Run) then
-        begin
-          case FIncrementalSearch of
-            isInitializedOnly:
-              if not (vsInitialized in Run.States) then
-                Run := nil;
-            isVisibleOnly:
-              if not FullyVisible[Run] then
-                Run := nil;
-          end;
-        end;
-        Stop := Run;
-
-        // VK_BACK temporarily changes search direction to opposite mode.
-        if PreviousSearch then
-        begin
-          if SearchDirection = sdBackward then
-            SearchDirection := sdForward
-          else
-            SearchDirection := sdBackward
-        end
-        else
-          SearchDirection := FSearchDirection;
-        // The &quot;single letter mode&quot; is used to advance quickly from node to node when pressing the same key several times.
-        SingleLetter := (Length(FSearchBuffer) = 1) and not PreviousSearch and (FSearchBuffer[1] = NewChar);
-        SetupNavigation;
-        FoundMatch := False;
-
-        if Assigned(Run) then
-        begin
-          if SingleLetter then
-            NewSearchText := FSearchBuffer
-          else
-            if PreviousSearch then
-            begin
-              SetLength(FSearchBuffer, Length(FSearchBuffer) - 1);
-              NewSearchText := FSearchBuffer;
-            end
-            else
-              NewSearchText := FSearchBuffer + NewChar;
-            
-          repeat
-            if DoIncrementalSearch(Run, NewSearchText) = 0 then
-            begin
-              FoundMatch := True;
-              Break;
-            end;
-
-            // Advance to next node if we have not found a match.
-            Run := GetNextNode(Run);
-            // Do wrap around start or end of tree.
-            if (Run &lt;&gt; Stop) and (Run = nil) then
-              SetupNavigation;
-          until Run = Stop;
-        end;
-      
-        if FoundMatch then
-        begin
-          ClearSelection;
-          FSearchBuffer := NewSearchText;
-          FLastSearchNode := Run;
-          FocusedNode := Run;
-          Selected[Run] := True;
-          FLastSearchNode := Run;
-        end
-        else
-          // Play an acoustic signal if nothing could be found but don't beep if only the currently
-          // focused node matches.
-          if Assigned(Run) and (DoIncrementalSearch(Run, NewSearchText) &lt;&gt; 0) then
-            Beep;
-      end;
-    end;
-    
-    // Restart search timeout interval.
-    SetTimer(Handle, SearchTimer, FSearchTimeout, nil);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.HandleMouseDblClick(var Message: TWMMouse; const HitInfo: THitInfo);
-
-var
-  NewCheckState: TCheckState;
-
-begin
-  if tsEditPending in FStates then
-  begin
-    StopTimer(EditTimer);
-    DoStateChange([], [tsEditPending]);
-  end;
-
-  if not (tsEditing in FStates) or DoEndEdit then
-  begin
-    if HitInfo.HitColumn = FHeader.FColumns.FClickIndex then
-      DoColumnDblClick(HitInfo.HitColumn, KeysToShiftState(Message.Keys));
-
-    if hiOnItemCheckBox in HitInfo.HitPositions then
-    begin                                        
-      if (FStates * [tsMouseCheckPending, tsKeyCheckPending] = []) and not (vsDisabled in HitInfo.HitNode.States) then
-      begin
-        with HitInfo.HitNode^ do
-          NewCheckState := DetermineNextCheckState(CheckType, CheckState);
-        if DoChecking(HitInfo.HitNode, NewCheckState) then
-        begin
-          DoStateChange([tsMouseCheckPending]);
-          FCheckNode := HitInfo.HitNode;
-          FPendingCheckState := NewCheckState;
-          FCheckNode.CheckState := PressedState[FCheckNode.CheckState];
-          InvalidateNode(HitInfo.HitNode);
-        end;
-      end;
-    end
-    else
-    begin
-      if hiOnItemButton in HitInfo.HitPositions then
-        ToggleNode(HitInfo.HitNode)
-      else
-      begin
-        if toToggleOnDblClick in FOptions.FMiscOptions then
-        begin
-          if ((([hiOnItemButton, hiOnItemLabel, hiOnNormalIcon, hiOnStateIcon] * HitInfo.HitPositions) &lt;&gt; []) or
-            ((toFullRowSelect in FOptions.FSelectionOptions) and Assigned(HitInfo.HitNode))) then
-            ToggleNode(HitInfo.HitNode);
-        end;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.HandleMouseDown(var Message: TWMMouse; const HitInfo: THitInfo);
-
-// centralized mouse button down handling
-
-var
-  LastFocused: PVirtualNode;
-  Column: TColumnIndex;
-  ShiftState: TShiftState;
-
-  // helper variables to shorten boolean equations/expressions
-  AutoDrag,              // automatic (or allowed) drag start
-  IsHit,                 // the node's caption or images are hit
-  IsCellHit,             // for grid extension or full row select (but not check box, button)
-  IsAnyHit,              // either IsHit or IsCellHit
-  MultiSelect,           // multiselection is enabled
-  ShiftEmpty,            // ShiftState = []
-  NodeSelected: Boolean; // the new node (if any) is selected
-  NewColumn: Boolean;    // column changed
-  NeedChange: Boolean;   // change event is required for selection change
-  CanClear: Boolean;     
-  NewCheckState: TCheckState;
-
-begin
-  if [tsWheelPanning, tsWheelScrolling] * FStates &lt;&gt; [] then
-  begin
-    StopWheelPanning;
-    Exit;
-  end;
-
-  if tsEditPending in FStates then
-  begin
-    StopTimer(EditTimer);
-    DoStateChange([], [tsEditPending]);
-  end;
-
-  if not (tsEditing in FStates) or DoEndEdit then
-  begin
-    // Keep clicked column in case the application needs it.
-    FHeader.FColumns.FClickIndex := HitInfo.HitColumn;
-  
-    // Change column only if we have hit the node label.
-    if (hiOnItemLabel in HitInfo.HitPositions) or
-      (toFullRowSelect in FOptions.FSelectionOptions) or
-      (toGridExtensions in FOptions.FMiscOptions) then
-    begin
-      NewColumn := FFocusedColumn &lt;&gt; HitInfo.HitColumn;
-      if toExtendedFocus in FOptions.FSelectionOptions then
-        Column := HitInfo.HitColumn
-      else
-        Column := FHeader.MainColumn;
-    end
-    else
-    begin
-      NewColumn := False;
-      Column := FFocusedColumn;
-    end;
-
-    // Translate keys and filter out shift and control key.
-    ShiftState := KeysToShiftState(Message.Keys) * [ssShift, ssCtrl];
-
-    // Various combinations determine what states the tree enters now.
-    // We initialize shorthand variables to avoid the following expressions getting too large
-    // and to avoid repeative expensive checks.
-    IsHit := (hiOnItemLabel in HitInfo.HitPositions) or (hiOnNormalIcon in HitInfo.HitPositions);
-    IsCellHit := not IsHit and Assigned(HitInfo.HitNode) and
-      ([hiOnItemButton, hiOnItemCheckBox] * HitInfo.HitPositions = []) and
-      ((toFullRowSelect in FOptions.FSelectionOptions) or (toGridExtensions in FOptions.FMiscOptions)); 
-    IsAnyHit := IsHit or IsCellHit;
-    MultiSelect := toMultiSelect in FOptions.FSelectionOptions;
-    ShiftEmpty := ShiftState = [];
-    NodeSelected := IsAnyHit and (vsSelected in HitInfo.HitNode.States);
-
-    // Dragging might be started in the inherited handler manually (which is discouraged for stability reasons)
-    // the test for manual mode is done below (after the focused node is set).
-    AutoDrag := ((DragMode = dmAutomatic) or Dragging) and not IsCellHit;
-
-    // Query the application to learn if dragging may start now (if set to dmManual).
-    if Assigned(HitInfo.HitNode) and not AutoDrag and (DragMode = dmManual) then
-      AutoDrag := DoBeforeDrag(HitInfo.HitNode, Column) and not IsCellHit;
-
-    // handle button clicks
-    if (hiOnItemButton in HitInfo.HitPositions) and (vsHasChildren in HitInfo.HitNode.States) then
-    begin
-      ToggleNode(HitInfo.HitNode);
-      Exit;
-    end;
-
-    // check event
-    if hiOnItemCheckBox in HitInfo.HitPositions then
-    begin
-      if (FStates * [tsMouseCheckPending, tsKeyCheckPending] = []) and not (vsDisabled in HitInfo.HitNode.States) then
-      begin
-        with HitInfo.HitNode^ do
-          NewCheckState := DetermineNextCheckState(CheckType, CheckState);
-        if DoChecking(HitInfo.HitNode, NewCheckState) then
-        begin
-          DoStateChange([tsMouseCheckPending]);
-          FCheckNode := HitInfo.HitNode;
-          FPendingCheckState := NewCheckState;
-          FCheckNode.CheckState := PressedState[FCheckNode.CheckState];
-          InvalidateNode(HitInfo.HitNode);
-        end;
-      end;
-      Exit;
-    end;
-
-    // Keep this node's level in case we need it for constraint selection.
-    if (FRoot.ChildCount &gt; 0) and ShiftEmpty or (FSelectionCount = 0) then
-      if Assigned(HitInfo.HitNode) then
-        FLastSelectionLevel := GetNodeLevel(HitInfo.HitNode)
-      else
-        FLastSelectionLevel := GetNodeLevel(GetLastVisibleNoInit);
-
-    // pending clearance
-    if MultiSelect and ShiftEmpty and not (hiOnItemCheckbox in HitInfo.HitPositions) and
-       (IsHit and ShiftEmpty and AutoDrag and NodeSelected) then
-      DoStateChange([tsClearPending]);
-
-    // immediate clearance
-    // Determine for the right mouse button if there is a popup menu. In this case and if drag'n drop is pending
-    // the current selection has to stay as it is.
-    with HitInfo, Message do
-      CanClear := not AutoDrag and
-        (not (tsRightButtonDown in FStates) or not HasPopupMenu(HitNode, HitColumn, Point(XPos, YPos)));
-    if (not IsAnyHit and MultiSelect and ShiftEmpty) or
-      (IsAnyHit and (not NodeSelected or (NodeSelected and CanClear)) and (ShiftEmpty or not MultiSelect)) then
-    begin
-      Assert(not (tsClearPending in FStates), 'Pending and direct clearance are mutual exclusive!');
-      if NodeSelected then
-      begin
-        // If the currently hit node is (also) selected then we have to reselect it again but without
-        // a change event if it is the only selected node.
-        NeedChange := FSelectionCount &gt; 1;
-        InternalClearSelection;
-        InternalAddToSelection(HitInfo.HitNode, True);
-        if NeedChange then
-        begin
-          Invalidate;
-          Change(nil);
-        end;
-      end
-      else
-        ClearSelection;
-    end;
-
-    // pending node edit
-    if Focused and
-      ((hiOnItemLabel in HitInfo.HitPositions) or ((toGridExtensions in FOptions.FMiscOptions) and
-      (hiOnItem in HitInfo.HitPositions))) and NodeSelected and not NewColumn and ShiftEmpty then
-      DoStateChange([tsEditPending]);
-
-    // focus change
-    if not Focused and CanFocus then
-      SetFocus;
-
-    // User starts a selection with a selection rectangle.
-    if not (toDisableDrawSelection in FOptions.FSelectionOptions) and not IsHit and MultiSelect then
-    begin
-      SetCapture(Handle); 
-      DoStateChange([tsDrawSelPending]);
-      FDrawSelShiftState := ShiftState;
-      FNewSelRect := Rect(Message.XPos - FOffsetX, Message.YPos - FOffsetY, Message.XPos - FOffsetX,
-        Message.YPos - FOffsetY);
-      FLastSelRect := FNewSelRect;
-      if not IsCellHit then
-        Exit;
-    end;
-
-    // Keep current mouse position.
-    FLastClickPos := Point(Message.XPos, Message.YPos);
-
-    // Handle selection and node focus change.
-    if (IsHit or IsCellHit) and
-       DoFocusChanging(FFocusedNode, HitInfo.HitNode, FFocusedColumn, Column) then
-    begin
-      if NewColumn then
-      begin
-        InvalidateColumn(FFocusedColumn);
-        InvalidateColumn(Column);
-        FFocusedColumn := Column;
-      end;
-      if DragKind = dkDock then
-      begin
-        StopTimer(ScrollTimer);
-        DoStateChange([], [tsScrollPending, tsScrolling]);
-      end;
-      // Get the currently focused node to make multiple multi-selection blocks possible.
-      LastFocused := FFocusedNode;
-      DoFocusNode(HitInfo.HitNode, False);
-
-      if MultiSelect and not Dragging and not ShiftEmpty then
-        HandleClickSelection(LastFocused, HitInfo.HitNode, ShiftState)
-      else
-      begin
-        if ShiftEmpty then
-          FRangeAnchor := HitInfo.HitNode;
-
-        // If the hit node is not yet selected then do it now.
-        if not NodeSelected then
-          AddToSelection(HitInfo.HitNode);
-      end;
-
-      DoFocusChange(FFocusedNode, FFocusedColumn);
-
-      // Drag'n drop initiation
-      // If we lost focus in the interim the button states would be cleared in WM_KILLFOCUS.
-      if AutoDrag and (FStates * [tsLeftButtonDown, tsRightButtonDown, tsMiddleButtonDown] &lt;&gt; []) then
-        BeginDrag(False);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.HandleMouseUp(var Message: TWMMouse; const HitInfo: THitInfo);
-
-// Counterpart to the mouse down handler.
-
-var
-  ReselectFocusedNode: Boolean;
-
-begin
-  ReleaseCapture;
-  
-  if not (tsVCLDragPending in FStates) then
-  begin
-    // reset pending or persistent states
-    if IsMouseSelecting then
-    begin
-      DoStateChange([], [tsDrawSelecting, tsDrawSelPending]);
-      Invalidate;
-    end;
-
-    if tsClearPending in FStates then
-    begin
-      ReselectFocusedNode := Assigned(FFocusedNode) and (vsSelected in FFocusedNode.States);
-      ClearSelection;
-      if ReselectFocusedNode then
-        AddToSelection(FFocusedNode);
-    end;
-
-    if (tsClearFocusedSelection in FStates) and Assigned(HitInfo.HitNode) then
-    begin
-      if vsSelected in HitInfo.HitNode.States then
-        RemoveFromSelection(HitInfo.HitNode)
-      else
-        AddToSelection(HitInfo.HitNode);
-      InvalidateNode(HitInfo.HitNode);
-    end;
-
-    DoStateChange([], [tsOLEDragPending, tsOLEDragging, tsClearPending, tsDrawSelPending, tsScrollPending,
-      tsScrolling, tsClearFocusedSelection]);
-    StopTimer(ScrollTimer);
-
-    if tsMouseCheckPending in FStates then
-    begin
-      DoStateChange([], [tsMouseCheckPending]);
-      // Is the mouse still over the same node?
-      if (HitInfo.HitNode = FCheckNode) and (hiOnItem in HitInfo.HitPositions) then
-      begin
-        ChangeCheckState(FCheckNode, FPendingCheckState);
-        DoCheckClick(FCheckNode, FPendingCheckState);
-      end
-      else
-        FCheckNode.CheckState := UnpressedState[FCheckNode.CheckState];
-      InvalidateNode(FCheckNode);
-      FCheckNode := nil;
-    end;
-
-    if (FHeader.FColumns.FClickIndex &gt; NoColumn) and (FHeader.FColumns.FClickIndex = HitInfo.HitColumn) then
-      DoColumnClick(HitInfo.HitColumn, KeysToShiftState(Message.Keys));
-
-    // handle a pending edit event
-    if tsEditPending in FStates then
-    begin
-      // Is the mouse still over the same node?
-      if (HitInfo.HitNode = FFocusedNode) and (hiOnItem in HitInfo.HitPositions) and
-         CanEdit(FFocusedNode, HitInfo.HitColumn) then
-      begin
-        FEditColumn := FFocusedColumn;
-        SetTimer(Handle, EditTimer, FEditDelay, nil);
-      end
-      else
-        DoStateChange([], [tsEditPending]);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.HasPopupMenu(Node: PVirtualNode; Column: TColumnIndex; Pos: TPoint): Boolean;
-
-// Determines whether the tree got a popup menu, either in its PopupMenu property, via the OnGetPopupMenu event or
-// through inheritannce. The latter case must be checked by the descendant which must override this method.
- 
-begin
-  Result := Assigned(PopupMenu) or Assigned(DoGetPopupMenu(Node, Column, Pos));
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InitChildren(Node: PVirtualNode);
-
-// Initiates the initialization of the child number of the given node.
-
-var
-  Count: Cardinal;
-
-begin
-  if Assigned(Node) and (Node &lt;&gt; FRoot) and (vsHasChildren in Node.States) then
-  begin
-    Count := Node.ChildCount; 
-    DoInitChildren(Node, Count);
-    if Count = 0 then
-    begin
-      // Remove any child node which is already there.
-      DeleteChildren(Node);
-      Exclude(Node.States, vsHasChildren);
-    end
-    else
-      SetChildCount(Node, Count);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InitNode(Node: PVirtualNode);
-
-// Initiates the initialization of the given node to allow the application to load needed data for it.
-
-var
-  InitStates: TVirtualNodeInitStates;
-
-begin
-  with Node^ do
-  begin
-    InitStates := [];
-    if Parent = FRoot then
-      DoInitNode(nil, Node, InitStates)
-    else
-      DoInitNode(Parent, Node, InitStates);
-    Include(States, vsInitialized);
-    if ivsDisabled in InitStates then
-      Include(States, vsDisabled);
-    if ivsHasChildren in InitStates then
-      Include(States, vsHasChildren);
-    if ivsSelected in InitStates then
-    begin
-      FSingletonNodeArray[0] := Node;
-      InternalAddToSelection(FSingletonNodeArray, 1, False);
-    end;
-    if ivsMultiline in InitStates then
-      Include(States, vsMultiline);
-
-    // Expanded may already be set (when called from ReinitNode) or be set in DoInitNode, allow both.
-    if (vsExpanded in Node.States) xor (ivsExpanded in InitStates) then
-    begin
-      // Expand node if not yet done (this will automatically initialize child nodes).
-      if ivsExpanded in InitStates then
-        ToggleNode(Node)
-      else
-        // If the node already was expanded then explicitly trigger child initialization.
-        if vsHasChildren in Node.States then
-          InitChildren(Node);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InternalAddFromStream(Stream: TStream; Version: Integer; Node: PVirtualNode);
-
-// Loads nodes from the given stream and adds them as children to Node.
-// Because the new nodes might be selected this method also fixes the selection array.
-
-var
-  Stop: PVirtualNode;
-  LastVisibleCount: Cardinal;
-  Index: Integer;
-
-begin
-  if Node = nil then
-    Node := FRoot;
-
-  // Read in the new nodes, keep number of visible nodes for a correction.
-  LastVisibleCount := FVisibleCount;
-  ReadNode(Stream, Version, Node);
-
-  // I need to fix the visible count here because of the hierarchical load procedure.
-  if (Node = FRoot) or ([vsExpanded, vsVisible] * Node.Parent.States = [vsExpanded, vsVisible]) then
-    FVisibleCount := LastVisibleCount + CountVisibleChildren(Node)
-  else
-    FVisibleCount := LastVisibleCount;
-
-  // Fix selection array.
-  ClearTempCache;
-  if Node = FRoot then
-    Stop := nil
-  else
-    Stop := Node.NextSibling;
-
-  if toMultiSelect in FOptions.FSelectionOptions then
-  begin
-    // Add all nodes which were selected before to the current selection (unless they are already there).
-    while Node &lt;&gt; Stop do
-    begin
-      if (vsSelected in Node.States) and not FindNodeInSelection(Node, Index, 0, High(FSelection)) then
-        InternalCacheNode(Node);
-      Node := GetNextNoInit(Node);
-    end;
-    if FTempNodeCount &gt; 0 then
-      AddToSelection(FTempNodeCache, FTempNodeCount, True);
-    ClearTempCache;
-  end
-  else // No further selected nodes allowed so delete the corresponding flag in all new nodes.
-    while Node &lt;&gt; Stop do
-    begin
-      Exclude(Node.States, vsSelected);
-      Node := GetNextNoInit(Node);
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.InternalAddToSelection(Node: PVirtualNode; ForceInsert: Boolean): Boolean;
-
-begin
-  Assert(Assigned(Node), 'Node must not be nil!');
-  FSingletonNodeArray[0] := Node;
-  Result := InternalAddToSelection(FSingletonNodeArray, 1, ForceInsert);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.InternalAddToSelection(const NewItems: TNodeArray; NewLength: Integer;
-  ForceInsert: Boolean): Boolean;
-
-// Internal version of method AddToSelection which does not trigger OnChange events
-
-var
-  I, J: Integer;
-  CurrentEnd: Integer;
-  Constrained,
-  SiblingConstrained: Boolean;
-
-begin
-  // The idea behind this code is to use a kind of reverse merge sort. QuickSort is quite fast
-  // and would do the job here too but has a serious problem with already sorted lists like FSelection.
-
-  // 1) Remove already selected items, mark all other as being selected.
-  if ForceInsert then
-  begin
-    for I := 0 to NewLength - 1 do
-      Include(NewItems[I].States, vsSelected);
-  end
-  else
-  begin
-    Constrained := toLevelSelectConstraint in FOptions.FSelectionOptions;
-    if Constrained and (FLastSelectionLevel = -1) then
-      FLastSelectionLevel := GetNodeLevel(NewItems[0]);
-    SiblingConstrained := toSiblingSelectConstraint in FOptions.FSelectionOptions;
-    if SiblingConstrained and (FRangeAnchor = nil) then
-      FRangeAnchor := NewItems[0];
-
-    for I := 0 to NewLength - 1 do
-      if ([vsSelected, vsDisabled] * NewItems[I].States &lt;&gt; []) or
-         (Constrained and (Cardinal(FLastSelectionLevel) &lt;&gt; GetNodeLevel(NewItems[I]))) or
-         (SiblingConstrained and (FRangeAnchor.Parent &lt;&gt; NewItems[I].Parent)) then
-        Inc(Cardinal(NewItems[I]))
-      else
-        Include(NewItems[I].States, vsSelected);
-  end;
-  
-  I := PackArray(NewItems, NewLength);
-  if I &gt; -1 then
-    NewLength := I;
-
-  Result := NewLength &gt; 0;
-  if Result then
-  begin
-    // 2) Sort the new item list so we can easily traverse it.
-    if NewLength &gt; 1 then
-      QuickSort(NewItems, 0, NewLength - 1);
-    // 3) Make room in FSelection for the new items.
-    if FSelectionCount + NewLength &gt;= Length(FSelection) then
-      SetLength(FSelection, FSelectionCount + NewLength);
-
-    // 4) Merge in new items
-    J := NewLength - 1;
-    CurrentEnd := FSelectionCount - 1;
-
-    while J &gt;= 0 do
-    begin
-      // First insert all new entries which are greater than the greatest entry in the old list.
-      // If the current end marker is &lt; 0 then there's nothing more to move in the selection
-      // array and only the remaining new items must be inserted.
-      if CurrentEnd &gt;= 0 then
-      begin
-        while (J &gt;= 0) and (Cardinal(NewItems[J]) &gt; Cardinal(FSelection[CurrentEnd])) do
-        begin
-          FSelection[CurrentEnd + J + 1] := NewItems[J];
-          Dec(J);
-        end;
-        // early out if nothing more needs to be copied
-        if J &lt; 0 then
-          Break;
-      end
-      else
-      begin
-        // insert remaining new entries at position 0
-        Move(NewItems[0], FSelection[0], (J + 1) * SizeOf(Pointer));
-        // nothing more to do so exit main loop
-        Break;
-      end;
-
-      // find the last entry in the remaining selection list which is smaller then the largest
-      // entry in the remaining new items list
-      FindNodeInSelection(NewItems[J], I, 0, CurrentEnd);
-      Dec(I);
-      // move all entries which are greater than the greatest entry in the new items list up
-      // so the remaining gap travels down to where new items must be inserted
-      Move(FSelection[I + 1], FSelection[I + J + 2], (CurrentEnd - I) * SizeOf(Pointer));
-      CurrentEnd := I;
-    end;
-
-    Inc(FSelectionCount, NewLength);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InternalCacheNode(Node: PVirtualNode);
-
-// Adds the given node to the temporary node cache (used when collecting possibly large amounts of nodes).
-
-var
-  Len: Cardinal;
-
-begin
-  Len := Length(FTempNodeCache);
-  if FTempNodeCount = Len then
-  begin
-    if Len &lt; 100 then
-      Len := 100
-    else
-      Len := Len + Len div 10;
-    SetLength(FTempNodeCache, Len);
-  end;
-  FTempNodeCache[FTempNodeCount] := Node;
-  Inc(FTempNodeCount);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InternalClearSelection;
-
-var
-  Count: Integer;
-
-begin
-  // It is possible that there are invalid node references in the selection array
-  // if the tree update is locked and changes in the structure were made.
-  // Handle this potentially dangerous situation by packing the selection array explicitely.
-  if FUpdateCount &gt; 0 then
-  begin
-    Count := PackArray(FSelection, FSelectionCount);
-    if Count &gt; -1 then
-    begin
-      FSelectionCount := Count;
-      SetLength(FSelection, FSelectionCount);
-    end;
-  end;
-
-  while FSelectionCount &gt; 0 do
-  begin
-    Dec(FSelectionCount);
-    Exclude(FSelection[FSelectionCount].States, vsSelected);
-  end;
-  ResetRangeAnchor;
-  FSelection := nil;
-  DoStateChange([], [tsClearPending]);
-end;                                         
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InternalConnectNode(Node, Destination: PVirtualNode; Target: TBaseVirtualTree;
-  Mode: TVTNodeAttachMode);
-
-// Connects Node with Destination depending on Mode.
-// No error checking takes place. Node as well as Destination must be valid. Node must never be a root node and
-// Destination must not be a root node if Mode is amInsertBefore or amInsertAfter.
-
-var
-  Run: PVirtualNode;
-
-begin
-  // Keep in mind that the destination node might belong to another tree.
-  with Target do
-  begin
-    case Mode of
-      amInsertBefore:
-        begin
-          Node.PrevSibling := Destination.PrevSibling;
-          Destination.PrevSibling := Node;
-          Node.NextSibling := Destination;
-          Node.Parent := Destination.Parent;
-          Node.Index := Destination.Index;
-          if Node.PrevSibling = nil then
-            Node.Parent.FirstChild := Node
-          else
-            Node.PrevSibling.NextSibling := Node;
-
-          // reindex all following nodes
-          Run := Destination;
-          while Assigned(Run) do
-          begin
-            Inc(Run.Index);
-            Run := Run.NextSibling;
-          end;
-
-          Inc(Destination.Parent.ChildCount);
-          Include(Destination.Parent.States, vsHasChildren);
-          AdjustTotalCount(Destination.Parent, Node.TotalCount, True);
-
-          // Add the new node's height only if its parent is expanded.
-          if vsExpanded in Destination.Parent.States then
-            AdjustTotalHeight(Destination.Parent, Node.TotalHeight, True);
-          if FullyVisible[Node] then
-            Inc(FVisibleCount, CountVisibleChildren(Node) + 1);
-        end;
-      amInsertAfter:
-        begin
-          Node.NextSibling := Destination.NextSibling;
-          Destination.NextSibling := Node;
-          Node.PrevSibling := Destination;
-          Node.Parent := Destination.Parent;
-          if Node.NextSibling = nil then
-            Node.Parent.LastChild := Node
-          else
-            Node.NextSibling.PrevSibling := Node;
-          Node.Index := Destination.Index;
-
-          // reindex all following nodes
-          Run := Node;
-          while Assigned(Run) do
-          begin
-            Inc(Run.Index);
-            Run := Run.NextSibling;
-          end;
-
-          Inc(Destination.Parent.ChildCount);
-          Include(Destination.Parent.States, vsHasChildren);
-          AdjustTotalCount(Destination.Parent, Node.TotalCount, True);
-          // Add the new node's height only if its parent is expanded.
-          if vsExpanded in Destination.Parent.States then
-            AdjustTotalHeight(Destination.Parent, Node.TotalHeight, True);
-          if FullyVisible[Node] then
-            Inc(FVisibleCount, CountVisibleChildren(Node) + 1);
-        end;
-      amAddChildFirst:
-        begin
-          if Assigned(Destination.FirstChild) then
-          begin
-            // If there's a first child then there must also be a last child.
-            Destination.FirstChild.PrevSibling := Node;
-            Node.NextSibling := Destination.FirstChild;
-            Destination.FirstChild := Node;
-          end
-          else
-          begin
-            // First child node at this location.
-            Destination.FirstChild := Node;
-            Destination.LastChild := Node;
-            Node.NextSibling := nil;
-          end;
-          Node.PrevSibling := nil;
-          Node.Parent := Destination;
-          Node.Index := 0;
-          // reindex all following nodes
-          Run := Node.NextSibling;
-          while Assigned(Run) do
-          begin
-            Inc(Run.Index);
-            Run := Run.NextSibling;
-          end;
-
-          Inc(Destination.ChildCount);
-          Include(Destination.States, vsHasChildren);
-          AdjustTotalCount(Destination, Node.TotalCount, True);
-          // add the new node's height only if its parent is expanded (visibility is handled elsewhere)
-          if vsExpanded in Destination.States then
-            AdjustTotalHeight(Destination, Node.TotalHeight, True);
-          if FullyVisible[Node] then
-            Inc(FVisibleCount, CountVisibleChildren(Node) + 1);
-        end;
-      amAddChildLast:
-        begin
-          if Assigned(Destination.LastChild) then
-          begin
-            // If there's a last child then there must also be a first child.
-            Destination.LastChild.NextSibling := Node;
-            Node.PrevSibling := Destination.LastChild;
-            Destination.LastChild := Node;
-          end
-          else
-          begin
-            // first child node at this location
-            Destination.FirstChild := Node;
-            Destination.LastChild := Node;
-            Node.PrevSibling := nil;
-          end;
-          Node.NextSibling := nil;
-          Node.Parent := Destination;
-          if Assigned(Node.PrevSibling) then
-            Node.Index := Node.PrevSibling.Index + 1
-          else
-            Node.Index := 0;
-          Inc(Destination.ChildCount);
-          Include(Destination.States, vsHasChildren);
-          AdjustTotalCount(Destination, Node.TotalCount, True);
-          // Add the new node's height only if its parent is expanded (visibility is handled elsewhere).
-          if vsExpanded in Destination.States then
-            AdjustTotalHeight(Destination, Node.TotalHeight, True);
-          if FullyVisible[Node] then
-            Inc(FVisibleCount, CountVisibleChildren(Node) + 1);
-        end;
-    else
-      // amNoWhere: do nothing
-    end;
-
-    // Update the hidden children flag of the parent.
-    if (Mode &lt;&gt; amNoWhere) and (Node.Parent &lt;&gt; FRoot) then
-    begin
-      // If we have added a visible node then simply remove the all-children-hidden flag.
-      if vsVisible in Node.States then
-        Exclude(Node.Parent.States, vsAllChildrenHidden)
-      else
-        // If we have added an invisible node and this is the only child node then
-        // make sure the all-children-hidden flag is in a determined state.
-        // If there were child nodes before then no action is needed.
-        if Node.Parent.ChildCount = 1 then
-          Include(Node.Parent.States, vsAllChildrenHidden);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.InternalData(Node: PVirtualNode): Pointer;
-
-begin
-  Result := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InternalDisconnectNode(Node: PVirtualNode; KeepFocus: Boolean; Reindex: Boolean = True);
-
-// Disconnects the given node from its parent and siblings. The node's pointer are not reset so they can still be used
-// after return from this method (probably a very short time only!).
-// If KeepFocus is True then the focused node is not reset. This is useful if the given node is reconnected to the tree
-// immediately after return of this method and should stay being the focused node if it was it before.
-// Note: Node must not be nil or the root node.
-
-var
-  Parent,
-  Run: PVirtualNode;
-  Index: Integer;
-
-begin
-  Assert(Assigned(Node) and (Node &lt;&gt; FRoot), 'Node must neither be nil nor the root node.');
-
-  if (Node = FFocusedNode) and not KeepFocus then
-  begin
-    DoFocusNode(nil, False);
-    DoFocusChange(FFocusedNode, FFocusedColumn);
-  end;
-
-  if Node = FRangeAnchor then
-    ResetRangeAnchor;
-
-  // Update the hidden children flag of the parent.
-  if (Node.Parent &lt;&gt; FRoot) and not (vsClearing in Node.Parent.States) then
-    DetermineHiddenChildrenFlag(Node.Parent);
-
-  if not (vsDeleting in Node.States) then
-  begin
-    // Some states are only temporary so take them out.
-    Node.States := Node.States - [vsChecking];
-    Parent := Node.Parent;
-    Dec(Parent.ChildCount);
-    if Parent.ChildCount = 0 then
-      Exclude(Parent.States, vsHasChildren);
-    AdjustTotalCount(Parent, -Integer(Node.TotalCount), True);
-    if vsExpanded in Parent.States then
-      AdjustTotalHeight(Parent, -Integer(Node.TotalHeight), True);
-    if FullyVisible[Node] then
-      Dec(FVisibleCount, CountVisibleChildren(Node) + 1);
-    if Assigned(Node.PrevSibling) then
-      Node.PrevSibling.NextSibling := Node.NextSibling
-    else
-      Parent.FirstChild := Node.NextSibling;
-
-    if Assigned(Node.NextSibling) then
-    begin
-      Node.NextSibling.PrevSibling := Node.PrevSibling;
-      // Reindex all following nodes.
-      if Reindex then
-      begin
-        Run := Node.NextSibling;
-        Index := Node.Index;
-        while Assigned(Run) do
-        begin
-          Run.Index := Index;
-          Inc(Index);
-          Run := Run.NextSibling;
-        end;
-      end;
-    end
-    else
-      Parent.LastChild := Node.PrevSibling;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InternalRemoveFromSelection(Node: PVirtualNode);
-
-// Special version to mark a node to be no longer in the current selection. PackArray must
-// be used to remove finally those entries.
-
-var
-  Index: Integer;
-
-begin
-  // Because pointers are always DWORD aligned we can simply increment all those
-  // which we want to have removed (see also PackArray) and still have the
-  // order in the list preserved.
-  if FindNodeInSelection(Node, Index, -1, -1) then
-  begin
-    Exclude(Node.States, vsSelected);
-    Inc(Cardinal(FSelection[Index]));
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InvalidateCache;
-
-// Marks the cache as invalid.
-
-begin
-  DoStateChange([tsValidationNeeded], [tsUseCache]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.MarkCutCopyNodes;
-
-// Sets the vsCutOrCopy style in every currently selected but not disabled node to indicate it is
-// now part of a clipboard operation.
-
-var
-  Nodes: TNodeArray;
-  I: Integer;
-
-begin
-  Nodes := nil;
-  if FSelectionCount &gt; 0 then
-  begin
-    // need the current selection sorted to exclude selected nodes which are children, grandchildren etc. of
-    // already selected nodes 
-    Nodes := GetSortedSelection(False);
-    for I := 0 to High(Nodes) do
-      with Nodes[I]^ do
-        if not (vsDisabled in States) then
-          Include(States, vsCutOrCopy);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.Loaded;
-
-var
-  LastRootCount: Cardinal;
-  IsReadOnly: Boolean;
-
-begin
-  inherited;
-
-  // If a root node count has been set during load of the tree then update its child structure now
-  // as this hasn't been done yet in this case.
-  if (tsNeedRootCountUpdate in FStates) and (FRoot.ChildCount &gt; 0) then
-  begin
-    DoStateChange([], [tsNeedRootCountUpdate]);
-    IsReadOnly := toReadOnly in FOptions.FMiscOptions;
-    Exclude(FOptions.FMiscOptions, toReadOnly);
-    LastRootCount := FRoot.ChildCount;
-    FRoot.ChildCount := 0;
-    BeginUpdate;
-    SetChildCount(FRoot, LastRootCount);
-    EndUpdate;
-    if IsReadOnly then
-      Include(FOptions.FMiscOptions, toReadOnly);
-  end;
-
-  // Prevent the object inspector at design time from marking the header as being modified
-  // when auto resize is enabled.
-  Updating;
-  try
-    FHeader.UpdateMainColumn;
-    FHeader.FColumns.FixPositions;
-    FHeader.RecalculateHeader;
-    if hoAutoResize in FHeader.FOptions then
-      FHeader.FColumns.AdjustAutoSize(InvalidColumn, True);
-  finally
-    Updated;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.MainColumnChanged;
-
-begin
-  DoCancelEdit;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.MouseMove(Shift: TShiftState; X, Y: Integer);
-
-var
-  R: TRect;
-  
-begin
-  // Remove current selection in case the user clicked somewhere in the window (but not a node)
-  // and moved the mouse.
-  if tsDrawSelPending in FStates then
-  begin
-    if CalculateSelectionRect(X, Y) then
-    begin
-      InvalidateRect(Handle, @FNewSelRect, False);
-      UpdateWindow(Handle);
-      if (Abs(FNewSelRect.Right - FNewSelRect.Left) &gt; Mouse.DragThreshold) or
-         (Abs(FNewSelRect.Bottom - FNewSelRect.Top) &gt; Mouse.DragThreshold) then
-      begin
-        if tsClearPending in FStates then
-        begin
-          DoStateChange([], [tsClearPending]);
-          ClearSelection;
-        end;
-        DoStateChange([tsDrawSelecting], [tsDrawSelPending]);
-        // reset to main column for multiselection
-        FocusedColumn := FHeader.MainColumn;
-
-        // The current rectangle may already include some node captions. Handle this.
-        if HandleDrawSelection(X, Y) then
-          InvalidateRect(Handle, nil, False);
-      end;
-    end;
-  end
-  else
-  begin
-    // If both wheel panning and auto scrolling are pending then the user moved the mouse while holding down the
-    // middle mouse button. This means panning is being used, hence remove the autoscroll flag.
-    if [tsWheelPanning, tsWheelScrolling] * FStates = [tsWheelPanning, tsWheelScrolling] then
-    begin
-      if ((Abs(FLastClickPos.X - X) &gt;= Mouse.DragThreshold) or (Abs(FLastClickPos.Y - Y) &gt;= Mouse.DragThreshold)) then
-        DoStateChange([], [tsWheelScrolling]);
-    end;
-
-    // Really start dragging if the mouse has been moved more than the threshold.
-    if (tsOLEDragPending in FStates) and ((Abs(FLastClickPos.X - X) &gt;= FDragThreshold) or
-       (Abs(FLastClickPos.Y - Y) &gt;= FDragThreshold)) then
-      DoDragging(FLastClickPos)
-    else
-    begin 
-      if CanAutoScroll then
-        DoAutoScroll(X, Y);
-      if [tsWheelPanning, tsWheelScrolling] * FStates &lt;&gt; [] then
-        AdjustPanningCursor(X, Y);
-      if not IsMouseSelecting then
-      begin
-        HandleHotTrack(X, Y);
-        inherited MouseMove(Shift, X, Y);
-      end
-      else
-      begin
-        // Handle draw selection if required, but don't do the work twice if the
-        // auto scrolling code already cares about the selection. 
-        if not (tsScrolling in FStates) and CalculateSelectionRect(X, Y) then
-        begin 
-          // If something in the selection changed then invalidate the entire
-          // tree instead trying to figure out the display rects of all changed nodes.
-          if HandleDrawSelection(X, Y) then
-            InvalidateRect(Handle, nil, False)
-          else
-          begin
-            UnionRect(R, OrderRect(FNewSelRect), OrderRect(FLastSelRect));
-            OffsetRect(R, FOffsetX, FOffsetY);
-            InvalidateRect(Handle, @R, False);
-          end;
-          UpdateWindow(Handle);
-        end;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.Notification(AComponent: TComponent; Operation: TOperation);
-
-begin
-  if (AComponent &lt;&gt; Self) and (Operation = opRemove) then
-  begin
-    // Check for components linked to the tree.
-    if AComponent = FImages then
-    begin
-      Images := nil;
-      if not (csDestroying in ComponentState) then
-        Invalidate;
-    end
-    else
-      if AComponent = FStateImages then
-      begin
-        StateImages := nil;
-        if not (csDestroying in ComponentState) then
-          Invalidate;
-      end
-      else
-        if AComponent = FCustomCheckImages then
-        begin
-          CustomCheckImages := nil;
-          FCheckImageKind := ckLightCheck;
-          if not (csDestroying in ComponentState) then
-            Invalidate;
-        end
-        else
-          if AComponent = PopupMenu then
-            PopupMenu := nil
-          else
-            // Check for components linked to the header.
-            if AComponent = FHeader.FImages then
-              FHeader.Images := nil
-            else
-              if AComponent = FHeader.PopupMenu then
-                FHeader.PopupMenu := nil;
-  end;
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.Paint;
-
-// Window paint routine. Used when the tree window needs to be updated.
-
-var
-  Window: TRect;
-  Target: TPoint;
-
-begin
-  // The update rect has already been filled in WMPaint, as it is the window's update rect, which gets
-  // reset when BeginPaint is called (in the ancestor).
-  // The difference to the DC's clipbox is that it is also valid with internal paint operations used
-  // e.g. by the Explorer while dragging, but show window content while dragging is disabled.
-  if not IsRectEmpty(FUpdateRect) then
-  begin
-    Window := FUpdateRect;
-    Target := Window.TopLeft;
-
-    // The clipping rectangle is given in client coordinates of the window. We have to convert it into
-    // a sliding window of the tree image.
-    OffsetRect(Window, -FOffsetX, -FOffsetY);
-    PaintTree(Canvas, Window, Target, [poBackground, poColumnColor, poDrawFocusRect, poDrawDropMark, poDrawSelection,
-      poGridLines]);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.PaintCheckImage(const PaintInfo: TVTPaintInfo);
-
-var
-  ForegroundColor: COLORREF;
-  {$ifdef ThemeSupport}
-    R: TRect;
-    Details: TThemedElementDetails;
-  {$endif ThemeSupport}
-
-begin
-  with PaintInfo, ImageInfo[iiCheck] do
-  begin
-    {$ifdef ThemeSupport}
-      if (tsUseThemes in FStates) and (FCheckImageKind &lt;&gt; ckCustom) then
-      begin
-        R := Rect(XPos - 1, YPos, XPos + 16, YPos + 16);
-        Details.Element := teButton;
-        case Index of
-          0..8: // radio buttons
-            begin
-              Details.Part := BP_RADIOBUTTON;
-              Details.State := Index;
-            end;
-          9..20: // check boxes
-            begin
-              Details.Part := BP_CHECKBOX;
-              Details.State := Index - 8;
-            end;
-          21..24: // buttons
-            begin
-              Details.Part := BP_PUSHBUTTON;
-              Details.State := Index - 20;
-            end;
-        else
-          Details.Part := 0;
-          Details.State := 0;
-        end;
-        ThemeServices.DrawElement(Canvas.Handle, Details, R);
-        if Index in [21..24] then
-          UtilityImages.Draw(Canvas, XPos - 1, YPos, 4);
-      end
-      else
-    {$endif ThemeSupport}
-      with FCheckImages do
-      begin
-        if (vsSelected in Node.States) and not Ghosted then
-        begin
-          if Focused or (toPopupMode in FOptions.FPaintOptions) then
-            ForegroundColor := ColorToRGB(FColors.FocusedSelectionColor)
-          else
-            ForegroundColor := ColorToRGB(FColors.UnfocusedSelectionColor);
-        end
-        else
-          ForegroundColor := GetRGBColor(BlendColor);
-
-          ImageList_DrawEx(Handle, Index, Canvas.Handle, XPos, YPos, 0, 0, GetRGBColor(BkColor), ForegroundColor,
-            ILD_TRANSPARENT);
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.PaintImage(const PaintInfo: TVTPaintInfo; ImageInfoIndex: TVTImageInfoIndex;
-  Images: TCustomImageList; DoOverlay: Boolean);
-
-const
-  Style: array[TImageType] of Cardinal = (0, ILD_MASK);
-
-var
-  OverlayImage: Integer;
-  OverlayGhosted: Boolean;
-  ExtraStyle: Cardinal;
-  ForegroundColor: COLORREF;
-  CutNode: Boolean;
-  PaintFocused: Boolean;
-
-begin
-  with PaintInfo, ImageInfo[ImageInfoIndex], Images do
-  begin
-    CutNode := (vsCutOrCopy in Node.States) and (tsCutPending in FStates);
-    PaintFocused := Focused or (toGhostedIfUnfocused in FOptions.FPaintOptions);
-    
-    if (vsSelected in Node.States) and not (Ghosted or CutNode) then
-    begin
-      if PaintFocused or (toPopupMode in FOptions.FPaintOptions) then
-        ForegroundColor := ColorToRGB(FColors.FocusedSelectionColor)
-      else
-        ForegroundColor := ColorToRGB(FColors.UnfocusedSelectionColor);
-    end
-    else
-      ForegroundColor := GetRGBColor(Color);
-
-    // Since the overlay image must be specified together with the image to draw
-    // it is meaningfull to retrieve it in advance.
-    if DoOverlay then
-      OverlayImage := GetImageIndex(PaintInfo.Node, ikOverlay, PaintInfo.Column, OverlayGhosted)
-    else
-      OverlayImage := -1;
-    if (vsDisabled in Node.States) or not Enabled then
-    begin
-      // The internal handling for disabled images in TImageList destroys the forground color on Windows API level.
-      // Hence the canvas does not recognize the change and we have to restore the color manually.
-      ForegroundColor := ColorToRGB(Canvas.Font.Color);
-
-      // If the tree or the current node is disabled then let the VCL draw the image as it already
-      // contains code to convert the image to the system colors.
-      if OverlayImage &gt; -1 then
-        Images.DrawOverlay(Canvas, XPos, YPos, Index, OverlayImage, False)
-      else
-        Images.Draw(Canvas, XPos, YPos, Index, False);
-
-      SetTextColor(Canvas.Handle, ForegroundColor);
-    end
-    else
-    begin
-      if OverlayImage &gt; -1 then
-        ExtraStyle := ILD_TRANSPARENT or ILD_OVERLAYMASK and IndexToOverlayMask(OverlayImage + 1)
-      else
-        ExtraStyle := ILD_TRANSPARENT;
-
-      // Blend image if enabled and the tree has the focus (or ghosted images must be drawn also if unfocused) ...
-      if (toUseBlendedImages in FOptions.FPaintOptions) and PaintFocused
-        // ... and the image is ghosted...
-        and (Ghosted or
-        // ... or it is not the check image and the node is selected (but selection is not for the entire row)...
-        ((vsSelected in Node.States) and
-        not (toFullRowSelect in FOptions.FSelectionOptions) and
-        not (toGridExtensions in FOptions.FMiscOptions)) or
-        // ... or the node must be shown in cut mode.
-        CutNode) then
-        ExtraStyle := ExtraStyle or ILD_BLEND50;
-
-      ImageList_DrawEx(Handle, Index, Canvas.Handle, XPos, YPos, 0, 0, GetRGBColor(BkColor), ForegroundColor,
-        Style[ImageType] or ExtraStyle);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.PaintNodeButton(Canvas: TCanvas; Node: PVirtualNode; const R: TRect; ButtonX,
-  ButtonY: Integer; BidiMode: TBiDiMode);
-
-var
-  Bitmap: TBitmap;
-  XPos: Integer;
-
-begin
-  if vsExpanded in Node.States then
-    Bitmap := FMinusBM
-  else
-    Bitmap := FPlusBM;
-
-  // Draw the node's plus/minus button according to the directionality.
-  if BidiMode = bdLeftToRight then
-    XPos := R.Left + ButtonX
-  else
-    XPos := R.Right - ButtonX - Bitmap.Width;
-
-  // Need to draw this masked.
-  Canvas.Draw(XPos, R.Top + ButtonY, Bitmap);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.PaintTreeLines(const PaintInfo: TVTPaintInfo; VAlignment, IndentSize: Integer;
-  LineImage: TLineImage);
-
-var
-  I: Integer;
-  XPos,
-  Offset: Integer;
-  NewStyles: TLineImage;
-
-begin
-  NewStyles := nil;
-   
-  with PaintInfo do
-  begin
-    if BidiMode = bdLeftToRight then
-    begin
-      XPos := CellRect.Left;
-      Offset := FIndent;
-    end
-    else
-    begin
-      Offset := -Integer(FIndent);
-      XPos := CellRect.Right + Offset;
-    end;
-
-    case FLineMode of
-      lmBands:
-        if poGridLines in PaintInfo.PaintOptions then
-        begin
-          // Convert the line images in correct bands.
-          SetLength(NewStyles, Length(LineImage));
-          for I := IndentSize - 1 downto 0 do
-          begin
-            if vsExpanded in Node.States then
-              NewStyles[I] := ltLeft
-            else
-              case LineImage[I] of
-                ltRight,
-                ltBottomRight,
-                ltTopDownRight,
-                ltTopRight:
-                  NewStyles[I] := ltLeftBottom;
-                ltNone:
-                  // Have to take over the image to the right of this one. A no line entry can never appear as
-                  // last entry so I don't need an end check here.
-                  if LineImage[I + 1] in [ltNone, ltTopRight] then
-                    NewStyles[I] := NewStyles[I + 1]
-                  else
-                    NewStyles[I] := ltLeft;
-                ltTopDown:
-                  // Have to check the image to the right of this one. A top down line can never appear as
-                  // last entry so I don't need an end check here.
-                  if LineImage[I + 1] in [ltNone, ltTopRight] then
-                    NewStyles[I] := NewStyles[I + 1]
-                  else
-                    NewStyles[I] := ltLeft;
-              end;
-          end;
-
-          PaintInfo.Canvas.Font.Color := FColors.GridLineColor;
-          for I := 0 to IndentSize - 1 do
-          begin
-            DrawLineImage(PaintInfo, XPos, CellRect.Top, Node.NodeHeight - 1, VAlignment, NewStyles[I],
-              BidiMode &lt;&gt; bdLeftToRight);
-            Inc(XPos, Offset);
-          end;
-        end;
-    else // lmNormal
-      PaintInfo.Canvas.Font.Color := FColors.TreeLineColor;
-      for I := 0 to IndentSize - 1 do
-      begin
-        DrawLineImage(PaintInfo, XPos, CellRect.Top, Node.NodeHeight, VAlignment, LineImage[I],
-          BidiMode &lt;&gt; bdLeftToRight);
-        Inc(XPos, Offset);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.PaintSelectionRectangle(Target: TCanvas; WindowOrgX: Integer; const SelectionRect: TRect;
-  TargetRect: TRect);
-
-// Helper routine to draw a selection rectangle in the mode determined by DrawSelectionMode.
-
-var
-  BlendRect: TRect;
-  TextColorBackup,
-  BackColorBackup: COLORREF;   // used to restore forground and background colors when drawing a selection rectangle
-
-begin
-  if ((FDrawSelectionMode = smDottedRectangle) and not (tsUseThemes in FStates)) or
-    not MMXAvailable then
-  begin
-    // Classical selection rectangle using dotted borderlines.
-    TextColorBackup := GetTextColor(Target.Handle);
-    SetTextColor(Target.Handle, $FFFFFF);
-    BackColorBackup := GetBkColor(Target.Handle);
-    SetBkColor(Target.Handle, 0);
-    Target.DrawFocusRect(SelectionRect);
-    SetTextColor(Target.Handle, TextColorBackup);
-    SetBkColor(Target.Handle, BackColorBackup);
-  end
-  else
-  begin
-    // Modern alpha blended style.
-    OffsetRect(TargetRect, WindowOrgX, 0);
-    if IntersectRect(BlendRect, OrderRect(SelectionRect), TargetRect) then
-    begin
-      OffsetRect(BlendRect, -WindowOrgX, 0);
-      AlphaBlend(0, Target.Handle, BlendRect, Point(0, 0), bmConstantAlphaAndColor, FSelectionBlendFactor,
-        ColorToRGB(FColors.SelectionRectangleBlendColor));
-
-      Target.Brush.Color := FColors.SelectionRectangleBorderColor;
-      Target.FrameRect(SelectionRect);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.PanningWindowProc(var Message: TMessage);
-
-var
-  PS: TPaintStruct;
-  Canvas: TCanvas;
-
-begin
-  if Message.Msg = WM_PAINT then
-  begin
-    BeginPaint(FPanningWindow, PS);
-    Canvas := TCanvas.Create;
-    Canvas.Handle := PS.hdc;
-    try
-      Canvas.Draw(0, 0, FPanningImage);
-    finally
-      Canvas.Handle := 0;
-      Canvas.Free;
-      EndPaint(FPanningWindow, PS);
-    end;
-    Message.Result := 0;
-  end
-  else
-    with Message do
-      Result := DefWindowProc(FPanningWindow, Msg, wParam, lParam);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.ReadChunk(Stream: TStream; Version: Integer; Node: PVirtualNode; ChunkType,
-  ChunkSize: Integer): Boolean;
-
-// Called while loading a tree structure, Node is already valid (allocated) at this point.
-// The function handles the base and user chunks, any other chunk is marked as being unknown (result becomes False)
-// and skipped. Descentants may handle them by overriding this method.
-// Returns True if the chunk could be handled, otherwise False.
-
-var
-  ChunkBody: TBaseChunkBody;
-  Run: PVirtualNode;
-  LastPosition: Integer;
-
-begin
-  case ChunkType of
-    BaseChunk:
-      begin
-        // Load base chunk's body (chunk header has already been consumed).
-        if Version &gt; 1 then
-          Stream.Read(ChunkBody, SizeOf(ChunkBody))
-        else
-        begin
-          with ChunkBody do
-          begin
-            // In version prior to 2 there was a smaller chunk body. Hence we have to read it entry by entry now.
-            Stream.Read(ChildCount, SizeOf(ChildCount));
-            Stream.Read(NodeHeight, SizeOf(NodeHeight));
-            // TVirtualNodeStates was a byte sized type in version 1
-            States := [];
-            Stream.Read(States, SizeOf(Byte));
-            // vsVisible is now in the place where vsSelected was before, but every node was visible in the old version
-            // so we need to fix this too.
-            if vsVisible in States then
-              Include(States, vsSelected)
-            else
-              Include(States, vsVisible);
-            Stream.Read(Align, SizeOf(Align));
-            Stream.Read(CheckState, SizeOf(CheckState));
-            Stream.Read(CheckType, SizeOf(CheckType));
-          end;
-        end;
-        
-        with Node^ do
-        begin
-          // Set states first, in case the node is invisble.
-          States := ChunkBody.States;
-
-          NodeHeight := ChunkBody.NodeHeight;
-          AdjustTotalHeight(Node, NodeHeight);
-
-          Align := ChunkBody.Align;
-          CheckState := ChunkBody.CheckState;
-          CheckType := ChunkBody.CheckType;
-
-          // Create and read child nodes.
-          while ChunkBody.ChildCount &gt; 0 do
-          begin
-            Run := MakeNewNode;
-            InternalConnectNode(Run, Node, Self, amAddChildLast);
-            ReadNode(Stream, Version, Run);
-            Dec(ChunkBody.ChildCount);
-          end;
-        end;
-        Result := True;
-      end;
-    UserChunk:
-      if ChunkSize &gt; 0 then
-      begin
-        // need to know whether the data was read
-        LastPosition := Stream.Position;
-        DoLoadUserData(Node, Stream);
-        // compare stream position to learn whether the data was read
-        Result := Stream.Position &gt; LastPosition;
-        // Improve stability by advancing the stream to the chunk's real end if
-        // the application did not read what has been written.
-        if not Result or (Stream.Position &lt;&gt; (LastPosition + ChunkSize)) then
-          Stream.Position := LastPosition + ChunkSize;
-      end
-      else
-        Result := True;
-  else
-    // unknown chunk, skip it 
-    Stream.Position := Stream.Position + ChunkSize;
-    Result := False;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ReadNode(Stream: TStream; Version: Integer; Node: PVirtualNode);
-
-// Reads the anchor chunk of each node and initiates reading the sub chunks for this node
-
-var
-  Header: TChunkHeader;
-  EndPosition: Integer;
-
-begin
-  with Stream do
-  begin
-    // Read anchor chunk of the node.
-    Stream.Read(Header, SizeOf(Header));
-    if Header.ChunkType = NodeChunk then
-    begin
-      EndPosition := Stream.Position + Header.ChunkSize;
-      // Read all subchunks until the indicated chunk end position is reached in the stream.
-      while Position &lt; EndPosition do
-      begin
-        // Read new chunk header.
-        Stream.Read(Header, SizeOf(Header));
-        ReadChunk(Stream, Version, Node, Header.ChunkType, Header.ChunkSize);
-      end;
-      // If the last chunk does not end at the given end position then there is something wrong.
-      if Position &lt;&gt; EndPosition then
-        ShowError(SCorruptStream2, hcTFCorruptStream2);
-    end
-    else
-      ShowError(SCorruptStream1, hcTFCorruptStream1);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.RedirectFontChangeEvent(Canvas: TCanvas);
-
-begin
-  if @Canvas.Font.OnChange &lt;&gt; @FOldFontChange then
-  begin
-    FOldFontChange := Canvas.Font.OnChange;
-    Canvas.Font.OnChange := FontChanged;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.RemoveFromSelection(Node: PVirtualNode);
-
-var
-  Index: Integer;
-
-begin
-  Assert(Assigned(Node), 'Node must not be nil!');
-  if vsSelected in Node.States then
-  begin
-    Exclude(Node.States, vsSelected);
-    if FindNodeInSelection(Node, Index, -1, -1) and (Index &lt; FSelectionCount - 1) then
-      Move(FSelection[Index + 1], FSelection[Index], (FSelectionCount - Index - 1) * 4);
-    if FSelectionCount &gt; 0 then
-      Dec(FSelectionCount);
-    SetLength(FSelection, FSelectionCount);
-
-    if FSelectionCount = 0 then
-      ResetRangeAnchor;
-      
-    Change(Node);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.RenderOLEData(const FormatEtcIn: TFormatEtc; out Medium: TStgMedium;
-  ForClipboard: Boolean): HResult;
-
-// Returns a memory expression of all currently selected nodes in the Medium structure.
-// Note: The memory requirement of this method might be very high. This depends however on the requested storage format.
-//       For HGlobal (a global memory block) we need to render first all nodes to local memory and copy this then to
-//       the global memory in Medium. This is necessary because we have first to determine how much
-//       memory is needed before we can allocate it. Hence for a short moment we need twice the space as used by the
-//       nodes alone (plus the amount the nodes need in the tree anyway)!
-//       With IStream this does not happen. We directly stream out the nodes and pass the constructed stream along.
-
-  //--------------- local function --------------------------------------------
-
-  procedure WriteNodes(Stream: TStream);
-
-  var
-    Selection: TNodeArray;
-    I: Integer;
-
-  begin
-    if ForClipboard then
-      Selection := GetSortedCutCopySet(True)
-    else
-      Selection := GetSortedSelection(True);
-    for I := 0 to High(Selection) do
-      WriteNode(Stream, Selection[I]);
-  end;
-
-  //--------------- end local function ----------------------------------------
-
-var
-  Data: PCardinal;
-  ResPointer: Pointer;
-  ResSize: Integer;
-  OLEStream: IStream;
-  VCLStream: TStream;
-  
-begin
-  FillChar(Medium, SizeOf(Medium), 0);
-
-  // We can render the native clipboard format in two different storage media.
-  if (FormatEtcIn.cfFormat = CF_VIRTUALTREE) and (FormatEtcIn.tymed and (TYMED_HGLOBAL or TYMED_ISTREAM) &lt;&gt; 0) then
-  begin
-    VCLStream := nil;
-    try
-      Medium.unkForRelease := nil;
-      // Return data in one of the supported storage formats, prefer IStream.
-      if FormatEtcIn.tymed and TYMED_ISTREAM &lt;&gt; 0 then
-      begin
-        // Create an IStream on a memory handle (here it is 0 which indicates to implicitely allocated a handle).
-        // Do not use TStreamAdapter as it is not compatible with OLE (when flushing the clipboard OLE wants the HGlobal
-        // back which is not supported by TStreamAdapater).
-        CreateStreamOnHGlobal(0, True, OLEStream);
-        VCLStream := TOLEStream.Create(OLEStream);
-        WriteNodes(VCLStream);
-        // Rewind stream.
-        VCLStream.Position := 0;
-        Medium.tymed := TYMED_ISTREAM;
-        IUnknown(Medium.stm) := OLEStream;
-        Result := S_OK;
-      end
-      else
-      begin
-        VCLStream := TMemoryStream.Create;
-        WriteNodes(VCLStream);
-        ResPointer := TMemoryStream(VCLStream).Memory;
-        ResSize := VCLStream.Position;
-
-        // Allocate memory to hold the string.
-        if ResSize &gt; 0 then
-        begin
-          Medium.hGlobal := GlobalAlloc(GHND or GMEM_SHARE, ResSize + SizeOf(Cardinal));
-          Data := GlobalLock(Medium.hGlobal);
-          // Store the size of the data too, for easy retrival.
-          Data^ := ResSize;
-          Inc(Data);
-          Move(ResPointer^, Data^, ResSize);
-          GlobalUnlock(Medium.hGlobal);
-          Medium.tymed := TYMED_HGLOBAL;
-
-          Result := S_OK;
-        end
-        else
-          Result := E_FAIL;
-      end;
-    finally
-      // We can free the VCL stream here since it was either a pure memory stream or only a wrapper around
-      // the OLEStream which exists independently.
-      VCLStream.Free;
-    end;
-  end
-  else // Ask application descentants to render self defined formats.
-    Result := DoRenderOLEData(FormatEtcIn, Medium, ForClipboard);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ResetRangeAnchor;
-
-// Called when there is no selected node anymore and the selection range anchor needs a new value.
-
-begin
-  FRangeAnchor := FFocusedNode;
-  FLastSelectionLevel := -1;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.RestoreFontChangeEvent(Canvas: TCanvas);
-
-begin
-  Canvas.Font.OnChange := FOldFontChange;
-  FOldFontChange := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SelectNodes(StartNode, EndNode: PVirtualNode; AddOnly: Boolean);
-
-// Selects a range of nodes and unselects all other eventually selected nodes which are not in this range if
-// AddOnly is False.
-// EndNode must be visible while StartNode does not necessarily as in the case where the last focused node is the start
-// node but it is a child of a node which has been collapsed previously. In this case the first visible parent node
-// is used as start node. StartNode can be nil in which case the very first node in the tree is used.
-
-var
-  NodeFrom,
-  NodeTo,
-  LastAnchor: PVirtualNode;
-  Index: Integer;
-
-begin
-  Assert(Assigned(EndNode), 'EndNode must not be nil!');
-  ClearTempCache;
-  if StartNode = nil then
-    StartNode := FRoot.FirstChild
-  else
-    if not FullyVisible[StartNode] then
-    begin
-      StartNode := GetPreviousVisible(StartNode);
-      if StartNode = nil then
-        StartNode := FRoot.FirstChild
-    end;
-
-  if CompareNodePositions(StartNode, EndNode) &lt; 0 then
-  begin
-    NodeFrom := StartNode;
-    NodeTo := EndNode;
-  end
-  else
-  begin
-    NodeFrom := EndNode;
-    NodeTo := StartNode;
-  end;
-
-  // The range anchor will be reset by the following call.
-  LastAnchor := FRangeAnchor;
-  if not AddOnly then
-    InternalClearSelection;
-
-  while NodeFrom &lt;&gt; NodeTo do
-  begin
-    InternalCacheNode(NodeFrom);
-    NodeFrom := GetNextVisible(NodeFrom);
-  end;
-  // select last node too
-  InternalCacheNode(NodeFrom);
-  // now add them all in &quot;one&quot; step
-  AddToSelection(FTempNodeCache, FTempNodeCount);
-  ClearTempCache;
-  if Assigned(LastAnchor) and FindNodeInSelection(LastAnchor, Index, -1, -1) then
-   FRangeAnchor := LastAnchor;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SetBiDiMode(Value: TBiDiMode);
-
-begin
-  inherited;                            
-
-  RecreateWnd;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SkipNode(Stream: TStream);
-
-// Skips the data for the next node in the given stream (including the child nodes).
-
-var
-  Header: TChunkHeader;
-
-begin
-  with Stream do
-  begin
-    // read achor chunk of the node
-    Stream.Read(Header, SizeOf(Header));
-    if Header.ChunkType = NodeChunk then
-      Stream.Position := Stream.Position + Header.ChunkSize
-    else
-      ShowError(SCorruptStream1, hcTFCorruptStream1);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-var
-  PanningWindowClass: TWndClass = (
-    style: 0;
-    lpfnWndProc: @DefWindowProc;
-    cbClsExtra: 0;
-    cbWndExtra: 0;
-    hInstance: 0;
-    hIcon: 0;
-    hCursor: 0;
-    hbrBackground: 0;
-    lpszMenuName: nil;
-    lpszClassName: 'VTPanningWindow'
-  );
-
-procedure TBaseVirtualTree.StartWheelPanning(Position: TPoint);
-
-// Called when wheel panning should start. A little helper window is created to indicate the reference position,
-// which determines in which direction and how far wheel panning/scrolling will happen.
-
-  //--------------- local function --------------------------------------------
-
-  function CreateClipRegion: HRGN;
-
-  // In order to avoid doing all the transparent drawing ourselves we use a
-  // window region for the wheel window.
-  // Since we only work on a very small image (32x32 pixels) this is acceptable.
-
-  var
-    Start, X, Y: Integer;
-    Temp: HRGN;
-    
-  begin
-    Assert(not FPanningImage.Empty, 'Invalid wheel panning image.');
-
-    // Create an initial region on which we operate.
-    Result := CreateRectRgn(0, 0, 0, 0);
-    with FPanningImage, Canvas do
-    begin
-      for Y := 0 to Height - 1 do
-      begin
-        Start := -1;
-        for X := 0 to Width - 1 do
-        begin
-          // Start a new span if we found a non-transparent pixel and no span is currently started.
-          if (Start = -1) and (Pixels[X, Y] &lt;&gt; clFuchsia) then
-            Start := X
-          else
-            if (Start &gt; -1) and (Pixels[X, Y] = clFuchsia) then
-            begin
-              // A non-transparent span is finished. Add it to the result region.
-              Temp := CreateRectRgn(Start, Y, X, Y + 1);
-              CombineRgn(Result, Result, Temp, RGN_OR);
-              DeleteObject(Temp);
-              Start := -1;
-            end;
-        end;
-        // If there is an open span then add this also to the result region.
-        if Start &gt; -1 then
-        begin
-          Temp := CreateRectRgn(Start, Y, Width, Y + 1);
-          CombineRgn(Result, Result, Temp, RGN_OR);
-          DeleteObject(Temp);
-        end;
-      end;
-    end;
-    // The resulting region is used as window region so we must not delete it.
-    // Windows will own it after the assignment below.
-  end;
-
-  //--------------- end local function ----------------------------------------
-
-var
-  TempClass: TWndClass;
-  ClassRegistered: Boolean;
-  ImageName: string;
-  
-begin
-  // Set both panning and scrolling flag. One will be removed shortly depending on whether the middle mouse button is
-  // released before the mouse is moved or vice versa. The first case is referred to as wheel scrolling while the
-  // latter is called wheel panning.
-  StopTimer(ScrollTimer);
-  DoStateChange([tsWheelPanning, tsWheelScrolling]);
-
-  // Register the helper window class.
-  PanningWindowClass.hInstance := HInstance;
-  ClassRegistered := GetClassInfo(HInstance, PanningWindowClass.lpszClassName, TempClass);
-  if not ClassRegistered or (TempClass.lpfnWndProc &lt;&gt; @DefWindowProc) then
-  begin
-    if ClassRegistered then
-      Windows.UnregisterClass(PanningWindowClass.lpszClassName, HInstance);
-    Windows.RegisterClass(PanningWindowClass);
-  end;
-  // Create the helper window and show at the given position without activating it.
-  with ClientToScreen(Position) do
-    FPanningWindow := CreateWindowEx(WS_EX_TOOLWINDOW, PanningWindowClass.lpszClassName, nil, WS_POPUP, X - 16, Y - 16,
-      32, 32, Handle, 0, HInstance, nil);
-
-  FPanningImage := TBitmap.Create;
-  if Integer(FRangeX) &gt; ClientWidth then
-  begin
-    if Integer(FRangeY) &gt; ClientHeight then
-      ImageName := 'VT_MOVEALL'
-    else
-      ImageName := 'VT_MOVEEW'
-  end
-  else
-    ImageName := 'VT_MOVENS';
-  FPanningImage.LoadFromResourceName(HInstance, ImageName);                
-  SetWindowRgn(FPanningWindow, CreateClipRegion, False);
-
-  {$ifdef COMPILER_6_UP}
-    SetWindowLong(FPanningWindow, GWL_WNDPROC, Integer(Classes.MakeObjectInstance(PanningWindowProc)));
-  {$else}
-    SetWindowLong(FPanningWindow, GWL_WNDPROC, Integer(MakeObjectInstance(PanningWindowProc)));
-  {$endif}
-  ShowWindow(FPanningWindow, SW_SHOWNOACTIVATE);
-
-  // Setup the panscroll timer and capture all mouse input.
-  SetFocus;
-  SetCapture(Handle);
-  SetTimer(Handle, ScrollTimer, 20, nil);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.StopWheelPanning;
-
-// Stops panning if currently active and destroys the helper window.
-
-var
-  Instance: Pointer;
-
-begin
-  if [tsWheelPanning, tsWheelScrolling] * FStates &lt;&gt; [] then
-  begin
-    // Release the mouse capture and stop the panscroll timer.
-    StopTimer(ScrollTimer);
-    ReleaseCapture;
-    DoStateChange([], [tsWheelPanning, tsWheelScrolling]);
-
-    // Destroy the helper window.
-    Instance := Pointer(GetWindowLong(FPanningWindow, GWL_WNDPROC));
-    DestroyWindow(FPanningWindow);
-    if Instance &lt;&gt; @DefWindowProc then
-      {$ifdef COMPILER_6_UP}
-        Classes.FreeObjectInstance(Instance);
-      {$else}
-        FreeObjectInstance(Instance);
-      {$endif}
-    FPanningWindow := 0;
-    FPanningImage.Free;
-    FPanningImage := nil;
-    DeleteObject(FPanningCursor);
-    FPanningCursor := 0;
-    Windows.SetCursor(Screen.Cursors[Cursor]);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.StructureChange(Node: PVirtualNode; Reason: TChangeReason);
-
-begin
-  AdviseChangeEvent(True, Node, Reason);
-
-  if FUpdateCount = 0 then
-  begin
-    if (FChangeDelay &gt; 0) and not (tsSynchMode in FStates) then
-      SetTimer(Handle, StructureChangeTimer, FChangeDelay, nil)
-    else
-      DoStructureChange(Node, Reason);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.SuggestDropEffect(Source: TObject; Shift: TShiftState; Pt: TPoint;
-  AllowedEffects: Integer): Integer;
-
-// determines the drop action to take if the drag'n drop operation ends on this tree
-// Note: Source can be any Delphi object not just a virtual tree
-
-begin
-  Result := AllowedEffects;
-
-  // prefer MOVE if source and target are the same control, otherwise whatever is allowed as initial value
-  if Assigned(Source) and (Source = Self) then
-    if (AllowedEffects and DROPEFFECT_MOVE) &lt;&gt; 0 then
-      Result := DROPEFFECT_MOVE
-    else // no change
-  else
-    // drag between different applicatons
-    if (AllowedEffects and DROPEFFECT_COPY) &lt;&gt; 0 then
-      Result := DROPEFFECT_COPY;
-
-  // consider modifier keys and what is allowed at the moment, if none of the following conditions apply then
-  // the initial value just set is used
-  if ssCtrl in Shift then
-  begin
-    // copy or link
-    if ssShift in Shift then
-    begin
-      // link
-      if (AllowedEffects and DROPEFFECT_LINK) &lt;&gt; 0 then
-        Result := DROPEFFECT_LINK;
-    end
-    else
-    begin
-      // copy
-      if (AllowedEffects and DROPEFFECT_COPY) &lt;&gt; 0 then
-        Result := DROPEFFECT_COPY;
-    end;
-  end
-  else
-  begin
-    // move, link or default
-    if ssShift in Shift then
-    begin
-      // move
-      if (AllowedEffects and DROPEFFECT_MOVE) &lt;&gt; 0 then
-        Result := DROPEFFECT_MOVE;
-    end
-    else
-    begin
-      // link or default
-      if ssAlt in Shift then
-      begin
-        // link
-        if (AllowedEffects and DROPEFFECT_LINK) &lt;&gt; 0 then
-          Result := DROPEFFECT_LINK;
-      end;
-      // else default
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ToggleSelection(StartNode, EndNode: PVirtualNode);
-
-// Switchs the selection state of a range of nodes.
-// Note: This method is specifically designed to help selecting ranges with the keyboard and considers therefore
-//       the range anchor.
-
-var
-  NodeFrom,
-  NodeTo: PVirtualNode;
-  NewSize: Integer;
-  Position: Integer;
-
-begin
-  Assert(Assigned(EndNode), 'EndNode must not be nil!');
-  if StartNode = nil then
-    StartNode := FRoot.FirstChild
-  else
-    if not FullyVisible[StartNode] then
-      StartNode := GetPreviousVisible(StartNode);
-
-  Position := CompareNodePositions(StartNode, EndNode);
-  // nothing to do if start and end node are the same
-  if Position &lt;&gt; 0 then
-  begin
-    if Position &lt; 0 then
-    begin
-      NodeFrom := StartNode;
-      NodeTo := EndNode;
-    end
-    else
-    begin
-      NodeFrom := EndNode;
-      NodeTo := StartNode;
-    end;
-
-    ClearTempCache;
-
-    // 1) toggle the start node if it is before the range anchor
-    if CompareNodePositions(NodeFrom, FRangeAnchor) &lt; 0 then
-      if not (vsSelected in NodeFrom.States) then
-        InternalCacheNode(NodeFrom)
-      else
-        InternalRemoveFromSelection(NodeFrom);
-
-    // 2) toggle all nodes within the range
-    NodeFrom := GetNextVisible(NodeFrom);
-    while NodeFrom &lt;&gt; NodeTo do
-    begin
-      if not (vsSelected in NodeFrom.States) then
-        InternalCacheNode(NodeFrom)
-      else
-        InternalRemoveFromSelection(NodeFrom);
-      NodeFrom := GetNextVisible(NodeFrom);
-    end;
-
-    // 3) toggle end node if it is after the range anchor
-    if CompareNodePositions(NodeFrom, FRangeAnchor) &gt; 0 then
-      if not (vsSelected in NodeFrom.States) then
-        InternalCacheNode(NodeFrom)
-      else
-        InternalRemoveFromSelection(NodeFrom);
-
-    // Do some housekeeping if there was a change.
-    NewSize := PackArray(FSelection, FSelectionCount);
-    if NewSize &gt; -1 then
-    begin
-      FSelectionCount := NewSize;
-      SetLength(FSelection, FSelectionCount);
-    end;
-    // If the range went over the anchor then we need to reselect it.
-    if not (vsSelected in FRangeAnchor.States) then
-      InternalCacheNode(FRangeAnchor);
-    if FTempNodeCount &gt; 0 then
-      AddToSelection(FTempNodeCache, FTempNodeCount);
-    ClearTempCache;
-
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.UnselectNodes(StartNode, EndNode: PVirtualNode);
-
-// Deselects a range of nodes.
-// EndNode must be visible while StartNode must not as in the case where the last focused node is the start node
-// but it is a child of a node which has been collapsed previously. In this case the first visible parent node
-// is used as start node. StartNode can be nil in which case the very first node in the tree is used.
-
-var
-  NodeFrom,
-  NodeTo: PVirtualNode;
-  NewSize: Integer;
-
-begin
-  Assert(Assigned(EndNode), 'EndNode must not be nil!');
-  
-  if StartNode = nil then
-    StartNode := FRoot.FirstChild
-  else
-    if not FullyVisible[StartNode] then
-    begin
-      StartNode := GetPreviousVisible(StartNode);
-      if StartNode = nil then
-        StartNode := FRoot.FirstChild
-    end;
-
-  if CompareNodePositions(StartNode, EndNode) &lt; 0 then
-  begin
-    NodeFrom := StartNode;
-    NodeTo := EndNode;
-  end
-  else
-  begin
-    NodeFrom := EndNode;
-    NodeTo := StartNode;
-  end;
-
-  while NodeFrom &lt;&gt; NodeTo do
-  begin
-    InternalRemoveFromSelection(NodeFrom);
-    NodeFrom := GetNextVisible(NodeFrom);
-  end;
-  // Deselect last node too.
-  InternalRemoveFromSelection(NodeFrom);
-
-  // Do some housekeeping.
-  NewSize := PackArray(FSelection, FSelectionCount);
-  if NewSize &gt; -1 then
-  begin
-    FSelectionCount := NewSize;
-    SetLength(FSelection, FSelectionCount);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.UpdateDesigner;
-
-var
-  ParentForm: TCustomForm;
-
-begin
-  if (csDesigning in ComponentState) and not (csUpdating in ComponentState) then
-  begin
-    ParentForm := GetParentForm(Self);
-    if Assigned(ParentForm) and Assigned(ParentForm.Designer) then
-      ParentForm.Designer.Modified;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.UpdateHeaderRect;
-
-// Calculates the rectangle the header occupies in non-client area.
-// These coordinates are in window rectangle.
-
-var
-  OffsetX,
-  OffsetY: Integer;
-  EdgeSize: Integer;
-  Styles: Integer;
-
-begin
-  FHeaderRect := Rect(0, 0, Width, Height);
-
-  // Consider borders...
-  Styles := GetWindowLong(Handle, GWL_STYLE);
-  if (Styles and WS_BORDER) &lt;&gt; 0 then
-    InflateRect(FHeaderRect, -1, -1);
-  if (Styles and WS_THICKFRAME) &lt;&gt; 0 then
-    InflateRect(FHeaderRect, -3, -3);
-
-  Styles := GetWindowLong(Handle, GWL_EXSTYLE);
-  if (Styles and WS_EX_CLIENTEDGE) &lt;&gt; 0 then
-    InflateRect(FHeaderRect, -2, -2);
-
-  // ... and bevels.
-  OffsetX := BorderWidth;
-  OffsetY := BorderWidth;
-  if BevelKind &lt;&gt; bkNone then
-  begin
-    EdgeSize := 0;
-    if BevelInner &lt;&gt; bvNone then
-      Inc(EdgeSize, BevelWidth);
-    if BevelOuter &lt;&gt; bvNone then
-      Inc(EdgeSize, BevelWidth);
-    if beLeft in BevelEdges then
-      Inc(OffsetX, EdgeSize);
-    if beTop in BevelEdges then
-      Inc(OffsetY, EdgeSize);
-  end;
-
-  InflateRect(FHeaderRect, -OffsetX, -OffsetY);
-
-  if hoVisible in FHeader.FOptions then
-  begin
-    if FHeaderRect.Left &lt;= FHeaderRect.Right then
-      FHeaderRect.Bottom := FHeaderRect.Top + Integer(FHeader.FHeight)
-    else
-      FHeaderRect := Rect(0, 0, 0, 0);
-  end
-  else
-    FHeaderRect.Bottom := FHeaderRect.Top;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.UpdateEditBounds;
-
-// Used to update the bounds of the current node editor if editing is currently active.
-
-var
-  R: TRect;
-  Dummy: Integer;
-  BidiMode: TBidiMode;
-
-begin
-  if tsEditing in FStates then
-  begin
-    if vsMultiline in FFocusedNode.States then
-      R := GetDisplayRect(FFocusedNode, FEditColumn, True, False)
-    else
-      R := GetDisplayRect(FFocusedNode, FEditColumn, True, True);
-    if (toGridExtensions in FOptions.MiscOptions) then
-    begin
-      // Consider visible tree lines, check boxes or images here. Do not forget about bidi.
-      if FEditColumn = NoColumn then
-        BidiMode := Self.BidiMode
-      else
-        BidiMode := FHeader.Columns[FEditColumn].FBiDiMode;
-      if BiDiMode = bdLeftToRight then
-        FHeader.Columns.GetColumnBounds(FEditColumn, Dummy, R.Right)
-      else
-        FHeader.Columns.GetColumnBounds(FEditColumn, R.Left, Dummy);
-    end;
-    if toShowHorzGridLines in TreeOptions.PaintOptions then
-      Dec(R.Bottom);
-    FEditLink.SetBounds(R);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-const
-  ScrollMasks: array[Boolean] of Cardinal = (0, SIF_DISABLENOSCROLL);
-
-const // Region identifiers for GetRandomRgn
-  CLIPRGN = 1;
-  METARGN = 2;
-  APIRGN = 3;
-  SYSRGN = 4;
-
-function GetRandomRgn(DC: HDC; Rgn: HRGN; iNum: Integer): Integer; stdcall; external 'GDI32.DLL';
-
-procedure TBaseVirtualTree.UpdateWindowAndDragImage(const Tree: TBaseVirtualTree; TreeRect: TRect; UpdateNCArea,
-  ReshowDragImage: Boolean);
-
-// Method to repaint part of the window area which is not covered by the drag image and to initiate a recapture
-// of the drag image.
-// Note: This method must only be called during a drag operation and the tree passed in is the one managing the current
-// drag image (so it is the actual drag source).
-
-var
-  DragRegion,          // the region representing the drag image
-  UpdateRegion,        // the unclipped region within the tree to be updated
-  NCRegion: HRGN;      // the region representing the non-client area of the tree
-  DragRect,
-  NCRect: TRect;
-  RedrawFlags: Cardinal;
-
-  VisibleTreeRegion: HRGN;
-
-  DC: HDC;
-
-begin
-  if IntersectRect(TreeRect, TreeRect, ClientRect) then
-  begin
-    // Retrieve the visible region of the window. This is important to avoid overpainting parts of other windows
-    // which overlap this one.
-    VisibleTreeRegion := CreateRectRgn(0, 0, 1, 1);
-    DC := GetDCEx(Handle, 0, DCX_CACHE or DCX_WINDOW or DCX_CLIPSIBLINGS or DCX_CLIPCHILDREN);
-    GetRandomRgn(DC, VisibleTreeRegion, SYSRGN);
-    ReleaseDC(Handle, DC);
-
-    // In Win9x the returned visible region is given in client coordinates. We need it in screen coordinates, though.
-    if not IsWinNT then
-      with ClientToScreen(Point(0, 0)) do
-        OffsetRgn(VisibleTreeRegion, X, Y);
-
-    // The drag image will figure out itself what part of the rectangle can be recaptured.
-    // Recapturing is not done by taking a snapshot of the screen, but by letting the tree draw itself
-    // into the back bitmap of the drag image. So the order here is unimportant.
-    Tree.FDragImage.RecaptureBackground(Self, TreeRect, VisibleTreeRegion, UpdateNCArea, ReshowDragImage);
-
-    // Calculate the screen area not covered by the drag image and which needs an update.
-    DragRect := Tree.FDragImage.GetDragImageRect;
-    MapWindowPoints(0, Handle, DragRect, 2);
-    DragRegion := CreateRectRgnIndirect(DragRect);
-                             
-    // Start with non-client area if requested.
-    if UpdateNCArea then
-    begin
-      // Compute the part of the non-client area which must be updated.
-
-      // Determine the outer rectangle of the entire tree window.
-      GetWindowRect(Handle, NCRect);
-      // Express the tree window rectangle in client coordinates (because RedrawWindow wants them so).
-      MapWindowPoints(0, Handle, NCRect, 2);
-      NCRegion := CreateRectRgnIndirect(NCRect);
-      // Determine client rect in screen coordinates and create another region for it.
-      UpdateRegion := CreateRectRgnIndirect(ClientRect);
-      // Create a region which only contains the NC part by subtracting out the client area.
-      CombineRgn(NCRegion, NCRegion, UpdateRegion, RGN_DIFF);
-      // Subtract also out what is hidden by the drag image.
-      CombineRgn(NCRegion, NCRegion, DragRegion, RGN_DIFF);
-      RedrawWindow(Handle, nil, NCRegion, RDW_FRAME or RDW_NOERASE or RDW_NOCHILDREN or RDW_INVALIDATE or RDW_VALIDATE or
-        RDW_UPDATENOW);
-      DeleteObject(NCRegion);
-      DeleteObject(UpdateRegion);
-    end;
-
-    UpdateRegion := CreateRectRgnIndirect(TreeRect);
-    RedrawFlags := RDW_INVALIDATE or RDW_VALIDATE or RDW_UPDATENOW or RDW_NOERASE or RDW_NOCHILDREN;
-    // Remove the part of the update region which is covered by the drag image.
-    CombineRgn(UpdateRegion, UpdateRegion, DragRegion, RGN_DIFF);
-    RedrawWindow(Handle, nil, UpdateRegion, RedrawFlags);
-    DeleteObject(UpdateRegion);
-    DeleteObject(DragRegion);
-    DeleteObject(VisibleTreeRegion);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ValidateCache;
-
-// Starts cache validation if not already done by adding this instance to the worker thread's waiter list
-// (if not already there) and signalling the thread it can start validating.
-
-begin
-  // Wait for thread to stop validation if it is currently validating this tree's cache.
-  InterruptValidation;
-
-  FStartIndex := 0;
-  if tsValidationNeeded in FStates then
-  begin
-    // Tell the thread this tree needs actually something to do.
-    WorkerThread.AddTree(Self);
-    SetEvent(WorkEvent);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ValidateNodeDataSize(var Size: Integer);
-
-begin
-  Size := 0;
-  if Assigned(FOnGetNodeDataSize) then
-    FOnGetNodeDataSize(Self, Size);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WndProc(var Message: TMessage);
-
-var
-  Handled: Boolean;
-
-begin
-  Handled := False;
-
-  // Try the header whether it needs to take this message.
-  if Assigned(FHeader) and (FHeader.FStates &lt;&gt; []) then
-    Handled := FHeader.HandleMessage(Message);
-  if not Handled then
-  begin
-    // For auto drag mode, let tree handle itself, instead of TControl.
-    if not (csDesigning in ComponentState) and
-       ((Message.Msg = WM_LBUTTONDOWN) or (Message.Msg = WM_LBUTTONDBLCLK)) then
-    begin
-      if (DragMode = dmAutomatic) and (DragKind = dkDrag) then
-      begin
-        if IsControlMouseMsg(TWMMouse(Message)) then
-          Handled := True;
-        if not Handled then
-        begin
-          ControlState := ControlState + [csLButtonDown];
-          Dispatch(Message);  // overrides TControl's BeginDrag
-          Handled := True;
-        end;
-      end;
-    end;
-
-    if not Handled and Assigned(FHeader) then
-      Handled := FHeader.HandleMessage(Message);
-
-    if not Handled then
-    begin
-      if (Message.Msg in [WM_NCLBUTTONDOWN, WM_NCRBUTTONDOWN, WM_NCMBUTTONDOWN]) and not Focused and CanFocus then
-        SetFocus;
-      inherited;
-    end;
-  end;
-end;                    
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WriteChunks(Stream: TStream; Node: PVirtualNode);
-
-// writes the core chunks for Node into the stream
-// Node: Descentants can optionally override this method to add other node specific chunks.
-//       Keep in mind that this method is also called for the root node. Using this fact in descentants you can
-//       create a kind of &quot;global&quot; chunks not directly bound to a specific node.
-
-var
-  Header: TChunkHeader;
-  LastPosition,
-  ChunkSize: Integer;
-  Chunk: TBaseChunk;
-  Run: PVirtualNode;
-
-begin
-  with Stream do
-  begin
-    // 1. The base chunk...
-    LastPosition := Position;
-    Chunk.Header.ChunkType := BaseChunk;
-    with Node^, Chunk do
-    begin
-      Body.ChildCount := ChildCount;
-      Body.NodeHeight := NodeHeight;
-      // some states are only temporary so take them out as they make no sense at the new location
-      Body.States := States - [vsChecking, vsCutOrCopy, vsDeleting, vsInitialUserData];
-      Body.Align := Align;
-      Body.CheckState := CheckState;
-      Body.CheckType := CheckType;
-      Body.Reserved := 0;
-    end;
-    // write the base chunk
-    Write(Chunk, SizeOf(Chunk));
-
-    // 2. ... directly followed by the child node chunks (actually they are child chunks of
-    //   the base chunk)
-    if vsInitialized in Node.States then
-    begin
-      Run := Node.FirstChild;
-      while Assigned(Run) do
-      begin
-        WriteNode(Stream, Run);
-        Run := Run.NextSibling;
-      end;
-    end;
-    
-    FinishChunkHeader(Stream, LastPosition, Position);
-
-    // 3. write user data
-    LastPosition := Position;
-    Header.ChunkType := UserChunk;
-    Write(Header, SizeOf(Header));
-    DoSaveUserData(Node, Stream);
-    // check if the application actually wrote data
-    ChunkSize := Position - LastPosition - SizeOf(TChunkHeader);
-    // seek back to start of chunk if nothing has been written 
-    if ChunkSize = 0 then
-    begin
-      Position := LastPosition;
-      Size := Size - SizeOf(Header);
-    end
-    else
-      FinishChunkHeader(Stream, LastPosition, Position);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.WriteNode(Stream: TStream; Node: PVirtualNode);
-
-// Writes the &quot;cover&quot; chunk for Node to Stream and initiates writing child nodes and chunks.
-
-var
-  LastPosition: Integer;
-  Header: TChunkHeader;
-  
-begin
-  // Initialize the node first if necessary and wanted.
-  if toInitOnSave in FOptions.FMiscOptions then
-  begin
-    if not (vsInitialized in Node.States) then
-      InitNode(Node);
-    if (vsHasChildren in Node.States) and (Node.ChildCount = 0) then
-      InitChildren(Node);
-  end;
-
-  with Stream do
-  begin
-    LastPosition := Position;
-    // Emit the anchor chunk.
-    Header.ChunkType := NodeChunk;
-    Write(Header, SizeOf(Header));
-    // Write other chunks to stream taking their size into this chunk's size.
-    WriteChunks(Stream, Node);
-
-    // Update chunk size.
-    FinishChunkHeader(Stream, LastPosition, Position);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.AbsoluteIndex(Node: PVirtualNode): Cardinal;
-
-begin
-  Result := 0;
-  while Assigned(Node) and (Node &lt;&gt; FRoot) do
-  begin
-    if not (vsInitialized in Node.States) then
-      InitNode(Node);
-    if Assigned(Node.PrevSibling) then
-    begin
-      // if there's a previous sibling then add its total count to the result
-      Node := Node.PrevSibling;
-      Inc(Result, Node.TotalCount);
-    end
-    else
-    begin
-      Node := Node.Parent;
-      if Node &lt;&gt; FRoot then
-        Inc(Result);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.AddChild(Parent: PVirtualNode; UserData: Pointer = nil): PVirtualNode;
-
-// Adds a new node to the given parent node. This is simply done by increasing the child count of the
-// parent node. If Parent is nil then the new node is added as (last) top level node.
-// UserData can be used to set the first 4 bytes of the user data area to an initial value which can be used
-// in OnInitNode and will also cause to trigger the OnFreeNode event (if &lt;&gt; nil) even if the node is not yet
-// &quot;officially&quot; initialized.
-// AddChild is a compatibility method and will implicitly validate the parent node. This is however
-// against the virtual paradigm and hence I dissuade from its usage.
-
-var
-  NodeData: ^Pointer;
-
-begin
-  if not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    CancelEditNode;
-
-    if Parent = nil then
-      Parent := FRoot;
-    if not (vsInitialized in Parent.States) then
-      InitNode(Parent);
-
-    // Locally stop updates of the tree in order to avoid usage of the new node before it is correctly set up.
-    // If the update count was 0 on enter then there will be a correct update at the end of this method.
-    Inc(FUpdateCount);
-    try
-      SetChildCount(Parent, Parent.ChildCount + 1);
-      // Update the hidden children flag of the parent. Nodes are added as being visible by default.
-      Exclude(Parent.States, vsAllChildrenHidden);
-    finally
-      Dec(FUpdateCount);
-    end;
-    Result := Parent.LastChild;
-
-    // Check if there is initial user data and there is also enough user data space allocated.
-    if Assigned(UserData) then
-      if FNodeDataSize &gt;= 4 then
-      begin
-        NodeData := Pointer(PChar(@Result.Data) + FTotalInternalDataSize);
-        NodeData^ := UserData;
-        Include(Result.States, vsInitialUserData);
-      end
-      else
-        ShowError(SCannotSetUserData, hcTFCannotSetUserData);
-
-    if FUpdateCount = 0 then
-    begin
-      ValidateCache;
-      if tsStructureChangePending in FStates then
-      begin
-        if Parent = FRoot then
-          StructureChange(nil, crChildAdded)
-        else
-          StructureChange(Parent, crChildAdded);
-      end;
-
-      if (toAutoSort in FOptions.FAutoOptions) and (FHeader.FSortColumn &gt; InvalidColumn) then
-        Sort(Parent, FHeader.FSortColumn, FHeader.FSortDirection, True);
-
-      InvalidateToBottom(Parent);
-      UpdateScrollbars(True);
-    end;
-  end
-  else
-    Result := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AddFromStream(Stream: TStream; TargetNode: PVirtualNode);
-
-// loads nodes from the given stream and adds them to TargetNode
-// the current content is not cleared before the load process starts (see also LoadFromStream)
-
-var
-  ThisID: TMagicID;
-  Version,
-  Count: Cardinal;
-  Node: PVirtualNode;
-
-begin
-  if not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    // check first whether this is a stream we can read
-    Stream.ReadBuffer(ThisID, SizeOf(TMagicID));
-    if (ThisID[0] = MagicID[0]) and
-       (ThisID[1] = MagicID[1]) and
-       (ThisID[2] = MagicID[2]) and
-       (ThisID[5] = MagicID[5]) then
-    begin
-      Version := Word(ThisID[3]);
-      if Version &lt;= VTTreeStreamVersion  then
-      begin
-        BeginUpdate;
-        try
-          if Version &lt; 2 then
-            Count := MaxInt
-          else
-            Stream.ReadBuffer(Count, SizeOf(Count));
-
-          while (Stream.Position &lt; Stream.Size) and (Count &gt; 0) do
-          begin
-            Dec(Count);
-            Node := MakeNewNode;
-            InternalConnectNode(Node, TargetNode, Self, amAddChildLast);
-            InternalAddFromStream(Stream, Version, Node);
-          end;
-          if TargetNode = FRoot then
-            DoNodeCopied(nil)
-          else
-            DoNodeCopied(TargetNode);
-        finally
-          EndUpdate;
-        end;
-      end
-      else
-        ShowError(SWrongStreamVersion, hcTFWrongStreamVersion);
-    end
-    else
-      ShowError(SWrongStreamVersion, hcTFWrongStreamVersion);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.AfterConstruction;
-
-begin
-  inherited;
-
-  if FRoot = nil then
-    InitRootNode;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.Assign(Source: TPersistent);
-
-begin
-  if (Source is TBaseVirtualTree) and not (toReadOnly in FOptions.FMiscOptions) then
-    with Source as TBaseVirtualTree do
-    begin
-      Self.Align := Align;
-      Self.Anchors := Anchors;
-      Self.AutoScrollDelay := AutoScrollDelay;
-      Self.AutoScrollInterval := AutoScrollInterval;
-      Self.AutoSize := AutoSize;
-      Self.Background := Background;
-      Self.BevelEdges := BevelEdges;
-      Self.BevelInner := BevelInner;
-      Self.BevelKind := BevelKind;
-      Self.BevelOuter := BevelOuter;
-      Self.BevelWidth := BevelWidth;
-      Self.BiDiMode := BiDiMode;
-      Self.BorderStyle := BorderStyle;
-      Self.BorderWidth := BorderWidth;
-      Self.ChangeDelay := ChangeDelay;
-      Self.CheckImageKind := CheckImageKind;
-      Self.Color := Color;
-      Self.Colors.Assign(Colors);
-      Self.Constraints.Assign(Constraints);
-      Self.Ctl3D := Ctl3D;
-      Self.DefaultNodeHeight := DefaultNodeHeight;
-      Self.DefaultPasteMode := DefaultPasteMode;
-      Self.DragCursor := DragCursor;
-      Self.DragImageKind := DragImageKind;
-      Self.DragKind := DragKind;
-      Self.DragMode := DragMode;
-      Self.Enabled := Enabled;
-      Self.Font := Font;
-      Self.Header := Header;
-      Self.HintAnimation := HintAnimation;
-      Self.HintMode := HintMode;
-      Self.HotCursor := HotCursor;
-      Self.Images := Images;
-      Self.ImeMode := ImeMode;
-      Self.ImeName := ImeName;
-      Self.Indent := Indent;
-      Self.Margin := Margin;
-      Self.NodeAlignment := NodeAlignment;
-      Self.NodeDataSize := NodeDataSize;
-      Self.TreeOptions := TreeOptions;
-      Self.ParentBiDiMode := ParentBiDiMode;
-      Self.ParentColor := ParentColor;
-      Self.ParentCtl3D := ParentCtl3D;
-      Self.ParentFont := ParentFont;
-      Self.ParentShowHint := ParentShowHint;
-      Self.PopupMenu := PopupMenu;            
-      Self.RootNodeCount := RootNodeCount;
-      Self.ScrollBarOptions := ScrollBarOptions;
-      Self.ShowHint := ShowHint;
-      Self.StateImages := StateImages;
-      Self.TabOrder := TabOrder;
-      Self.TabStop := TabStop;
-      Self.Visible := Visible;
-      Self.SelectionCurveRadius := SelectionCurveRadius;
-      Self.SelectionBlendFactor := SelectionBlendFactor;
-    end
-    else
-      inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.BeginDrag(Immediate: Boolean; Threshold: Integer);
-
-// Reintroduced method to allow to start OLE drag'n drop as well as VCL drag'n drop.
-
-begin
-  if FDragType = dtVCL then
-  begin
-    DoStateChange([tsVCLDragPending]);
-    inherited;
-  end
-  else
-    if (FStates * [tsOLEDragPending, tsOLEDragging]) = [] then
-    begin
-      // Drag start position has already been recorded in WMMouseDown.
-      if Threshold &lt; 0 then
-        FDragThreshold := Mouse.DragThreshold
-      else
-        FDragThreshold := Threshold;
-      if Immediate then
-        DoDragging(FLastClickPos)
-      else
-        DoStateChange([tsOLEDragPending]);
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.BeginSynch;
-
-// Starts the synchronous update mode (if not already active).
-
-begin
-  if not (csDestroying in ComponentState) then
-  begin
-    if FSynchUpdateCount = 0 then
-    begin
-      DoUpdating(usBeginSynch);
-
-      // Stop all timers...
-      StopTimer(ChangeTimer);
-      StopTimer(StructureChangeTimer);
-      StopTimer(ExpandTimer);
-      StopTimer(EditTimer);
-      StopTimer(HeaderTimer);
-      StopTimer(ScrollTimer);
-      StopTimer(SearchTimer);
-      FSearchBuffer := '';
-      FLastSearchNode := nil;
-      DoStateChange([], [tsEditPending, tsScrollPending, tsScrolling, tsIncrementalSearching]);
-
-      // ...and trigger pending update states.
-      if tsStructureChangePending in FStates then
-        DoStructureChange(FLastStructureChangeNode, FLastStructureChangeReason);
-      if tsChangePending in FStates then
-        DoChange(FLastChangedNode);
-    end
-    else
-      DoUpdating(usSynch);
-  end;
-  Inc(FSynchUpdateCount);
-  DoStateChange([tsSynchMode]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.BeginUpdate;
-
-begin
-  if not (csDestroying in ComponentState) then
-  begin
-    if FUpdateCount = 0 then
-    begin
-      DoUpdating(usBegin);
-      SetUpdateState(True);
-    end
-    else
-      DoUpdating(usUpdate);
-  end;
-  Inc(FUpdateCount);
-  DoStateChange([tsUpdating]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CancelCutOrCopy;
-
-// Resets nodes which are marked as being cut.
-
-var
-  Run: PVirtualNode;
-
-begin
-  if ([tsCutPending, tsCopyPending] * FStates) &lt;&gt; [] then
-  begin
-    Run := FRoot.FirstChild;
-    while Assigned(Run) do
-    begin
-      if vsCutOrCopy in Run.States then
-        Exclude(Run.States, vsCutOrCopy);
-      Run := GetNextNoInit(Run);
-    end;
-  end;
-  DoStateChange([], [tsCutPending, tsCopyPending]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CancelEditNode: Boolean;
-
-// Called by the application or the current edit link to cancel the edit action.
-
-begin
-  if HandleAllocated and ([tsEditing, tsEditPending] * FStates &lt;&gt; []) then
-    Result := DoCancelEdit
-  else
-    Result := True;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CanFocus: Boolean;
-
-var
-  Form: TCustomForm;
-  
-begin
-  {$ifdef COMPILER_5_UP}
-    Result := inherited CanFocus;
-  {$else}
-    Result := True;
-  {$endif}
-
-  if Result then
-  begin
-    Form := GetParentForm(Self);
-    Result := (Form = nil) or (Form.Enabled and Form.Visible);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.Clear;
-
-begin
-  if not (toReadOnly in FOptions.FMiscOptions) or (csDestroying in ComponentState) then
-  begin
-    BeginUpdate;
-    try
-      InterruptValidation;
-      if IsEditing then
-        CancelEditNode;
-
-      if ClipboardStates * FStates &lt;&gt; [] then
-      begin
-        OleSetClipBoard(nil);
-        DoStateChange([], ClipboardStates);
-      end;
-      ClearSelection;
-      FFocusedNode := nil;
-      FLastSelected := nil;
-      FCurrentHotNode := nil;
-      DeleteChildren(FRoot, True);
-      FVisibleCount := 0;
-      FOffsetX := 0;
-      FOffsetY := 0;
-
-      {$ifdef UseLocalMemoryManager}
-        FNodeMemoryManager.Clear;
-      {$endif UseLocalMemoryManager}
-    finally
-      EndUpdate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ClearSelection;
-
-var
-  Node: PVirtualNode;
-  Dummy: Integer;
-  R: TRect;
-  Counter: Integer;
-
-begin
-  if (FSelectionCount &gt; 0) and not (csDestroying in ComponentState) then
-  begin
-    if (FUpdateCount = 0) and HandleAllocated and (FVisibleCount &gt; 0) then
-    begin
-      // Iterate through nodes currently visible in the client area and invalidate them.
-      Node := GetNodeAt(0, 0, True, Dummy);
-      if Assigned(Node) then
-        R := GetDisplayRect(Node, NoColumn, False);
-      Counter := FSelectionCount;
-
-      while Assigned(Node) do
-      begin
-        R.Bottom := R.Top + Node.NodeHeight;
-        if vsSelected in Node.States then
-        begin
-          InvalidateRect(Handle, @R, False);
-          Dec(Counter);
-          // Only try as many nodes as are selected.
-          if Counter = 0 then
-            Break;
-        end;
-        R.Top := R.Bottom;
-        if R.Top &gt; ClientHeight then
-          Break;
-        Node := GetNextVisibleNoInit(Node);
-      end;
-    end;
-
-    InternalClearSelection;
-    Change(nil);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CopyTo(Source: PVirtualNode; Tree: TBaseVirtualTree; Mode: TVTNodeAttachMode;
-  ChildrenOnly: Boolean): PVirtualNode;
-
-// A simplified CopyTo method to allow to copy nodes to the root of another tree.
-
-begin
-  Result := CopyTo(Source, Tree.FRoot, Mode, ChildrenOnly);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.CopyTo(Source, Target: PVirtualNode; Mode: TVTNodeAttachMode;
-  ChildrenOnly: Boolean): PVirtualNode;
-
-// Copies Source and all its child nodes to Target.
-// Mode is used to specify further where to add the new node actually (as sibling of Target or as child of Target).
-// Result is the newly created node to which source has been copied if ChildrenOnly is False or just contains Target
-// in the other case.
-// ChildrenOnly determines whether to copy also the source node or only its child nodes.
-
-var
-  TargetTree: TBaseVirtualTree;
-  Stream: TMemoryStream;
-  
-begin
-  Assert(TreeFromNode(Source) = Self, 'The source tree must contain the source node.');
-
-  Result := nil;
-  if (Mode &lt;&gt; amNoWhere) and Assigned(Source) and (Source &lt;&gt; FRoot) then
-  begin
-    // Assume that an empty destination means the root in this (the source) tree.
-    if Target = nil then
-    begin
-      TargetTree := Self;
-      Target := FRoot;
-      Mode := amAddChildFirst;
-    end
-    else
-      TargetTree := TreeFromNode(Target);
-
-    if not (toReadOnly in TargetTree.FOptions.FMiscOptions) then
-    begin
-      if Target = TargetTree.FRoot then
-      begin
-        case Mode of
-          amInsertBefore:
-            Mode := amAddChildFirst;
-          amInsertAfter:
-            Mode := amAddChildLast;
-        end;
-      end;
-
-      Stream := TMemoryStream.Create;
-      try
-        // Write all nodes into a temprary stream depending on the ChildrenOnly flag.
-        if not ChildrenOnly then
-          WriteNode(Stream, Source)
-        else
-        begin
-          Source := Source.FirstChild;
-          while Assigned(Source) do
-          begin
-            WriteNode(Stream, Source);
-            Source := Source.NextSibling;
-          end;
-        end;
-        // Now load the serialized nodes into the target node (tree).
-        TargetTree.BeginUpdate;
-        try
-          Stream.Position := 0;
-          while Stream.Position &lt; Stream.Size do
-          begin
-            Result := TargetTree.MakeNewNode;
-            InternalConnectNode(Result, Target, TargetTree, Mode);
-            TargetTree.InternalAddFromStream(Stream, VTTreeStreamVersion, Result);
-            if not DoNodeCopying(Result, Target) then
-            begin
-              TargetTree.DeleteNode(Result);
-              Result := nil;
-            end
-            else
-              DoNodeCopied(Result);
-          end;
-          if ChildrenOnly then
-            Result := Target;
-        finally
-          TargetTree.EndUpdate;
-        end;
-      finally
-        Stream.Free;
-      end;
-
-      with TargetTree do
-      begin
-        InvalidateCache;
-        if FUpdateCount = 0 then
-        begin
-          ValidateCache;
-          UpdateScrollBars(True);
-          Invalidate;
-        end;
-        StructureChange(Source, crNodeCopied);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CopyToClipBoard;
-
-var
-  DataObject: IDataObject;
-
-begin
-  if FSelectionCount &gt; 0 then
-  begin
-    DataObject := TVTDataObject.Create(Self, True) as IDataObject;
-    if OleSetClipBoard(DataObject) = S_OK then
-    begin
-      MarkCutCopyNodes;
-      DoStateChange([tsCopyPending]);
-      Invalidate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.CutToClipBoard;
-
-var
-  DataObject: IDataObject;
-
-begin
-  if (FSelectionCount &gt; 0) and not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    DataObject := TVTDataObject.Create(Self, True) as IDataObject;
-    if OleSetClipBoard(DataObject) = S_OK then
-    begin
-      MarkCutCopyNodes;
-      DoStateChange([tsCutPending]);
-      Invalidate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DeleteChildren(Node: PVirtualNode; ResetHasChildren: Boolean = False);
-
-// Removes all children and their children from memory without changing the vsHasChildren style by default.
-
-var
-  Run,
-  Mark: PVirtualNode;
-  LastTop,
-  LastLeft: Integer;
-  ParentVisible: Boolean;
-
-begin
-  if (Node.ChildCount &gt; 0) and not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    Assert(not (tsIterating in FStates), 'Deleting nodes during tree iteration leads to invalid pointers.');
-
-    // The code below uses some flags for speed improvements which may cause invalid pointers if updates of
-    // the tree happen. Hence switch updates off until we have finished the operation.
-    Inc(FUpdateCount);
-    try
-      InterruptValidation;
-      LastLeft := FOffsetX;
-      LastTop := FOffsetY;
-
-      // Make a local copy of the visibility state of this node to speed up
-      // adjusting the visible nodes count.
-      ParentVisible := Node = FRoot;
-      if not ParentVisible then
-        ParentVisible := FullyVisible[Node] and (vsExpanded in Node.States);
-
-      // Show that we are clearing the child list, to avoid registering structure change events.
-      Include(Node.States, vsClearing);  
-      Run := Node.LastChild;
-      while Assigned(Run) do
-      begin
-        if ParentVisible and (vsVisible in Run.States) then
-          Dec(FVisibleCount);
-        
-        Include(Run.States, vsDeleting);
-        Mark := Run;
-        Run := Run.PrevSibling;
-        // Important, to avoid exchange of invalid pointers while disconnecting the node.
-        if Assigned(Run) then
-          Run.NextSibling := nil;
-        DeleteNode(Mark);
-      end;
-      Exclude(Node.States, vsClearing);
-      if ResetHasChildren then
-        Exclude(Node.States, vsHasChildren);
-      if Node &lt;&gt; FRoot then
-        Exclude(Node.States, vsExpanded);
-      Node.ChildCount := 0;
-      if (Node = FRoot) or (vsDeleting in Node.States) then
-      begin
-        Node.TotalHeight := Node.NodeHeight;
-        Node.TotalCount := 1;
-      end
-      else
-      begin
-        AdjustTotalHeight(Node, Node.NodeHeight);
-        AdjustTotalCount(Node, 1);
-      end;
-      Node.FirstChild := nil;
-      Node.LastChild := nil;
-    finally
-      Dec(FUpdateCount);
-    end;
-
-    InvalidateCache;
-    if FUpdateCount = 0 then
-    begin
-      ValidateCache;
-      UpdateScrollbars(True);
-      // Invalidate entire tree if it scrolled e.g. to make the last node also the
-      // bottom node in the treeview.
-      if (LastLeft &lt;&gt; FOffsetX) or (LastTop &lt;&gt; FOffsetY) then
-        Invalidate
-      else
-        InvalidateToBottom(Node);
-    end;
-    StructureChange(Node, crChildDeleted);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DeleteNode(Node: PVirtualNode; Reindex: Boolean = True);
-
-var
-  LastTop,
-  LastLeft: Integer;
-  LastParent: PVirtualNode;
-  WasInSynchMode: Boolean;
-  ParentClearing: Boolean;
-
-begin
-  if Assigned(Node) and (Node &lt;&gt; FRoot) and not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    Assert(not (tsIterating in FStates), 'Deleting nodes during tree iteration leads to invalid pointers.');
-
-    // Determine parent node for structure change notification.
-    ParentClearing := vsClearing in Node.Parent.States;
-    LastParent := Node.Parent;
-
-    if not ParentClearing then
-    begin
-      if LastParent = FRoot then
-        StructureChange(nil, crChildDeleted)
-      else
-        StructureChange(LastParent, crChildDeleted);
-    end;
-
-    LastLeft := FOffsetX;
-    LastTop := FOffsetY;
-
-    if vsSelected in Node.States then
-    begin
-      if FUpdateCount = 0 then
-      begin
-        // Go temporarily into sync mode to avoid a delayed change event for the node
-        // when unselecting. 
-        WasInSynchMode := tsSynchMode in FStates;
-        Include(FStates, tsSynchMode);
-        RemoveFromSelection(Node);
-        if not WasInSynchMode then
-          Exclude(FStates, tsSynchMode);
-        InvalidateToBottom(LastParent);
-      end
-      else
-        InternalRemoveFromSelection(Node);
-    end
-    else
-      InvalidateToBottom(LastParent);
-    
-    if tsHint in FStates then
-    begin
-      Application.CancelHint;
-      DoStateChange([], [tsHint]);
-    end;
-
-    DeleteChildren(Node);
-    InternalDisconnectNode(Node, False, Reindex);
-    DoFreeNode(Node);
-
-    if not ParentClearing then
-    begin
-      DetermineHiddenChildrenFlag(LastParent);
-      InvalidateCache;
-      if FUpdateCount = 0 then
-      begin
-        ValidateCache;
-        UpdateScrollbars(True);
-        // Invalidate entire tree if it scrolled e.g. to make the last node also the
-        // bottom node in the treeview.
-        if (LastLeft &lt;&gt; FOffsetX) or (LastTop &lt;&gt; FOffsetY) then
-          Invalidate;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.DeleteSelectedNodes;
-
-// Deletes all currently selected nodes (including their child nodes).
-
-var
-  Nodes: TNodeArray;
-  I: Integer;
-  LevelChange: Boolean;
-  
-begin
-  Nodes := nil;
-  if (FSelectionCount &gt; 0) and not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    BeginUpdate;
-    try
-      Nodes := GetSortedSelection(True);
-      for I := High(Nodes) downto 1 do
-      begin
-        LevelChange := Nodes[I].Parent &lt;&gt; Nodes[I - 1].Parent;
-        DeleteNode(Nodes[I], LevelChange);
-      end;
-      DeleteNode(Nodes[0]);
-    finally
-      EndUpdate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.Dragging: Boolean;
-
-begin
-  // Check for both OLE drag'n drop as well as VCL drag'n drop.
-  Result := ([tsOLEDragPending, tsOLEDragging] * FStates &lt;&gt; []) or inherited Dragging;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.EditNode(Node: PVirtualNode; Column: TColumnIndex): Boolean;
-
-// Application triggered edit event for the given node.
-// Returns True if the tree started editing otherwise False.
-
-begin
-  Assert(Assigned(Node), 'Node must not be nil.');
-  Assert((Column &gt; InvalidColumn) and (Column &lt; FHeader.Columns.Count),
-    'Column must be a valid column index (-1 if no header is shown).');
-
-  Result := tsEditing in FStates;
-  // If the tree is already editing then we don't disrupt this. 
-  if not Result and not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    FocusedNode := Node;
-    if Assigned(FFocusedNode) and (Node = FFocusedNode) and CanEdit(FFocusedNode, Column) then
-    begin
-      FEditColumn := Column;
-      if not (vsInitialized in Node.States) then
-        InitNode(Node);
-      DoEdit;
-      Result := tsEditing in FStates;
-    end
-    else
-      Result := False;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.EndEditNode: Boolean;
-
-// Called by the application or the current edit link to finish the edit action.
-
-begin
-  if [tsEditing, tsEditPending] * FStates &lt;&gt; [] then
-    Result := DoEndEdit
-  else
-    Result := True;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.EndSynch;
-
-begin
-  if FSynchUpdateCount &gt; 0 then
-    Dec(FSynchUpdateCount);
-
-  if not (csDestroying in ComponentState) then
-  begin
-    if FSynchUpdateCount = 0 then
-    begin
-      DoStateChange([], [tsSynchMode]);
-      DoUpdating(usEndSynch);
-    end
-    else
-      DoUpdating(usSynch);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.EndUpdate;
-
-var
-  NewSize: Integer;
-
-begin
-  if FUpdateCount &gt; 0 then
-    Dec(FUpdateCount);
-
-  if not (csDestroying in ComponentState) then
-  begin
-    if (FUpdateCount = 0) and (tsUpdating in FStates) then
-    begin
-      if tsUpdateHiddenChildrenNeeded in FStates then
-      begin
-        DetermineHiddenChildrenFlagAllNodes;
-        Exclude(FStates, tsUpdateHiddenChildrenNeeded);
-      end;
-      
-      DoStateChange([], [tsUpdating]);
-
-      NewSize := PackArray(FSelection, FSelectionCount);
-      if NewSize &gt; -1 then
-      begin
-        FSelectionCount := NewSize;
-        SetLength(FSelection, FSelectionCount);
-      end;
-      ValidateCache;
-      if HandleAllocated then
-        UpdateScrollBars(True);
-
-      if tsStructureChangePending in FStates then
-        DoStructureChange(FLastStructureChangeNode, FLastStructureChangeReason);
-      if tsChangePending in FStates then
-        DoChange(FLastChangedNode);
-
-      if toAutoSort in FOptions.FAutoOptions then
-        SortTree(FHeader.FSortColumn, FHeader.FSortDirection, True);
-
-      SetUpdateState(False);
-      if HandleAllocated then
-        Invalidate;
-    end;
-
-    if FUpdateCount = 0 then
-      DoUpdating(usEnd)
-    else
-      DoUpdating(usUpdate);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.ExecuteAction(Action: TBasicAction): Boolean;
-
-// Some support for standard actions.
-
-begin
-  Result := inherited ExecuteAction(Action);
-
-  if not Result and not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    Result := Action is TEditCut;
-    if Result then
-      CutToClipboard
-    else
-    begin
-      Result := Action is TEditCopy;
-      if Result then
-        CopyToClipboard
-      else
-      begin
-        Result := Action is TEditPaste;
-        if Result then
-          PasteFromClipboard
-        {$ifdef COMPILER_5_UP}
-          else
-          begin
-            Result := Action is TEditDelete;
-            if Result then
-              DeleteSelectedNodes
-            else
-            begin
-              Result := Action is TEditSelectAll;
-              if Result then
-                SelectAll(False);
-            end;
-          end;
-        {$endif COMPILER_5_UP}
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.FinishCutOrCopy;
-
-// Deletes nodes which are marked as being cutted.
-
-var
-  Run: PVirtualNode;
-
-begin
-  if tsCutPending in FStates then
-  begin
-    Run := FRoot.FirstChild;
-    while Assigned(Run) do
-    begin
-      if vsCutOrCopy in Run.States then
-        DeleteNode(Run);
-      Run := GetNextNoInit(Run);
-    end;
-    DoStateChange([], [tsCutPending]);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.FlushClipboard;
-
-// Used to render the data which is currently on the clipboard (finishes delayed rendering).
-
-begin
-  if ClipboardStates * FStates &lt;&gt; [] then
-  begin
-    DoStateChange([tsClipboardFlushing]);
-    OleFlushClipboard;
-    CancelCutOrCopy;
-    DoStateChange([], [tsClipboardFlushing]);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.FullCollapse(Node: PVirtualNode = nil);
-
-// This routine collapses all expanded nodes in the subtree given by Node or the whole tree if Node is FRoot or nil.
-// Only nodes which are expanded will be collapsed. This excludes uninitialized nodes but nodes marked as visible
-// will still be collapsed if they are expanded.
-
-var
-  Stop: PVirtualNode;
-
-begin
-  if FRoot.TotalCount &gt; 1 then
-  begin
-    if Node = FRoot then
-      Node := nil;
-
-    DoStateChange([tsCollapsing]);
-    BeginUpdate;
-    try
-      Stop := Node;
-      Node := GetLastVisibleNoInit(Node);
-
-      if Assigned(Node) then
-      begin
-        repeat
-          if [vsHasChildren, vsExpanded] * Node.States = [vsHasChildren, vsExpanded] then
-            ToggleNode(Node);
-          Node := GetPreviousNoInit(Node);
-        until Node = Stop;
-
-        // Collapse the start node too.
-        if Assigned(Node) and ([vsHasChildren, vsExpanded] * Node.States = [vsHasChildren, vsExpanded]) then
-          ToggleNode(Node);
-      end;
-    finally
-      EndUpdate;
-      DoStateChange([], [tsCollapsing]);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.FullExpand(Node: PVirtualNode = nil);
-
-// This routine expands all collapsed nodes in the subtree given by Node or the whole tree if Node is FRoot or nil.
-// All nodes on the way down are initialized so this procedure might take a long time.
-// Since all nodes are validated, the tree cannot make use of optimatizations. Hence it is counter productive and you
-// should consider avoiding its use.
-
-var
-  Stop: PVirtualNode;
-
-begin
-  if FRoot.TotalCount &gt; 1 then
-  begin
-    DoStateChange([tsExpanding]);
-    BeginUpdate;
-    try
-      if Node = nil then
-      begin
-        Node := FRoot.FirstChild;
-        Stop := nil;
-      end
-      else
-      begin
-        Stop := Node.NextSibling;
-        if Stop = nil then
-        begin
-          Stop := Node;
-          repeat
-            Stop := Stop.Parent;
-          until (Stop = FRoot) or Assigned(Stop.NextSibling);
-          if Stop = FRoot then
-            Stop := nil
-          else
-            Stop := Stop.NextSibling;
-        end;
-      end;
-
-      // Initialize the start node. Others will be initialized in GetNext.
-      if not (vsInitialized in Node.States) then
-        InitNode(Node);
-
-      repeat
-        if not (vsExpanded in Node.States) then
-          ToggleNode(Node);
-        Node := GetNext(Node);
-      until Node = Stop;
-    finally
-      EndUpdate;
-      DoStateChange([], [tsExpanding]);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetControlsAlignment: TAlignment;
-
-begin
-  Result := FAlignment;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetDisplayRect(Node: PVirtualNode; Column: TColumnIndex; TextOnly: Boolean;
-  Unclipped: Boolean = False): TRect;
-
-// Determines the client coordinates the given node covers, depending on scrolling, expand state etc.
-// If the given node cannot be found (because one of its parents is collapsed or it is invisible) then an empty
-// rectangle is returned.
-// If TextOnly is True then only the text bounds are returned, that is, the resulting rectangle's left and right border
-// are updated according to bidi mode, alignment and text width of the node.
-// If Unclipped is True (which only makes sense if also TextOnly is True) then the calculated text rectangle is
-// not clipped if the text does not entirely fit into the text space. This is special handling needed for hints.
-// If Column is -1 then the entire client width is used before determining the node's width otherwise the bounds of the
-// particular column are used.
-// Note: Column must be a valid column and is used independent of whether the header is visible or not.
-
-var
-  Temp: PVirtualNode;
-  Offset: Cardinal;
-  Indent,
-  TextWidth: Integer;
-  MainColumnHit,
-  Ghosted: Boolean;
-  CurrentBidiMode: TBidiMode;
-  CurrentAlignment: TAlignment;
-
-begin
-  Assert(Assigned(Node), 'Node must not be nil.');
-  Assert(Node &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-  MainColumnHit := (Column + 1) in [0, FHeader.MainColumn + 1];
-  if not (vsInitialized in Node.States) then
-    InitNode(Node);
-
-  Result := Rect(0, 0, 0, 0);
-  
-  // Check whether the node is visible (determine indentation level btw.).
-  Temp := Node;
-  Indent := 0;
-  while Temp &lt;&gt; FRoot do
-  begin                                                                          
-    if not (vsVisible in Temp.States) or not (vsExpanded in Temp.Parent.States) then
-      Exit;
-    Temp := Temp.Parent;
-    if MainColumnHit and (Temp &lt;&gt; FRoot) then
-      Inc(Indent, FIndent);
-  end;
-
-  // Here we know the node is visible.
-  Offset := 0;
-  if tsUseCache in FStates then
-  begin
-    // If we can use the position cache then do a binary search to find a cached node which is as close as possible
-    // to the current node. Iterate then through all following and visible nodes and sum up their heights.
-    Temp := FindInPositionCache(Node, Offset);
-    while Assigned(Temp) and (Temp &lt;&gt; Node) do
-    begin
-      Inc(Offset, Temp.NodeHeight);
-      Temp := GetNextVisibleNoInit(Temp);
-    end;
-  end
-  else
-  begin
-    // If the cache is not available then go straight through all nodes up to the root and sum up their heights.
-    Temp := Node;
-    repeat
-      Temp := GetPreviousVisibleNoInit(Temp);
-      if Temp = nil then
-        Break;
-      Inc(Offset, Temp.NodeHeight);
-    until False;
-  end;
-
-  Result := Rect(0, Offset, Max(FRangeX, ClientWidth), Offset + Node.NodeHeight);
-
-  // Limit left and right bounds to the given column (if any) and move bounds according to current scroll state.
-  if Column &gt; NoColumn then
-  begin
-    FHeader.FColumns.GetColumnBounds(Column, Result.Left, Result.Right);
-    // The right column border is not part of this cell.
-    Dec(Result.Right);
-    OffsetRect(Result, 0, FOffsetY);
-  end
-  else
-    OffsetRect(Result, FOffsetX, FOffsetY);
-
-  // Limit left and right bounds further if only the text area is required.
-  if TextOnly then
-  begin
-    // Start with the offset of the text in the column and consider the indentation level too.
-    Offset := FMargin + Indent;
-    // If the text of a node is involved then we have to consider directionality and alignment too.
-    if Column = NoColumn then
-    begin
-      CurrentBidiMode := BidiMode;
-      CurrentAlignment := Alignment;
-    end
-    else
-    begin
-      CurrentBidiMode := FHeader.FColumns[Column].BidiMode;
-      CurrentAlignment := FHeader.FColumns[Column].Alignment;
-    end;
-
-    TextWidth := DoGetNodeWidth(Node, Column);
-
-    if MainColumnHit then
-    begin
-      if toShowRoot in FOptions.FPaintOptions then
-        Inc(Offset, FIndent);
-      if (toCheckSupport in FOptions.FMiscOptions) and Assigned(FCheckImages) and (Node.CheckType &lt;&gt; ctNone) then
-        Inc(Offset, FCheckImages.Width + 2);
-    end;
-    // Consider associated images.
-    if Assigned(FStateImages) and (GetImageIndex(Node, ikState, Column, Ghosted) &gt; -1) then
-      Inc(Offset, FStateImages.Width + 2);
-    if Assigned(FImages) and (GetImageIndex(Node, ikNormal, Column, Ghosted) &gt; -1) then
-      Inc(Offset, FImages.Width + 2);
-
-    // Offset contains now the distance from the left or right border of the rectangle (depending on bidi mode).
-    // Now consider the alignment too and calculate the final result.
-    if CurrentBidiMode = bdLeftToRight then
-    begin
-      Inc(Result.Left, Offset);
-      // Left-to-right reading does not need any special adjustment of the alignment.
-    end
-    else
-    begin
-      Dec(Result.Right, Offset);
-
-      // Consider bidi mode here. In RTL context does left alignment actually mean right alignment and vice versa.
-      ChangeBiDiModeAlignment(CurrentAlignment);
-    end;
-
-    if Unclipped then
-    begin
-      // The caller requested the text coordinates unclipped. This means they must be calculated so as would
-      // there be enough space, regardless of column bounds etc.
-      // The layout still depends on the available space too, because this determines the position
-      // of the unclipped text rectangle.
-      if Result.Right - Result.Left &lt; TextWidth then
-        if CurrentBidiMode = bdLeftToRight then
-          CurrentAlignment := taLeftJustify
-        else
-          CurrentAlignment := taRightJustify;
-
-      case CurrentAlignment of
-        taCenter:
-          begin
-            Result.Left := (Result.Left + Result.Right - TextWidth) div 2;
-            Result.Right := Result.Left + TextWidth;
-          end;
-        taRightJustify:
-          Result.Left := Result.Right - TextWidth;
-      else // taLeftJustify
-        Result.Right := Result.Left + TextWidth;
-      end;
-    end
-    else
-      // Modify rectangle only if the text fits entirely into the given room.
-      if Result.Right - Result.Left &gt; TextWidth then
-        case CurrentAlignment of
-          taCenter:
-            begin
-              Result.Left := (Result.Left + Result.Right - TextWidth) div 2;
-              Result.Right := Result.Left + TextWidth;
-            end;
-          taRightJustify:
-            Result.Left := Result.Right - TextWidth;
-        else // taLeftJustify
-          Result.Right := Result.Left + TextWidth;
-        end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFirst: PVirtualNode;
-
-// Returns the first node in the tree.
-
-begin
-  Result := FRoot.FirstChild;
-  if Assigned(Result) and not (vsInitialized in Result.States) then
-    InitNode(Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFirstChild(Node: PVirtualNode): PVirtualNode;
-
-// Returns the first child of the given node. The result node is initialized before exit.
-
-begin
-  if (Node = nil) or (Node = FRoot) then
-    Result := FRoot.FirstChild
-  else
-  begin
-    if not (vsInitialized in Node.States) then
-      InitNode(Node);
-    if vsHasChildren in Node.States then
-    begin
-      if Node.ChildCount = 0 then
-        InitChildren(Node);
-      Result := Node.FirstChild;
-    end
-    else
-      Result := nil;
-  end;
-  
-  if Assigned(Result) and not (vsInitialized in Result.States) then
-    InitNode(Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFirstCutCopy: PVirtualNode;
-
-// Returns the first node in the tree which is currently marked for a clipboard operation.
-// See also GetNextCutCopy for comments on initialization.
-
-begin
-  Result := GetNextCutCopy(nil);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFirstInitialized: PVirtualNode;
-
-// Returns the first node which is already initialized.
-
-begin
-  Result := FRoot.FirstChild;
-  if Assigned(Result) and not (vsInitialized in Result.States) then
-    Result := GetNextInitialized(Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFirstNoInit: PVirtualNode;
-
-begin
-  Result := FRoot.FirstChild;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFirstSelected: PVirtualNode;
-
-// Returns the first node in the current selection.
-
-begin
-  Result := GetNextSelected(nil);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFirstVisible: PVirtualNode;
-
-// Returns the first visible node in the tree. If necessary nodes are initialized on demand.
-
-begin
-  if vsHasChildren in FRoot.States then
-  begin
-    Result := FRoot;
-
-    if Result.ChildCount = 0 then
-      InitChildren(Result);
-
-    // Child nodes are the first choice if possible.
-    if Assigned(Result.FirstChild) then
-    begin
-      Result := GetFirstChild(Result);
-
-      // If there are no children or the first child is not visible then search the sibling nodes or traverse parents.
-      if not (vsVisible in Result.States) then
-      begin
-        repeat
-          // Is there a next sibling?
-          if Assigned(Result.NextSibling) then
-          begin
-            Result := Result.NextSibling;
-            // The visible state can be removed during initialization so init the node first.
-            if not (vsInitialized in Result.States) then
-              InitNode(Result);
-            if vsVisible in Result.States then
-              Break;
-          end
-          else
-          begin
-            // No sibling anymore, so use the parent's next sibling.
-            if Result.Parent &lt;&gt; FRoot then
-              Result := Result.Parent
-            else
-            begin
-              // There are no further nodes to examine, hence there is no further visible node.
-              Result := nil;
-              Break;
-            end;
-          end;
-        until False;
-      end;
-    end
-    else
-      Result := nil;
-  end
-  else
-    Result := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFirstVisibleChild(Node: PVirtualNode): PVirtualNode;
-
-// Returns the first visible child node of Node. If necessary nodes are initialized on demand.
-
-begin
-  Result := GetFirstChild(Node);
-  if Assigned(Result) and not (vsVisible in Result.States) then
-    Result := GetNextVisibleSibling(Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFirstVisibleChildNoInit(Node: PVirtualNode): PVirtualNode;
-
-// Returns the first visible child node of Node. 
-
-begin
-  if Node = nil then
-    Node := FRoot;
-  Result := Node.FirstChild;
-  if Assigned(Result) and not (vsVisible in Result.States) then
-    Result := GetNextVisibleSiblingNoInit(Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetFirstVisibleNoInit: PVirtualNode;
-
-// Returns the first visible node in the tree. No initialization is performed.
-
-begin
-  if vsHasChildren in FRoot.States then
-  begin
-    Result := FRoot;
-
-    // Child nodes are the first choice if possible.
-    if Assigned(Result.FirstChild) then
-    begin
-      Result := Result.FirstChild;
-
-      // If there are no children or the first child is not visible then search the sibling nodes or traverse parents.
-      if not (vsVisible in Result.States) then
-      begin
-        repeat
-          // Is there a next sibling?
-          if Assigned(Result.NextSibling) then
-          begin
-            Result := Result.NextSibling;
-            if vsVisible in Result.States then
-              Break;
-          end
-          else
-          begin
-            // No sibling anymore, so use the parent's next sibling.
-            if Result.Parent &lt;&gt; FRoot then
-              Result := Result.Parent
-            else
-            begin
-              // There are no further nodes to examine, hence there is no further visible node.
-              Result := nil;
-              Break;
-            end;
-          end;
-        until False;
-      end;
-    end
-    else
-      Result := nil;
-  end
-  else
-    Result := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.GetHitTestInfoAt(X, Y: Integer; Relative: Boolean; var HitInfo: THitInfo);
-
-// Determines the node that occupies the specified point or nil if there's none. The parameter Relative determines
-// whether to consider X and Y as being client coordinates (if True) or as being absolute tree coordinates.
-// HitInfo is filled with flags describing the hit further.
-
-var
-  ColLeft,
-  ColRight: Integer;
-  NodeTop: Integer;
-  InitialColumn,
-  NextColumn: TColumnIndex;
-  CurrentBidiMode: TBidiMode;
-  CurrentAlignment: TAlignment;
-  
-begin
-  HitInfo.HitNode := nil;
-  HitInfo.HitPositions := [];
-  HitInfo.HitColumn := NoColumn;
-
-  // Determine if point lies in the tree's client area.
-  if X &lt; 0 then
-    Include(HitInfo.HitPositions, hiToLeft)
-  else
-    if X &gt; Max(FRangeX, ClientWidth) then
-      Include(HitInfo.HitPositions, hiToRight);
-
-  if Y &lt; 0 then
-    Include(HitInfo.HitPositions, hiAbove)
-  else
-    if Y &gt; Max(FRangeY, ClientHeight) then
-      Include(HitInfo.HitPositions, hiBelow);
-
-  // Convert position into absolute coordinate if necessary.
-  if Relative then
-  begin
-    Inc(X, -FOffsetX);
-    Inc(Y, -FOffsetY);
-  end;
-
-  // If the point is in the tree area then check the nodes.
-  if HitInfo.HitPositions = [] then
-  begin
-    HitInfo.HitNode := GetNodeAt(X, Y, False, NodeTop);
-    if HitInfo.HitNode = nil then
-      Include(HitInfo.HitPositions, hiNowhere)
-    else
-    begin
-      // At this point we need some info about the node, so it must be initialized.
-      if not (vsInitialized in HitInfo.HitNode.States) then
-        InitNode(HitInfo.HitNode);
-
-      if FHeader.UseColumns then
-      begin
-        HitInfo.HitColumn := FHeader.Columns.GetColumnAndBounds(Point(X, Y), ColLeft, ColRight, False);
-        // If auto column spanning is enabled then look for the last non empty column.
-        if toAutoSpanColumns in FOptions.FAutoOptions then
-        begin
-          InitialColumn := HitInfo.HitColumn;
-          // Search to the left of the hit column for empty columns.
-          while (HitInfo.HitColumn &gt; NoColumn) and ColumnIsEmpty(HitInfo.HitNode, HitInfo.HitColumn) do
-          begin
-            NextColumn := FHeader.FColumns.GetPreviousVisibleColumn(HitInfo.HitColumn);
-            if NextColumn = InvalidColumn then
-              Break;
-            HitInfo.HitColumn := NextColumn;
-            Dec(ColLeft, FHeader.FColumns[NextColumn].Width);
-          end;
-          // Search to the right of the hit column for empty columns.
-          repeat
-            InitialColumn := FHeader.FColumns.GetNextVisibleColumn(InitialColumn);
-            if (InitialColumn = InvalidColumn) or not ColumnIsEmpty(HitInfo.HitNode, InitialColumn) then
-              Break;
-            Inc(ColRight, FHeader.FColumns[InitialColumn].Width);
-          until False;
-        end;
-        // Make the X position and the right border relative to the start of the column.
-        Dec(X, ColLeft);
-        Dec(ColRight, ColLeft);
-      end
-      else
-      begin
-        HitInfo.HitColumn := NoColumn;
-        ColRight := Max(FRangeX, ClientWidth);
-      end;
-      ColLeft := 0;
-
-      if HitInfo.HitColumn = InvalidColumn then
-        Include(HitInfo.HitPositions, hiNowhere)
-      else
-      begin
-        // From now on X is in &quot;column&quot; coordinates (relative to the left column border).
-        HitInfo.HitPositions := [hiOnItem];
-        if HitInfo.HitColumn = NoColumn then
-        begin
-          CurrentBidiMode := BidiMode;
-          CurrentAlignment := Alignment;
-        end
-        else
-        begin
-          CurrentBidiMode := FHeader.FColumns[HitInfo.HitColumn].BidiMode;
-          CurrentAlignment := FHeader.FColumns[HitInfo.HitColumn].Alignment;
-        end;
-
-        if CurrentBidiMode = bdLeftToRight then
-          DetermineHitPositionLTR(HitInfo, X, ColRight, CurrentAlignment)
-        else
-          DetermineHitPositionRTL(HitInfo, X, ColRight, CurrentAlignment);
-      end;
-    end; 
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetLast(Node: PVirtualNode = nil): PVirtualNode;
-
-// Returns the very last node in the tree branch given by Node and initializes the nodes all the way down including the
-// result. By using Node = nil the very last node in the tree is returned.
-
-var
-  Next: PVirtualNode;
-  
-begin
-  Result := GetLastChild(Node);
-  while Assigned(Result) do
-  begin
-    // Test if there is a next last child. If not keep the node from the last run.
-    // Otherwise use the next last child.
-    Next := GetLastChild(Result);
-    if Next = nil then
-      Break;
-    Result := Next;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetLastInitialized(Node: PVirtualNode): PVirtualNode;
-
-// Returns the very last initialized child node in the tree branch given by Node.
-
-begin
-  Result := GetLastNoInit(Node);
-  if Assigned(Result) and not (vsInitialized in Result.States) then
-    Result := GetPreviousInitialized(Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetLastNoInit(Node: PVirtualNode = nil): PVirtualNode;
-
-// Returns the very last node in the tree branch given by Node without initialization.
-
-var
-  Next: PVirtualNode;
-
-begin
-  Result := GetLastChildNoInit(Node);
-  while Assigned(Result) do
-  begin
-    // Test if there is a next last child. If not keep the node from the last run.
-    // Otherwise use the next last child.
-    Next := GetLastChildNoInit(Result);
-    if Next = nil then
-      Break;
-    Result := Next;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetLastChild(Node: PVirtualNode): PVirtualNode;
-
-// Determines the last child of the given node and initializes it if there is one. 
-
-begin
-  if (Node = nil) or (Node = FRoot) then
-    Result := FRoot.LastChild
-  else
-  begin
-    if not (vsInitialized in Node.States) then
-      InitNode(Node);
-    if vsHasChildren in Node.States then
-    begin
-      if Node.ChildCount = 0 then
-        InitChildren(Node);
-      Result := Node.LastChild;
-    end
-    else
-      Result := nil;
-  end;
-  
-  if Assigned(Result) and not (vsInitialized in Result.States) then
-    InitNode(Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetLastChildNoInit(Node: PVirtualNode): PVirtualNode;
-
-// Determines the last child of the given node but does not initialize it. 
-
-begin
-  if (Node = nil) or (Node = FRoot) then
-    Result := FRoot.LastChild
-  else
-  begin
-    if vsHasChildren in Node.States then
-      Result := Node.LastChild
-    else
-      Result := nil;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetLastVisible(Node: PVirtualNode = nil): PVirtualNode;
-
-// Returns the very last visible node in the tree and initializes nodes all the way down including the result node.
-
-var
-  Next: PVirtualNode;
-  
-begin
-  Result := GetLastVisibleChild(Node);
-  while Assigned(Result) do
-  begin
-    // Test if there is a next last visible child. If not keep the node from the last run.
-    // Otherwise use the next last visible child.
-    Next := GetLastVisibleChild(Result);
-    if Next = nil then
-      Break;
-    Result := Next;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetLastVisibleChild(Node: PVirtualNode): PVirtualNode;
-
-// Determines the last visible child of the given node and initializes it if necessary.
-
-begin
-  if (Node = nil) or (Node = FRoot) then
-    Result := GetLastChild(FRoot)
-  else
-    if FullyVisible[Node] and (vsExpanded in Node.States) then
-      Result := GetLastChild(Node)
-    else
-      Result := nil;
-
-  if Assigned(Result) and not (vsVisible in Result.States) then
-    Result := GetPreviousVisibleSibling(Result);
-
-  if Assigned(Result) and not (vsInitialized in Result.States) then
-    InitNode(Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetLastVisibleChildNoInit(Node: PVirtualNode): PVirtualNode;
-
-// Determines the last visible child of the given node without initialization.
-
-begin
-  if (Node = nil) or (Node = FRoot) then
-    Result := GetLastChildNoInit(FRoot)
-  else
-    if FullyVisible[Node] and (vsExpanded in Node.States) then
-      Result := GetLastChildNoInit(Node)
-    else
-      Result := nil;
-
-  if Assigned(Result) and not (vsVisible in Result.States) then
-    Result := GetPreviousVisibleSiblingNoInit(Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetLastVisibleNoInit(Node: PVirtualNode = nil): PVirtualNode;
-
-// Returns the very last visible node in the tree without initialization.
-
-var
-  Next: PVirtualNode;
-
-begin
-  Result := GetLastVisibleChildNoInit(Node);
-  while Assigned(Result) do
-  begin
-    // Test if there is a next last visible child. If not keep the node from the last run.
-    // Otherwise use the next last visible child.
-    Next := GetLastVisibleChildNoInit(Result);
-    if Next = nil then
-      Break;
-    Result := Next;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetMaxColumnWidth(Column: TColumnIndex): Integer;
-
-// This method determines the width of the largest node in the given column.
-// Note: Every visible node in the tree will be initialized contradicting so the virtual paradigm.
-
-var
-  Run,
-  NextNode: PVirtualNode;
-  NodeLeft,
-  TextLeft,
-  CurrentWidth: Integer;
-  WithCheck,
-  WithImages,
-  WithStateImages,
-  Ghosted: Boolean;
-  CheckOffset,
-  ImageOffset,
-  StateImageOffset: Integer;
-
-begin
-  Result := 0;
-
-  // Don't check the event here as descendant trees might have overriden the DoGetImageIndex method.
-  WithImages := Assigned(FImages);
-  if WithImages then
-    ImageOffset := FImages.Width + 2
-  else
-    ImageOffset := 0;
-  WithStateImages := Assigned(FStateImages);
-  if WithStateImages then
-    StateImageOffset := FStateImages.Width + 2
-  else
-    StateImageOffset := 0;
-  if Assigned(FCheckImages) then
-    CheckOffset := FCheckImages.Width + 2
-  else
-    CheckOffset := 0;
-
-  Run := GetFirstVisible;
-  if Column = FHeader.MainColumn then
-  begin
-    if toShowRoot in FOptions.FPaintOptions then
-      NodeLeft := Integer((GetNodeLevel(Run) + 1) * FIndent)
-    else
-      NodeLeft := Integer(GetNodeLevel(Run) * FIndent);
-
-    WithCheck := (toCheckSupport in FOptions.FMiscOptions) and Assigned(FCheckImages);
-  end
-  else
-  begin
-    NodeLeft := 0;
-    WithCheck := False;
-  end;
-
-  // Leave a margin at both sides of the nodes.
-  Inc(NodeLeft, 2 * FMargin);
-
-  while Assigned(Run) do
-  begin
-    TextLeft := NodeLeft;
-    if WithCheck and (Run.CheckType &lt;&gt; ctNone) then
-      Inc(TextLeft, CheckOffset);
-    if WithImages and (GetImageIndex(Run, ikNormal, Column, Ghosted) &gt; -1) then
-      Inc(TextLeft, ImageOffset);
-    if WithStateImages and (GetImageIndex(Run, ikState, Column, Ghosted) &gt; -1) then
-      Inc(TextLeft, StateImageOffset);
-
-    CurrentWidth := DoGetNodeWidth(Run, Column);
-
-    if Result &lt; (TextLeft + CurrentWidth) then
-      Result := TextLeft + CurrentWidth;
-
-    // Get next visible node and update left node position if needed.
-    NextNode := GetNextVisible(Run);
-    if NextNode = nil then
-      Break;
-    if Column = Header.MainColumn then
-      Inc(NodeLeft, CountLevelDifference(Run, NextNode) * Integer(FIndent));
-    Run := NextNode;
-  end;
-  if toShowVertGridLines in FOptions.FPaintOptions then
-    Inc(Result)
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNext(Node: PVirtualNode): PVirtualNode;
-
-// Returns next node in tree (advances to next sibling of the node's parent or its parent, if necessary).
-
-begin
-  Result := Node;
-  if Assigned(Result) then
-  begin
-    Assert(Result &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-    // Has this node got children?
-    if vsHasChildren in Result.States then
-    begin
-      // Yes, there are child nodes. Initialize them if necessary.
-      if Result.ChildCount = 0 then
-        InitChildren(Result);
-    end;
-
-    // if there is no child node try siblings
-    if Assigned(Result.FirstChild) then
-      Result := Result.FirstChild
-    else
-    begin
-      repeat
-        // Is there a next sibling?
-        if Assigned(Result.NextSibling) then
-        begin
-          Result := Result.NextSibling;
-          Break;
-        end
-        else
-        begin
-          // No sibling anymore, so use the parent's next sibling.
-          if Result.Parent &lt;&gt; FRoot then
-            Result := Result.Parent
-          else
-          begin
-            // There are no further nodes to examine, hence there is no further visible node.
-            Result := nil;
-            Break;
-          end;
-        end;
-      until False;
-    end;
-
-    if Assigned(Result) and not (vsInitialized in Result.States) then
-      InitNode(Result);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNextCutCopy(Node: PVirtualNode): PVirtualNode;
-
-// Returns the next node in the tree which is currently marked for a clipboard operation. Since only visible nodes can
-// be marked (or they are hidden after they have been marked) it is not necessary to initialize nodes to check for
-// child nodes. The result, however, is initialized if necessary.
-
-begin
-  if ClipboardStates * FStates &lt;&gt; [] then
-  begin
-    if (Node = nil) or (Node = FRoot) then
-      Result := FRoot.FirstChild
-    else
-      Result := GetNextNoInit(Node);
-    while Assigned(Result) and not (vsCutOrCopy in Result.States) do
-      Result := GetNextNoInit(Result);
-    if Assigned(Result) and not (vsInitialized in Result.States) then
-      InitNode(Result);
-  end
-  else
-    Result := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNextInitialized(Node: PVirtualNode): PVirtualNode;
-
-// Returns the next node in tree which is initialized.
-
-begin
-  Result := Node;
-  repeat
-    Result := GetNextNoInit(Result);
-  until (Result = nil) or (vsInitialized in Result.States);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNextNoInit(Node: PVirtualNode): PVirtualNode;
-
-// optimized variant of GetNext, no initialization of nodes is performed (if a node is not initialized
-// then it is considered as not being there)
-
-begin
-  Result := Node;
-  if Assigned(Result) then
-  begin
-    Assert(Result &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-    // if there is no child node try siblings
-    if Assigned(Result.FirstChild) then
-      Result := Result.FirstChild
-    else
-    begin
-      repeat
-        // Is there a next sibling?
-        if Assigned(Result.NextSibling) then
-        begin
-          Result := Result.NextSibling;
-          Break;
-        end
-        else
-        begin
-          // No sibling anymore, so use the parent's next sibling.
-          if Result.Parent &lt;&gt; FRoot then
-            Result := Result.Parent
-          else
-          begin
-            // There are no further nodes to examine, hence there is no further visible node.
-            Result := nil;
-            Break;
-          end;
-        end;
-      until False;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNextSelected(Node: PVirtualNode): PVirtualNode;
-
-// Returns the next node in the tree which is currently selected. Since children of unitialized nodes cannot be
-// in the current selection (because they simply do not exist yet) it is not necessary to initialize nodes here. 
-// The result however is initialized if necessary.
-
-begin
-  if FSelectionCount &gt; 0 then
-  begin
-    if (Node = nil) or (Node = FRoot) then
-      Result := FRoot.FirstChild
-    else
-      Result := GetNextNoInit(Node);
-    while Assigned(Result) and not (vsSelected in Result.States) do
-      Result := GetNextNoInit(Result);
-    if Assigned(Result) and not (vsInitialized in Result.States) then
-      InitNode(Result);
-  end
-  else
-    Result := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNextSibling(Node: PVirtualNode): PVirtualNode;
-
-// Returns the next sibling of Node and initializes it if necessary.
-
-begin
-  Result := Node;
-  if Assigned(Result) then
-  begin
-    Assert(Result &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-    Result := Node.NextSibling;
-    if Assigned(Result) and not (vsInitialized in Result.States) then
-      InitNode(Result);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNextVisible(Node: PVirtualNode): PVirtualNode;
-
-// Returns next node in tree, with regard to Node, which is visible.
-// Nodes which need an initialization (including the result) are initialized.
-
-var
-  ForceSearch: Boolean;
-
-begin
-  Result := Node;
-  if Assigned(Result) then
-  begin
-    Assert(Result &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-    // If the given node is not visible then look for a parent node which is visible, otherwise we will
-    // likely go unnecessarily through a whole bunch of invisible nodes.
-    if not FullyVisible[Result] then
-      Result := GetVisibleParent(Result);
-
-    // Has this node got children?
-    if [vsHasChildren, vsExpanded] * Result.States = [vsHasChildren, vsExpanded] then
-    begin
-      // Yes, there are child nodes. Initialize them if necessary.
-      if Result.ChildCount = 0 then
-        InitChildren(Result);
-    end;
-
-    // Child nodes are the first choice if possible.
-    if (vsExpanded in Result.States) and Assigned(Result.FirstChild) then
-    begin
-      Result := GetFirstChild(Result);
-      ForceSearch := False;
-    end
-    else
-      ForceSearch := True;
-
-    // If there are no children or the first child is not visible then search the sibling nodes or traverse parents.
-    if Assigned(Result) and (ForceSearch or not (vsVisible in Result.States)) then
-    begin
-      repeat
-        // Is there a next sibling?
-        if Assigned(Result.NextSibling) then
-        begin
-          Result := Result.NextSibling;
-          if not (vsInitialized in Result.States) then
-            InitNode(Result);
-          if vsVisible in Result.States then
-            Break;
-        end
-        else
-        begin
-          // No sibling anymore, so use the parent's next sibling.
-          if Result.Parent &lt;&gt; FRoot then
-            Result := Result.Parent
-          else
-          begin
-            // There are no further nodes to examine, hence there is no further visible node.
-            Result := nil;
-            Break;
-          end;
-        end;
-      until False;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNextVisibleNoInit(Node: PVirtualNode): PVirtualNode;
-
-// Returns the next node in tree, with regard to Node, which is visible.
-// No initialization is done.
-
-var
-  ForceSearch: Boolean;
-
-begin
-  Result := Node;
-  if Assigned(Result) then
-  begin
-    Assert(Result &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-    // If the given node is not visible then look for a parent node which is visible, otherwise we will
-    // likely go unnecessarily through a whole bunch of invisible nodes.
-    if not FullyVisible[Result] then
-      Result := GetVisibleParent(Result);
-
-    // Child nodes are the first choice if possible.
-    if (vsExpanded in Result.States) and Assigned(Result.FirstChild) then
-    begin
-      Result := Result.FirstChild;
-      ForceSearch := False;
-    end
-    else
-      ForceSearch := True;
-
-    // If there are no children or the first child is not visible then search the sibling nodes or traverse parents.
-    if ForceSearch or not (vsVisible in Result.States) then
-    begin
-      repeat
-        // Is there a next sibling?
-        if Assigned(Result.NextSibling) then
-        begin
-          Result := Result.NextSibling;
-          if vsVisible in Result.States then
-            Break;
-        end
-        else
-        begin
-          // No sibling anymore, so use the parent's next sibling.
-          if Result.Parent &lt;&gt; FRoot then
-            Result := Result.Parent
-          else
-          begin
-            // There are no further nodes to examine, hence there is no further visible node.
-            Result := nil;
-            Break;
-          end;
-        end;
-      until False;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNextVisibleSibling(Node: PVirtualNode): PVirtualNode;
-
-// Returns the next visible sibling after Node. Initialization is done implicitly.
-
-begin
-  Assert(Assigned(Node) and (Node &lt;&gt; FRoot), 'Invalid parameter.');
-
-  Result := Node;
-  repeat
-    Result := GetNextSibling(Result);
-  until (Result = nil) or (vsVisible in Result.States);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNextVisibleSiblingNoInit(Node: PVirtualNode): PVirtualNode;
-
-// Returns the next visible sibling after Node.
-
-begin
-  Assert(Assigned(Node) and (Node &lt;&gt; FRoot), 'Invalid parameter.');
-
-  Result := Node;
-  repeat
-    Result := Result.NextSibling;
-  until (Result = nil) or (vsVisible in Result.States);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNodeAt(X, Y: Integer): PVirtualNode;
-
-// Overloaded variant of GetNodeAt to easy life of application developers which do not need to have the exact
-// top position returned and always use client coordinates.
-
-var
-  Dummy: Integer;
-
-begin
-  Result := GetNodeAt(X, Y, True, Dummy);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNodeAt(X, Y: Integer; Relative: Boolean; var NodeTop: Integer): PVirtualNode;
-
-// This method returns the node that occupies the specified point, or nil if there's none.
-// If Releative is True then X and Y are given in client coordinates otherwise they are considered as being
-// absolute values into the virtual tree image (regardless of the current offsets in the tree window).
-// NodeTop gets the absolute or relative top position of the node returned or is untouched if no node
-// could be found.
-
-var
-  AbsolutePos,
-  CurrentPos: Cardinal;
-
-begin
-  if Y &lt; 0 then
-    Y := 0;
-    
-  AbsolutePos := Y;
-  if Relative then
-    Inc(AbsolutePos, -FOffsetY);
-
-  // CurrentPos tracks a running term of the current position to test for.
-  // It corresponds always to the top position of the currently considered node.
-  CurrentPos := 0;
-
-  // If the cache is available then use it.
-  if tsUseCache in FStates then
-    Result := FindInPositionCache(AbsolutePos, CurrentPos)
-  else
-    Result := GetFirstVisibleNoInit;
-
-  // Determine node, of which position and height corresponds to the scroll position most closely.
-  while Assigned(Result) and (Result &lt;&gt; FRoot) do
-  begin
-    if (vsVisible in Result.States) and (AbsolutePos &lt; (CurrentPos + Result.TotalHeight)) then
-    begin
-      // Found a node which covers the given position. Now go down one level
-      // and search its children (if any, otherwise stop looking).
-      if (AbsolutePos &gt;= CurrentPos + Result.NodeHeight) and Assigned(Result.FirstChild) and
-         (vsExpanded in Result.States) then
-      begin
-        Inc(CurrentPos, Result.NodeHeight);
-        Result := Result.FirstChild;
-        Continue;
-      end
-      else
-        Break;
-    end
-    else
-    begin
-      // Advance current position to after the current node, if the node is visible.
-      if vsVisible in Result.States then
-        Inc(CurrentPos, Result.TotalHeight); 
-      // Find following node not being a child of the currently considered node (e.g. a sibling or parent).
-      repeat
-        // Is there a next sibling?
-        if Assigned(Result.NextSibling) then
-        begin
-          Result := Result.NextSibling;
-          if vsVisible in Result.States then
-            Break;
-        end
-        else
-        begin
-          // No sibling anymore, so use the parent's next sibling.
-          if Result.Parent &lt;&gt; FRoot then
-            Result := Result.Parent
-          else
-          begin
-            // There are no further nodes to examine, hence there is no further visible node.
-            Result := nil;
-            Break;
-          end;
-        end;
-      until False;
-    end;
-  end;
-
-  if Result = FRoot then
-    Result := nil;
-
-  // Since the given vertical position is likely not the same as the top position
-  // of the found node this top position is returned.
-  if Assigned(Result) then
-  begin
-    NodeTop := CurrentPos;
-    if Relative then
-      Inc(NodeTop, FOffsetY);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNodeData(Node: PVirtualNode): Pointer;
-
-// Returns the address of the user defined data area in the node.
-
-begin
-  Assert(FNodeDataSize &gt; 0, 'NodeDataSize not initialized.');
-  
-  if (FNodeDataSize &lt;= 0) or (Node = nil) or (Node = FRoot) then
-    Result := nil
-  else
-    Result := PChar(@Node.Data) + FTotalInternalDataSize;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetNodeLevel(Node: PVirtualNode): Cardinal;
-
-// returns the level of the given node
-
-var
-  Run: PVirtualNode;
-  
-begin
-  Result := 0;
-  if Assigned(Node) and (Node &lt;&gt; FRoot) then
-  begin
-    Run := Node.Parent;
-    while Run &lt;&gt; FRoot do
-    begin
-      Run := Run.Parent;
-      Inc(Result);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetPrevious(Node: PVirtualNode): PVirtualNode;
-
-// Resturns previous node in tree with regard to Node. The result node is initialized if necessary. 
-
-begin
-  Result := Node;
-  if Assigned(Result) then
-  begin
-    Assert(vsInitialized in Result.States, 'Node must already be initialized.');
-    Assert(Result &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-    // Is there a previous sibling?
-    if Assigned(Node.PrevSibling) then
-    begin
-      // Go down and find the last child node.
-      Result := GetLast(Node.PrevSibling);
-      if Result = nil then
-        Result := Node.PrevSibling;
-    end
-    else
-      // no previous sibling so the parent of the node is the previous visible node
-      if Node.Parent &lt;&gt; FRoot then
-        Result := Node.Parent
-      else
-        Result := nil;
-
-    if Assigned(Result) and not (vsInitialized in Result.States) then
-      InitNode(Result);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetPreviousInitialized(Node: PVirtualNode): PVirtualNode;
-
-// Returns the previous node in tree which is initialized.
-
-begin
-  Result := Node;
-  repeat
-    Result := GetPreviousNoInit(Result);
-  until (Result = nil) or (vsInitialized in Result.States);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetPreviousNoInit(Node: PVirtualNode): PVirtualNode;
-
-// Returns the previous node in the tree with regard to Node. No initialization in done, hence this
-// method might be faster than GetPrevious. Not yet initialized nodes are ignored during search.
-
-begin
-  Result := Node;
-  if Assigned(Result) then
-  begin
-    Assert(Result &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-    // Is there a previous sibling?
-    if Assigned(Node.PrevSibling) then
-    begin
-      // Go down and find the last child node.
-      Result := GetLastNoInit(Node.PrevSibling);
-      if Result = nil then
-        Result := Node.PrevSibling;
-    end
-    else
-      // No previous sibling so the parent of the node is the previous node.
-      if Node.Parent &lt;&gt; FRoot then
-        Result := Node.Parent
-      else
-        Result := nil
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetPreviousSibling(Node: PVirtualNode): PVirtualNode;
-
-// get next sibling of Node, initialize it if necessary
-
-begin
-  if Assigned(Node) and (Node &lt;&gt; FRoot) then
-  begin
-    Result := Node.PrevSibling;
-    if Assigned(Result) and not (vsInitialized in Result.States) then
-      InitNode(Result);
-  end
-  else
-    Result := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetPreviousVisible(Node: PVirtualNode): PVirtualNode;
-
-// Returns the previous node in tree, with regard to Node, which is visible.
-// Nodes which need an initialization (including the result) are initialized.
-
-var
-  Marker: PVirtualNode;
-
-begin
-  Result := Node;
-  if Assigned(Result) then
-  begin
-    Assert(vsInitialized in Result.States, 'Node must already be initialized.');
-    Assert(Result &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-    // If the given node is not visible then look for a parent node which is visible and use its last visible
-    // child or the parent node (if there is no visible child) as result.
-    if not FullyVisible[Result] then
-    begin
-      Result := GetVisibleParent(Result);
-      if Result = FRoot then
-        Result := nil;
-      Marker := GetLastVisible(Result);
-      if Assigned(Marker) then
-        Result := Marker;
-    end
-    else
-    begin
-      repeat
-        // Is there a previous sibling node?
-        if Assigned(Result.PrevSibling) then
-        begin
-          Result := Result.PrevSibling;
-          // Initialize the new node and check its visibility.
-          if not (vsInitialized in Result.States) then
-            InitNode(Result);
-          if vsVisible in Result.States then
-          begin
-            // If there are visible child nodes then use the last one.
-            Marker := GetLastVisible(Result);
-            if Assigned(Marker) then
-              Result := Marker;
-            Break;
-          end;
-        end
-        else
-        begin
-          // No previous sibling there so the parent node is the nearest previous node.
-          Result := Result.Parent;
-          if Result = FRoot then
-            Result := nil;
-          Break;
-        end;
-      until False;
-      
-      if Assigned(Result) and not (vsInitialized in Result.States) then
-        InitNode(Result);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetPreviousVisibleNoInit(Node: PVirtualNode): PVirtualNode;
-
-// Returns the previous node in tree, with regard to Node, which is visible.
-
-var
-  Marker: PVirtualNode;
-
-begin
-  Result := Node;
-  if Assigned(Result) then
-  begin
-    Assert(Result &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-    // If the given node is not visible then look for a parent node which is visible and use its last visible
-    // child or the parent node (if there is no visible child) as result.
-    if not FullyVisible[Result] then
-    begin
-      Result := GetVisibleParent(Result);
-      if Result = FRoot then
-        Result := nil;
-      Marker := GetLastVisibleNoInit(Result);
-      if Assigned(Marker) then
-        Result := Marker;
-    end
-    else
-    begin
-      repeat
-        // Is there a previous sibling node?
-        if Assigned(Result.PrevSibling) then
-        begin
-          Result := Result.PrevSibling;
-          if vsVisible in Result.States then
-          begin
-            // If there are visible child nodes then use the last one.
-            Marker := GetLastVisibleNoInit(Result);
-            if Assigned(Marker) then
-              Result := Marker;
-            Break;
-          end;
-        end
-        else
-        begin
-          // No previous sibling there so the parent node is the nearest previous node.
-          Result := Result.Parent;
-          if Result = FRoot then
-            Result := nil;
-          Break;
-        end;
-      until False;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetPreviousVisibleSibling(Node: PVirtualNode): PVirtualNode;
-
-// Returns the previous visible sibling before Node. Initialization is done implicitly.
-
-begin
-  Assert(Assigned(Node) and (Node &lt;&gt; FRoot), 'Invalid parameter.');
-
-  Result := Node;
-  repeat
-    Result := GetPreviousSibling(Result);
-  until (Result = nil) or (vsVisible in Result.States);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetPreviousVisibleSiblingNoInit(Node: PVirtualNode): PVirtualNode;
-
-// Returns the previous visible sibling before Node. 
-
-begin
-  Assert(Assigned(Node) and (Node &lt;&gt; FRoot), 'Invalid parameter.');
-
-  Result := Node;
-  repeat
-    Result := Result.PrevSibling;
-  until (Result = nil) or (vsVisible in Result.States);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetSortedCutCopySet(Resolve: Boolean): TNodeArray;
-
-// Same as GetSortedSelection but with nodes marked as being part in the current cut/copy set (e.g. for clipboard).
-
-var
-  Run: PVirtualNode;
-  Counter: Cardinal;
-
-  //--------------- local function --------------------------------------------
-
-  procedure IncludeThisNode(Node: PVirtualNode);
-
-  // adds the given node to the result
-
-  var
-    Len: Cardinal;
-
-  begin
-    Len := Length(Result);
-    if Counter = Len then
-    begin
-      if Len &lt; 100 then
-        Len := 100
-      else
-        Len := Len + Len div 10;
-      SetLength(Result, Len);
-    end;
-    Result[Counter] := Node;
-    Inc(Counter);
-  end;
-
-  //--------------- end local function ----------------------------------------
-
-begin
-  Run := FRoot.FirstChild;
-  Counter := 0;
-  if Resolve then
-  begin
-    // Resolving is actually easy: just find the first cutted node in logical order
-    // and then never go deeper in level than this node as long as there's a sibling node.
-    // Restart the search for a cutted node (at any level) if there are no further siblings.
-    while Assigned(Run) do
-    begin
-      if vsCutOrCopy in Run.States then
-      begin
-        IncludeThisNode(Run);
-        if Assigned(Run.NextSibling) then
-          Run := Run.NextSibling
-        else
-        begin
-          // If there are no further siblings then go up one or more levels until a node is
-          // found or all nodes have been processed. Although we consider here only initialized
-          // nodes we don't need to make any special checks as only initialized nodes can also be selected.
-          repeat
-            Run := Run.Parent;
-          until (Run = FRoot) or Assigned(Run.NextSibling);
-          if Run = FRoot then
-            Break
-          else
-            Run := Run.NextSibling;
-        end;
-      end
-      else
-        Run := GetNextNoInit(Run);
-    end;
-  end
-  else
-    while Assigned(Run) do
-    begin
-      if vsCutOrCopy in Run.States then
-        IncludeThisNode(Run);
-      Run := GetNextNoInit(Run);
-    end;
-    
-  // set the resulting array to its real length
-  SetLength(Result, Counter);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetSortedSelection(Resolve: Boolean): TNodeArray;
-
-// Returns a list of selected nodes sorted in logical order, that is, as they appear in the tree.
-// If Resolve is True then nodes which are children of other selected nodes are not put into the new array.
-// This feature is in particuar important when doing drag'n drop as in this case all selected node plus their children
-// need to be considered. A selected node which is child (grand child etc.) of another selected node is then
-// automatically included and doesn't need to be explicitely mentioned in the returned selection array.
-//
-// Note: The caller is responsible for freeing the array. Allocation is done here. Usually, though, freeing the array
-//       doesn't need additional attention as it is automatically freed by Delphi when it gets out of scope.
-
-var
-  Run: PVirtualNode;
-  Counter: Cardinal;
-
-begin
-  SetLength(Result, FSelectionCount);
-  if FSelectionCount &gt; 0 then
-  begin
-    Run := FRoot.FirstChild;
-    Counter := 0;
-    if Resolve then
-    begin
-      // Resolving is actually easy: just find the first selected node in logical order
-      // and then never go deeper in level than this node as long as there's a sibling node.
-      // Restart the search for a selected node (at any level) if there are no further siblings.
-      while Assigned(Run) do
-      begin
-        if vsSelected in Run.States then
-        begin
-          Result[Counter] := Run;
-          Inc(Counter);
-          if Assigned(Run.NextSibling) then
-            Run := Run.NextSibling
-          else
-          begin
-            // If there are no further siblings then go up one or more levels until a node is
-            // found or all nodes have been processed. Although we consider here only initialized
-            // nodes we don't need to make any special checks as only initialized nodes can also be selected.
-            repeat
-              Run := Run.Parent;
-            until (Run = FRoot) or Assigned(Run.NextSibling);
-            if Run = FRoot then
-              Break
-            else
-              Run := Run.NextSibling;
-          end;
-        end
-        else
-          Run := GetNextNoInit(Run);
-      end;
-    end
-    else
-      while Assigned(Run) do
-      begin
-        if vsSelected in Run.States then
-        begin
-          Result[Counter] := Run;
-          Inc(Counter);
-        end;
-        Run := GetNextNoInit(Run);
-      end;
-
-    // Since we may have skipped some nodes the result array is likely to be smaller than the
-    // selection array, hence shorten the result to true length.
-    if Integer(Counter) &lt; Length(Result) then
-      SetLength(Result, Counter);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetTreeRect: TRect;
-
-// Returns the true size of the tree in pixels. This size is at least ClientHeight x ClientWidth and depends on
-// the expand state, header size etc.
-// Note: if no columns are used then the width of the tree is determined by the largest node which is currently in the
-//       client area. This might however not be the largest node in the entire tree.
-
-begin
-  Result := Rect(0, 0, Max(FRangeX, ClientWidth), Max(FRangeY, ClientHeight));
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.GetVisibleParent(Node: PVirtualNode): PVirtualNode;
-
-// Returns the first (nearest) parent node of Node which is visible.
-// This method is one of the seldom cases where the hidden root node could be returned.
-
-begin
-  Assert(Assigned(Node), 'Node must not be nil.');
-
-  Result := Node;
-  while Result &lt;&gt; FRoot do
-  begin
-    // FRoot is always expanded hence the loop will safely stop there if no other node is expanded
-    repeat
-      Result := Result.Parent;
-    until vsExpanded in Result.States;
-
-    if (Result = FRoot) or FullyVisible[Result] then
-      Break;
-
-    // if there is still a collapsed parent node then advance to it and repeat the entire loop
-    while (Result &lt;&gt; FRoot) and (vsExpanded in Result.Parent.States) do
-      Result := Result.Parent;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.HasAsParent(Node, PotentialParent: PVirtualNode): Boolean;
-
-// Determines whether Node has got PotentialParent as one of its parents.
-
-var
-  Run: PVirtualNode;
-
-begin
-  Result := Assigned(Node) and Assigned(PotentialParent) and (Node &lt;&gt; PotentialParent);
-  if Result then
-  begin
-    Run := Node;
-    while (Run &lt;&gt; FRoot) and (Run &lt;&gt; PotentialParent) do
-      Run := Run.Parent;
-    Result := Run = PotentialParent;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.InsertNode(Node: PVirtualNode; Mode: TVTNodeAttachMode; UserData: Pointer = nil): PVirtualNode;
-
-// Adds a new node relative to Node. The final position is determined by Mode. 
-// UserData can be used to set the first 4 bytes of the user data area to an initial value which can be used
-// in OnInitNode and will also cause to trigger the OnFreeNode event (if &lt;&gt; nil) even if the node is not yet
-// &quot;officially&quot; initialized.
-// InsertNode is a compatibility method and will implicitly validate the given node if the new node
-// is to be added as child node. This is however against the virtual paradigm and hence I dissuade from its usage.
-
-var
-  NodeData: ^Pointer;
-
-begin
-  if Mode &lt;&gt; amNoWhere then
-  begin
-    CancelEditNode;
-
-    if Node = nil then
-      Node := FRoot;
-    // we need a new node...
-    Result := MakeNewNode;
-    // avoid erronous attach modes
-    if Node = FRoot then
-    begin
-      case Mode of
-        amInsertBefore:
-          Mode := amAddChildFirst;
-        amInsertAfter:
-          Mode := amAddChildLast;
-      end;
-    end;
-
-    // Validate given node in case the new node becomes its child.
-    if (Mode in [amAddChildFirst, amAddChildLast]) and not (vsInitialized in Node.States) then
-      InitNode(Node);
-    InternalConnectNode(Result, Node, Self, Mode);
-
-    // Check if there is initial user data and there is also enough user data space allocated.
-    if Assigned(UserData) then
-      if FNodeDataSize &gt;= 4 then
-      begin
-        NodeData := Pointer(PChar(@Result.Data) + FTotalInternalDataSize);
-        NodeData^ := UserData;                                        
-        Include(Result.States, vsInitialUserData);
-      end
-      else
-        ShowError(SCannotSetUserData, hcTFCannotSetUserData);
-
-    if FUpdateCount = 0 then
-    begin
-      // If auto sort is enabled then sort the node or its parent (depending on the insert mode).
-      if (toAutoSort in FOptions.FAutoOptions) and (FHeader.FSortColumn &gt; InvalidColumn) then
-        case Mode of
-          amInsertBefore,
-          amInsertAfter:
-            // Here no initialization is necessary because *if* a node has already got children then it
-            // must also be initialized.
-            // Note: Node can never be FRoot at this point.
-            Sort(Node.Parent, FHeader.FSortColumn, FHeader.FSortDirection, True);
-          amAddChildFirst,
-          amAddChildLast:
-            Sort(Node, FHeader.FSortColumn, FHeader.FSortDirection, True);
-        end;
-
-      UpdateScrollbars(True);
-      if Mode = amInsertBefore then
-        InvalidateToBottom(Result)
-      else
-        InvalidateToBottom(Node);
-    end;
-    StructureChange(Result, crNodeAdded);
-  end
-  else
-    Result := nil;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InvalidateChildren(Node: PVirtualNode; Recursive: Boolean);
-
-// Invalidates Node and its immediate children.
-// If Recursive is True then all grandchildren are invalidated as well.
-// The node itself is initialized if necessary and its child nodes are created (and initialized too if
-// Recursive is True).
-
-var
-  Run: PVirtualNode;
-
-begin
-  if Assigned(Node) then
-  begin
-    if not (vsInitialized in Node.States) then
-      InitNode(Node);
-    InvalidateNode(Node);
-    if (vsHasChildren in Node.States) and (Node.ChildCount = 0) then
-      InitChildren(Node);
-    Run := Node.FirstChild;
-  end
-  else
-    Run := FRoot.FirstChild;
-    
-  while Assigned(Run) do
-  begin
-    InvalidateNode(Run);
-    if Recursive then
-      InvalidateChildren(Run, True);
-    Run := Run.NextSibling;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InvalidateColumn(Column: TColumnIndex);
-
-// Invalidates the client area part of a column.
-
-var
-  R: TRect;
-
-begin
-  if (FUpdateCount = 0) and FHeader.Columns.IsValidColumn(Column) then
-  begin
-    R := ClientRect;
-    FHeader.Columns.GetColumnBounds(Column, R.Left, R.Right);
-    InvalidateRect(Handle, @R, False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.InvalidateNode(Node: PVirtualNode): TRect;
-
-// Initiates repaint of the given node and returns the just invalidated rectangle.
-
-begin
-  if (FUpdateCount = 0) and HandleAllocated then
-  begin
-    Result := GetDisplayRect(Node, NoColumn, False);
-    InvalidateRect(Handle, @Result, False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InvalidateToBottom(Node: PVirtualNode);
-
-// Initiates repaint of client area starting at given node. If this node is not visible or not yet initialized
-// then nothing happens.
-
-var
-  R: TRect;
-
-begin
-  if FUpdateCount = 0 then
-  begin
-    if (Node = nil) or (Node = FRoot) then
-      Invalidate
-    else
-      if [vsInitialized, vsVisible] * Node.States = [vsInitialized, vsVisible] then
-      begin
-        R := GetDisplayRect(Node, -1, False);
-        if R.Top &lt; ClientHeight then
-        begin
-          R.Bottom := ClientHeight;
-          InvalidateRect(Handle, @R, False);
-        end;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.InvertSelection(VisibleOnly: Boolean);
-
-// Inverts the current selection (so nodes which are selected become unselected and vice versa).
-// If VisibleOnly is True then only visible nodes are considered.
-
-var
-  Run: PVirtualNode;
-  NewSize: Integer;
-  NextFunction: function(Node: PVirtualNode): PVirtualNode of object;
-  TriggerChange: Boolean;
-
-begin
-  if toMultiSelect in FOptions.FSelectionOptions then
-  begin
-    Run := FRoot.FirstChild;
-    ClearTempCache;
-    if VisibleOnly then
-      NextFunction := GetNextVisibleNoInit
-    else
-      NextFunction := GetNextNoInit;
-    while Assigned(Run) do
-    begin
-      if vsSelected in Run.States then
-        InternalRemoveFromSelection(Run)
-      else
-        InternalCacheNode(Run);
-      Run := NextFunction(Run);
-    end;
-
-    // do some housekeeping
-    // Need to trigger the OnChange event from here if nodes were only deleted but not added.
-    TriggerChange := False;
-    NewSize := PackArray(FSelection, FSelectionCount);
-    if NewSize &gt; -1 then
-    begin
-      FSelectionCount := NewSize;
-      SetLength(FSelection, FSelectionCount);
-      TriggerChange := True;
-    end;
-    if FTempNodeCount &gt; 0 then
-    begin
-      AddToSelection(FTempNodeCache, FTempNodeCount);
-      ClearTempCache;
-      TriggerChange := False;
-    end;
-    Invalidate;
-    if TriggerChange then
-      Change(nil);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.IsEditing: Boolean;
-
-begin
-  Result := tsEditing in FStates;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.IsMouseSelecting: Boolean;
-
-begin
-  Result := (tsDrawSelPending in FStates) or (tsDrawSelecting in FStates);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.IterateSubtree(Node: PVirtualNode; Callback: TVTGetNodeProc; Data: Pointer;
-  Filter: TVirtualNodeStates = []; DoInit: Boolean = False; ChildNodesOnly: Boolean = False): PVirtualNode;
-
-// Iterates through the all children and grandchildren etc. of Node (or the entire tree if Node = nil)
-// and calls for each node the provided callback method (which must not be empty).
-// Filter determines which nodes to consider (an empty set denotes all nodes).
-// If DoInit is True then nodes which aren't initialized yet will be initialized.
-// Note: During execution of the callback the application can set Abort to True. In this case the iteration is stopped
-//       and the last accessed node (the one on which the callback set Abort to True) is returned to the caller.
-//       Otherwise (no abort) nil is returned.
-
-var
-  Stop: PVirtualNode;
-  Abort: Boolean;
-  GetNextNode: TGetNextNodeProc;
-  WasIterating: Boolean;
-  
-begin
-  Assert(Node &lt;&gt; FRoot, 'Node must not be the hidden root node.');
-
-  WasIterating := tsIterating in FStates;
-  DoStateChange([tsIterating]);
-  try
-    // prepare function to be used when advancing
-    if DoInit then
-      GetNextNode := GetNext
-    else
-      GetNextNode := GetNextNoInit;
-
-    Abort := False;
-    if Node = nil then
-      Stop := nil
-    else
-    begin
-      if not (vsInitialized in Node.States) and DoInit then
-        InitNode(Node);
-
-      // The stopper does not need to be initialized since it is not taken into the enumeration.
-      Stop := Node.NextSibling;
-      if Stop = nil then
-      begin
-        Stop := Node;
-        repeat
-          Stop := Stop.Parent;
-        until (Stop = FRoot) or Assigned(Stop.NextSibling);
-        if Stop = FRoot then
-          Stop := nil
-        else
-          Stop := Stop.NextSibling;
-      end;
-    end;
-
-    // Use first node if we start with the root.
-    if Node = nil then
-      Node := GetFirstNoInit;
-
-    if Assigned(Node) then
-    begin
-      if not (vsInitialized in Node.States) and DoInit then
-        InitNode(Node);
-
-      // Skip given node if only the child nodes are requested.
-      if ChildNodesOnly then
-      begin
-        if Node.ChildCount = 0 then
-          Node := nil
-        else
-          Node := GetNextNode(Node);
-      end;
-
-      if Filter = [] then
-      begin
-        // unfiltered loop
-        while Assigned(Node) and (Node &lt;&gt; Stop) do
-        begin
-          Callback(Self, Node, Data, Abort);
-          if Abort then
-            Break;
-          Node := GetNextNode(Node);
-        end;
-      end
-      else
-      begin
-        // filtered loop
-        while Assigned(Node) and (Node &lt;&gt; Stop) do
-        begin
-          if Node.States * Filter = Filter then
-            Callback(Self, Node, Data, Abort);
-          if Abort then
-            Break;
-          Node := GetNextNode(Node)
-        end;
-      end;
-    end;
-  
-    if Abort then
-      Result := Node
-    else
-      Result := nil;
-  finally
-    if not WasIterating then
-      DoStateChange([], [tsIterating]);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.LoadFromFile(const FileName: TFileName);
-
-var
-  FileStream: TFileStream;
-
-begin
-  FileStream := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
-  try
-    LoadFromStream(FileStream);
-  finally
-    FileStream.Free;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.LoadFromStream(Stream: TStream);
-
-// Clears the current content of the tree and loads a new structure from the given stream.
-
-var
-  ThisID: TMagicID;
-  Version,
-  Count: Cardinal;
-  Node: PVirtualNode;
-
-begin
-  if not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    Clear;
-    // Check first whether this is a stream we can read.
-    if Stream.Read(ThisID, SizeOf(TMagicID)) &lt; SizeOf(TMagicID) then
-      ShowError(SStreamTooSmall, hcTFStreamTooSmall);
-
-    if (ThisID[0] = MagicID[0]) and (ThisID[1] = MagicID[1]) and (ThisID[2] = MagicID[2]) and
-      (ThisID[5] = MagicID[5]) then
-    begin
-      Version := Word(ThisID[3]);
-      if Version &lt;= VTTreeStreamVersion then
-      begin
-        BeginUpdate;
-        try
-          if Version &lt; 2 then
-            Count := MaxInt
-          else
-            Stream.ReadBuffer(Count, SizeOf(Count));
-
-          while (Stream.Position &lt; Stream.Size) and (Count &gt; 0) do
-          begin
-            Dec(Count);
-            Node := MakeNewNode;
-            InternalConnectNode(Node, FRoot, Self, amAddChildLast);
-            InternalAddFromStream(Stream, Version, Node);
-          end;
-          DoNodeCopied(nil);
-        finally
-          EndUpdate;
-        end;
-      end
-      else
-        ShowError(SWrongStreamVersion, hcTFWrongStreamVersion);
-    end
-    else
-      ShowError(SWrongStreamFormat, hcTFWrongStreamFormat);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.MoveTo(Node: PVirtualNode; Tree: TBaseVirtualTree; Mode: TVTNodeAttachMode;
-  ChildrenOnly: Boolean);
-
-// A simplified method to allow to move nodes to the root of another tree.
-
-begin
-  MoveTo(Node, Tree.FRoot, Mode, ChildrenOnly);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.MoveTo(Source, Target: PVirtualNode; Mode: TVTNodeAttachMode; ChildrenOnly: Boolean);
-
-// Moves the given node (and all its children) to Target. Source must belong to the tree instance which calls this
-// MoveTo method. Mode determines how to connect Source to Target.
-// This method might involve a change of the tree if Target belongs to a different tree than Source. 
-
-var
-  TargetTree: TBaseVirtualTree;
-  Allowed: Boolean;
-  NewNode: PVirtualNode;
-  Stream: TMemoryStream;
-
-begin
-  Assert(TreeFromNode(Source) = Self, 'The source tree must contain the source node.');
-
-  // When moving nodes then source and target must not be the same node unless only the source's children are
-  // moved and they are inserted before or after the node itself.
-  Allowed := (Source &lt;&gt; Target) or ((Mode in [amInsertBefore, amInsertAfter]) and ChildrenOnly);
-
-  if Allowed and (Mode &lt;&gt; amNoWhere) and Assigned(Source) and (Source &lt;&gt; FRoot) and
-    not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    // Assume that an empty destination means the root in this (the source) tree.
-    if Target = nil then
-    begin
-      TargetTree := Self;
-      Target := FRoot;
-      Mode := amAddChildFirst;
-    end
-    else
-      TargetTree := TreeFromNode(Target);
-
-    if Target = TargetTree.FRoot then
-    begin
-      case Mode of
-        amInsertBefore:
-          Mode := amAddChildFirst;
-        amInsertAfter:
-          Mode := amAddChildLast;
-      end;
-    end;
-
-    if TargetTree = Self then
-    begin
-      // Simple case: move node(s) within the same tree.
-      if Target = FRoot then
-        Allowed := DoNodeMoving(Source, nil)
-      else
-        Allowed := DoNodeMoving(Source, Target);
-      if Allowed then
-      begin
-        // Check first that Source is not added as new child to a target node which
-        // is already a child of Source.
-        // Consider the case Source and Target are the same node, but only child nodes are moved.
-        if (Source &lt;&gt; Target) and HasAsParent(Target, Source) then
-            ShowError(SWrongMoveError, hcTFWrongMoveError);
-
-        if not ChildrenOnly then
-        begin
-          // Disconnect from old location.
-          InternalDisconnectNode(Source, True);
-          // Connect to new location.
-          InternalConnectNode(Source, Target, Self, Mode);
-          DoNodeMoved(Source);
-        end
-        else
-        begin
-          // Only child nodes should be moved.
-          Source := Source.LastChild;
-          while Assigned(Source) do
-          begin
-            NewNode := Source.PrevSibling;
-            // Disconnect from old location.
-            InternalDisconnectNode(Source, True, False);
-            // Connect to new location.
-            InternalConnectNode(Source, Target, Self, Mode);
-            DoNodeMoved(Source);
-            Source := NewNode;
-          end;
-        end;
-      end;
-    end
-    else
-    begin
-      // Difficult case: move node(s) to another tree.
-      // In opposition to node copying we ask only once if moving is allowed because
-      // we cannot take back a move once done.
-      if Target = TargetTree.FRoot then
-        Allowed := DoNodeMoving(Source, nil)
-      else
-        Allowed := DoNodeMoving(Source, Target);
-        
-      if Allowed then
-      begin
-        Stream := TMemoryStream.Create;
-        try
-          // Write all nodes into a temporary stream depending on the ChildrenOnly flag.
-          if not ChildrenOnly then
-            WriteNode(Stream, Source)
-          else
-          begin
-            Source := Source.FirstChild;
-            while Assigned(Source) do
-            begin
-              WriteNode(Stream, Source);
-              Source := Source.NextSibling;
-            end;
-          end;
-          // Now load the serialized nodes into the target node (tree).
-          TargetTree.BeginUpdate;
-          try
-            Stream.Position := 0;
-            while Stream.Position &lt; Stream.Size do
-            begin
-              NewNode := TargetTree.MakeNewNode;
-              InternalConnectNode(NewNode, Target, TargetTree, Mode);
-              TargetTree.InternalAddFromStream(Stream, VTTreeStreamVersion, NewNode);
-              DoNodeMoved(NewNode);
-            end;
-          finally
-            TargetTree.EndUpdate;
-          end;
-        finally
-          Stream.Free;
-        end;
-        // finally delete original nodes
-        BeginUpdate;
-        try
-          if ChildrenOnly then
-            DeleteChildren(Source)
-          else
-            DeleteNode(Source);
-        finally
-          EndUpdate;
-        end;
-      end;
-    end;
-
-    InvalidateCache;
-    if (FUpdateCount = 0) and Allowed then
-    begin
-      ValidateCache;
-      UpdateScrollBars(True);
-      Invalidate;
-      if TargetTree &lt;&gt; Self then
-        TargetTree.Invalidate;
-    end;
-    StructureChange(Source, crNodeMoved);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.PaintTree(TargetCanvas: TCanvas; Window: TRect; Target: TPoint;
-  PaintOptions: TVTInternalPaintOptions);
-
-// This is the core paint routine of the tree. It is responsible for maintaining the paint cycles per node as well
-// as coordinating drawing of the various parts of the tree image.
-// TargetCanvas is the canvas to which to draw the tree image. This is usually the tree window itself but could well
-// be a bitmap or printer canvas.
-// Window determines which part of the entire tree image to draw. The full size of the virtual image is determined
-// by GetTreeRect.
-// Target is the position in TargetCanvas where to draw the tree part specified by Window.
-// PaintOptions determines what of the tree to draw. For different tasks usually different parts need to be drawn, with
-// a full image in the window, selected only nodes for a drag image etc.
-
-const
-  ImageKind: array[Boolean] of TVTImageKind = (ikNormal, ikSelected);
-
-var
-  DrawSelectionRect,
-  UseBackground,
-  ShowImages,
-  ShowStateImages,
-  ShowCheckImages,
-  UseColumns,
-  IsMainColumn: Boolean;
-
-  VAlign,
-  IndentSize,
-  ButtonX,
-  ButtonY: Integer;
-  Temp: PVirtualNode;
-  LineImage: TLineImage;
-  PaintInfo: TVTPaintInfo;     // all necessary information about a node to pass to the paint routines
-
-  R,                           // the area of an entire node in its local coordinate
-  TargetRect,                  // the area of a node (part) in the target canvas
-  SelectionRect: TRect;        // ordered rectangle used for drawing the selection focus rect
-  NextColumn: TColumnIndex;
-  BaseOffset: Integer;         // top position of the top node to draw given in absolute tree coordinates
-  NodeBitmap: TBitmap;         // small buffer to draw flicker free
-  MaximumRight,                // maximum horizontal target position
-  MaximumBottom: Integer;      // maximum vertical target position
-  SelectLevel: Integer;        // &gt; 0 if current node is selected or child/grandchild etc. of a selected node
-  FirstColumn: TColumnIndex;   // index of first column which is at least partially visible in the given window
-
-begin
-  DoStateChange([tsPainting]);
-
-  DoBeforePaint(TargetCanvas);
-
-  // Create small bitmaps and initialize default values.
-  // The bitmaps are used to paint one node at a time and to draw the result to the target (e.g. screen) in one step,
-  // to prevent flickering.
-  NodeBitmap := TBitmap.Create;
-  // For alpha blending we need the 32 bit pixel format.
-  if MMXAvailable and ((FDrawSelectionMode = smBlendedRectangle) or (tsUseThemes in FStates)) then
-    NodeBitmap.PixelFormat := pf32Bit;
-
-  // Prepare paint info structure and lock the back bitmap canvas to avoid that it gets freed on the way.
-  FillChar(PaintInfo, SizeOf(PaintInfo), 0);
-  PaintInfo.Canvas := NodeBitmap.Canvas;
-  NodeBitmap.Canvas.Lock;
-  try
-    // Prepare the current selection rectangle once. The corner points are absolute tree coordinates.
-    SelectionRect := OrderRect(FNewSelRect);
-    DrawSelectionRect := IsMouseSelecting and not IsRectEmpty(SelectionRect);
-
-    // R represents an entire node (all columns), but is a bit unprecise when it comes to
-    // trees without any column defined, because FRangeX only represents the maximum width of all
-    // nodes in the client area (not all defined nodes). There might be, however, wider nodes somewhere. Without full
-    // validation I cannot better determine the width, though. By using at least the control's width it is ensured
-    // that the tree is fully displayed on screen.
-    R := Rect(0, 0, Max(FRangeX, ClientWidth), 0);
-    NodeBitmap.Width := Window.Right - Window.Left;
-
-    // Make sure the buffer bitmap and target bitmap use the same transformation mode.
-    SetMapMode(NodeBitmap.Canvas.Handle, GetMapMode(TargetCanvas.Handle));
-
-    // For quick checks some intermediate variables are used.
-    UseBackground := (toShowBackground in FOptions.FPaintOptions) and (FBackground.Graphic is TBitmap) and
-      (poBackground in PaintOptions);
-    ShowImages := Assigned(FImages);
-    ShowStateImages := Assigned(FStateImages);
-    ShowCheckImages := Assigned(FCheckImages) and (toCheckSupport in FOptions.FMiscOptions);
-    UseColumns := FHeader.UseColumns;
-
-    // Adjust paint options to tree settings.
-    if not Focused and (toHideSelection in FOptions.FPaintOptions) then
-      Exclude(PaintOptions, poDrawSelection);
-    if toHideFocusRect in FOptions.FPaintOptions then
-      Exclude(PaintOptions, poDrawFocusRect);
-      
-    // Determine node to start drawing with.
-    BaseOffset := 0;
-    PaintInfo.Node := GetNodeAt(0, Window.Top, False, BaseOffset);
-
-    // Transform selection rectangle into node bitmap coordinates.
-    if DrawSelectionRect then
-      OffsetRect(SelectionRect, 0, -BaseOffset);
-
-    // The target rectangle holds the coordinates of the exact area to blit in target canvas coordinates.
-    // It is usually smaller than an entire node and wanders while the paint loop advances.
-    MaximumRight := Target.X + (Window.Right - Window.Left);
-    MaximumBottom := Target.Y + (Window.Bottom - Window.Top);
-
-    TargetRect := Rect(Target.X, Target.Y - (Window.Top - BaseOffset), MaximumRight, 0);
-    TargetRect.Bottom := TargetRect.Top;
-
-    // This marker gets the index of the first column which is visible in the given window.
-    // This is needed for column based background colors.
-    FirstColumn := InvalidColumn;
-    
-    if Assigned(PaintInfo.Node) then
-    begin
-      SelectLevel := InitializeLineImageAndSelectLevel(PaintInfo.Node, LineImage);
-      IndentSize := Length(LineImage);
-
-      // Precalculate horizontal position of buttons relative to the column start.
-      ButtonX := (Length(LineImage) * Integer(FIndent)) + Round((Integer(FIndent) - FPlusBM.Width) / 2) - FIndent;
-                                                           
-      // ----- main node paint loop
-      while Assigned(PaintInfo.Node) do
-      begin
-        // Initialize node if not already done.
-        if not (vsInitialized in PaintInfo.Node.States) then
-          InitNode(PaintInfo.Node);
-        if vsSelected in PaintInfo.Node.States then
-          Inc(SelectLevel);
-
-        // Adjust the brush origin for dotted lines depending on the current source position.
-        // It is applied some lines later, as the canvas might get reallocated, when changing the node bitmap.
-        PaintInfo.BrushOrigin := Point(Window.Left and 1, BaseOffset and 1);
-        Inc(BaseOffset, PaintInfo.Node.NodeHeight);
-
-        TargetRect.Bottom := TargetRect.Top + PaintInfo.Node.NodeHeight;
-
-        // If poSelectedOnly is active then do the following stuff only for selected nodes or nodes
-        // which are children of selected nodes.
-        if (SelectLevel &gt; 0) or not (poSelectedOnly in PaintOptions) then
-        begin
-          // Adjust height of temporary node bitmap.
-          with NodeBitmap do
-          begin
-            if Height &lt;&gt; PaintInfo.Node.NodeHeight then
-            begin
-              // Avoid that the VCL copies the bitmap while changing its height.
-              Height := 0;
-              Height := PaintInfo.Node.NodeHeight;
-              SetWindowOrgEx(Canvas.Handle, Window.Left, 0, nil);
-              R.Bottom := PaintInfo.Node.NodeHeight;
-            end;
-            // Set the origin of the canvas' brush. This depends on the node heights.
-            with PaintInfo do
-              SetBrushOrgEx(Canvas.Handle, BrushOrigin.X, BrushOrigin.Y, nil);
-          end;
-          CalculateVerticalAlignments(ShowImages, ShowStateImages, PaintInfo.Node, VAlign, ButtonY);
-
-          // Let application decide whether the node should normally be drawn or by the application itself.
-          if not DoBeforeItemPaint(PaintInfo.Canvas, PaintInfo.Node, R) then
-          begin
-            // Init paint options for the background painting.
-            PaintInfo.PaintOptions := PaintOptions;
-
-            // The node background can contain a single color, a bitmap or can be drawn by the application.
-            ClearNodeBackground(PaintInfo, UseBackground, True, Rect(Window.Left, TargetRect.Top, Window.Right,
-              TargetRect.Bottom));
-                                                                                                            
-            // Prepare column, position and node clipping rectangle.
-            PaintInfo.CellRect := R;
-            if UseColumns then
-              InitializeFirstColumnValues(PaintInfo);
-
-            // Now go through all visible columns (there's still one run if columns aren't used).
-            with FHeader.FColumns do
-            begin
-              while ((PaintInfo.Column &gt; InvalidColumn) or not UseColumns)
-                and (PaintInfo.CellRect.Left &lt; Window.Right) do
-              begin
-                if UseColumns then
-                begin
-                  PaintInfo.Column := FPositionToIndex[PaintInfo.Position];
-                  if FirstColumn = InvalidColumn then
-                    FirstColumn := PaintInfo.Column;
-                  PaintInfo.BidiMode := Items[PaintInfo.Column].FBiDiMode;
-                  PaintInfo.Alignment := Items[PaintInfo.Column].FAlignment;
-                end
-                else
-                begin
-                  PaintInfo.Column := NoColumn;
-                  PaintInfo.BidiMode := BidiMode;
-                  PaintInfo.Alignment := FAlignment;
-                end;
-
-                PaintInfo.PaintOptions := PaintOptions;
-                with PaintInfo do
-                begin
-                  if (tsEditing in FStates) and (Node = FFocusedNode) and
-                    ((Column = FEditColumn) or not UseColumns) then
-                    Exclude(PaintOptions, poDrawSelection);
-                  if not UseColumns or
-                    ((vsSelected in Node.States) and (toFullRowSelect in FOptions.FSelectionOptions) and
-                     (poDrawSelection in PaintOptions)) or
-                    (coParentColor in Items[PaintInfo.Column].Options) then
-                    Exclude(PaintOptions, poColumnColor);
-                end;
-                IsMainColumn := PaintInfo.Column = FHeader.MainColumn;
-
-                // Consider bidi mode here. In RTL context means left alignment actually right alignment and vice versa.
-                if PaintInfo.BidiMode &lt;&gt; bdLeftToRight then
-                  ChangeBiDiModeAlignment(PaintInfo.Alignment);
-
-                // Paint the current cell if it is marked as being visible or columns aren't used and
-                // if this cell belongs to the main column if only the main column should be drawn.
-                if (not UseColumns or (coVisible in Items[PaintInfo.Column].FOptions)) and
-                  (not (poMainOnly in PaintOptions) or IsMainColumn) then
-                begin
-                  AdjustPaintCellRect(PaintInfo, NextColumn);
-
-                  // Paint the cell only if it is in the current window.
-                  if PaintInfo.CellRect.Right &gt; Window.Left then
-                  begin
-                    with PaintInfo do
-                    begin
-                      // Fill in remaining values in the paint info structure.
-                      NodeWidth := DoGetNodeWidth(Node, Column, Canvas);
-                      // Not the entire cell is covered by text. Hence we need a running rectangle to follow up.
-                      ContentRect := CellRect;
-                      // Set up the distance from column border (margin).
-                      if BidiMode &lt;&gt; bdLeftToRight then
-                        Dec(ContentRect.Right, FMargin)
-                      else
-                        Inc(ContentRect.Left, FMargin);
-
-                      if ShowCheckImages and IsMainColumn then
-                      begin
-                        ImageInfo[iiCheck].Index := GetCheckImage(Node);
-                        if ImageInfo[iiCheck].Index &gt; -1 then
-                        begin
-                          AdjustImageBorder(FCheckImages, BidiMode, VAlign, ContentRect, ImageInfo[iiCheck]);
-                          ImageInfo[iiCheck].Ghosted := False;
-                        end;
-                      end
-                      else
-                        ImageInfo[iiCheck].Index := -1;
-                      if ShowStateImages then
-                      begin
-                        ImageInfo[iiState].Index := GetImageIndex(Node, ikState, Column, ImageInfo[iiState].Ghosted);
-                        if ImageInfo[iiState].Index &gt; -1 then
-                          AdjustImageBorder(FStateImages, BidiMode, VAlign, ContentRect, ImageInfo[iiState]);
-                      end
-                      else
-                        ImageInfo[iiState].Index := -1;
-                      if ShowImages then
-                      begin
-                        ImageInfo[iiNormal].Index := GetImageIndex(Node, ImageKind[vsSelected in Node.States], Column,
-                          ImageInfo[iiNormal].Ghosted);
-                        if ImageInfo[iiNormal].Index &gt; -1 then
-                          AdjustImageBorder(FImages, BidiMode, VAlign, ContentRect, ImageInfo[iiNormal]);
-                      end
-                      else
-                        ImageInfo[iiNormal].Index := -1;
-
-                      // Take the space for the tree lines into account.
-                      if IsMainColumn then
-                        AdjustCoordinatesByIndent(PaintInfo, IndentSize);
-
-                      if UseColumns then
-                        LimitPaintingToArea(Canvas, CellRect);
-
-                      // Paint the horizontal grid line.
-                      if (poGridLines in PaintOptions) and (toShowHorzGridLines in FOptions.FPaintOptions) then
-                      begin
-                        Canvas.Font.Color := FColors.GridLineColor;
-                        if IsMainColumn and (FLineMode = lmBands) then
-                        begin
-                          if BidiMode = bdLeftToRight then
-                          begin
-                            DrawDottedHLine(PaintInfo, CellRect.Left + IndentSize * Integer(FIndent), CellRect.Right - 1,
-                              CellRect.Bottom - 1);
-                          end
-                          else
-                          begin
-                            DrawDottedHLine(PaintInfo, CellRect.Left, CellRect.Right - IndentSize * Integer(FIndent) - 1,
-                              CellRect.Bottom - 1);
-                          end;
-                        end
-                        else
-                          DrawDottedHLine(PaintInfo, CellRect.Left, CellRect.Right, CellRect.Bottom - 1);
-                        Dec(CellRect.Bottom);
-                        Dec(ContentRect.Bottom);
-                      end;
-
-                      if UseColumns then
-                      begin
-                        // Paint vertical grid line.
-                        // Don't draw if this is the last column and the header is in autosize mode.
-                        if (poGridLines in PaintOptions) and (toShowVertGridLines in FOptions.FPaintOptions) and
-                          (not (hoAutoResize in FHeader.FOptions) or (Position &lt; TColumnPosition(Count - 1))) then
-                        begin
-                          if (BidiMode = bdLeftToRight) or not ColumnIsEmpty(Node, Column) then
-                          begin
-                            Canvas.Font.Color := FColors.GridLineColor;
-                            DrawDottedVLine(PaintInfo, CellRect.Top, CellRect.Bottom, CellRect.Right - 1);
-                          end;
-                          Dec(CellRect.Right);
-                          Dec(ContentRect.Right);
-                        end;
-                      end;
-
-                      // Prepare background and focus rect for the current cell.
-                      PrepareCell(PaintInfo);
-
-                      // Some parts are only drawn for the main column.
-                      if IsMainColumn then
-                      begin
-                        if toShowTreeLines in FOptions.FPaintOptions then
-                          PaintTreeLines(PaintInfo, VAlign, IndentSize, LineImage);
-                        // Show node button if allowed, if there child nodes and at least one of the child
-                        // nodes is visible or auto button hiding is disabled. 
-                        if (toShowButtons in FOptions.FPaintOptions) and (vsHasChildren in Node.States) and
-                          not ((vsAllChildrenHidden in Node.States) and
-                          (toAutoHideButtons in TreeOptions.FAutoOptions)) then
-                          PaintNodeButton(Canvas, Node, CellRect, ButtonX, ButtonY, BidiMode);
-
-                        if ImageInfo[iiCheck].Index &gt; -1 then
-                          PaintCheckImage(PaintInfo);
-                      end;
-
-                      if ImageInfo[iiState].Index &gt; -1 then
-                        PaintImage(PaintInfo, iiState, FStateImages, False);
-                      if ImageInfo[iiNormal].Index &gt; -1 then
-                        PaintImage(PaintInfo, iiNormal, FImages, True);
-
-                      // Now let descendants or applications draw whatever they want,
-                      // but don't draw the node if it is currently being edited.
-                      if not ((tsEditing in FStates) and (Node = FFocusedNode) and
-                        ((Column = FEditColumn) or not UseColumns)) then
-                        DoPaintNode(PaintInfo);
-
-                      DoAfterCellPaint(Canvas, Node, Column, CellRect);
-                    end;
-                  end;
-
-                  // leave after first run if columns aren't used
-                  if not UseColumns then
-                    Break;
-                end
-                else
-                  NextColumn := GetNextVisibleColumn(PaintInfo.Column);
-
-                SelectClipRgn(PaintInfo.Canvas.Handle, 0);
-                // Stop column loop if there are no further columns in the given window.
-                if (PaintInfo.CellRect.Left &gt;= Window.Right) or (NextColumn = InvalidColumn) then
-                  Break;
-
-                // Move on to next column which might not be the one immediately following the current one
-                // because of auto span feature.
-                PaintInfo.Position := Items[NextColumn].Position;
-
-                // Move clip rectangle and continue.
-                if coVisible in Items[NextColumn].FOptions then
-                  with PaintInfo do
-                  begin
-                    Items[NextColumn].GetAbsoluteBounds(CellRect.Left, CellRect.Right);
-                    CellRect.Bottom := Node.NodeHeight;
-                    ContentRect.Bottom := Node.NodeHeight;
-                  end;
-              end;
-            end;
-        
-            // This node is finished, notify descentants/application.
-            with PaintInfo do
-            begin
-              DoAfterItemPaint(Canvas, Node, R);
-
-              // Final touch for this node: mark it if it is the current drop target node.
-              if (Node = FDropTargetNode) and (toShowDropmark in FOptions.FPaintOptions) and
-                (poDrawDropMark in PaintOptions) then
-                DoPaintDropMark(Canvas, Node, R);
-            end;
-          end;
-
-          with PaintInfo.Canvas do
-          begin
-            if DrawSelectionRect then
-            begin
-              PaintSelectionRectangle(PaintInfo.Canvas, Window.Left, SelectionRect, Rect(0, 0, NodeBitmap.Width,
-                NodeBitmap.Height));
-            end;
-
-            // Put the constructed node image onto the target canvas.
-            with TargetRect, NodeBitmap do
-              BitBlt(TargetCanvas.Handle, Left, Top, Width, Height, Canvas.Handle, Window.Left, 0, SRCCOPY);
-          end;                                                                       
-        end;
-
-        Inc(TargetRect.Top, PaintInfo.Node.NodeHeight);
-        if TargetRect.Top &gt;= MaximumBottom then
-          Break;
-
-        // Keep selection rectangle coordinates in sync.
-        if DrawSelectionRect then
-          OffsetRect(SelectionRect, 0, -PaintInfo.Node.NodeHeight);
-
-        // Advance to next visible node.
-        Temp := GetNextVisible(PaintInfo.Node);
-        if Assigned(Temp) then
-        begin
-          // Adjust line bitmap (and so also indentation level).
-          if Temp.Parent = PaintInfo.Node then
-          begin
-            // New node is a child node. Need to adjust previous bitmap level.
-            if IndentSize &gt; 0 then
-              if HasVisibleNextSibling(PaintInfo.Node) then
-                LineImage[IndentSize - 1] := ltTopDown
-              else
-                LineImage[IndentSize - 1] := ltNone;
-            // Enhance line type array if necessary.
-            Inc(IndentSize);
-            if Length(LineImage) &lt;= IndentSize then
-              SetLength(LineImage, IndentSize + 8);
-            Inc(ButtonX, FIndent);
-          end
-          else
-          begin
-            // New node is at the same or higher tree level.
-            // Take back select level increase if the node was selected
-            if vsSelected in PaintInfo.Node.States then
-              Dec(SelectLevel);
-            if PaintInfo.Node.Parent &lt;&gt; Temp.Parent then
-            begin
-              // We went up one or more levels. Determine how many levels it was actually.
-              while PaintInfo.Node.Parent &lt;&gt; Temp.Parent do
-              begin
-                Dec(IndentSize);
-                Dec(ButtonX, FIndent);
-                PaintInfo.Node := PaintInfo.Node.Parent;
-                // Take back one selection level increase for every step up.
-                if vsSelected in PaintInfo.Node.States then
-                  Dec(SelectLevel);
-              end;
-            end;
-          end;
-
-          // Set new image in front of the new node.
-          if IndentSize &gt; 0 then
-            if HasVisibleNextSibling(Temp) then
-              LineImage[IndentSize - 1] := ltTopDownRight
-            else
-              LineImage[IndentSize - 1] := ltTopRight;
-        end;
-
-        PaintInfo.Node := Temp;
-      end;
-    end;
-
-    // Erase rest of window not covered by a node.
-    if TargetRect.Top &lt; MaximumBottom then
-    begin
-      // Keep the horizontal target position to determine the selection rectangle offset later (if necessary).
-      BaseOffset := Target.X;
-      Target := TargetRect.TopLeft;
-      R := Rect(TargetRect.Left, 0, MaximumRight, MaximumBottom - Target.Y);
-      TargetRect := Rect(0, 0, MaximumRight - Target.X, MaximumBottom - Target.Y);
-      // Avoid unnecessary copying of bitmap content. This will destroy the DC handle too.
-      NodeBitmap.Height := 0;
-      NodeBitmap.PixelFormat := pf32Bit;
-      NodeBitmap.Width := TargetRect.Right - TargetRect.Left + 1;
-      NodeBitmap.Height := TargetRect.Bottom - TargetRect.Top + 1;
-
-      // Call back application/descentants whether they want to erase this area.
-      SetWindowOrgEx(NodeBitmap.Canvas.Handle, Target.X, 0, nil);
-      if not DoPaintBackground(NodeBitmap.Canvas, TargetRect) then
-      begin
-        if UseBackground then
-        begin
-          SetWindowOrgEx(NodeBitmap.Canvas.Handle, 0, 0, nil);
-          TileBackground(FBackground.Bitmap, NodeBitmap.Canvas, Target, TargetRect);
-        end
-        else
-        begin
-          // Consider here also colors of the columns.
-          if UseColumns then
-          begin
-            with FHeader.FColumns do
-            begin
-              // If there is no content in the tree then the first column has not yet been determined.
-              if FirstColumn = InvalidColumn then
-              begin
-                FirstColumn := GetFirstVisibleColumn;
-                repeat
-                  if FirstColumn &lt;&gt; InvalidColumn then
-                  begin
-                    R.Left := Items[FirstColumn].Left;
-                    R.Right := R.Left +  Items[FirstColumn].FWidth;
-                    if R.Right &gt; TargetRect.Left then
-                      Break;
-                    FirstColumn := GetNextVisibleColumn(FirstColumn);
-                  end;
-                until FirstColumn = InvalidColumn;
-              end
-              else
-              begin
-                R.Left := Items[FirstColumn].Left;
-                R.Right := R.Left +  Items[FirstColumn].FWidth;
-              end;
-
-              while (FirstColumn &lt;&gt; InvalidColumn) and (R.Left &lt; TargetRect.Right + Target.X) do
-              begin
-                if not (coParentColor in Items[FirstColumn].FOptions) then
-                  NodeBitmap.Canvas.Brush.Color := Items[FirstColumn].FColor
-                else
-                  NodeBitmap.Canvas.Brush.Color := Color;
-
-                NodeBitmap.Canvas.FillRect(R);
-                FirstColumn := GetNextVisibleColumn(FirstColumn);
-                if FirstColumn &lt;&gt; InvalidColumn then
-                begin
-                  R.Left := Items[FirstColumn].Left;
-                  R.Right := R.Left + Items[FirstColumn].FWidth;
-                end;
-              end;
-              // Erase also the part of the tree not covert by a column.
-              if R.Right &lt; TargetRect.Right + Target.X then
-              begin
-                R.Left := R.Right;
-                R.Right := TargetRect.Right + Target.X;
-                NodeBitmap.Canvas.Brush.Color := Color;
-                NodeBitmap.Canvas.FillRect(R);
-              end;
-            end;
-            SetWindowOrgEx(NodeBitmap.Canvas.Handle, 0, 0, nil);
-          end
-          else
-          begin
-            // No columns nor bitmap background. Simply erase it with the tree color.
-            SetWindowOrgEx(NodeBitmap.Canvas.Handle, 0, 0, nil);
-            NodeBitmap.Canvas.Brush.Color := Color;
-            NodeBitmap.Canvas.FillRect(TargetRect);
-          end;
-        end;
-      end;
-      SetWindowOrgEx(NodeBitmap.Canvas.Handle, 0, 0, nil);
-
-      if DrawSelectionRect then
-      begin
-        R := OrderRect(FNewSelRect);
-        // Remap the selection rectangle to the current window of the tree.
-        // Since Target has been used for other tasks BaseOffset got the left extent of the target position here.
-        OffsetRect(R, -Target.X + BaseOffset - Window.Left, -Target.Y);
-        SetBrushOrgEx(NodeBitmap.Canvas.Handle, 0, Target.X and 1, nil);
-        PaintSelectionRectangle(NodeBitmap.Canvas, 0, R, TargetRect);
-      end;
-      with Target, NodeBitmap do
-        BitBlt(TargetCanvas.Handle, X, Y, Width, Height, Canvas.Handle, 0, 0, SRCCOPY);
-    end;
-  finally
-    NodeBitmap.Canvas.Unlock;
-    NodeBitmap.Free;
-  end;
-  DoAfterPaint(TargetCanvas);
-  DoStateChange([], [tsPainting]);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.PasteFromClipboard: Boolean;
-
-// Reads what is currently on the clipboard into the tree (if the format is supported).
-// Note: If the application wants to have text or special formats to be inserted then it must implement
-//       its own code (OLE). Here only the native tree format is accepted.
-
-var
-  Data: IDataObject;
-  Source: TBaseVirtualTree;
-
-begin
-  Result := False;
-  if not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    if OleGetClipboard(Data) &lt;&gt; S_OK then
-      ShowError(SClipboardFailed, hcTFClipboardFailed)
-    else
-    try
-      // Try to get the source tree of the operation to optimize the operation.
-      Source := GetTreeFromDataObject(Data);
-      Result := ProcessOLEData(Source, Data, FFocusedNode, FDefaultPasteMode, Assigned(Source) and
-        (tsCutPending in Source.FStates));
-      if Assigned(Source) and (Source &lt;&gt; Self) then
-        Source.FinishCutOrCopy;
-    finally
-      Data := nil;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.PrepareDragImage(Hotspot: TPoint; const DataObject: IDataObject);
-
-// Initiates an image drag operation. Hotspot is the position of the mouse in client coordinates.
-
-var
-  PaintOptions: TVTInternalPaintOptions;
-  TreeRect,
-  PaintRect: TRect;
-  LocalSpot,
-  ImagePos,
-  PaintTarget: TPoint;
-  Image: TBitmap;
-
-begin
-  if CanShowDragImage then
-  begin
-    // Determine the drag rectangle which is a square around the hot spot. Operate in virtual tree space.
-    LocalSpot := HotSpot;
-    Dec(LocalSpot.X, FOffsetX);
-    Dec(LocalSpot.Y, FOffsetY);
-    TreeRect := Rect(LocalSpot.X - FDragWidth div 2, LocalSpot.Y - FDragHeight div 2, LocalSpot.X + FDragWidth div 2,
-      LocalSpot.Y + FDragHeight div 2);
-
-    // Check that we have a valid rectangle.
-    with TreeRect do
-    begin
-      PaintRect := TreeRect;
-      if Left &lt; 0 then
-      begin
-        PaintTarget.X := -Left;
-        PaintRect.Left := 0;
-      end
-      else
-        PaintTarget.X := 0;
-      if Top &lt; 0 then
-      begin
-        PaintTarget.Y := -Top;
-        PaintRect.Top := 0;
-      end
-      else
-        PaintTarget.Y := 0;
-    end;
-
-    Image := TBitmap.Create;
-    with Image do
-    try
-      PixelFormat := pf32Bit;
-      Width := TreeRect.Right - TreeRect.Left;
-      Height := TreeRect.Bottom - TreeRect.Top;
-      // Erase the entire image with the color key value, for the case not everything
-      // in the image is covered by the tree image. 
-      Canvas.Brush.Color := Color;
-      Canvas.FillRect(Rect(0, 0, Width, Height));
-
-      PaintOptions := [poDrawSelection, poSelectedOnly];
-      if FDragImageKind = diMainColumnOnly then
-        Include(PaintOptions, poMainOnly);
-      PaintTree(Image.Canvas, PaintRect, PaintTarget, PaintOptions);
-
-      // Once we have got the drag image we can convert all necessary coordinates into screen space.
-      OffsetRect(TreeRect, FOffsetX, FOffsetY);
-      ImagePos := ClientToScreen(TreeRect.TopLeft);
-      HotSpot := ClientToScreen(HotSpot);
-
-      FDragImage.ColorKey := Color;
-      FDragImage.PrepareDrag(Image, ImagePos, HotSpot, DataObject);
-    finally
-      Image.Free;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.Print(Printer: TPrinter; PrintHeader: Boolean);
-
-var
-  SaveTreeFont: TFont;                 // Remembers the tree's current font.
-  SaveHeaderFont: TFont;               // Remembers the header's current font.
-  ImgRect,                             // Describes the dimensions of Image.
-  TreeRect,                            // The total VTree dimensions.
-  DestRect,                            // Dimensions of PrinterImage.
-  SrcRect: TRect;                      // Clip dimensions from Image -&gt; PrinterImage
-  P: TPoint;                           // Used by PaintTree.
-  Options: TVTInternalPaintOptions;    // Used by PaintTree.
-  Image,                               // Complete Tree is drawn to this image.
-  PrinterImage: TBitmap;               // This is the image that gets printed.
-  SaveColor: TColor;                   // Remembers the VTree Color.
-  pTxtHeight,                          // Height of font in the TPrinter.Canvas
-  vTxtHeight,                          // Height of font in the VTree Canvas
-  vPageWidth,
-  vPageHeight,                         // Printer height in VTree resolution
-  xPageNum, yPageNum,                  // # of pages (except the occasional last one)
-  xPage, yPage: Integer;               // Loop counter
-  Scale: Extended;                     // Scale factor between Printer Canvas and VTree Canvas
-  LogFont: TLogFont;
-
-begin
-  if Assigned(Printer) then
-  begin
-    BeginUpdate;
-
-    // Grid lines are the only parts which are desirable when printing.
-    Options := [poGridLines];
-
-    // Remember the tree font.
-    SaveTreeFont := TFont.Create;
-    SaveTreeFont.Assign(Font);
-    // Create a new font for printing which does not use clear type output (but is antialiased, if possible)
-    // and which has the highest possible quality.
-    GetObject(Font.Handle, SizeOf(TLogFont), @LogFont);
-    LogFont.lfQuality := ANTIALIASED_QUALITY;
-    Font.Handle := CreateFontIndirect(LogFont);
-
-    // Create an image that will hold the complete VTree
-    Image := TBitmap.Create;
-    Image.PixelFormat := pf32Bit;
-    PrinterImage := nil;
-    try
-      TreeRect := GetTreeRect;
-
-      Image.Width := TreeRect.Right - TreeRect.Left;
-      P := Point(0, 0);
-      if (hoVisible in FHeader.Options) and PrintHeader then
-      begin
-        Inc(TreeRect.Bottom, FHeader.Height);
-        Inc(P.Y, FHeader.Height);
-      end;
-      Image.Height := TreeRect.Bottom - TreeRect.Top;
-
-      ImgRect.Left := 0;
-      ImgRect.Top := 0;
-      ImgRect.Right := Image.Width;
-
-      // Force the background to white color during the rendering.
-      SaveColor := Color;
-      Color := clWhite;
-      // Print header if it is visible.
-      if (hoVisible in FHeader.Options) and PrintHeader then
-      begin
-        SaveHeaderFont := TFont.Create;
-        try
-          SaveHeaderFont.Assign(FHeader.Font);
-          // Create a new font for printing which does not use clear type output (but is antialiased, if possible)
-          // and which has the highest possible quality.
-          GetObject(FHeader.Font.Handle, SizeOf(TLogFont), @LogFont);
-          LogFont.lfQuality := ANTIALIASED_QUALITY;
-          FHeader.Font.Handle := CreateFontIndirect(LogFont);
-          ImgRect.Bottom := FHeader.Height;
-          FHeader.FColumns.PaintHeader(Image.Canvas.Handle, ImgRect, 0);
-          FHeader.Font := SaveHeaderFont; 
-        finally
-          SaveHeaderFont.Free;
-        end;
-      end;
-      // The image's height is already adjusted for the header if it is visible.
-      ImgRect.Bottom := Image.Height;
-
-      PaintTree(Image.Canvas, ImgRect, P, Options);
-      Color := SaveColor;
-
-      // Activate the printer
-      Printer.BeginDoc;
-      Printer.Canvas.Font := Font;
-
-      // Now we can calculate the scaling :
-      pTxtHeight := Printer.Canvas.TextHeight('Tj');
-      vTxtHeight := Canvas.TextHeight('Tj');
-
-      Scale := pTxtHeight / vTxtHeight;
-
-      // Create an Image that has the same dimensions as the printer canvas but
-      // scaled to the VTree resolution:
-      PrinterImage := TBitmap.Create;
-
-      vPageHeight := Round(Printer.PageHeight / Scale);
-      vPageWidth := Round(Printer.PageWidth / Scale);
-
-      // We do a minumum of one page.
-      xPageNum := Trunc(Image.Width / vPageWidth);
-      yPageNum := Trunc(Image.Height / vPageHeight);
-
-      PrinterImage.Width := vPageWidth;  
-      PrinterImage.Height := vPageHeight;
-
-      // Split vertically:
-      for yPage := 0 to yPageNum do
-      begin
-        DestRect.Left := 0;
-        DestRect.Top := 0;
-        DestRect.Right := PrinterImage.Width;
-        DestRect.Bottom := PrinterImage.Height;
-
-        // Split horizontally:
-        for xPage := 0 to xPageNum do
-          begin
-            SrcRect.Left := vPageWidth * xPage;
-            SrcRect.Top := vPageHeight * yPage;
-            SrcRect.Right := vPageWidth * xPage + PrinterImage.Width;
-            SrcRect.Bottom := SrcRect.Top + vPageHeight;
-
-            // Clear the image
-            PrinterImage.Canvas.Brush.Color := clWhite;
-            PrinterImage.Canvas.FillRect(Rect(0, 0, PrinterImage.Width, PrinterImage.Height));
-            PrinterImage.Canvas.CopyRect(DestRect, Image.Canvas, SrcRect);
-            PrtStretchDrawDIB(Printer.Canvas, Rect(0, 0, Printer.PageWidth, Printer.PageHeight - 1), PrinterImage);
-            if xPage &lt;&gt; xPageNum then
-              Printer.NewPage;
-          end;
-        if yPage &lt;&gt; yPageNum then
-          Printer.NewPage;
-      end;
-
-      // Restore tree font.
-      Font := SaveTreeFont;
-      SaveTreeFont.Free;
-      Printer.EndDoc;
-    finally
-      PrinterImage.Free;
-      Image.Free;
-      EndUpdate;
-    end;
-  end;    
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.ProcessDrop(DataObject: IDataObject; TargetNode: PVirtualNode; var Effect: Integer;
-  Mode: TVTNodeAttachMode): Boolean;
-
-// Recreates the (sub) tree structure serialized into memory and provided by DataObject. The new nodes are attached to
-// the passed node or FRoot if TargetNode is nil.
-// Returns True on success, i.e. the CF_VIRTUALTREE format is supported by the data object and the structure could be
-// recreated, otherwise False.
-
-var
-  Source: TBaseVirtualTree;
-
-begin
-  Result := False;
-  if Mode = amNoWhere then
-    Effect := DROPEFFECT_NONE
-  else
-  begin
-    BeginUpdate;
-    // try to get the source tree of the operation
-    Source := GetTreeFromDataObject(DataObject);
-    if Assigned(Source) then
-      Source.BeginUpdate;
-    try
-      try
-        // Before adding the new nodes try to optimize the operation if source and target tree reside in
-        // the same application and operation is a move.
-        if ((Effect and DROPEFFECT_MOVE) &lt;&gt; 0) and Assigned(Source) then
-        begin
-          // If both copy and move are specified then prefer a copy because this is not destructing.
-          Result := ProcessOLEData(Source, DataObject, TargetNode, Mode, (Effect and DROPEFFECT_COPY) = 0);
-          // Since we made an optimized move or a copy there's no reason to act further after DoDragging returns.
-          Effect := DROPEFFECT_NONE;
-        end
-        else
-          // Act only if move or copy operation is requested.
-          if (Effect and (DROPEFFECT_MOVE or DROPEFFECT_COPY)) &lt;&gt; 0 then
-            Result := ProcessOLEData(Source, DataObject, TargetNode, Mode, False)
-          else
-            Result := False;
-      except
-        Effect := DROPEFFECT_NONE;
-      end;
-    finally
-      if Assigned(Source) then
-        Source.EndUpdate;
-      EndUpdate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-type
-  // needed to handle OLE global memory objects  
-  TOLEMemoryStream = class(TCustomMemoryStream)
-  public
-    function Write(const Buffer; Count: Integer): Longint; override;
-  end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TOLEMemoryStream.Write(const Buffer; Count: Integer): Integer;
-
-begin
-  {$ifdef COMPILER_5_UP}
-    raise EStreamError.CreateRes(PResStringRec(@SCantWriteResourceStreamError));
-  {$else}
-    raise EStreamError.Create(SCantWriteResourceStreamError);
-  {$endif COMPILER_5_UP}
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.ProcessOLEData(Source: TBaseVirtualTree; DataObject: IDataObject; TargetNode: PVirtualNode;
-  Mode: TVTNodeAttachMode; Optimized: Boolean): Boolean;
-
-// Recreates the (sub) tree structure serialized into memory and provided by DataObject. The new nodes are attached to
-// the passed node or FRoot if TargetNode is nil according to Mode. Optimized can be set to True if the entire operation
-// happens within the same process (i.e. sender and receiver of the OLE operation are located in the same process).
-// Optimize = True makes only sense if the operation to carry out is a move hence it is also the indication of the
-// operation to be done here. Source is the source of the OLE data and only of use (and usually assigned) when
-// an OLE operation takes place in the same application.
-// Returns True on success, i.e. the CF_VIRTUALTREE format is supported by the data object and the structure could be
-// recreated, otherwise False.
-
-var
-  Medium: TStgMedium;
-  Stream: TStream;
-  Data: Pointer;
-  Node: PVirtualNode;
-  Nodes: TNodeArray;
-  I: Integer;
-  Res: HRESULT;
-  ChangeReason: TChangeReason;
-
-begin
-  Nodes := nil;
-  // Check the data format available by the data object.
-  with StandardOLEFormat do
-  begin
-    // Read best format.
-    cfFormat := CF_VIRTUALTREE;
-  end;
-  Result := DataObject.QueryGetData(StandardOLEFormat) = S_OK;
-  if Result and not (toReadOnly in FOptions.FMiscOptions) then
-  begin
-    BeginUpdate;
-    Result := False;
-    try
-      if TargetNode = nil then
-        TargetNode := FRoot;
-      if TargetNode = FRoot then
-      begin
-        case Mode of
-          amInsertBefore:
-            Mode := amAddChildFirst;
-          amInsertAfter:
-            Mode := amAddChildLast;
-        end;
-      end;
-
-      // Optimized means source is known and in the same process so we can access its pointers, which avoids duplicating
-      // the data while doing a serialization. Can only be used with cut'n paste and drag'n drop with move effect.
-      if Optimized then
-      begin
-        if tsOLEDragging in Source.FStates then
-          Nodes := Source.FDragSelection
-        else
-          Nodes := Source.GetSortedCutCopySet(True);
-
-        if Mode in [amInsertBefore,amAddChildLast] then
-        begin
-          for I := 0 to High(Nodes) do
-            if not HasAsParent(TargetNode, Nodes[I]) then
-              Source.MoveTo(Nodes[I], TargetNode, Mode, False);
-        end
-        else
-        begin
-          for I := High(Nodes) downto 0 do
-            if not HasAsParent(TargetNode, Nodes[I]) then
-              Source.MoveTo(Nodes[I], TargetNode, Mode, False);
-        end;
-        Result := True;
-      end
-      else
-      begin
-        if Source = Self then
-          ChangeReason := crNodeCopied
-        else
-          ChangeReason := crNodeAdded;
-        Res := DataObject.GetData(StandardOLEFormat, Medium);
-        if Res = S_OK then
-        begin
-          case Medium.tymed of
-            TYMED_ISTREAM, // IStream interface
-            TYMED_HGLOBAL: // global memory block
-              begin
-                Stream := nil;
-                if Medium.tymed = TYMED_ISTREAM then
-                  Stream := TOLEStream.Create(IUnknown(Medium.stm) as IStream)
-                else
-                begin
-                  Data := GlobalLock(Medium.hGlobal);
-                  if Assigned(Data) then
-                  begin
-                    // Get the total size of data to retrieve.
-                    I := PCardinal(Data)^;
-                    Inc(PCardinal(Data));
-                    Stream := TOLEMemoryStream.Create;
-                    TOLEMemoryStream(Stream).SetPointer(Data, I);
-                  end;
-                end;
-
-                if Assigned(Stream) then
-                try
-                  while Stream.Position &lt; Stream.Size do
-                  begin
-                    Node := MakeNewNode;
-                    InternalConnectNode(Node, TargetNode, Self, Mode);
-                    InternalAddFromStream(Stream, VTTreeStreamVersion, Node);
-                    // This seems a bit strange because of the callback for granting to add the node
-                    // which actually comes after the node has been added. The reason is that the node must
-                    // contain valid data otherwise I don't see how the application can make a funded decision.
-                    if not DoNodeCopying(Node, TargetNode) then
-                      DeleteNode(Node)
-                    else
-                      DoNodeCopied(Node);
-                    StructureChange(Node, ChangeReason);
-                  end;
-                  Result := True;
-                finally
-                  Stream.Free;
-                  if Medium.tymed = TYMED_HGLOBAL then
-                    GlobalUnlock(Medium.hGlobal);
-                end;
-              end;
-          end;
-          ReleaseStgMedium(Medium);
-        end;
-      end;
-    finally
-      EndUpdate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ReinitChildren(Node: PVirtualNode; Recursive: Boolean);
-
-// Forces all child nodes of Node to be reinitialized.
-// If Recursive is True then also the grandchildren are reinitialized.
-
-var
-  Run: PVirtualNode;
-
-begin
-  if Assigned(Node) then
-  begin
-    InitChildren(Node);
-    Run := Node.FirstChild;
-  end
-  else
-  begin
-    InitChildren(FRoot);
-    Run := FRoot.FirstChild;
-  end;
-
-  while Assigned(Run) do
-  begin
-    ReinitNode(Run, recursive);
-    Run := Run.NextSibling;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ReinitNode(Node: PVirtualNode; Recursive: Boolean);
-
-// Forces the given node and all its children (if recursive is True) to be initialized again without
-// modifying any data in the nodes nor deleting children (unless the application requests a different amount).
-
-begin
-  if Assigned(Node) and (Node &lt;&gt; FRoot) then
-  begin
-    // remove dynamic styles
-    Node.States := Node.States - [vsChecking, vsCutOrCopy, vsDeleting];
-    InitNode(Node);
-  end;
-
-  if Recursive then
-    ReinitChildren(Node, True);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.RepaintNode(Node: PVirtualNode);
-
-// Causes an immediate repaint of the given node.
-
-var
-  R: Trect;
-
-begin
-  if Assigned(Node) and (Node &lt;&gt; FRoot) then
-  begin
-    R := GetDisplayRect(Node, -1, False);
-    RedrawWindow(Handle, @R, 0, RDW_INVALIDATE or RDW_UPDATENOW or RDW_NOERASE or RDW_VALIDATE or RDW_NOCHILDREN);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ResetNode(Node: PVirtualNode);
-
-// Deletes all children of the given node and marks it as being uninitialized.
-
-begin
-  DoCancelEdit;
-  if (Node = nil) or (Node = FRoot) then
-    Clear
-  else
-  begin
-    DoReset(Node);
-    DeleteChildren(Node);
-    // Remove initialized and other dynamic styles, keep persistent styles.
-    Node.States := Node.States - [vsInitialized, vsChecking, vsCutOrCopy, vsDeleting, vsHasChildren, vsExpanded];
-    InvalidateNode(Node);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SaveToFile(const FileName: TFileName);
-
-// Saves the entire content of the tree into a file (see further notes in SaveToStream).
-
-var
-  FileStream: TFileStream;
-
-begin
-  FileStream := TFileStream.Create(FileName, fmCreate);
-  try
-    SaveToStream(FileStream);
-  finally
-    FileStream.Free;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SaveToStream(Stream: TStream; Node: PVirtualNode = nil);  
-
-// Saves Node and all its children to Stream. If Node is nil then all top level nodes will be stored.
-// Note: You should be careful about assuming what is actually saved. The problem here is that we are dealing with
-//       virtual data. The tree can so not know what it has to save. The only fact we reliably know is the tree's
-//       structure. To be flexible for future enhancements as well as unknown content (unknown to the tree class which
-//       is saving/loading the stream) a chunk based approach is used here. Every tree class handles only those
-//       chunks which are not handled by an anchestor class and are known by the class.
-//
-// The base tree class saves only the structure of the tree along with application provided data. Descentants may
-// optionally add their own chunks to store additional information. See: WriteChunks.
-
-var
-  Count: Cardinal;
-  
-begin
-  Stream.Write(MagicID, SizeOf(MagicID));
-  if Node = nil then
-  begin
-    // Keep number of top level nodes for easy restauration.
-    Count := FRoot.ChildCount;
-    Stream.WriteBuffer(Count, SizeOf(Count));
-
-    // Save entire tree here.
-    Node := FRoot.FirstChild;
-    while Assigned(Node) do
-    begin
-      WriteNode(Stream, Node);
-      Node := Node.NextSibling;
-    end;
-  end
-  else
-  begin
-    Count := 1;
-    Stream.WriteBuffer(Count, SizeOf(Count));
-    WriteNode(Stream, Node);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.ScrollIntoView(Node: PVirtualNode; Center: Boolean; Horizontally: Boolean = False): Boolean;
-
-// Scrolls the tree so that the given node is in the client area and returns True if the tree really has been
-// scrolled (e.g. to avoid further updates) else returns False. If extened focus is enabled then the tree will also
-// be horizontally scrolled if needed.
-// Note: All collapsed parents of the node are expanded.
-
-var
-  MidPoint: Integer;
-  R: TRect;
-  Run: PVirtualNode;
-  UseColumns,
-  HScrollBarVisible: Boolean;
-
-begin
-  Result := False;
-  if Assigned(Node) and (Node &lt;&gt; FRoot) then
-  begin
-    // Make sure all parents of the node are expanded.
-    Run := Node.Parent;
-    while Run &lt;&gt; FRoot do
-    begin
-      if not (vsExpanded in Run.States) then
-        ToggleNode(Run);
-      Run := Run.Parent;
-    end;
-    UseColumns := FHeader.UseColumns;
-    if UseColumns then
-      R := GetDisplayRect(Node, FFocusedColumn, not (toGridExtensions in FOptions.FMiscOptions))
-    else
-      R := GetDisplayRect(Node, NoColumn, not (toGridExtensions in FOptions.FMiscOptions));
-
-    // The returned rectangle can never be empty after the expand code above.
-    // 1) scroll vertically
-    if R.Top &lt; 0 then
-    begin
-      if Center then
-        SetOffsetY(FOffsetY - R.Top + ClientHeight div 2)
-      else
-        SetOffsetY(FOffsetY - R.Top);
-      Result := True;
-    end
-    else
-      if (R.Bottom &gt; ClientHeight) or Center then
-      begin
-        HScrollBarVisible := (ScrollBarOptions.ScrollBars in [ssBoth, ssHorizontal]) and
-          (ScrollBarOptions.AlwaysVisible or (Integer(FRangeX) &gt; ClientWidth));
-        if Center then
-          SetOffsetY(FOffsetY - R.Bottom + ClientHeight div 2)
-        else
-          SetOffsetY(FOffsetY - R.Bottom + ClientHeight);
-        // When scrolling up and the horizontal scroll appears because of the operation
-        // then we have to move up the node the horizontal scrollbar's height too
-        // in order to avoid that the scroll bar hides the node which we wanted to have in view.
-        if not UseColumns and not HScrollBarVisible and (Integer(FRangeX) &gt; ClientWidth) then
-          SetOffsetY(FOffsetY - GetSystemMetrics(SM_CYHSCROLL));
-        Result := True;
-      end;
-
-    if Horizontally then
-    begin
-      // 2) scroll horizontally
-      if (R.Right &gt; ClientWidth) or (R.Left &lt; 0) then
-      begin
-        MidPoint := -FOffsetX + (R.Left + R.Right) div 2;
-        SetOffsetX((ClientWidth div 2) - MidPoint);
-        Result := True;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SelectAll(VisibleOnly: Boolean);
-
-// Select all nodes in the tree.
-// If VisibleOnly is True then only visible nodes are selected.
-
-var
-  Run: PVirtualNode;
-  NextFunction: function(Node: PVirtualNode): PVirtualNode of object;
-
-begin
-  if toMultiSelect in FOptions.FSelectionOptions then
-  begin
-    ClearTempCache;
-    if VisibleOnly then
-    begin
-      Run := GetFirstVisible;
-      NextFunction := GetNextVisible;
-    end
-    else
-    begin
-      Run := GetFirst;
-      NextFunction := GetNext;
-    end;
-
-    while Assigned(Run) do
-    begin
-      if not(vsSelected in Run.States) then
-        InternalCacheNode(Run);
-      Run := NextFunction(Run);
-    end;
-    if FTempNodeCount &gt; 0 then
-      AddToSelection(FTempNodeCache, FTempNodeCount);
-    ClearTempCache;
-    Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.Sort(Node: PVirtualNode; Column: TColumnIndex; Direction: TSortDirection; DoInit: Boolean = True);
-
-// Sorts the given node. The application is queried about how to sort via the OnCompareNodes event.
-// Column is simply passed to the the compare function so the application can also sort in a particular column.
-// In order to free the application from taking care about the sort direction the parameter Direction is used.
-// This way the application can always sort in increasing order, while this method reorders nodes according to this flag.
-
-  //--------------- local functions -------------------------------------------
-
-  function MergeAscending(A, B: PVirtualNode): PVirtualNode;
-
-  // Merges A and B (which both must be sorted via Compare) into one list.
-
-  var
-    Dummy: TVirtualNode;
-
-  begin
-    // This avoids checking for Result = nil in the loops.
-    Result := @Dummy;
-    while Assigned(A) and Assigned(B) do
-    begin
-      if DoCompare(A, B, Column) &lt;= 0 then
-      begin
-        Result.NextSibling := A;
-        Result := A;
-        A := A.NextSibling;
-      end
-      else
-      begin
-        Result.NextSibling := B;
-        Result := B;
-        B := B.NextSibling;
-      end;
-    end;
-
-    // Just append the list which is not nil (or set end of result list to nil if both lists are nil).
-    if Assigned(A) then
-      Result.NextSibling := A
-    else
-      Result.NextSibling := B;
-    // return start of the new merged list
-    Result := Dummy.NextSibling;
-  end;
-
-  //---------------------------------------------------------------------------
-
-  function MergeDescending(A, B: PVirtualNode): PVirtualNode;
-
-  // Merges A and B (which both must be sorted via Compare) into one list.
-
-  var
-    Dummy: TVirtualNode;
-
-  begin
-    // this avoids checking for Result = nil in the loops
-    Result := @Dummy;
-    while Assigned(A) and Assigned(B) do
-    begin
-      if DoCompare(A, B, Column) &gt;= 0 then
-      begin
-        Result.NextSibling := A;
-        Result := A;
-        A := A.NextSibling;
-      end
-      else
-      begin
-        Result.NextSibling := B;
-        Result := B;
-        B := B.NextSibling;
-      end;
-    end;
-
-    // Just append the list which is not nil (or set end of result list to nil if both lists are nil).
-    if Assigned(A) then
-      Result.NextSibling := A
-    else
-      Result.NextSibling := B;
-    // Return start of the newly merged list.
-    Result := Dummy.NextSibling;
-  end;
-
-  //---------------------------------------------------------------------------
-
-  function MergeSortAscending(var Node: PVirtualNode; N: Cardinal): PVirtualNode;
-
-  // Sorts the list of nodes given by Node (which must not be nil).
-
-  var
-    A, B: PVirtualNode;
-
-  begin
-    if N &gt; 1 then
-    begin
-      A := MergeSortAscending(Node, N div 2);
-      B := MergeSortAscending(Node, (N + 1) div 2);
-      Result := MergeAscending(A, B);
-    end
-    else
-    begin
-      Result := Node;
-      Node := Node.NextSibling;
-      Result.NextSibling := nil;
-    end;
-  end;
-
-  //---------------------------------------------------------------------------
-
-  function MergeSortDescending(var Node: PVirtualNode; N: Cardinal): PVirtualNode;
-
-  // Sorts the list of nodes given by Node (which must not be nil).
-
-  var
-    A, B: PVirtualNode;
-
-  begin
-    if N &gt; 1 then
-    begin
-      A := MergeSortDescending(Node, N div 2);
-      B := MergeSortDescending(Node, (N + 1) div 2);
-      Result := MergeDescending(A, B);
-    end
-    else
-    begin
-      Result := Node;
-      Node := Node.NextSibling;
-      Result.NextSibling := nil;
-    end;
-  end;
-
-  //--------------- end local functions ---------------------------------------
-
-var
-  Run: PVirtualNode;
-  Index: Cardinal;
-  
-begin
-  InterruptValidation;
-  if tsEditPending in FStates then
-  begin
-    StopTimer(EditTimer);
-    DoStateChange([], [tsEditPending]);
-  end;
-
-  if not (tsEditing in FStates) or DoEndEdit then
-  begin
-    if Node = nil then
-      Node := FRoot;
-    if vsHasChildren in Node.States then
-    begin
-      if (Node.ChildCount = 0) and DoInit then
-        InitChildren(Node);
-      // Make sure the children are valid, so they can be sorted at all.
-      if DoInit and (Node.ChildCount &gt; 1) then
-        ValidateChildren(Node, False);
-      // Child count might have changed.
-      if Node.ChildCount &gt; 1 then
-      begin
-        // Sort the linked list, check direction flag only once.
-        if Direction = sdAscending then
-          Node.FirstChild := MergeSortAscending(Node.FirstChild, Node.ChildCount)
-        else
-          Node.FirstChild := MergeSortDescending(Node.FirstChild, Node.ChildCount);
-        // Consolidate the child list finally.
-        Run := Node.FirstChild;
-        Run.PrevSibling := nil;
-        Index := 0;
-        repeat
-          Run.Index := Index;
-          Inc(Index);
-          if Run.NextSibling = nil then
-            Break;
-          Run.NextSibling.PrevSibling := Run;
-          Run := Run.NextSibling;
-        until False;
-        Node.LastChild := Run;
-
-        InvalidateCache;
-      end;
-      if FUpdateCount = 0 then
-      begin
-        ValidateCache;
-        Invalidate;
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.SortTree(Column: TColumnIndex; Direction: TSortDirection; DoInit: Boolean = True);
-
-  //--------------- local function --------------------------------------------
-
-  procedure DoSort(Node: PVirtualNode);
-
-  // Recursively sorts Node and its child nodes.
-
-  var
-    Run: PVirtualNode;
-
-  begin
-    Sort(Node, Column, Direction, DoInit);
-
-    Run := Node.FirstChild;
-    while Assigned(Run) do
-    begin
-      if DoInit and not (vsInitialized in Run.States) then
-        InitNode(Run);
-      if vsInitialized in Run.States then
-        DoSort(Run);
-      Run := Run.NextSibling;
-    end;
-  end;
-
-  //--------------- end local function ----------------------------------------
-
-begin
-  // Instead of wrapping the sort using BeginUpdate/EndUpdate simply the update counter
-  // is modified. Otherwise the EndUpdate call will recurse here.
-  Inc(FUpdateCount);
-  try
-    if Column &gt; InvalidColumn then
-      DoSort(FRoot);
-    InvalidateCache;
-  finally
-    if FUpdateCount &gt; 0 then
-      Dec(FUpdateCount);
-    if FUpdateCount = 0 then
-    begin
-      ValidateCache;
-      Invalidate;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ToggleNode(Node: PVirtualNode);
-
-// Changes a node's expand state to the opposite state.
-
-var
-  LastTopNode,
-  Child: PVirtualNode;
-  NewHeight: Integer;
-  NeedUpdate: Boolean;
-  ToggleData: TToggleAnimationData;
-  
-begin
-  Assert(Assigned(Node), 'Node must not be nil.');
-  NeedUpdate := False;
-
-  // We don't need to switch the expand state if the node is being deleted otherwise some
-  // updates (e.g. visible node count) are done twice with disasterous results).
-  if not (vsDeleting in Node.States) then
-  begin
-    // LastTopNode is needed to know when the entire tree scrolled during toggling.
-    // It is of course only needed when we also update the display here.
-    if FUpdateCount = 0 then
-      LastTopNode := GetTopNode
-    else
-      LastTopNode := nil;
-
-    if vsExpanded in Node.States then
-    begin
-      if DoCollapsing(Node) then
-      begin
-        NeedUpdate := True;
-
-        if (FUpdateCount = 0) and (toAnimatedToggle in FOptions.FAnimationOptions) and not (tsCollapsing in FStates) then
-        begin
-          Application.CancelHint;
-          UpdateWindow(Handle);
-        
-          // animated collapsing
-          with ToggleData do
-          begin
-            Expand := False;
-            R := GetDisplayRect(Node, NoColumn, False);
-            R.Bottom := ClientHeight;
-            Inc(R.Top, Node.NodeHeight);
-            Window := Handle;
-            DC := GetDC(Handle);
-            Self.Brush.Color := Color;
-            Brush := Self.Brush.Handle;
-            try
-              Animate(Min(R.Bottom - R.Top + 1, Node.TotalHeight - Node.NodeHeight), FAnimationDuration, ToggleCallback,
-                @ToggleData);
-            finally
-              ReleaseDC(Window, DC);
-            end;
-          end;
-        end;
-
-        // collapse the node
-        AdjustTotalHeight(Node, Node.NodeHeight);
-        if FullyVisible[Node] then
-          Dec(FVisibleCount, CountVisibleChildren(Node));
-        Exclude(Node.States, vsExpanded);
-        DoCollapsed(Node);
-
-        // Remove child nodes now, if enabled.
-        if (toAutoFreeOnCollapse in FOptions.FAutoOptions) and (Node.ChildCount &gt; 0) then
-        begin
-          DeleteChildren(Node);
-          Include(Node.States, vsHasChildren);
-        end;
-      end;
-    end
-    else
-      if DoExpanding(Node) then
-      begin
-        NeedUpdate := True;
-        // expand the node, need to adjust the height
-        if not (vsInitialized in Node.States) then
-          InitNode(Node);
-        if (vsHasChildren in Node.States) and (Node.ChildCount = 0) then
-          InitChildren(Node);
-
-        // Avoid setting the vsExpanded style if there are no child nodes.
-        if Node.ChildCount &gt; 0 then
-        begin
-          // Iterate through the child nodes without initializing them. We have to determine the entire height.
-          NewHeight := 0;
-          Child := Node.FirstChild;
-          repeat
-            if vsVisible in Child.States then
-              Inc(NewHeight, Child.TotalHeight);
-            Child := Child.NextSibling;
-          until Child = nil;
-
-          if FUpdateCount = 0 then
-          begin
-            ToggleData.R := GetDisplayRect(Node, NoColumn, False);
-
-            // Do animated expanding if enabled and it is not the last visible node to be expanded.
-            if (ToggleData.R.Top &lt; ClientHeight) and ([tsPainting, tsExpanding] * FStates = []) and
-              (toAnimatedToggle in FOptions.FAnimationOptions) and (GetNextVisibleNoInit(Node) &lt;&gt; nil) then
-            begin
-              Application.CancelHint;
-              UpdateWindow(Handle);
-              // animated expanding
-              with ToggleData do
-              begin
-                Inc(R.Top, Node.NodeHeight);
-                R.Bottom := ClientHeight;
-                if R.Bottom &gt; R.Top then
-                begin
-                  Expand := True;
-                  Window := Handle;
-                  DC := GetDC(Handle);
-
-                  Self.Brush.Color := Color;
-                  Brush := Self.Brush.Handle;
-                  try
-                    Animate(Min(R.Bottom - R.Top + 1, NewHeight), FAnimationDuration, ToggleCallback, @ToggleData);
-                  finally
-                    ReleaseDC(Window, DC);
-                  end;
-                end;
-              end;
-            end;
-          end;
-        
-          Include(Node.States, vsExpanded);
-          AdjustTotalHeight(Node, NewHeight, True);
-          if FullyVisible[Node] then
-            Inc(FVisibleCount, CountVisibleChildren(Node));
-
-          DoExpanded(Node);
-        end;
-      end;
-
-    if NeedUpdate then
-    begin
-      InvalidateCache;
-      if FUpdateCount = 0 then
-        if Node.ChildCount &gt; 0 then
-        begin
-          ValidateCache;
-          UpdateScrollbars(True);
-          // Scroll as much child nodes into view as possible if the node has been expanded.
-          if (toAutoScrollOnExpand in FOptions.FAutoOptions) and (vsExpanded in Node.States) then
-          begin
-            if Integer(Node.TotalHeight) &lt;= ClientHeight then
-              ScrollIntoView(GetLastChild(Node), toCenterScrollIntoView in FOptions.SelectionOptions)
-            else
-              TopNode := Node;
-          end;
-
-          // Check for automatically scrolled tree.
-          if LastTopNode &lt;&gt; GetTopNode then
-            Invalidate
-          else
-            InvalidateToBottom(Node);
-        end
-        else
-          InvalidateNode(Node);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.UpdateAction(Action: TBasicAction): Boolean;
-
-// Support for standard actions.
-
-begin
-  if not Focused then
-    Result := inherited UpdateAction(Action)
-  else
-  begin
-    Result := (Action is TEditCut) or (Action is TEditCopy)
-      {$ifdef COMPILER_5_UP} or (Action is TEditDelete) {$endif COMPILER_5_UP};
-
-    if Result then
-      TAction(Action).Enabled := (FSelectionCount &gt; 0) and
-        ({$ifdef COMPILER_5_UP} (Action is TEditDelete) or {$endif COMPILER_5_UP} (FClipboardFormats.Count &gt; 0))
-    else
-    begin
-      Result := Action is TEditPaste;
-      if Result then
-        TAction(Action).Enabled := True
-      else
-      begin
-        {$ifdef COMPILER_5_UP}
-          Result := Action is TEditSelectAll;
-          if Result then
-            TAction(Action).Enabled := (toMultiSelect in FOptions.FSelectionOptions) and (FVisibleCount &gt; 0)
-          else
-        {$endif COMPILER_5_UP}
-            Result := inherited UpdateAction(Action);
-      end;
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.UpdateHorizontalScrollBar(DoRepaint: Boolean);
-
-var
-  ScrollInfo: TScrollInfo;
-
-begin
-  if FHeader.UseColumns then
-    FRangeX := FHeader.FColumns.TotalWidth
-  else
-    FRangeX := GetMaxRightExtend;
-
-  if FScrollBarOptions.ScrollBars in [ssHorizontal, ssBoth] then
-  begin
-    FillChar(ScrollInfo, SizeOf(ScrollInfo), 0);
-    ScrollInfo.cbSize := SizeOf(ScrollInfo);
-    ScrollInfo.fMask := SIF_ALL;
-    {$ifdef UseFlatScrollbars}
-      FlatSB_GetScrollInfo(Handle, SB_HORZ, ScrollInfo);
-    {$else}
-      GetScrollInfo(Handle, SB_HORZ, ScrollInfo);
-    {$endif UseFlatScrollbars}
-
-    if (Integer(FRangeX) &gt; ClientWidth) or FScrollBarOptions.AlwaysVisible then
-    begin
-      {$ifdef UseFlatScrollbars}
-        FlatSB_ShowScrollBar(Handle, SB_HORZ, True);
-      {$else}
-        ShowScrollBar(Handle, SB_HORZ, True);
-      {$endif UseFlatScrollbars}
-      
-      ScrollInfo.nMin := 0;
-      ScrollInfo.nMax := FRangeX;
-      ScrollInfo.nPos := -FOffsetX;
-      ScrollInfo.nPage := Max(0, ClientWidth + 1);
-
-      ScrollInfo.fMask := SIF_ALL or ScrollMasks[FScrollBarOptions.AlwaysVisible];
-      {$ifdef UseFlatScrollbars}
-        FlatSB_SetScrollInfo(Handle, SB_HORZ, ScrollInfo, DoRepaint);
-      {$else}
-        SetScrollInfo(Handle, SB_HORZ, ScrollInfo, DoRepaint);
-      {$endif UseFlatScrollbars}
-    end
-    else
-    begin
-      ScrollInfo.nMin := 0;
-      ScrollInfo.nMax := 0;
-      ScrollInfo.nPos := 0;
-      ScrollInfo.nPage := 0;
-      {$ifdef UseFlatScrollbars}
-        FlatSB_ShowScrollBar(Handle, SB_HORZ, False);
-        FlatSB_SetScrollInfo(Handle, SB_HORZ, ScrollInfo, False);
-      {$else}
-        ShowScrollBar(Handle, SB_HORZ, False);
-        SetScrollInfo(Handle, SB_HORZ, ScrollInfo, False);
-      {$endif UseFlatScrollbars}
-    end;
-      
-    // Since the position is automatically changed if it doesn't meet the range
-    // we better read the current position back to stay synchronized.
-    {$ifdef UseFlatScrollbars}
-      SetOffsetX(-FlatSB_GetScrollPos(Handle, SB_HORZ));
-    {$else}
-      SetOffsetX(-GetScrollPos(Handle, SB_HORZ));
-    {$endif UseFlatScrollbars}
-  end
-  else
-  begin
-    {$ifdef UseFlatScrollbars}
-      FlatSB_ShowScrollBar(Handle, SB_HORZ, False);
-    {$else}
-      ShowScrollBar(Handle, SB_HORZ, False);
-    {$endif UseFlatScrollbars}
-
-    // Reset the current horizontal offset to account for window resize etc.
-    SetOffsetX(FOffsetX);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.UpdateScrollBars(DoRepaint: Boolean);
-
-// adjusts scrollbars to reflect current size and paint offset of the tree
-
-begin
-  if HandleAllocated then
-  begin
-    UpdateHorizontalScrollBar(DoRepaint);
-    UpdateVerticalScrollBar(DoRepaint);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.UpdateVerticalScrollBar(DoRepaint: Boolean);
-
-var
-  ScrollInfo: TScrollInfo;
-
-begin
-  // total node height includes the height of the invisble root node
-  if FRoot.TotalHeight &lt; FDefaultNodeHeight then
-    FRoot.TotalHeight := FDefaultNodeHeight;
-  FRangeY := FRoot.TotalHeight - FRoot.NodeHeight;
-
-  if FScrollBarOptions.ScrollBars in [ssVertical, ssBoth] then
-  begin
-    ScrollInfo.cbSize := SizeOf(ScrollInfo);
-    ScrollInfo.fMask := SIF_ALL;
-    {$ifdef UseFlatScrollbars}
-      FlatSB_GetScrollInfo(Handle, SB_VERT, ScrollInfo);
-    {$else}
-      GetScrollInfo(Handle, SB_VERT, ScrollInfo);
-    {$endif UseFlatScrollbars}
-
-    if (Integer(FRangeY) &gt; ClientHeight) or FScrollBarOptions.AlwaysVisible then
-    begin
-      {$ifdef UseFlatScrollbars}
-        FlatSB_ShowScrollBar(Handle, SB_VERT, True);
-      {$else}
-        ShowScrollBar(Handle, SB_VERT, True);
-      {$endif UseFlatScrollbars}
-
-      ScrollInfo.nMin := 0;
-      ScrollInfo.nMax := FRangeY;
-      ScrollInfo.nPos := -FOffsetY;
-      ScrollInfo.nPage := Max(0, ClientHeight + 1);
-
-      ScrollInfo.fMask := SIF_ALL or ScrollMasks[FScrollBarOptions.AlwaysVisible];
-      {$ifdef UseFlatScrollbars}
-        FlatSB_SetScrollInfo(Handle, SB_VERT, ScrollInfo, DoRepaint);
-      {$else}
-        SetScrollInfo(Handle, SB_VERT, ScrollInfo, DoRepaint);
-      {$endif UseFlatScrollbars}
-    end
-    else
-    begin
-      ScrollInfo.nMin := 0;
-      ScrollInfo.nMax := 0;
-      ScrollInfo.nPos := 0;
-      ScrollInfo.nPage := 0;
-      {$ifdef UseFlatScrollbars}
-        FlatSB_ShowScrollBar(Handle, SB_VERT, False);
-        FlatSB_SetScrollInfo(Handle, SB_VERT, ScrollInfo, False);
-      {$else}
-        ShowScrollBar(Handle, SB_VERT, False);
-        SetScrollInfo(Handle, SB_VERT, ScrollInfo, False);
-      {$endif UseFlatScrollbars}
-    end;
-
-    // Since the position is automatically changed if it doesn't meet the range
-    // we better read the current position back to stay synchronized.
-    {$ifdef UseFlatScrollbars}
-      SetOffsetY(-FlatSB_GetScrollPos(Handle, SB_VERT));
-    {$else}
-      SetOffsetY(-GetScrollPos(Handle, SB_VERT));
-    {$endif UseFlatScrollBars}
-  end
-  else
-  begin
-    {$ifdef UseFlatScrollbars}
-      FlatSB_ShowScrollBar(Handle, SB_VERT, False);
-    {$else}
-      ShowScrollBar(Handle, SB_VERT, False);
-    {$endif UseFlatScrollbars}
-
-    // Reset the current vertical offset to account for window resize etc.
-    SetOffsetY(FOffsetY);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TBaseVirtualTree.UseRightToLeftReading: Boolean;
-
-// The tree can handle right-to-left reading also on non-middle-east systems, so we cannot use the same function as
-// it is implemented in TControl.
-
-begin
-  Result := BiDiMode &lt;&gt; bdLeftToRight;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ValidateChildren(Node: PVirtualNode; Recursive: Boolean);
-
-// Ensures that the children of the given node (and all their children, if Recursive is True) are initialized.
-// Node must already be initialized
-
-var
-  Child: PVirtualNode;
-
-begin
-  if Node = nil then
-    Node := FRoot;
-
-  if (vsHasChildren in Node.States) and (Node.ChildCount = 0) then
-    InitChildren(Node);
-  Child := Node.FirstChild;
-  while Assigned(Child) do
-  begin
-    ValidateNode(Child, Recursive);
-    Child := Child.NextSibling;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TBaseVirtualTree.ValidateNode(Node: PVirtualNode; Recursive: Boolean);
-
-// Ensures that the given node (and all its children, if Recursive is True) are initialized.
-
-var
-  Child: PVirtualNode;
-
-begin
-  if Node = nil then
-    Node := FRoot
-  else
-    if not (vsInitialized in Node.States) then
-      InitNode(Node);
-
-  if Recursive then
-  begin
-    if (vsHasChildren in Node.States) and (Node.ChildCount = 0) then
-      InitChildren(Node);
-    Child := Node.FirstChild;
-    while Assigned(Child) do
-    begin
-      ValidateNode(Child, recursive);
-      Child := Child.NextSibling;
-    end;
-  end;
-end;
-
-//----------------- TCustomStringTreeOptions ---------------------------------------------------------------------------
-
-constructor TCustomStringTreeOptions.Create(AOwner: TBaseVirtualTree);
-
-begin
-  inherited;
-  
-  FStringOptions := DefaultStringOptions;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomStringTreeOptions.SetStringOptions(const Value: TVTStringOptions);
-
-var
-  ChangedOptions: TVTStringOptions;
-
-begin
-  if FStringOptions &lt;&gt; Value then
-  begin
-    // Exclusive ORing to get all entries wich are in either set but not in both.
-    ChangedOptions := FStringOptions + Value - (FStringOptions * Value);
-    FStringOptions := Value;
-    with FOwner do
-      if (toShowStaticText in ChangedOptions) and not (csLoading in ComponentState) and HandleAllocated then
-        Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomStringTreeOptions.AssignTo(Dest: TPersistent);
-
-begin
-  if Dest is TCustomStringTreeOptions then
-  begin
-    with Dest as TCustomStringTreeOptions do
-      StringOptions := Self.StringOptions;
-  end;
-
-  // Let ancestors assign their options to the destination class.
-  inherited;
-end;
-
-//----------------- TVTEdit --------------------------------------------------------------------------------------------
-
-// Implementation of a generic node caption editor.
-
-constructor TVTEdit.Create(Link: TStringEditLink);
-
-begin
-  inherited Create(nil);
-  ShowHint := False;
-  ParentShowHint := False;
-  FLink := Link;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTEdit.CMAutoAdjust(var Message: TMessage);
-
-begin
-  AutoAdjustSize;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTEdit.CMExit(var Message: TMessage);
-
-begin
-  if not FLink.FStopping then
-    with FLink, FTree do
-    begin
-      if (toAutoAcceptEditChange in TreeOptions.StringOptions) then
-        FLink.FTree.DoEndEdit
-      else
-        FLink.FTree.DoCancelEdit;
-    end;
-
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTEdit.CNCommand(var Message: TWMCommand);
-
-begin
-  if Assigned(FLink) and Assigned(FLink.FTree) and (Message.NotifyCode = EN_UPDATE) and
-    not (toGridExtensions in FLink.FTree.FOptions.MiscOptions) and
-    not (vsMultiline in FLink.FNode.States) then
-    // Instead directly calling AutoAdjustSize it is necessary on Win9x/Me to decouple this notification message
-    // and eventual resizing. Hence we use a message to accomplish that.
-    if IsWinNT then
-      AutoAdjustSize
-    else
-      PostMessage(Handle, CM_AUTOADJUST, 0, 0);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTEdit.WMChar(var Message: TWMChar);
-
-begin
-  if not (Message.CharCode in [VK_ESCAPE, VK_TAB]) then
-    inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTEdit.WMDestroy(var Message: TWMDestroy);
-
-begin
-  // If editing stopped by other means than accept or cancel then we have to do default processing for
-  // pending changes.
-  if not FLink.FStopping then
-    with FLink, FTree do
-    begin
-      if (toAutoAcceptEditChange in TreeOptions.StringOptions) and Modified then
-        DoNewText(FNode, FColumn, FEdit.Caption);
-    end;
-
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTEdit.WMGetDlgCode(var Message: TWMGetDlgCode);
-
-begin
-  inherited;
-
-  Message.Result := Message.Result or DLGC_WANTALLKEYS;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTEdit.WMKeyDown(var Message: TWMKeyDown);
-
-// Handles some control keys. 
-
-var
-  Shift: TShiftState;
-  EndEdit: Boolean;
-  
-begin
-  case Message.CharCode of
-    // Pretend these keycodes were send to the tree.
-    VK_ESCAPE:
-      begin
-        FLink.FTree.DoCancelEdit;
-        // Set focus back to tree.
-        FLink.FTree.SetFocus;
-      end;
-    VK_RETURN:
-      begin
-        EndEdit := not (vsMultiline in FLink.FNode.States);
-        if not EndEdit then
-        begin
-          // If a multiline node is being edited the finish editing only if Ctrl+Enter was pressed,
-          // otherwise allow to insert line breaks into the text.
-          Shift := KeyDataToShiftState(Message.KeyData);
-          EndEdit := ssCtrl in Shift;
-        end;
-        if EndEdit then
-        begin
-          FLink.FTree.InvalidateNode(FLink.FNode);
-          FLink.FTree.DoEndEdit;
-          // Set focus back to tree.
-          FLink.FTree.SetFocus;
-        end;
-      end;
-    VK_UP:
-      begin
-        if not (vsMultiline in FLink.FNode.States) then
-          Message.CharCode := VK_LEFT;
-        inherited;
-      end;
-    VK_DOWN:
-      begin
-        if not (vsMultiline in FLink.FNode.States) then
-          Message.CharCode := VK_RIGHT;
-        inherited;
-      end;
-  else
-    inherited;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTEdit.AutoAdjustSize;
-
-// Changes the size of the edit to accomodate as much as possible of its text within its container window.
-// NewChar describes the next character which will be added to the edit's text.
-
-var
-  DC: HDC;
-  Size: TSize;
-  LastFont: THandle;
-
-begin
-  if not (vsMultiline in FLink.FNode.States) then
-  begin
-    // avoid flicker
-    SendMessage(Handle, WM_SETREDRAW, 0, 0);
-
-    DC := GetDC(Handle);
-    LastFont := SelectObject(DC, Font.Handle);
-    try
-      // Read needed space for the current text.
-      {$ifdef TntSupport}
-        GetTextExtentPoint32W(DC, PWideChar(Text), Length(Text), Size);
-      {$else}
-        GetTextExtentPoint32(DC, PChar(Text), Length(Text), Size);
-      {$endif TntSupport}
-      Inc(Size.cx, 2 * FLink.FTree.FTextMargin);
-
-      // Repaint associated node if the edit becomes smaller.
-      if Size.cx &lt; Width then
-        FLink.FTree.InvalidateNode(FLink.FNode);
-
-      if FLink.FAlignment = taRightJustify then
-        FLink.SetBounds(Rect(Left + Width - Size.cx, Top, Left + Width, Top + Height))
-      else
-        FLink.SetBounds(Rect(Left, Top, Left + Size.cx, Top + Height));
-    finally
-      SelectObject(DC, LastFont);
-      ReleaseDC(Handle, DC);
-      SendMessage(Handle, WM_SETREDRAW, 1, 0);
-    end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVTEdit.CreateParams(var Params: TCreateParams);
-
-begin
-  inherited;
-
-  // Only with multiline style we can use the text formatting rectangle.
-  // This does not harm formatting as single line control, if we don't use word wrapping.
-  with Params do
-  begin
-    Style := Style or ES_MULTILINE;
-    if vsMultiline in FLink.FNode.States then               
-      Style := Style and not (ES_AUTOHSCROLL or WS_HSCROLL) or WS_VSCROLL or ES_AUTOVSCROLL;
-    if tsUseThemes in FLink.FTree.FStates then
-    begin
-      Style := Style and not WS_BORDER;
-      ExStyle := ExStyle or WS_EX_CLIENTEDGE;
-    end
-    else
-    begin
-      Style := Style or WS_BORDER;
-      ExStyle := ExStyle and not WS_EX_CLIENTEDGE;
-    end;
-  end;
-end;
-
-//----------------- TStringEditLink ------------------------------------------------------------------------------------
-
-constructor TStringEditLink.Create;
-
-begin
-  inherited;
-  FEdit := TVTEdit.Create(Self);
-  with FEdit do
-  begin
-    Visible := False;
-    BorderStyle := bsSingle;
-    AutoSize := False;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-destructor TStringEditLink.Destroy;
-
-begin
-  FEdit.Free;
-  inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TStringEditLink.BeginEdit: Boolean;
-
-// Notifies the edit link that editing can start now. Descentants may cancel node edit
-// by returning False.
-
-begin
-  Result := not FStopping;
-  if Result then
-  begin
-    FEdit.Show;
-    FEdit.SelectAll;
-    FEdit.SetFocus;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TStringEditLink.SetEdit(const Value: TVTEdit);
-
-begin
-  if Assigned(FEdit) then
-    FEdit.Free;
-  FEdit := Value;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TStringEditLink.CancelEdit: Boolean;
-
-begin
-  Result := not FStopping;
-  if Result then
-  begin
-    FStopping := True;
-    FEdit.Hide;
-    FTree.CancelEditNode;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TStringEditLink.EndEdit: Boolean;
-
-begin
-  Result := not FStopping;
-  if Result then
-  try
-    FStopping := True;
-    if FEdit.Modified then
-      FTree.DoNewText(FNode, FColumn, FEdit.Text);
-    FEdit.Hide;
-  except
-    FStopping := False;
-    raise;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TStringEditLink.GetBounds: TRect;
-
-begin
-  Result := FEdit.BoundsRect;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TStringEditLink.PrepareEdit(Tree: TBaseVirtualTree; Node: PVirtualNode; Column: TColumnIndex): Boolean;
-
-// Retrieves the true text bounds from the owner tree.
-
-var
-  Text: WideString;
-
-begin
-  Result := Tree is TCustomVirtualStringTree;
-  if Result then
-  begin
-    FTree := Tree as TCustomVirtualStringTree;
-    FNode := Node;
-    FColumn := Column;
-    // Initial size, font and text of the node.
-    FTree.GetTextInfo(Node, Column, FEdit.Font, FTextBounds, Text);
-    FEdit.Font.Color := clBlack;
-    FEdit.Parent := Tree;
-    FEdit.RecreateWnd;
-    FEdit.HandleNeeded;
-    {$ifdef TntSupport}
-      FEdit.Text := Text;
-    {$else}
-      FEdit.Caption := Text;
-    {$endif}
-
-    if Column &lt;= NoColumn then
-    begin
-      FEdit.BidiMode := FTree.BidiMode;
-      FAlignment := FTree.Alignment;
-    end
-    else
-    begin
-      FEdit.BidiMode := FTree.Header.Columns[Column].BidiMode;
-      FAlignment := FTree.Header.Columns[Column].Alignment;
-    end;
-
-    if FEdit.BidiMode &lt;&gt; bdLeftToRight then
-      ChangeBidiModeAlignment(FAlignment);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TStringEditLink.ProcessMessage(var Message: TMessage);
-
-begin
-  FEdit.WindowProc(Message);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TStringEditLink.SetBounds(R: TRect);
-
-// Sets the outer bounds of the edit control and the actual edit area in the control.
-
-var
-  Offset: Integer;
-  
-begin
-  if not FStopping then
-  begin
-    with R do
-    begin
-      // Set the edit's bounds but make sure there's a minimum width and the right border does not
-      // extend beyond the parent's left/right border.
-      if Left &lt; 0 then
-        Left := 0;
-      if Right - Left &lt; 30 then
-      begin
-        if FAlignment = taRightJustify then
-          Left := Right - 30
-        else
-          Right := Left + 30;
-      end;
-      if Right &gt; FTree.ClientWidth then
-        Right := FTree.ClientWidth;
-      FEdit.BoundsRect := R;
-
-      // The selected text shall exclude the text margins and be centered vertically.
-      // We have to take out the two pixel border of the edit control as well as a one pixel &quot;edit border&quot; the
-      // control leaves around the (selected) text.
-      R := FEdit.ClientRect;
-      Offset := 2;
-      if tsUseThemes in FTree.FStates then
-        Inc(Offset);
-      if vsMultiline in FNode.States then
-        InflateRect(R, -FTree.FTextMargin + Offset, -FTree.FTextMargin + Offset)
-      else
-      begin
-        InflateRect(R, -FTree.FTextMargin + Offset, Offset);
-        OffsetRect(R, 0, FTextBounds.Top - FEdit.Top);
-      end;
-      
-      SendMessage(FEdit.Handle, EM_SETRECTNP, 0, Integer(@R));
-    end;
-  end;
-end;
-
-//----------------- TCustomVirtualString -------------------------------------------------------------------------------
-
-constructor TCustomVirtualStringTree.Create(AOwner: TComponent);
-
-begin
-  inherited;
-  
-  FDefaultText := 'Node';
-  FInternalDataOffset := AllocateInternalDataArea(SizeOf(Cardinal));
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.GetRenderStartValues(Source: TVSTTextSourceType; var Node: PVirtualNode;
-  var NextNodeProc: TGetNextNodeProc);
-
-begin
-  case Source of
-    tstInitialized:
-      begin
-        Node := GetFirstInitialized;
-        NextNodeProc := GetNextInitialized;
-      end;
-    tstSelected:
-      begin
-        Node := GetFirstSelected;
-        NextNodeProc := GetNextSelected;
-      end;
-    tstCutCopySet:
-      begin
-        Node := GetFirstCutCopy;
-        NextNodeProc := GetNextCutCopy;
-      end;
-    tstVisible:
-      begin
-        Node := GetFirstVisible;
-        NextNodeProc := GetNextVisible;
-      end;
-  else // tstAll
-    Node := GetFirst;
-    NextNodeProc := GetNext;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.GetOptions: TCustomStringTreeOptions;
-
-begin
-  Result := FOptions as TCustomStringTreeOptions;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.GetText(Node: PVirtualNode; Column: TColumnIndex): WideString;
-
-begin
-  Assert(Assigned(Node), 'Node must not be nil.');
-
-  if not (vsInitialized in Node.States) then
-    InitNode(Node);
-  Result := FDefaultText;
-
-  DoGetText(Node, Column, ttNormal, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-                                                
-procedure TCustomVirtualStringTree.InitializeTextProperties(const Canvas: TCanvas; Node: PVirtualNode;
-  Column: TColumnIndex);
-
-// Initializes default values for customization in PaintNormalText.
-
-begin
-  Canvas.Font := Font;
-
-  if (toHotTrack in FOptions.FPaintOptions) and (Node = FCurrentHotNode) then
-  begin
-    Canvas.Font.Style := Canvas.Font.Style + [fsUnderline];
-    Canvas.Font.Color := FColors.HotColor;
-  end;
-
-  if (Column = FFocusedColumn) or (toFullRowSelect in FOptions.FSelectionOptions) then
-  begin
-    if Node = FDropTargetNode then
-    begin
-      if (FLastDropMode = dmOnNode) or (vsSelected in Node.States)then
-        Canvas.Font.Color := clHighlightText
-      else
-        Canvas.Font.Color := Font.Color;
-    end
-    else
-      if vsSelected in Node.States then
-      begin
-        if Focused or (toPopupMode in FOptions.FPaintOptions) then
-          Canvas.Font.Color := clHighlightText
-        else
-          Canvas.Font.Color := Font.Color;
-      end;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.PaintNormalText(var PaintInfo: TVTPaintInfo; TextOutFlags: Integer;
-  Text: WideString);
-
-// This method is responsible for painting the given test to target canvas (under consideration of the given rectangles).
-// The text drawn here is considered as the normal text in a node.
-// Note: NodeWidth is the actual width of the text to be drawn. This does not necessarily correspond to the width of
-//       the node rectangle. The clipping rectangle comprises the entire node (including tree lines, buttons etc.).
-
-var
-  TripleWidth: Integer;
-  R: TRect;
-  DrawFormat: Cardinal;
-  Size: TSize;
-
-begin
-  with PaintInfo do
-  begin
-    InitializeTextProperties(Canvas, Node, Column);
-
-    R := ContentRect;
-    Canvas.TextFlags := 0;
-
-    // Multiline nodes don't need special font handling or text manipulation.
-    // Note: multiline support requires the Unicode version of DrawText, which is able to do word breaking.
-    //       The emulation in this unit does not support this so we have to use the OS version. However
-    //       DrawTextW is only available on NT/2000/XP and up. Hence there is only partial multiline support
-    //       for 9x/Me.
-    if vsMultiline in Node.States then
-    begin
-      InflateRect(R, -FTextMargin, -FTextMargin);
-      DoPaintText(Node, Canvas, Column, ttNormal);
-      // Disabled node color overrides all other variants.
-      if (vsDisabled in Node.States) or not Enabled then
-        Canvas.Font.Color := FColors.DisabledColor;
-
-      // The edit control flag will ensure that no partial line is displayed, that is, only lines
-      // which are (vertically) fully visible are drawn.
-      DrawFormat := DT_NOPREFIX or DT_WORDBREAK or DT_END_ELLIPSIS or DT_EDITCONTROL or AlignmentToDrawFlag[Alignment];
-      if BidiMode &lt;&gt; bdLeftToRight then
-        DrawFormat := DrawFormat or DT_RTLREADING;
-    end
-    else
-    begin
-      InflateRect(R, -FTextMargin, 0);
-      FFontChanged := False;
-      TripleWidth := FEllipsisWidth;
-      DoPaintText(Node, Canvas, Column, ttNormal);
-      if FFontChanged then
-      begin
-        // If the font has been changed then the ellipsis width must be recalculated.
-        TripleWidth := 0;
-        // Recalculate also the width of the normal text.
-        GetTextExtentPoint32W(Canvas.Handle, PWideChar(Text), Length(Text), Size);
-        NodeWidth := Size.cx + 2 * FTextMargin;
-      end;
-
-      // Disabled node color overrides all other variants.
-      if (vsDisabled in Node.States) or not Enabled then
-        Canvas.Font.Color := FColors.DisabledColor;
-
-      DrawFormat := DT_NOPREFIX or DT_VCENTER or DT_SINGLELINE;
-      if BidiMode &lt;&gt; bdLeftToRight then
-        DrawFormat := DrawFormat or DT_RTLREADING;
-      // Check if the text must be shortend.
-      if (Column &gt; -1) and ((NodeWidth - 2 * FTextMargin) &gt; R.Right - R.Left) then
-      begin
-        Text := DoShortenString(Canvas, Node, Column, Text, R.Right - R.Left, BidiMode &lt;&gt; bdLeftToRight, TripleWidth);
-        if Alignment = taRightJustify then
-          DrawFormat := DrawFormat or DT_RIGHT
-        else
-          DrawFormat := DrawFormat or DT_LEFT;
-      end
-      else
-        DrawFormat := DrawFormat or AlignmentToDrawFlag[Alignment];
-    end;
-    
-    if Canvas.TextFlags and ETO_OPAQUE = 0 then
-      SetBkMode(Canvas.Handle, TRANSPARENT)
-    else
-      SetBkMode(Canvas.Handle, OPAQUE);
-    if IsWinNT then
-      Windows.DrawTextW(Canvas.Handle, PWideChar(Text), Length(Text), R, DrawFormat)
-    else
-      DrawTextW(Canvas.Handle, PWideChar(Text), Length(Text), R, DrawFormat, False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.PaintStaticText(const PaintInfo: TVTPaintInfo; TextOutFlags: Integer;
-  const Text: WideString);
-
-// This method retrives and draws the static text bound to a particular node.
-
-var
-  R: TRect;
-  DrawFormat: Cardinal;
-
-begin
-  with PaintInfo do
-  begin
-    Canvas.Font := Font;
-    if toFullRowSelect in FOptions.FSelectionOptions then
-    begin
-      if Node = FDropTargetNode then
-      begin
-        if (FLastDropMode = dmOnNode) or (vsSelected in Node.States)then
-          Canvas.Font.Color := clHighlightText
-        else
-          Canvas.Font.Color := Font.Color;
-      end
-      else
-        if vsSelected in Node.States then
-        begin
-          if Focused or (toPopupMode in FOptions.FPaintOptions) then
-            Canvas.Font.Color := clHighlightText
-          else
-            Canvas.Font.Color := Font.Color;
-        end;
-    end;
-
-    DrawFormat := DT_VCENTER or DT_SINGLELINE;
-    Canvas.TextFlags := 0;
-    DoPaintText(Node, Canvas, Column, ttStatic);
-
-    // Disabled node color overrides all other variants.
-    if (vsDisabled in Node.States) or not Enabled then
-      Canvas.Font.Color := FColors.DisabledColor;
-
-    R := ContentRect;
-    if Alignment = taRightJustify then
-      Dec(R.Right, NodeWidth + FTextMargin)
-    else
-      Inc(R.Left, NodeWidth + FTextMargin);
-
-    if Canvas.TextFlags and ETO_OPAQUE = 0 then
-      SetBkMode(Canvas.Handle, TRANSPARENT)
-    else
-      SetBkMode(Canvas.Handle, OPAQUE);
-    if IsWinNT then
-      Windows.DrawTextW(Canvas.Handle, PWideChar(Text), Length(Text), R, DrawFormat)
-    else
-      DrawTextW(Canvas.Handle, PWideChar(Text), Length(Text), R, DrawFormat, False);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.ReadText(Reader: TReader);
-
-begin
-  case Reader.NextValue of
-    vaLString, vaString:
-      SetDefaultText(Reader.ReadString);
-  else
-    SetDefaultText(Reader.ReadWideString);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.SetDefaultText(const Value: WideString);
-
-begin
-  if FDefaultText &lt;&gt; Value then
-  begin
-    FDefaultText := Value;
-    if not (csLoading in ComponentState) then
-      Invalidate;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.SetOptions(const Value: TCustomStringTreeOptions);
-
-begin
-  FOptions.Assign(Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.SetText(Node: PVirtualNode; Column: TColumnIndex; const Value: WideString);
-
-begin
-  DoNewText(Node, Column, Value);
-  InvalidateNode(Node);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.WriteText(Writer: TWriter);
-
-begin
-  Writer.WriteWideString(FDefaultText);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.WMSetFont(var Msg: TWMSetFont);
-
-// Whenever a new font is applied to the tree some default values are determined to avoid frequent
-// determination of the same value.
-
-var
-  MemDC: HDC;
-  Run: PVirtualNode;
-  TM: TTextMetric;
-  Size: TSize;
-  
-begin
-  inherited;
-
-  MemDC := CreateCompatibleDC(0);
-  try
-    SelectObject(MemDC, Msg.Font);
-    GetTextMetrics(MemDC, TM);
-    FTextHeight := TM.tmHeight;
-
-    GetTextExtentPoint32W(MemDC, '...', 3, Size);
-    FEllipsisWidth := Size.cx;
-  finally
-    DeleteDC(MemDC);
-  end;
-
-  // Have to reset all node widths.
-  Run := FRoot.FirstChild;
-  while Assigned(Run) do
-  begin
-    PInteger(InternalData(Run))^ := 0;
-    Run := GetNextNoInit(Run);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.AdjustPaintCellRect(var PaintInfo: TVTPaintInfo; var NextNonEmpty: TColumnIndex);
-
-// In the case a node spans several columns (if enabled) we need to determine how many columns.
-// Note: the autospan feature can only be used with left-to-right layout.
-
-begin
-  if (toAutoSpanColumns in FOptions.FAutoOptions) and FHeader.UseColumns and (PaintInfo.BidiMode = bdLeftToRight) then
-    with FHeader.FColumns, PaintInfo do
-    begin
-      // Start with the directly following column.
-      NextNonEmpty := GetNextVisibleColumn(Column);
-
-      // Auto spanning columns can only be used for left-to-right directionality because the tree is drawn
-      // from left to right. For RTL directionality it would be necessary to draw it from right to left.
-      // While this could be managed, it becomes impossible when directionality is mixed.
-      repeat
-        if (NextNonEmpty = InvalidColumn) or not ColumnIsEmpty(Node, NextNonEmpty) or
-          (Items[NextNonEmpty].BidiMode &lt;&gt; bdLeftToRight) then
-          Break;
-        Inc(CellRect.Right, Items[NextNonEmpty].Width);
-        NextNonEmpty := GetNextVisibleColumn(NextNonEmpty);
-      until False;
-    end
-    else
-      inherited;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.CalculateTextWidth(Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
-  Text: WideString): Integer;
-
-// determines the width of the given text
-
-var
-  Size: TSize;
-
-begin
-  Result := 2 * FTextMargin;
-  if Length(Text) &gt; 0 then
-  begin
-    Canvas.Font := Font;
-    DoPaintText(Node, Canvas, Column, ttNormal);
-
-    GetTextExtentPoint32W(Canvas.Handle, PWideChar(Text), Length(Text), Size);
-    Inc(Result, Size.cx);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.ColumnIsEmpty(Node: PVirtualNode; Column: TColumnIndex): Boolean;
-
-// For hit tests it is necessary to consider cases where columns are empty and automatic column spanning is enabled.
-// This method simply checks the given column's text and if this is empty then the column is considered as being empty.
-
-begin
-  Result := Length(Text[Node, Column]) = 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.DefineProperties(Filer: TFiler);
-
-begin
-  inherited;
-
-  // Delphi still cannot handle wide strings properly while streaming
-  Filer.DefineProperty('WideDefaultText', ReadText, WriteText, FDefaultText &lt;&gt; 'Node'); 
-  Filer.DefineProperty('StringOptions', ReadOldStringOptions, nil, False);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.DoCreateEditor(Node: PVirtualNode; Column: TColumnIndex): IVTEditLink;
-
-begin
-  Result := inherited DoCreateEditor(Node, Column);
-  // Enable generic label editing support if the application does not have own editors.
-  if Result = nil then
-    Result := TStringEditLink.Create;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.DoGetNodeHint(Node: PVirtualNode; Column: TColumnIndex): WideString;
-
-begin
-  Result := inherited DoGetNodeHint(Node, Column);
-  if Assigned(FOnGetHint) then
-    FOnGetHint(Self, Node, Column, ttNormal, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.DoGetNodeTooltip(Node: PVirtualNode; Column: TColumnIndex): WideString;
-
-begin
-  Result := Hint;
-  Result := Text[Node, Column];
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.DoGetNodeWidth(Node: PVirtualNode; Column: TColumnIndex; Canvas: TCanvas = nil): Integer;
-
-// Returns the text width of the given node in pixels.
-// This width is stored in the node's data member to increase access speed.
-
-var
-  Data: PInteger;
-  
-begin
-  if (Column &gt; NoColumn) and (vsMultiline in Node.States) then
-    Result := FHeader.Columns[Column].Width
-  else
-  begin
-    if Canvas = nil then
-      Canvas := Self.Canvas;
-
-    if Column = FHeader.MainColumn then
-    begin
-      // primary column or no columns
-      Data := InternalData(Node);
-      Result := Data^;
-      if Result = 0 then
-      begin
-        Data^ := CalculateTextWidth(Canvas, Node, Column, Text[Node, Column]);
-        Result := Data^;
-      end;
-    end
-    else
-      // any other column
-      Result := CalculateTextWidth(Canvas, Node, Column, Text[Node, Column]);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.DoGetText(Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
-  var Text: WideString);
-
-begin
-  if Assigned(FOnGetText) then
-    FOnGetText(Self, Node, Column, TextType, Text);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.DoIncrementalSearch(Node: PVirtualNode; const Text: WideString): Integer;
-
-// Since the string tree has access to node text it can do incremental search on its own. Use the event to
-// override the default behavior.
-
-begin
-  Result := 0;
-  if Assigned(FOnIncrementalSearch) then
-    FOnIncrementalSearch(Self, Node, Text, Result)
-  else
-    // Default behavior is to match the search string with the start of the node text.
-    if Pos(Text, GetText(Node, FocusedColumn)) &lt;&gt; 1 then
-      Result := 1;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.DoNewText(Node: PVirtualNode; Column: TColumnIndex; Text: WideString);
-
-begin
-  if Assigned(FOnNewText) then
-    FOnNewText(Self, Node, Column, Text);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.DoPaintNode(var PaintInfo: TVTPaintInfo);
-
-// Main output routine to print the text of the given node using the space provided in PaintInfo.ContentRect.
-
-var
-  S: WideString;
-  TextOutFlags: Integer;
-
-begin
-  // Set a new OnChange event for the canvas' font so we know if the application changes it in the callbacks.
-  // This long winded procedure is necessary because font changes (as well as brush and pen changes) are
-  // unfortunately not announced via the Canvas.OnChange event.
-  RedirectFontChangeEvent(PaintInfo.Canvas);
-
-  // Determine main text direction as well as other text properties.
-  TextOutFlags := ETO_CLIPPED or RTLFlag[PaintInfo.BidiMode &lt;&gt; bdLeftToRight];
-  S := Text[PaintInfo.Node, PaintInfo.Column];
-
-  // Paint the normal text first...
-  if Length(S) &gt; 0 then
-    PaintNormalText(PaintInfo, TextOutFlags, S);
-
-  // ... and afterwards the static text if not centered and the node is not multiline enabled.
-  if (Alignment &lt;&gt; taCenter) and not (vsMultiline in PaintInfo.Node.States) and (toShowStaticText in TreeOptions.FStringOptions) then
-  begin
-    S := '';
-    with PaintInfo do
-      DoGetText(Node, Column, ttStatic, S);
-    if Length(S) &gt; 0 then
-      PaintStaticText(PaintInfo, TextOutFlags, S);
-  end;
-  RestoreFontChangeEvent(PaintInfo.Canvas);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.DoPaintText(Node: PVirtualNode; const Canvas: TCanvas; Column: TColumnIndex;
-  TextType: TVSTTextType);
-
-begin
-  if Assigned(FOnPaintText) then
-    FOnPaintText(Self, Canvas, Node, Column, TextType);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.DoShortenString(Canvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
-  const S: WideString; Width: Integer; RightToLeft: Boolean; EllipsisWidth: Integer = 0): WideString;
-
-var
-  Done: Boolean;
-
-begin
-  Done := False;
-  if Assigned(FOnShortenString) then
-    FOnShortenString(Self, Canvas, Node, Column, S, Width, RightToLeft, Result, Done);
-  if not Done then
-    Result := ShortenString(Canvas.Handle, S, Width, RightToLeft, EllipsisWidth);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.GetOptionsClass: TTreeOptionsClass;
-
-begin
-  Result := TCustomStringTreeOptions;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.GetTextInfo(Node: PVirtualNode; Column: TColumnIndex; const AFont: TFont; var R: TRect;
-  var Text: WideString);
-
-// Returns the font, the text and its bounding rectangle to the caller. R is returned as the closest
-// bounding rectangle around Text.
-
-var
-  NewHeight: Integer;
-  TM: TTextMetric;
-
-begin
-  // Get default font and initialize the other parameters.
-  inherited GetTextInfo(Node, Column, AFont, R, Text);
-
-  Canvas.Font := AFont;
-
-  FFontChanged := False;
-  RedirectFontChangeEvent(Canvas);
-  DoPaintText(Node, Canvas, Column, ttNormal);
-  if FFontChanged then
-  begin
-    AFont.Assign(Canvas.Font);
-    GetTextMetrics(Canvas.Handle, TM);
-    NewHeight := TM.tmHeight;
-  end
-  else // Otherwise the correct font is already there and we only need to set the correct height.
-    NewHeight := FTextHeight;
-  RestoreFontChangeEvent(Canvas);
-
-  // Alignment to the actual text.
-  Text := Self.Text[Node, Column];
-  R := GetDisplayRect(Node, Column, True, not (vsMultiline in Node.States));
-  if toShowHorzGridLines in TreeOptions.PaintOptions then
-    Dec(R.Bottom);
-  InflateRect(R, 0, -(R.Bottom - R.Top - NewHeight) div 2);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.InternalData(Node: PVirtualNode): Pointer;
-
-begin
-  if (Node = FRoot) or (Node = nil) then
-    Result := nil
-  else
-    Result := PChar(Node) + FInternalDataOffset;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.MainColumnChanged;
-
-var
-  Run: PVirtualNode;
-
-begin
-  inherited;
-
-  // Have to reset all node widths.
-  Run := FRoot.FirstChild;
-  while Assigned(Run) do
-  begin
-    PInteger(InternalData(Run))^ := 0;
-    Run := GetNextNoInit(Run);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.ReadChunk(Stream: TStream; Version: Integer; Node: PVirtualNode; ChunkType,
-  ChunkSize: Integer): Boolean;
-
-// read in the caption chunk if there is one
-
-var
-  NewText: WideString;
-
-begin
-  case ChunkType of
-    CaptionChunk:
-      begin
-        NewText := '';
-        if ChunkSize &gt; 0 then
-        begin
-          SetLength(NewText, ChunkSize div 2);
-          Stream.Read(PWideChar(NewText)^, ChunkSize);
-        end;
-        // Do a new text event regardless of the caption content to allow removing the default string.
-        DoNewText(Node, FHeader.MainColumn, NewText);
-        Result := True;
-      end;
-  else
-    Result := inherited ReadChunk(Stream, Version, Node, ChunkType, ChunkSize);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-type
-  TOldVTStringOption = (soSaveCaptions, soShowStaticText);
-
-procedure TCustomVirtualStringTree.ReadOldStringOptions(Reader: TReader);
-
-// Migration helper routine to silently convert forms containing the old tree options member into the new
-// sub-options structure.
-
-var
-  OldOption: TOldVTStringOption;
-  EnumName: string;
-
-begin
-  // If we are at design time currently then let the designer know we changed something.
-  UpdateDesigner;
-
-  // It should never happen at this place that there is something different than the old set.
-  if Reader.ReadValue = vaSet then
-    with TreeOptions do
-    begin
-      // Remove all default values set by the constructor.
-      StringOptions := [];
-
-      while True do
-      begin
-        // Sets are stored with their members as simple strings. Read them one by one and map them to the new option
-        // in the correct sub-option set.
-        EnumName := Reader.ReadStr;
-        if EnumName = '' then
-          Break;
-        OldOption := TOldVTStringOption(GetEnumValue(TypeInfo(TOldVTStringOption), EnumName));
-        case OldOption of
-          soSaveCaptions:
-            StringOptions := FStringOptions + [toSaveCaptions];
-          soShowStaticText:
-            StringOptions := FStringOptions + [toShowStaticText];
-        end;
-      end;
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.RenderOLEData(const FormatEtcIn: TFormatEtc; out Medium: TStgMedium;
-  ForClipboard: Boolean): HResult;
-
-// Returns string expressions of all currently selected nodes in the Medium structure.
-
-begin
-  Result := inherited RenderOLEData(FormatEtcIn, Medium, ForClipboard);
-  if Failed(Result) then
-  try
-    if ForClipboard then
-      Medium.hGlobal := ContentToClipboard(FormatEtcIn.cfFormat, tstCutCopySet)
-    else
-      Medium.hGlobal := ContentToClipboard(FormatEtcIn.cfFormat, tstSelected);
-
-    // Fill rest of the Medium structure if rendering went fine.
-    if Medium.hGlobal &lt;&gt; 0 then
-    begin
-      Medium.tymed := TYMED_HGLOBAL;
-      Medium.unkForRelease := nil;
-
-      Result := S_OK;
-    end;
-  except
-    Result := E_FAIL;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.WriteChunks(Stream: TStream; Node: PVirtualNode);
-
-// Adds another sibling chunk for Node storing the label if the node is initialized.
-// Note: If the application stores a node's caption in the node's data member (which will be quite common) and needs to
-//       store more node specific data then it should use the OnSaveNode event rather than the caption autosave function
-//       (take out soSaveCaption from StringOptions). Otherwise the caption is unnecessarily stored twice.
-
-var
-  Header: TChunkHeader;
-  S: WideString;
-  Len: Integer;
-
-begin
-  inherited;
-  if (toSaveCaptions in TreeOptions.FStringOptions) and (Node &lt;&gt; FRoot) and
-    (vsInitialized in Node.States) then
-    with Stream do
-    begin
-      // Read the node's caption (primary column only).
-      S := Text[Node, FHeader.MainColumn];
-      Len := 2 * Length(S);
-      if Len &gt; 0 then
-      begin
-        // Write a new sub chunk.
-        Header.ChunkType := CaptionChunk;
-        Header.ChunkSize := Len;
-        Write(Header, SizeOf(Header));
-        Write(PWideChar(S)^, Len);
-      end;
-    end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.ContentToClipboard(Format: Word; Source: TVSTTextSourceType): HGLOBAL;
-
-// This method constructs a shareable memory object filled with string data in the required format. Supported are:
-// CF_TEXT - plain ANSI text (Unicode text is converted using the user's current locale)
-// CF_UNICODETEXT - plain Unicode text
-// CF_CSV - comma separated plain ANSI text 
-// CF_VRTF + CF_RTFNOOBS - rich text (plain ANSI)
-// CF_HTML - HTML text encoded using UTF-8
-//
-// Result is the handle to a globally allocated memory block which can directly be used for clipboard and drag'n drop
-// transfers. The caller is responsible for freeing the memory. If for some reason the content could not be rendered
-// the Result is 0.
-
-  //--------------- local function --------------------------------------------
-
-  procedure MakeFragment(var HTML: string);
-
-  // Helper routine to build a properly-formatted HTML fragment.
-
-  const
-    Version = 'Version:1.0'#13#10;
-    StartHTML = 'StartHTML:';
-    EndHTML = 'EndHTML:';
-    StartFragment = 'StartFragment:';
-    EndFragment = 'EndFragment:';
-    DocType = '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;';
-    HTMLIntro = '&lt;html&gt;&lt;head&gt;&lt;META http-equiv=Content-Type content=&quot;text/html; charset=utf-8&quot;&gt;' +
-      '&lt;/head&gt;&lt;body&gt;&lt;!--StartFragment--&gt;';
-    HTMLExtro = '&lt;!--EndFragment--&gt;&lt;/body&gt;&lt;/html&gt;';
-    NumberLengthAndCR = 10;
-
-    // Let the compiler determine the description length.
-    DescriptionLength = Length(Version) + Length(StartHTML) + Length(EndHTML) + Length(StartFragment) +
-      Length(EndFragment) + 4 * NumberLengthAndCR;
-
-  var
-    Description: string;
-    StartHTMLIndex,
-    EndHTMLIndex,
-    StartFragmentIndex,
-    EndFragmentIndex: Integer;
-
-  begin
-    // The HTML clipboard format is defined by using byte positions in the entire block where HTML text and
-    // fragments start and end. These positions are written in a description. Unfortunately the positions depend on the
-    // length of the description but the description may change with varying positions.
-    // To solve this dilemma the offsets are converted into fixed length strings which makes it possible to know
-    // the description length in advance.
-    StartHTMLIndex := DescriptionLength;              // position 0 after the description
-    StartFragmentIndex := StartHTMLIndex + Length(DocType) + Length(HTMLIntro);
-    EndFragmentIndex := StartFragmentIndex + Length(HTML);
-    EndHTMLIndex := EndFragmentIndex + Length(HTMLExtro);
-
-    Description := Version +
-      SysUtils.Format('%s%.8d', [StartHTML, StartHTMLIndex]) + #13#10 +
-      SysUtils.Format('%s%.8d', [EndHTML, EndHTMLIndex]) + #13#10 +
-      SysUtils.Format('%s%.8d', [StartFragment, StartFragmentIndex]) + #13#10 +
-      SysUtils.Format('%s%.8d', [EndFragment, EndFragmentIndex]) + #13#10;
-    HTML := Description + DocType + HTMLIntro + HTML + HTMLExtro;
-  end;
-
-  //--------------- end local function ----------------------------------------
-
-var
-  Data: Pointer;
-  DataSize: Cardinal;
-  S: string;
-  WS: WideString;
-  P: Pointer;
-
-begin
-  Result := 0;
-  case Format of
-    CF_TEXT:
-      begin
-        S := ContentToText(Source, #9) + #0;
-        Data := PChar(S);
-        DataSize := Length(S);
-      end;
-    CF_UNICODETEXT:
-      begin
-        WS := ContentToUnicode(Source, #9) + #0;
-        Data := PWideChar(WS);
-        DataSize := 2 * Length(WS);
-      end;
-  else
-    if Format = CF_CSV then
-      S := ContentToText(Source, ListSeparator) + #0
-    else
-      if (Format = CF_VRTF) or (Format = CF_VRTFNOOBJS) then
-        S := ContentToRTF(Source) + #0
-      else
-        if Format = CF_HTML then
-        begin
-          S := ContentToHTML(Source);
-          // Build a valid HTML clipboard fragment.
-          MakeFragment(S);
-          S := S + #0;
-        end;
-    Data := PChar(S);
-    DataSize := Length(S);
-  end;
-
-  if DataSize &gt; 0 then
-  begin
-    Result := GlobalAlloc(GHND or GMEM_SHARE, DataSize);
-    P := GlobalLock(Result);
-    Move(Data^, P^, DataSize);
-    GlobalUnlock(Result);
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.ContentToHTML(Source: TVSTTextSourceType; Caption: WideString = ''): string;
-
-// Renders the current tree content (depending on Source) as HTML text encoded in UTF-8.
-// If Caption is not empty then it is used to create and fill the header for the table built here.
-// Based on ideas and code from Frank van den Bergh and Andreas H&#246;rstemeier.
-
-type
-  UCS2 = Word;
-  UCS4 = Cardinal;
-
-const
-  MaximumUCS4: UCS4 = $7FFFFFFF;
-  ReplacementCharacter: UCS4 = $0000FFFD;
-
-var
-  Buffer: TBufferedString;
-  
-  //--------------- local functions -------------------------------------------
-
-  function ConvertSurrogate(S1, S2: UCS2): UCS4;
-
-  // Converts a pair of high and low surrogate into the corresponding UCS4 character.
-  
-  const
-    SurrogateOffset = ($D800 shl 10) + $DC00 - $10000;
-
-  begin
-    Result := Word(S1) shl 10 + Word(S2) - SurrogateOffset;
-  end;
-
-  //---------------------------------------------------------------------------
-
-  function UTF16ToUTF8(const S: WideString): string;
-
-  // Converts the given Unicode text (which may contain surrogates) into
-  // the UTF-8 encoding used for the HTML clipboard format.
-
-  const
-    FirstByteMark: array[0..6] of Byte = ($00, $00, $C0, $E0, $F0, $F8, $FC);
-
-  var
-    Ch: UCS4;
-    I, J, T: Integer;
-    BytesToWrite: Cardinal;
-
-  begin
-    if Length(S) = 0 then
-      Result := ''
-    else
-    begin
-      // Make room for the result. Assume worst case, there are only short texts to convert.
-      SetLength(Result, 6 * Length(S));
-      T := 1;
-      I := 1;
-      while I &lt;= Length(S) do
-      begin
-        Ch := UCS4(S[I]);
-
-        // Is the character a surrogate?
-        if (Ch and $FFFFF800) = $D800 then
-        begin
-          Inc(I);
-          // Check the following char whether it forms a valid surrogate pair with the first character.
-          if (I &lt;= Length(S)) and ((UCS4(S[I]) and $FFFFFC00) = $DC00) then
-            Ch := ConvertSurrogate(UCS2(Ch), UCS2(S[I]))
-          else // Skip invalid surrogate value.
-            Continue;
-        end;
-
-        if Ch &lt; $80 then
-          BytesToWrite := 1
-        else
-          if Ch &lt; $800 then
-            BytesToWrite := 2
-          else
-            if Ch &lt; $10000 then
-              BytesToWrite := 3
-            else
-              if Ch &lt; $200000 then
-                BytesToWrite := 4
-              else
-                if Ch &lt; $4000000 then
-                  BytesToWrite := 5
-                else
-                  if Ch &lt;= MaximumUCS4 then
-                    BytesToWrite := 6
-                  else
-                  begin
-                    BytesToWrite := 2;
-                    Ch := ReplacementCharacter;
-                  end;
-
-        for J := BytesToWrite downto 2 do
-        begin
-          Result[T + J - 1] := Char((Ch or $80) and $BF);
-          Ch := Ch shr 6;
-        end;
-        Result[T] := Char(Ch or FirstByteMark[BytesToWrite]);
-        Inc(T, BytesToWrite);
-
-        Inc(I);
-      end;
-      SetLength(Result, T - 1); // set to actual length
-    end;
-  end;
-  
-  //---------------------------------------------------------------------------
-
-  procedure WriteColorAsHex(Color: TColor);
-
-  var
-    WinColor: COLORREF;
-    I: Integer;
-    Component,
-    Value: Byte;
-
-  begin
-    Buffer.Add('#');
-    WinColor := ColorToRGB(Color);
-    I := 1;
-    while I &lt;= 6 do
-    begin
-      Component := WinColor and $FF;
-
-      Value := 48 + (Component shr 4);
-      if Value &gt; $39 then
-        Inc(Value, 7);
-      Buffer.Add(Char(Value));
-      Inc(I);
-
-      Value := 48 + (Component and $F);
-      if Value &gt; $39 then
-        Inc(Value, 7);
-      Buffer.Add(Char(Value));
-      Inc(I);
-
-      WinColor := WinColor shr 8;
-    end;
-  end;
-
-  //---------------------------------------------------------------------------
-
-  procedure WriteStyle(Name: string; Font: TFont);
-
-  // Creates a CSS style entry with the given name for the given font.
-  // If Name is empty then the entry is created as inline style.
-
-  begin
-    if Length(Name) = 0 then
-      Buffer.Add(' style=&quot;{font:')
-    else
-    begin
-      Buffer.Add('.');
-      Buffer.Add(Name);
-      Buffer.Add('{font:');
-    end;
-    if fsUnderline in Font.Style then
-      Buffer.Add(' underline');
-    if fsItalic in Font.Style then
-      Buffer.Add(' italic');
-    if fsBold in Font.Style then
-      Buffer.Add(' bold');
-    Buffer.Add(Format(' %dpt &quot;%s&quot;;', [Font.Size, Font.Name]));
-    Buffer.Add('color:');
-    WriteColorAsHex(Font.Color);
-    Buffer.Add(';}');
-    if Length(Name) = 0 then
-      Buffer.Add('&quot;');
-  end;
-
-  //--------------- end local functions ---------------------------------------
-
-var
-  I, J : Integer;
-  Level, MaxLevel: Cardinal;
-  AddHeader: string;
-  Save, Run: PVirtualNode;
-  GetNextNode: TGetNextNodeProc;
-  Text: WideString;
-
-  RenderColumns: Boolean;
-  Columns: TColumnsArray;
-  ColumnColors: array of string;
-  Index: Integer;
-  IndentWidth,
-  LineStyleText: string;
-  Alignment: TAlignment;
-  BidiMode: TBidiMode;
-
-  CellPadding: string;
-
-begin
-  Buffer := TBufferedString.Create;
-  try
-    // For customization by the application or descentants we use again the redirected font change event.
-    RedirectFontChangeEvent(Canvas);
-
-    CellPadding := Format('padding-left:%dpx;padding-right:%0:dpx;', [FMargin]);
-
-    IndentWidth := IntToStr(FIndent);
-    AddHeader := ' ';
-    // Add title if adviced so by giving a caption.
-    if Length(Caption) &gt; 0 then
-      AddHeader := AddHeader + 'caption=&quot;' + UTF16ToUTF8(Caption) + '&quot;'; 
-    if Borderstyle &lt;&gt; bsNone then
-      AddHeader := AddHeader + Format('border=&quot;%d&quot; frame=box', [BorderWidth + 1]);
-
-    // Create HTML table based on the tree structure. To simplify formatting we use styles defined in a small CSS area.
-    Buffer.Add('&lt;style type=&quot;text/css&quot;&gt;');
-    Buffer.AddnewLine;
-    WriteStyle('default', Font);
-    Buffer.AddNewLine;
-    WriteStyle('header', FHeader.Font);
-    Buffer.AddNewLine;
-
-    // Determine grid/table lines and create CSS for it.
-    // Vertical and/or horizontal border to show.
-    if FLineStyle = lsSolid then
-      LineStyleText := 'solid;'
-    else
-      LineStyleText := 'dotted;';
-    if toShowHorzGridLines in FOptions.FPaintOptions then
-    begin
-      Buffer.Add('.noborder{border-style:');
-      Buffer.Add(LineStyleText);
-      Buffer.Add(' border-bottom:1;border-left:0;border-right:0; border-top:0;');
-      Buffer.Add(CellPadding);
-      Buffer.Add('}');
-    end
-    else
-    begin
-      Buffer.Add('.noborder{border-style:none;');
-      Buffer.Add(CellPadding);
-      Buffer.Add('}');
-    end;
-    Buffer.AddNewLine;
-
-    Buffer.Add('.normalborder {border-top:none; border-left:none; ');
-    if toShowVertGridLines in FOptions.FPaintOptions then
-      Buffer.Add('border-right:1 ' + LineStyleText)
-    else
-      Buffer.Add('border-right:none;');
-    if toShowHorzGridLines in FOptions.FPaintOptions then
-      Buffer.Add('border-bottom:1 ' + LineStyleText)
-    else
-      Buffer.Add('border-bottom:none;');
-    Buffer.Add(CellPadding);
-    Buffer.Add('}');
-    Buffer.Add('&lt;/style&gt;');
-    Buffer.AddNewLine;
-
-    // General table properties.
-    Buffer.Add('&lt;table class=&quot;default&quot; bgcolor=');
-    WriteColorAsHex(Color);
-    Buffer.Add(AddHeader);
-    Buffer.Add(' cellspacing=&quot;0&quot; cellpadding=');
-    Buffer.Add(IntToStr(FMargin) + '&gt;');
-    Buffer.AddNewLine;
-
-    Columns := nil;
-    ColumnColors := nil;
-    RenderColumns := FHeader.UseColumns;
-    if RenderColumns then
-    begin
-      Columns := FHeader.FColumns.GetVisibleColumns;
-      SetLength(ColumnColors, Length(Columns));
-    end;
-
-    GetRenderStartValues(Source, Run, GetNextNode);
-    Save := Run;
-  
-    MaxLevel := 0;
-    // The table consists of visible columns and rows as used in the tree, but the main tree column is splitted
-    // into several HTML columns to accomodate the indentation. 
-    while Assigned(Run) do
-    begin
-      Level := GetNodeLevel(Run);
-      If Level &gt; MaxLevel then
-        MaxLevel := Level;
-      Run := GetNextNode(Run);
-    end;
-
-    if RenderColumns then
-    begin
-      Buffer.Add('&lt;tr class=&quot;header&quot; style=&quot;');
-      Buffer.Add(CellPadding);
-      Buffer.Add('&quot;&gt;');
-      Buffer.AddNewLine;
-      // Make the first row in the HTML table an image of the tree header.
-      for I := 0 to High(Columns) do
-      begin
-        Buffer.Add('&lt;th height=&quot;');
-        Buffer.Add(IntToStr(FHeader.FHeight));
-        Buffer.Add('px&quot;');
-        Alignment := Columns[I].Alignment;
-        // Consider directionality.
-        if Columns[I].FBiDiMode &lt;&gt; bdLeftToRight then
-        begin
-          ChangeBidiModeAlignment(Alignment);
-          Buffer.Add(' dir=&quot;rtl&quot;');
-        end;
-
-          // Consider aligment.
-        case Alignment of
-          taRightJustify:
-            Buffer.Add(' align=right');
-          taCenter:
-            Buffer.Add(' align=center');
-        else
-          Buffer.Add(' align=left');
-        end;
-
-        Index := Columns[I].Index;
-        // Merge cells of the header emulation in the main column.
-        if (MaxLevel &gt; 0) and (Index = Header.MainColumn) then
-        begin
-          Buffer.Add(' colspan=&quot;');
-          Buffer.Add(IntToStr(MaxLevel + 1));
-          Buffer.Add('&quot;');
-        end;
-
-        // The color of the header is usually clBtnFace.
-        Buffer.Add(' bgcolor=');
-        WriteColorAsHex(clBtnFace);
-
-        // Set column width in pixels.
-        Buffer.Add(' width=&quot;');
-        Buffer.Add(IntToStr(Columns[I].Width));
-        Buffer.Add('px&quot;&gt;');
-
-        if Length(Columns[I].Text) &gt; 0 then
-          Buffer.Add(UTF16ToUTF8(Columns[I].Text));
-        Buffer.Add('&lt;/th&gt;');
-      end;
-      Buffer.Add('&lt;/tr&gt;');
-      Buffer.AddNewLine;
-    end;
-  
-    // Now go through the tree.
-    Run := Save;
-    while Assigned(Run) do
-    begin
-      Level := GetNodeLevel(Run);
-      Buffer.Add(' &lt;tr class=&quot;default&quot;&gt;');
-      Buffer.AddNewLine;
-
-      I := 0;
-      while (I &lt; Length(Columns)) or not RenderColumns do
-      begin
-        if RenderColumns then
-          Index := Columns[I].Index
-        else
-          Index := NoColumn;
-
-        if not RenderColumns or (coVisible in Columns[I].FOptions) then
-        begin
-          // Call back the application to know about font customization.
-          Canvas.Font := Font;
-          FFontChanged := False;
-          DoPaintText(Run, Canvas, Index, ttNormal);
-
-          if Index = Header.MainColumn then
-          begin
-            // Create a cell for each indentation level.
-            if RenderColumns and not (coParentColor in Columns[I].FOptions) then
-            begin
-              for J := 1 to Level do
-              begin
-                Buffer.Add('&lt;td class=&quot;noborder&quot; width=&quot;');
-                Buffer.Add(IndentWidth);
-                Buffer.Add('&quot; height=&quot;');
-                Buffer.Add(IntToStr(Run.NodeHeight));
-                Buffer.Add('px&quot;');
-                if not (coParentColor in Columns[I].FOptions) then
-                begin
-                  Buffer.Add(' bgcolor=');
-                  WriteColorAsHex(Columns[I].Color);
-                end;
-                Buffer.Add('&gt;&nbsp;&lt;/td&gt;');
-              end;
-            end
-            else
-            begin
-              for J := 1 to Level do
-                if J = 1 then
-                begin
-                  Buffer.Add(' &lt;td height=&quot;');
-                  Buffer.Add(IntToStr(Run.NodeHeight));
-                  Buffer.Add('px&quot;&gt;&nbsp;&lt;/td&gt;');
-                end
-                else
-                  Buffer.Add(' &lt;td&gt;&nbsp;&lt;/td&gt;');
-            end;
-          end;
-
-          if FFontChanged then
-          begin
-            Buffer.Add(' &lt;td class=&quot;normalborder&quot; ');
-            WriteStyle('', Canvas.Font);
-            Buffer.Add(' height=&quot;');
-            Buffer.Add(IntToStr(Run.NodeHeight));
-            Buffer.Add('px&quot;');
-          end
-          else
-          begin
-            Buffer.Add(' &lt;td class=&quot;normalborder&quot;  height=&quot;');
-            Buffer.Add(IntToStr(Run.NodeHeight));
-            Buffer.Add('px&quot;');
-          end;
-
-          if RenderColumns then
-          begin
-            Alignment := Columns[I].Alignment;
-            BidiMode := Columns[I].BidiMode;
-          end
-          else
-          begin
-            Alignment := Self.Alignment;
-            BidiMode := Self.BidiMode;
-          end;
-          // Consider directionality.
-          if BiDiMode &lt;&gt; bdLeftToRight then
-          begin
-            ChangeBidiModeAlignment(Alignment);
-            Buffer.Add(' dir=&quot;rtl&quot;');
-          end;
-
-          // Consider aligment.
-          case Alignment of
-            taRightJustify:
-              Buffer.Add(' align=right');
-            taCenter:
-              Buffer.Add(' align=center');
-          else
-            Buffer.Add(' align=left');
-          end;
-          // Merge cells in the main column.
-          if (MaxLevel &gt; 0) and (Index = FHeader.MainColumn) and (Level &lt; MaxLevel) then
-          begin
-            Buffer.Add(' colspan=&quot;');
-            Buffer.Add(IntToStr(MaxLevel - Level + 1));
-            Buffer.Add('&quot;');
-          end;
-          if RenderColumns and not (coParentColor in Columns[I].FOptions) then
-          begin
-            Buffer.Add(' bgcolor=');
-            WriteColorAsHex(Columns[I].Color);
-          end;
-          Buffer.Add('&gt;');
-          Text := Self.Text[Run, Index];
-          if Length(Text) &gt; 0 then
-          begin
-            Text := UTF16ToUTF8(Text);
-            Buffer.Add(Text);
-          end;
-          Buffer.Add('&lt;/td&gt;');
-        end;
-
-        if not RenderColumns then
-          Break;
-        Inc(I);
-      end;
-      Run := GetNextNode(Run);
-      Buffer.Add(' &lt;/tr&gt;');
-      Buffer.AddNewLine;
-    end;
-    Buffer.Add('&lt;/table&gt;');
-
-    RestoreFontChangeEvent(Canvas);
-
-    Result := Buffer.AsString;
-  finally
-    Buffer.Free;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.ContentToRTF(Source: TVSTTextSourceType): string;
-
-// Renders the current tree content (depending on Source) as RTF (rich text).
-// Based on ideas and code from Frank van den Bergh and Andreas H&#246;rstemeier.
-
-var
-  Fonts: TStringList;
-  Colors: TList;
-  CurrentFontIndex,
-  CurrentFontColor,
-  CurrentFontSize: Integer;
-  Buffer: TBufferedString;
-  
-  //--------------- local functions -------------------------------------------
-
-  procedure SelectFont(Font: string);
-
-  var
-    I: Integer;
-
-  begin
-    I := Fonts.IndexOf(Font);
-    if I &gt; -1 then
-    begin
-      // Font has already been used
-      if I &lt;&gt; CurrentFontIndex then
-      begin
-        Buffer.Add('\f');
-        Buffer.Add(IntToStr(I));
-        CurrentFontIndex := I;
-      end;
-    end
-    else
-    begin
-      I := Fonts.Add(Font);
-      Buffer.Add('\f');
-      Buffer.Add(IntToStr(I));
-      CurrentFontIndex := I;
-    end;
-  end;
-
-  //---------------------------------------------------------------------------
-
-  procedure SelectColor(Color: TColor);
-
-  var
-    I: Integer;
-
-  begin
-    I := Colors.IndexOf(Pointer(Color));
-    if I &gt; -1 then
-    begin
-      // Color has already been used
-      if I &lt;&gt; CurrentFontColor then
-      begin
-        Buffer.Add('\cf');
-        Buffer.Add(IntToStr(I + 1));
-        CurrentFontColor := I;
-      end;
-    end
-    else
-    begin
-      I := Colors.Add(Pointer(Color));
-      Buffer.Add('\cf');
-      Buffer.Add(IntToStr(I + 1));
-      CurrentFontColor := I;
-    end;
-  end;
-
-  //---------------------------------------------------------------------------
-
-  procedure TextPlusFont(Text: WideString; Font: TFont);
-
-  var
-    UseUnderline,
-    UseItalic,
-    UseBold: Boolean;
-    I: Integer;
-
-  begin
-    if Length(Text) &gt; 0 then
-    begin
-      UseUnderline := fsUnderline in Font.Style;
-      if UseUnderline then
-        Buffer.Add('\ul');
-      UseItalic := fsItalic in Font.Style;
-      if UseItalic then
-        Buffer.Add('\i');
-      UseBold := fsBold in Font.Style;
-      if UseBold then
-        Buffer.Add('\b');
-      SelectFont(Font.Name);
-      SelectColor(Font.Color);
-      if Font.Size &lt;&gt; CurrentFontSize then
-      begin
-        // Font size must be given in half points.
-        Buffer.Add('\fs');
-        Buffer.Add(IntToStr(2 * Font.Size));
-        CurrentFontSize := Font.Size;
-      end;
-      // Use escape sequences to note Unicode text.
-      Buffer.Add(' ');
-      // Note: Unicode values &gt; 32767 must be expressed as negative numbers. This is implicitly done
-      //       by interpreting the wide chars (word values) as small integers.
-      for I := 1 to Length(Text) do
-        Buffer.Add(Format('\u%d\''3f', [SmallInt(Text[I])]));
-      if UseUnderline then
-        Buffer.Add('\ul0');
-      if UseItalic then
-        Buffer.Add('\i0');
-      if UseBold then
-        Buffer.Add('\b0');
-    end;
-  end;
-
-  //--------------- end local functions ---------------------------------------
-
-var
-  Level, LastLevel: Integer;
-  I, J: Integer;
-  Save, Run: PVirtualNode;
-  GetNextNode: TGetNextNodeProc;
-  S, Tabs : string;
-  Text: WideString;
-  Twips: Integer;
-
-  RenderColumns: Boolean;
-  Columns: TColumnsArray;
-  Index: Integer;
-  Alignment: TAlignment;
-  BidiMode: TBidiMode;
-
-begin
-  Buffer := TBufferedString.Create;
-  try
-    // For customization by the application or descentants we use again the redirected font change event.
-    RedirectFontChangeEvent(Canvas);
-
-    Fonts := TStringList.Create;
-    Colors := TList.Create;
-    CurrentFontIndex := -1;
-    CurrentFontColor := -1;
-    CurrentFontSize := -1;
-
-    Columns := nil;
-    Tabs := '';
-    LastLevel := 0;
-
-    RenderColumns := FHeader.UseColumns;
-    if RenderColumns then
-      Columns := FHeader.FColumns.GetVisibleColumns;
-
-    GetRenderStartValues(Source, Run, GetNextNode);
-    Save := Run;
-
-    // First make a table structure. The \rtf and other header stuff is included
-    // when the font and color tables are created.
-    Buffer.Add('\uc1\trowd\trgaph70');
-    J := 0;
-    if RenderColumns then
-    begin
-      for I := 0 to High(Columns) do
-      begin
-        Inc(J, Columns[I].Width);
-        // This value must be expressed in twips (1 inch = 1440 twips).
-        Twips := Round(1440 * J / Screen.PixelsPerInch);
-        Buffer.Add('\cellx');
-        Buffer.Add(IntToStr(Twips));
-      end;
-    end
-    else
-    begin
-      Twips := Round(1440 * ClientWidth / Screen.PixelsPerInch);
-      Buffer.Add('\cellx');
-      Buffer.Add(IntToStr(Twips));
-    end;
-    
-    // Fill table header.
-    if RenderColumns then
-    begin
-      Buffer.Add('\pard\intbl');
-      for I := 0 to High(Columns) do
-      begin
-        Alignment := Columns[I].Alignment;
-        BidiMode := Columns[I].BidiMode;
-
-        // Alignment is not supported with older RTF formats, however it will be ignored.
-        if BidiMode &lt;&gt; bdLeftToRight then
-          ChangeBidiModeAlignment(Alignment);
-        case Alignment of
-          taRightJustify:
-            Buffer.Add('\qr');
-          taCenter:
-            Buffer.Add('\qc');
-        end;
-
-        TextPlusFont(Columns[I].Text, Header.Font);
-        Buffer.Add('\cell');
-      end;
-      Buffer.Add('\row');
-    end;
-  
-    // Now write the contents.
-    Run := Save;
-    while Assigned(Run) do
-    begin
-      I := 0;
-      while not RenderColumns or (I &lt; Length(Columns)) do
-      begin
-        if RenderColumns then
-        begin
-          Index := Columns[I].Index;
-          Alignment := Columns[I].Alignment;
-          BidiMode := Columns[I].BidiMode;
-        end
-        else
-        begin
-          Index := NoColumn;
-          Alignment := FAlignment;
-          BidiMode := Self.BidiMode;
-        end;
-        
-        if not RenderColumns or (coVisible in Columns[I].Options) then
-        begin
-          Text := Self.Text[Run, Index];
-          Buffer.Add('\pard\intbl');
-
-          // Alignment is not supported with older RTF formats, however it will be ignored.
-          if BidiMode &lt;&gt; bdLeftToRight then
-            ChangeBidiModeAlignment(Alignment);
-          case Alignment of
-            taRightJustify:
-              Buffer.Add('\qr');
-            taCenter:
-              Buffer.Add('\qc');
-          end;
-
-          // Call back the application to know about font customization.
-          Canvas.Font := Font;
-          FFontChanged := False;
-          DoPaintText(Run, Canvas, Index, ttNormal);
-
-          if Index = Header.MainColumn then
-          begin
-            Level := GetNodeLevel(Run);
-            if Level &lt;&gt; LastLevel then
-            begin
-              LastLevel := Level;
-              Tabs := '';
-              for J := 0 to Level - 1 do
-                Tabs := Tabs + '\tab';
-            end;
-            if Level &gt; 0 then
-            begin
-              Buffer.Add(Tabs);
-              Buffer.Add(' ');
-              TextPlusFont(Text, Canvas.Font);
-              Buffer.Add('\cell');
-            end
-            else
-            begin
-              TextPlusFont(Text, Canvas.Font);
-              Buffer.Add('\cell');
-            end;
-          end
-          else
-          begin
-            TextPlusFont(Text, Canvas.Font);
-            Buffer.Add('\cell');
-          end;
-        end;
-        
-        if not RenderColumns then
-          Break;
-        Inc(I);
-      end;
-      Buffer.Add('\row');
-      Run := GetNextNode(Run);
-    end;
-
-    Buffer.Add('\pard\par');
-
-    // Build lists with fonts and colors. They have to be at the start of the document.
-    S := '{\rtf1\ansi\ansicpg1252\deff0\deflang1043{\fonttbl';
-    for I := 0 to Fonts.Count - 1 do
-      S := S + Format('{\f%d %s;}', [I, Fonts[I]]);
-    S := S + '}';
-
-    S := S + '{\colortbl;';
-    for I := 0 to Colors.Count - 1 do
-    begin
-      J := ColorToRGB(TColor(Colors[I]));
-      S := S + Format('\red%d\green%d\blue%d;', [J and $FF, (J shr 8) and $FF, (J shr 16) and $FF]);
-    end;
-    S := S + '}';
-
-    Result := S + Buffer.AsString + '}';
-    Fonts.Free;
-    Colors.Free;
-
-    RestoreFontChangeEvent(Canvas);
-  finally
-    Buffer.Free;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.ContentToText(Source: TVSTTextSourceType; Separator: Char): string;
-
-// Renders the current tree content (depending on Source) as plain ANSI text.
-// Note: Unicode strings are implicitely converted to ANSI strings based on the currently active user locale.
-
-var
-  RenderColumns: Boolean;
-  Tabs: string;
-  GetNextNode: TGetNextNodeProc;
-  Run, Save: PVirtualNode;
-  Level, MaxLevel: Cardinal;
-  Columns: TColumnsArray;
-  LastColumn: TVirtualTreeColumn;
-  Index,
-  I: Integer;
-  Text: string;
-  Buffer: TBufferedString;
-
-begin
-  Columns := nil;
-  Buffer := TBufferedString.Create;
-  try
-    RenderColumns := FHeader.UseColumns;
-    if RenderColumns then
-      Columns := FHeader.FColumns.GetVisibleColumns;
-
-    GetRenderStartValues(Source, Run, GetNextNode);
-    Save := Run;
-
-    // The text consists of visible groups representing the columns, which are separated by one or more separator
-    // characters. There are always MaxLevel separator chars in a line (main column only). Either before the caption
-    // to ident it or after the caption to make the following column aligned.
-    MaxLevel := 0;
-    while Assigned(Run) do
-    begin
-      Level := GetNodeLevel(Run);
-      If Level &gt; MaxLevel then
-        MaxLevel := Level;
-      Run := GetNextNode(Run);
-    end;
-
-    SetLength(Tabs, MaxLevel);
-    FillChar(PChar(Tabs)^, MaxLevel, Separator);
-
-    // First line is always the header if used.
-    if RenderColumns then
-    begin
-      LastColumn := Columns[High(Columns)];
-      for I := 0 to High(Columns) do
-      begin
-        Buffer.Add(Columns[I].Text);
-        if Columns[I] &lt;&gt; LastColumn then
-        begin
-          if Columns[I].Index = Header.MainColumn then
-          begin
-            Buffer.Add(Tabs);
-            Buffer.Add(Separator);
-          end
-          else
-            Buffer.Add(Separator);
-        end;
-      end;
-      Buffer.AddNewLine;
-    end
-    else
-      LastColumn := nil;
-
-    Run := Save;
-    if RenderColumns then
-    begin
-      while Assigned(Run) do
-      begin
-        for I := 0 to High(Columns) do
-        begin
-          if coVisible in Columns[I].Options then
-          begin
-            Index := Columns[I].Index;
-            // This line implicitly converts the Unicode text to ANSI.
-            Text := Self.Text[Run, Index];
-            if Index = Header.MainColumn then
-            begin
-              Level := GetNodeLevel(Run);
-              Buffer.Add(Copy(Tabs, 1, Level));
-              Buffer.Add(Text);
-              Buffer.Add(Copy(Tabs, 1, MaxLevel - Level));
-            end
-            else
-              Buffer.Add(Text);
-
-            if Columns[I] &lt;&gt; LastColumn then
-              Buffer.Add(Separator);
-          end;
-        end;
-        Run := GetNextNode(Run);
-        Buffer.AddNewLine;
-      end;
-    end
-    else
-    begin
-      while Assigned(Run) do
-      begin
-        // This line implicitly converts the Unicode text to ANSI.
-        Text := Self.Text[Run, NoColumn];
-        Level := GetNodeLevel(Run);
-        Buffer.Add(Copy(Tabs, 1, Level));
-        Buffer.Add(Text);
-        Buffer.AddNewLine;
-
-        Run := GetNextNode(Run);
-      end;
-    end;
-    
-    Result := Buffer.AsString;
-  finally
-    Buffer.Free;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.ContentToUnicode(Source: TVSTTextSourceType; Separator: WideChar): WideString;
-
-// Renders the current tree content (depending on Source) as Unicode text.
-
-const
-  WideCRLF: WideString = #13#10;
-
-var
-  RenderColumns: Boolean;
-  Tabs: WideString;
-  GetNextNode: TGetNextNodeProc;
-  Run, Save: PVirtualNode;
-
-  Columns: TColumnsArray;
-  LastColumn: TVirtualTreeColumn;
-  Level, MaxLevel: Cardinal;
-  Index,
-  I: Integer;
-  Text: WideString;
-  Buffer: TWideBufferedString;
-
-begin
-  Columns := nil;
-
-  Buffer := TWideBufferedString.Create;
-  try
-    RenderColumns := FHeader.UseColumns;
-    if RenderColumns then
-      Columns := FHeader.FColumns.GetVisibleColumns;
-
-    GetRenderStartValues(Source, Run, GetNextNode);
-    Save := Run;
-
-    // The text consists of visible groups representing the columns, which are separated by one or more separator
-    // characters. There are always MaxLevel separator chars in a line (main column only). Either before the caption
-    // to ident it or after the caption to make the following column aligned.
-    MaxLevel := 0;
-    while Assigned(Run) do
-    begin
-      Level := GetNodeLevel(Run);
-      If Level &gt; MaxLevel then
-        MaxLevel := Level;
-      Run := GetNextNode(Run);
-    end;
-
-    SetLength(Tabs, MaxLevel);
-    for I := 1 to MaxLevel do
-      Tabs[I] := Separator;
-
-    // First line is always the header if used.
-    if RenderColumns then
-    begin
-      LastColumn := Columns[High(Columns)];
-      for I := 0 to High(Columns) do
-      begin
-        Buffer.Add(Columns[I].Text);
-        if Columns[I] &lt;&gt; LastColumn then
-        begin
-          if Columns[I].Index = Header.MainColumn then
-          begin
-            Buffer.Add(Tabs);
-            Buffer.Add(Separator);
-          end
-          else
-            Buffer.Add(Separator);
-        end;
-      end;
-      Buffer.AddNewLine;
-    end
-    else
-      LastColumn := nil;
-
-    Run := Save;
-    if RenderColumns then
-    begin
-      while Assigned(Run) do
-      begin
-        for I := 0 to High(Columns) do
-        begin
-          if coVisible in Columns[I].Options then
-          begin
-            Index := Columns[I].Index;
-            Text := Self.Text[Run, Index];
-            if Index = Header.MainColumn then
-            begin
-              Level := GetNodeLevel(Run);
-              Buffer.Add(Copy(Tabs, 1, Level));
-              Buffer.Add(Text);
-              Buffer.Add(Copy(Tabs, 1, MaxLevel - Level));
-            end
-            else
-              Buffer.Add(Text);
-
-            if Columns[I] &lt;&gt; LastColumn then
-              Buffer.Add(Separator);
-          end;
-        end;
-        Run := GetNextNode(Run);
-        Buffer.AddNewLine;
-      end;
-    end
-    else
-    begin
-      while Assigned(Run) do
-      begin
-        Text := Self.Text[Run, NoColumn];
-        Level := GetNodeLevel(Run);
-        Buffer.Add(Copy(Tabs, 1, Level));
-        Buffer.Add(Text);
-        Buffer.AddNewLine;
-
-        Run := GetNextNode(Run);
-      end;
-    end;
-    Result := Buffer.AsString;
-  finally
-    Buffer.Free;
-  end;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.InvalidateNode(Node: PVirtualNode): TRect;
-
-var
-  Data: PInteger;
-  
-begin
-  Result := inherited InvalidateNode(Node);
-  // Reset node width so changed text attributes are applied correctly.
-  Data := InternalData(Node);
-  if Assigned(Data) then
-    Data^ := 0;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualStringTree.Path(Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
-  Delimiter: WideChar): WideString;
-
-// Constructs a string containing the node and all its parents. The last character in the returned path is always the
-// given delimiter.
-
-var
-  S: WideString;
-
-begin
-  if (Node = nil) or (Node = FRoot) then
-    Result := Delimiter
-  else
-  begin
-    Result := '';
-    while Node &lt;&gt; FRoot do
-    begin
-      DoGetText(Node, Column, TextType, S);
-      Result := S + Delimiter + Result;
-      Node := Node.Parent;
-    end;
-  end; 
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualStringTree.ReinitNode(Node: PVirtualNode; Recursive: Boolean);
-
-begin
-  inherited;
-  // Reset node width so changed text attributes are applied correctly.
-  if Assigned(Node) and (Node &lt;&gt; FRoot) then
-    PInteger(InternalData(Node))^ := 0;
-end;
-
-//----------------- TVirtualStringTree ---------------------------------------------------------------------------------
-
-function TVirtualStringTree.GetOptions: TStringTreeOptions;
-
-begin
-  Result := FOptions as TStringTreeOptions;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualStringTree.SetOptions(const Value: TStringTreeOptions);
-
-begin
-  FOptions.Assign(Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualStringTree.GetOptionsClass: TTreeOptionsClass;
-
-begin
-  Result := TStringTreeOptions;
-end;
-
-//----------------- TCustomVirtualDrawTree -----------------------------------------------------------------------------
-
-procedure TCustomVirtualDrawTree.DoDrawHint(Canvas: TCanvas; Node: PVirtualNode; R: TRect; Column: TColumnIndex);
-
-begin
-  if Assigned(FOnDrawHint) then
-    FOnDrawHint(Self, Canvas, Node, R, Column);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualDrawTree.DoGetHintSize(Node: PVirtualNode; Column: TColumnIndex; var R: TRect);
-
-begin
-  if Assigned(FOnGetHintSize) then
-    FOnGetHintSize(Self, Node, Column, R);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TCustomVirtualDrawTree.DoGetNodeWidth(Node: PVirtualNode; Column: TColumnIndex; Canvas: TCanvas = nil): Integer;
-
-begin
-  Result := 2 * FTextMargin;
-  if Canvas = nil then
-    Canvas := Self.Canvas;
-
-  if Assigned(FOnGetNodeWidth) then
-    FOnGetNodeWidth(Self, Canvas, Node, Column, Result);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TCustomVirtualDrawTree.DoPaintNode(var PaintInfo: TVTPaintInfo);
-
-begin
-  if Assigned(FOnDrawNode) then
-    FOnDrawNode(Self, PaintInfo);            
-end;
-
-//----------------- TVirtualDrawTree -----------------------------------------------------------------------------------
-
-function TVirtualDrawTree.GetOptions: TVirtualTreeOptions;
-
-begin
-  Result := FOptions as TVirtualTreeOptions;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-procedure TVirtualDrawTree.SetOptions(const Value: TVirtualTreeOptions);
-
-begin
-  FOptions.Assign(Value);
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-function TVirtualDrawTree.GetOptionsClass: TTreeOptionsClass;
-
-begin
-  Result := TVirtualTreeOptions;
-end;
-
-//----------------------------------------------------------------------------------------------------------------------
-
-initialization
-  // This watcher is used whenever a global structure could be modified by more than one thread.
-  Watcher := TCriticalSection.Create;
-finalization
-  if Initialized then
-    FinalizeGlobalStructures;
-
-  InternalClipboardFormats.Free;
-  Watcher.Free;
-end.

Deleted: trunk/WPGM/ImportDefinitions/ImportDefinitions.~dpr
===================================================================
--- trunk/WPGM/ImportDefinitions/ImportDefinitions.~dpr	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/ImportDefinitions/ImportDefinitions.~dpr	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,13 +0,0 @@
-program ImportDefinitions;
-
-uses
-  Forms,
-  Main in 'Main.pas' {MainForm};
-
-{$R *.res}
-
-begin
-  Application.Initialize;
-  Application.CreateForm(TMainForm, MainForm);
-  Application.Run;
-end.

Deleted: trunk/WPGM/ImportDefinitions/Main.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/ImportDefinitions/Main.~dfm
===================================================================
--- trunk/WPGM/ImportDefinitions/Main.~dfm	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/ImportDefinitions/Main.~dfm	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,5167 +0,0 @@
-object MainForm: TMainForm
-  Left = 487
-  Top = 332
-  BorderIcons = [biSystemMenu, biMinimize]
-  BorderStyle = bsSingle
-  Caption = 'Import Definitions'
-  ClientHeight = 287
-  ClientWidth = 433
-  Color = clBtnFace
-  Font.Charset = DEFAULT_CHARSET
-  Font.Color = clWindowText
-  Font.Height = -11
-  Font.Name = 'MS Sans Serif'
-  Font.Style = []
-  OldCreateOrder = False
-  OnCreate = FormCreate
-  PixelsPerInch = 96
-  TextHeight = 13
-  object BottomBevel: TBevel
-    Left = 0
-    Top = 232
-    Width = 433
-    Height = 9
-    Shape = bsBottomLine
-  end
-  object TopImage: TImage
-    Left = 0
-    Top = 0
-    Width = 586
-    Height = 87
-    AutoSize = True
-    Picture.Data = {
-      07544269746D617056560200424D565602000000000036000000280000004A02
-      000057000000010018000000000020560200120B0000120B0000000000000000
-      0000284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00274A00274A00274A00274A00274A
-      00274A00274A00274A00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00274B00274B00274B00284C00294D01254B00264D00284C00264802274B
-      00284A03294D01284B01284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00294D01284C00284C00284B01274A
-      0026480126480225470124460024460024460024460023440123440122420122
-      4201244300234200234200244300244300244300254401264502264502264502
-      264502244300244300234200244300244300243F00243F00233E00243F00243F
-      00243F00233E00233D01253E00253E00253E00243D00253E00253E00253E0026
-      4000253E00263F01264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274A00274A00274A00274A00274A00274A00274A00274A00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00294D01
-      284C00274B00274B00284C00284C00284C00284C00284A03264A00264801274B
-      00274902294C02294B04284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00294D01284C00284C00284C00274B
-      00274A00274A0026490024460024460024460024450223440122430022420122
-      4201244300244300244300244300244300244300244300254401244300254401
-      284402274301274301254401234200244201263F01263F01253E00253E00243D
-      00253E00243D00243D00253E00253E00253E00243D00243D00253E00263F0126
-      3F01264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      274B00274B00284C00284C00284C00284C002B5000284B01284C002C5003284C
-      00274B002B4E04284B01284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C0025470025470024460024460024460023450023440123
-      4401244300244300244300234200244300244201244201244201234200244300
-      284402284402284402284402244300244201264000264000264000264000253F
-      00253F00243D00253E00243D00253E00253E00243D00243D00243D00253E0026
-      3F01264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000294C02294C02294C02294C02294C02294C02294C02294C02284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00294D01
-      284C00284C00284C00284C00294D012A4E02284C002B4F02274A002C50042C51
-      01274B002A4E02274B00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00294D01284B
-      01294C02294C02294B0427490226480125470025470125470124460023440123
-      4401264502254401264502244300244300244201244201244201244201244300
-      274301284402284402284402244300244300253F00253F00264000264000263F
-      01263F01243D00243D00243D00243D00253E00243D00243D00243D00253E0025
-      3E00264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000284C00284C00284C00284C00284C00284C00284C00284C00274A00274A00
-      274A00274A00274A00274A00274A00274A00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00294D01294D012A4E022B4F022648012E5009284B012749022B4F
-      02284B012A4E01274A00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00294D01284C
-      00284C00294C02284B01284C00274A0026490026480125470025470125470124
-      4600284402284402284402264502264502254401244300244201244201234200
-      2443002743012743012844022544012443002640002640002640002640002640
-      00264000264000264000243D00243D00253E00253E00243D00243D00243D0024
-      3D00264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274A00274A00274A00274A00274A00274A00274A00274A00274A00274A00
-      274A00274A00274A00274A00274A00274A00274A00274A00274A00274A00274A
-      00274A00274A00274A00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00294D012A4E022B4F022B4F02274E00375C14284F012648012D50
-      06274B002C5003274A00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00274A0026480125470024460024
-      4600284402284402284402284402274301244300244300244300244300244300
-      2443002443002544012544012844022743012743012743012642002642002642
-      00264200254100254100243D00253E00253E00253E00253E00243D00243D0024
-      3D00253E00263F01264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801264801264801264801264801264801274A00274A00
-      274A00274A00274A00274A00274A00274A00274A00274A00274A00274A00274A
-      00274A00274A00274A00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00294D01
-      294D01284C00284C002A4E012C50032C5003325A08426C15325909254B002E52
-      062A4E012B4F02284B01284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00294D01284C00284C00284C00274A
-      00274A00274A00274902284C00284C00284B01274A0025470024460024460024
-      4502284500284402284402284402274301244300244300244300244300244300
-      2344012243002344012342002743012743012844022844022642002642002641
-      01264101264101254000253E00253E00253E00253E00253E00253E00243D0024
-      3D00243D00253E00264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801264801264802244600244600254701274902274A00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00274B00274A00274A00254903254A00
-      264D00264C00254D00264D012248061F4B06264D02274D012750002C50032C50
-      042E51012C53002B50002C5101284C00284C00284C00284B01294C02284C0026
-      4900274A00274A00274A00264900274A00284C00284C00284C002A4E01284B01
-      284C00284C00284C00274E002A51012E5800295600507B483B59282C52002959
-      01274E03284E02274A00294D01284C00284C00294D01294D01284C00274A0027
-      4A00284C00284C00284C00284C00284C00294D01284C00284C00294C02284B01
-      294D01284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00264801274A00284C00284C00284C00284C00284C00284C00274E00274E00
-      274E00274E00274E00274E00274E00274E00274A002C4F052446002B50002648
-      02264802264801264801284C00284C00294D01284C00274D01264D00274E0027
-      4E00274A00284A04294B05294B05264802274A00284C002B50002A5101305A05
-      234A002B52072A4E02284A032C5004274D01284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00264900274A0027490226480126480126480126480126
-      4801284A04284A04284A04284A04284A04284A04284A04284A04284A03284A03
-      284A03284A03284A03284A03284A03284A03284A04284A04284A04284A04284A
-      04284A04284A04284A04284A03284A03284A03284A03284A03284A03284A0328
-      4A03284A04284A04284A04284A04284A04284A04284A04284A04264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480124460024460024460024460024460024460024460024
-      4600244600244600244600244600244600244600244600244600244201244201
-      2443002342002443002544012443002443002642002642002642002642002642
-      00264200244300244300254000243F00233E00243F00243F00243F00243D0024
-      3D00233E00253E00264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801264801264802244600244600254700274A00274A00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00274A00274A00274B00264C00
-      2C4E012A50002C52002851002C50032B4E042E52002E51012C53002C56003155
-      012E50032B4D002C4F002C5003294D01284C00284C00294D012A4E02294C0228
-      4B01274B00284C00284C00284C00284C00284C00284C00284C00274B00264C00
-      284A03264900274B002A4E012A52002C56003063096E9568477632335C012E5C
-      03294F03285002244B00284C00284C00284C00284C00284C00274B00274A0026
-      4900284C00284C00284C00284C00284C00284C00284C00284C00284B01284B01
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00274A00274A00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00294D002A4E01274A002D51052648
-      022B4F022C50042B4E04284C00284C00284C00284C00284C00264C00274E0027
-      4E00274A00294C02284A03284A04264801284C002B50002A51012B5500284F01
-      335A0A2244002D4C07274D012A5103294D00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00264900274A00274A0026480126480226480126480126
-      4801264802264802264802264802264802264802264802264802264802264802
-      2648022648022648022648022648022648022648022648022648022648022648
-      0226480226480226480226480226480226480226480226480226480226480226
-      4802264802264802264802264802264802264802264802264802264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480124460024460024460024460024460024460024460024
-      4600244600244600244600244600244600244600244600244600264502254401
-      2544012443002443002443002443002443002642002642002642002642002443
-      00244300244300244300254000254000243F00243F00233E00243F00253E0024
-      3D00243F00253E00264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801264802264802254700254700264801274A00274B00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00294D01284C00284C00284C00294D012B4C01
-      275400335403315501375A03315503315600375B01375B01345A02355B033054
-      003354032C51012750002C50042A4E01294D01284B01284C002A4E02294C0228
-      4B012A4E022A4E02294D01294D01294D01294D01294D01294D01284C00284B01
-      264A04284906294B042A51012F55032E570235620180AA75527C453360032955
-      02294E042D5104254C00284C00284C00284C00284C00274B00274B00274A0027
-      4A00284C00284C00284C00284C00284C00284C00284C00284C00274A00274A00
-      274A00274B00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C002A4E022A4E022345
-      002C50032C5004274B00264C00274D01294D01284C00294D01294D01294D0128
-      4C00284C00284C00274903294C02284C00294D012A52002C56002D59002A5300
-      3059082B51052C50032C5004274E002E4E01284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00274A00274A0026490024460024460024460025470026
-      4801264801264801264801264801264801264801264801264801244600244600
-      2446002446002446002446002446002446002648012648012648012648012648
-      0126480126480126480124460024460024460024460024460024460024460024
-      4600264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480124460024460024460024460024460024460024460024
-      4600244600244600244600244600244600244600244600244600274400284500
-      2844022844022544012443002442012442012443002443002443002443002443
-      00244300244300244300264000264000264000253E00243D00243D00243F0024
-      3F00243F00253E00264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801244600254700264801274A00274A00274A00284C00294D01284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00294D012751042C5206
-      305400365C023A5A013C5D023F5E033F5D04415D033A64003763043B5B02365D
-      07305C002E59022E55002B4F02294D00284C00274A00284C00294D01284C0028
-      4C00294C02294C02284B01284B01284B01284C00294D01284C00284B01274E00
-      2A4C062B4D07294E042C50032F5901345B062B590078A677527B482D5C002A55
-      002A4C052C5305244F00294D01294D01284C00284C00274B00274B00274A0027
-      4A00284A03284A03284A03294B04284A03284A03264801264801264900264900
-      274A00274B00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00294D01294D01294D00284C00284C00
-      284C00284C00284C00284C00284C00284C00284B01274A002A4E02294D00284C
-      002C5003294C02284C00284C00294D01284C00274B00284C00294D01294C0229
-      4C02274B00284C00284B01294C02284C002A4F002C56002F5902315C01335907
-      2F52084677332F53062E55002C5200244E01284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00274B00274B0026490024460024460024460026480126
-      4801264801264801264801264801264801264801264801264801244600244600
-      2446002446002446002446002446002446002648012648012648012648012648
-      0126480126480126480124460024460024460024460024460024460024460024
-      4600264801264801264801264801264801264801264801264801244600244600
-      2446002446002446002446002446002446002648012648012648012648012648
-      0126480126480126480124460024460024460024460024460024460024460024
-      4600244600244600244600244600244600244600244600244600274400284500
-      2743012844022844022743012844022844022443002443002443002443002443
-      00244300244300244300264000264000264000264000253E00243D00233E0024
-      3F00243F00263F01264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801244600264801274A00284B01284C00284C00284C00294D01284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00274B00274B00284C00284C002A4E022B4F032E55072C5600
-      385B003060003B65003965003863023A63014167073F69043864013C63013463
-      003362002F5E02335C012B51002A4E01284C00274A00274A00284C00284C0028
-      4C00264C00264C00284C00284C00274B00274A00274A00274A00264B01294D01
-      264C00294C022B4F032A51012F5600315B0334610085A778547B473361012D59
-      002D5105295103294D00274B00284C00284C00284C00284C00284C00284C0028
-      4C00294C02294C02284B01284B01284B01284B01274A00274A00284C00284C00
-      284C00284C00284C00294D01284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00294D01294D00294D002A4F002B4F022B4F02
-      2B4F022B4F022B4F022B4F022B4F022B4F02274E00274E00284E022C5200345A
-      083056042B50002F54042D50002D50002A4F002A4E012A4E01274D01264C0027
-      4D01264C00284C00294D01284B01274B002B51002D5601315B03336200315B06
-      4776315284362F57052B55022E5500264A00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00274B0026490025470124460024460026480126
-      4802244600244600244600244600244600244600244600244600264801264801
-      2648012648012648012648012648012648012446002446002446002446002446
-      0024460024460024460026480126480126480126480126480126480126480126
-      4801244600244600244600244600244600244600244600244600244600244600
-      2446002446002446002446002446002446002446002446002446002446002446
-      0024460024460024460024460024460024460024460024460024460024460024
-      4600244600244600244600244600244600244600244600244600284402284402
-      2844022844022844022844022844022844022443002443002443002443002443
-      00244300264200264200264000264000264000264000264000253E00243F0024
-      3F00243F00263F01264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801264801274A00284B01284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00294D01284C00274B00274A00284C00284C002A4E022B4F02385B01385B01
-      336101376304396A023A6C00396C0B3D6C0A3A6D0B3B6B0B396D093A6D0C3A64
-      00346003316101315D002C53002A4E01294D01284C00284B01294D01294D0028
-      4C00295000284F002950002B50002B50002B5000295000295000295002285000
-      2A4E01274E00284F002C52002E5800315C0130640683A977507D453461003461
-      002B52062B5400284F01284C00284C00284C00284C00284C00284C00284C0028
-      4C002B4F022B4F022A4E01294D00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00274A00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00294D01294D002A4F002B51002B5100315501315501
-      3155013155013155013155013155013155012A53002C5500284F012D5301365D
-      072E55002D57002A52002E58012D57002C56002C55002B53012C51012B4F022C
-      5003295000274C02294D01284C00284C002C52002D5601315C01315B03315A09
-      A6C99047782E2A5B053058002C5903264C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00294D01284C00274A0026480124460024460026480125
-      4701264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801264801264801264801264801264801264801264801264801244600244600
-      2446002446002446002446002446002446002446002446002446002446002446
-      0024460024460024460024460024460024460024460024460024460024460024
-      4600244600244600244600244600244600244600244600244600254401284402
-      2844022844022844022844022844022844022443002443002443002443002443
-      00264200264200264200264000264000264000264000264000264000243F0023
-      3E00243F00253E00264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801274A00274A00284C00284C00294D01284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00274A00264900284B01284C002B4F032C5003375A033E5D00
-      3766003B6A033A6D0B3975173775173A76183776163977193976143675173C6C
-      0C3D6C0A3965023460012E54022D52022B4F02294D002A4E022B4F032D51052C
-      50042B55022C55002C55002C56002D57002E58012E58012F59022F59012C5500
-      2C56002C55002C55002E5900315C0134610033620084A879547A48346003325D
-      022A56032D5000274F01284C00284C00284C00284C00294D01294D012A4E022A
-      4E012C56002C55002E55002E55002D53012C52002A52002A52002B4F032B4F02
-      2A4E012A4E01284C00284C00274A00274A00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00294D01294D002B51002E54022F5503375B01375B01
-      375B01375B01375B01375B01375B01375B01315C01315C01305800345C04355E
-      03315B04426D162E5A01346202326000315E01305B002E58002F560031550131
-      55032A52002A52002B5000294D012A4E012F5601305A02315C01316200406D17
-      C8F2C9365B172D5C00325E012A54002A4F05284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00294C02294C02294C02284A0327490326480126480124
-      4600264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801264801264801264801264801264801264801264801264801244600244600
-      2446002446002446002446002446002446002446002446002446002446002446
-      0024460024460024460023440123440123440123440123440123440123440123
-      4401244600244600244600244600244600244600244600244600264502264502
-      2844022743012743012743012743012743012443002443002443002443002443
-      0024430024430024430026400026400026400026400026400026400025400024
-      3F00243F00253E00264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801264801264801264801264801264801264801264801
-      2648012648012648012648012648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801274A00274B00284C00294D01294D00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00274A00264900284B01284C002C50032C5003355C003D6500
-      4168063B6C0A4273094279163B7828397A243C852939852747862844831D4279
-      163C74093D6A033864003056042E54022C51012A4E012A4F002C50032E51072E
-      51072D59002E5A01315B03305B00315C01345E06345E06355F07346100345F04
-      345E06315B03315C01335F003764033B6A0432620989AA87578647336101305B
-      002E5507275400295000284C00284C00284C00284C00294D012B4F032B4F022B
-      4F022E58002E58002F56002F56012E55002E55002C55002C55002C50032C5003
-      2B4F022A4E01294D00284C00274A00274A00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00294D002A4F002B51002F5503305604375B01375B01
-      375B01375B01375B01375B01375B01375B013461003862033965003D69043965
-      02416D14628F393A6D0B3A6301396502366302346001315D00305A022E58012C
-      56002C55002D56012D52022C52002C52002E5500315C01335F003B6409548638
-      C8F3C8365A14365E063460012252002B5206284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00294C02294C02294C02284A0327490326480126480124
-      4600264801264801264801264801264801264801264801264801244600244600
-      2446002446002446002446002446002446002648012648012648012648012648
-      0126480126480126480124460024460024460024460024460024460024460024
-      4600264801264801264801264801264801264801264801264801244600244600
-      2446002446002446002446002446002446002446002446002446002446002446
-      0024460024460024460021440121440121440121440121440121440121440121
-      4401244600244600244600244600244600244600244600244600264500254400
-      2844022844022844022743012642002442012443002443002443002443002443
-      0024430024430024430026400026400026400026400026400026400025400025
-      4000233E00253E00264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000254701244600264801274A00274A00274902264801264900264801264801
-      2648012648012648012648012648012648012446002547002446002547012446
-      0025470124460024460026480125470025470026480126480126480126480126
-      4802284C00284C00284C00284C00284C00294D01284C00274B002E4E00264D00
-      325302264C002E5500285100254401285002284E06264C00264D01254C002449
-      01284C00295000284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00274D01284C00284C00284C00294D01284F012951002C550029541B296501
-      32620A4279163A7618588B598AAA91A7C8B3C8D9CBC7D9CCC5E0BFA3BBA977A5
-      764877333774062A72072D6401235A002151022951032D5605305500365B0038
-      64013B630B385B01406A053A63023864013B6C04396A023269023B6B01346902
-      3D6B013B6B013B6A04316902346901316B0C39761684A8795786473973062659
-      022E5D002A52002A4C06214C012A5302294B04244600264801314C0331560035
-      5C003362003B64023A5D03425C02426A053A63012C6601316801415D03315503
-      3054002C4E012D4E042B5207244900285506284C00284C00284C00284C00284C
-      00284C00284C00284C002847022C5004274A00254A022A5004214D002753002A
-      5200305C03284E0232520B2A4C00335F042D5900315C01315B08336200346001
-      375B013F5D043F5E033F5E033460033A63013B6C00396C0B2B65003E6C0C4279
-      16416D1484A9773B6C00316902326804296501316200345F04336101325B0033
-      62003161012D59002E5A002E55002D5801305C0131620039650C326A01568D54
-      B5CBB83C64003269023162002E58002B55002B50002A4E01294D00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00274B00274A00274A0027
-      4A00244600244600244600244600244600264802264801264801264802254701
-      2446002446002446002446002446002446002446002446002446002446002446
-      0024460024460024460024460024460024460024460024460024460024460024
-      4600244600254701264802244600244600264801264801264801264801264801
-      2648012648012446002446002446002446002844022844022844022844022844
-      0228440228440228440224430024430024430024430024430024430024430024
-      4300244300254401244300254401254401244300254401244300284402274301
-      2642002743012743012844022443002342002443002443002342002443002443
-      00244201244201244201254000254000243F00233E00233E00233E00243F0023
-      3D01253F00253F00264000264000253F00264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000244600244600264801274A00274A00274A00274A00274A00274A00274A00
-      274A00274A00274A00274A00274A00274A002648022648022648022648022446
-      00244600244600244600264801264801264801274902274A00274A00274A0027
-      4A00284C00284C00284C00284C00284C00284C00284C00284C00294902284C00
-      2E52002C56002A51032B54002E55072B5301284E02264C002951032D5104244B
-      00254701284C00254B00284C00284C00284C00284C00284C00284C00284C0028
-      4C00274D01284C00284C00284C00284C00274E002A52002C55003B6500367206
-      3E640A527C45A6C990EDF6F9F0FEFDECFEFDF3FFFFEBF7F9EDFDF2EAFFFDEBFF
-      F2C8D9CC629153365B153864013A6603306000315C01375B013863023F680642
-      68043774063972093575043B6A033A74084079173C6E0A377517367305347208
-      376C0B3B6C0A3B6D0F3777143877173C751A37771797BB97588D54326B09346A
-      00326104265600264802214E00264D00274A00254B002A5103305505385B0137
-      5C00436808426A0440730B417A1840730B3C6D0B3B6A0D436907386401346001
-      345F083757062D50002B4C01284E02254700284C00284C00284C00284C00284C
-      00284C00284C00284C002C5101294F03224400264A042C5004284F012F59012B
-      59002E5A00234A003155083253092B51003D6303416A013B6403385B01375A00
-      3863023B65003362003A6902386C012B650033630A30630737720938811B2872
-      08396B1776B07A377307316B0C3669013A6B00387507386C013469023B6A033A
-      6B01365D12365D083361012B65003261043361013965004268043773078A9D84
-      98AD97336101316902315C012E55002A51012B50002A4E01294D00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00274B00274A0027
-      4A00244600244600244600244600244600264802264801264801244600244600
-      2446002446002446002446002446002446002446002446002446002446002446
-      0024460024460024460024460024460024460024460024460024460024460024
-      4600254700254700264801264801264801264801264801264801264801264801
-      2648012648012446002446002446002446002844022844022844022844022844
-      0228440228440228440228440228440228440228440228440228440228440228
-      4402244300244300244300244300244300244300244300244300274301284402
-      2743012844022844022844022743012743012645022544012443002443002443
-      00244300244300234200264000264000264000253E00253E00243D00243D0024
-      3D00264000264000253F00264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000254701264802264801274A00274B00274A00274A00274A00284C00284C00
-      284C00284C00284C00284C00284C00284C00284A04284A04284A03284A032648
-      0125470024460024460024460024460025470125470126480127490226480125
-      4700284C00284C00284C00284C00284C00284C00284C00284C00294A002A5204
-      284F013055002952002C55002D5503224A032D5507234D00274D01295201264D
-      01264801284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00274E00284C00284C00284C00284C00274E002A52002D56013765023D6B01
-      578648B9D8BBF1FFF4F2FFFDD7EAD9B8D7BA93BC979AC9A38BC699CCE6D6D0F0
-      D1EBFDFED1F0CF709468426E153B64034369054169043C6D013F6B003B6A0340
-      7409407916427817497B1D49841B4278143A77152E731837811B397927397A25
-      44781A436E133877173A79233D782736831B47772FB5CDBB6B9467346A093B6C
-      043261002E5A012E5009274D01254A00274A002950002B5400295901305B003B
-      630438640044750943750937761645821A43851C4178154379183573073B6B01
-      2D5900345A00395C022A4C002B52072A4C05284C00284C00284C00284C00284C
-      00284C00284C00284C002A4E01264900274902284E062C52062850022D57002D
-      5900284F00436E17254A02345E07396403426A053965023E5D02375A03406B04
-      3C6C022765013971083774062C71083A7717336C0A3D7925458319366B144587
-      35558D5299B9A86A95685A8D535F905267915459854850863947772F406D172A
-      52042D64013463012F5B0830580A335F063F6A033B6B013864013B6C0AAFCDB0
-      6A96673269023B6C00365D08325A082D56052B50002A4E01294D00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00274B00274B0027
-      4A00264801264801264801264801254700264801264802264802244600244600
-      2446002446002547012547002648012648012648012648012648012648012648
-      0126480126480126480126480126480126480126480126480126480126480126
-      4801274A00274A00274A00274A00264900264801254701264802264801264801
-      2648012648012446002446002446002446002844022844022844022844022844
-      0228440228440228440228440228440228440228440228440228440228440228
-      4402284402284402284402284402284402284402284402284402274301284402
-      2844022844022844022844022844022844022743012844022844022743012443
-      00244300244300244300264000264000264000264000264000253E00253E0024
-      3D00264000264000253F00253F00264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000244600264802264801274A00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00294C02294C02294C02284B01274A
-      00274902254701244502264801264801264801264801274902284A03284A0328
-      4A04284C00284C00284C00294D01284C00284C00284C00294D002D4E04355308
-      2C55002C55002F5B022D5C06214A00375A17396A162E5507204C00284F01274F
-      012A4E012B50002C4D02284C00284C00284C00284C00284C00284C00284C0028
-      4C00274E00294D00284C00284C00284C00274E002A52002C5500335D08346202
-      899C81EEFEF3AECDAC6F956B5586484F8538478A47458A4746893494BD8A5986
-      47899E85C0E6C8CFE5CD4F7A1F4078194074093B6A0335730741831A42841B43
-      831946852946842A588449659154517B46527B486D936987B586A5BBA8A9C7B4
-      B2CDB9C7D9CCB4CCBA9EB497889D846A9568547C45ABC7B46D94673E6E153B6C
-      0A2F59022651002B5006295005254C012950042950002A52002B5A003965023B
-      6B013674083773073975173A842A46893444883537792747862838811A427817
-      316902336003385A032D5100274B002B4B0A284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00294D002B4F002B52042851002855002E5A002C
-      5902375C1281B96E345A08345E074169033C64003B6402416806426808315C01
-      3068013774063977193B741743773146762E56854678A26BA6C991C3E1BEF5FF
-      EED9F7E4F3F9FEEEFFF2D6E8DBB6DAC4A8C7B8B2CDB9CBE5D7ECFEF1E4FDE9B6
-      CCB97AA369457731315C01305C033463062A5B0532620A41750A456D15D9F7E4
-      527C45397307386C00335C002A54012D51042B50002A4E01294D00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0027
-      4B00264801264801264801264801254700254700244600244600244600244600
-      244600254701254700264801264801264801284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00274B00274B00284C00284C00284B01264900264801264802264801264801
-      2648012648012446002446002446002446002844022844022844022844022844
-      0228440228440228440228440228440228440228440228440228440228440228
-      4402284402274301284402284402284402284402274301284402284402284402
-      2844022844022844022844022844022844022844022844022844022844022743
-      01284402264200264200274101264000253F0026400026400026400026400026
-      4000264000263F01243D00243F00254001264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000254701264802264801284B01294D01284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284B01274A00274B
-      00274A0026480125470126480126480126480126480226480226480227490326
-      4802284C00284C00284C00284C00284C00284C002A4E012B4F022B52062D5601
-      365D07315D0039640D2E53032B510578A26B406E152F5C06295000265100284F
-      012A4B00264D00294A00284C00284C00284C00284C00284C00284C00284C0028
-      4C00274E00294D00294D01284C00284C00274E002A52002C5500365C14276812
-      B0CDAC98C8A4518734397A254486274785273C8F2D39842851963B9CD7AA5196
-      3B517E46558648AAD5AA65A45445862A48831A4587284587283885293B792748
-      8737398A3558995495BE8BC2E6C8E2EFDFFAFFFEFEFEFEFFFAFFEDFEF3D4E8DC
-      C8D8CDB4CCBAB5CEBAB8D7BAD3EFD2E4FDE9B0E5BAE2FDF9A0B4973A77172C66
-      013163052E5902285100254A02244D022B51002C55002B58013B64023B6B013B
-      6B012C73053978286A9568A4B9AAB6D8BABAD9BA87B489578B55397A254A831A
-      44811F3B6B01315D00355B01295000224700284C00284C00284C00284C00284C
-      00284C00284C00284C00284E022A4E012E5101284F012C5600355F0739640932
-      6307385829A5C890426E153D65003A6A043B6B013F68063965021E63022F7108
-      3776183B7417457731507C478AAA91C8D8CDF2FEFEEDF8F6CAF1D198B8A585A8
-      767AA16DB5CEBA45772F427719396C0A3C6D0B346A092F59013263074F7A1F51
-      8636879D84B0CCAFB2D2AF7CA36B3E6A0B2866023C6C023D6C09457731E5FBE8
-      4376323A6B01335F022B59002F57002A52042B50002A4E01294D00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00264801264801264801264801264801264801244600244600244600244600
-      244600254701254700264801264801264801294C02294C02294C02294C02294C
-      02294C02294C02294C02294C02294C02294C02294C02294C02294C02294C0229
-      4C02284C00284C00294D01294D01284C00274A00264900264801264801264801
-      2648012648012446002446002446002446002844022844022844022844022844
-      0228440228440228440228440228440228440228440228440228440228440228
-      4402284402274301284402284402284402284402274301284402274301274301
-      2844022743012743012743012844022844022743012743012743012844022844
-      02284402264200264200274101264000253F0026400026400026400026400026
-      4000264000263F01243D00243F00243F00263F01264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000244600254701264801284B01294D01284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00274A00274A00274A00274A00274B
-      00274B00274B00284B01284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00294D002B4F022C50032C5902295502
-      386401346001365F04244E01527B48A6C990335D062E55002A5401305402264E
-      00264801284C00274D01284C00284C00284C00284C00284C00284C00284C0028
-      4C00274E00274E00294D01284C00284C00284F012A52002E5500265A002E6502
-      AFE3BB4377312D73184786283A85293688353A893244894652974699D5A55596
-      4A558B564B8A4565A3578BC797559746398936468A37458736517E465A8B5774
-      A775C5DACBEDFCF4F1FFFBF3FFF9E3FFF1CBE5D798BB996A95683B7927366A17
-      386A16416C15377517396B17387618468626609153C8E6D3C5E0BE54963D3268
-      042E5D012D58012A51032648012B4C01274D0129510033610134610030610039
-      6502477632AECDAEF8FFF8F8FBFFFFF6FFFBFDFEF7FFFDE5FBE977B17A457632
-      3B79273775172C6502336000325A082A4E02284C00284C00284C00284C00284C
-      00284C00284C00284C00294902254A002C51012B5202325B00386409315B0333
-      5C0186B48964905339630B427916396D013B6B0B3469023269022C76183D7827
-      4776316E9666B1CBADDCF8E5F1FFF8E9FEFBAECCAF6B9566467832547B473D78
-      2844792FAEE2BA43781A407409326B02316801326B02305B00345F04365D0732
-      5A08365B152C5504396C1561905195BF8A95BE8B62A1573A76186C9667D1F0CF
-      386917316801346301385E06315C013053092B50002A4E01294D00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00294D01284C00284C00284C00284C00284C00284C0028
-      4C00284A04284A03274902264801264801264801244600244600244600244600
-      244600244600254701254700264801264801284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00274A00274A00274902264801264801
-      2648012648012446002446002446002446002844022844022844022844022844
-      0228440228440228440228440228440228440228440228440228440228440228
-      4402284402284402284402284402284402284402284402284402244300244300
-      2443002443002443002443002443002642002743012844022844022844022443
-      00244300234200244300264000264000264000264000264000253E00253E0024
-      3D00264000263F01243F00243F00243F00243F00253E00264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000244600244600264801274A00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00274A00274902264801264801274A
-      00284C002B4F022C50042E56042D55032B52022C51012C51012C51012C52002C
-      5200284C00284C00284C00294D01284C002A4E012C50032D5104315D00335F02
-      3460033766002F5B00345C1593BF8A6C95682F59022A55002F56012C5500254C
-      002749022B4F03294F03284C00284C00284C00284C00284C00284C00284C0028
-      4C00274F01284F012A4E02294D01284C002A4E012D53012E55002C6601326902
-      ADCCAF477631437916428627397A2547782E3B7925498A45458B44A4E7C24CA2
-      544689464BA454399145489954448A44498947527C476F956BB1D3AEDCF8E5F3
-      FFFEFFF6FFFEFFFDE2ECE6B6DAC46A966746883730802537821A387717356C09
-      326307326B09346B08356B0A3774193C8628477632B5CFB895BB973877172B64
-      023660012B5900254B00264A00284C00234901265100315D00305A0230620A4D
-      791EB4CEB7E0F0DFCDEFD0B8DAC2CAE4D6EFFFF4F9FFFEFFFEFEDAF8E584A977
-      47772F3A7B25306B09285B012E54022C4E01284C00284C00284C00284C00284C
-      00284C00284C00284C00274800264B012A53002D59003965023362002F5B0241
-      6C15D9F6DC527C47426C1544831D377209346A09346B163B7A24437731578C53
-      A7C8ADEBFCF1F8FFFFF1FFF3C5E0BF6C956846821D4379182E7207397A253886
-      28497532A9D6AB386A162B6401336800356A032D5900295900355F07325E052A
-      5504275B01316200326A012C6502245B00386A16588E5388AA92B6CEB6B9D6BD
-      436D163D6A033A6301345F04265500284C002B50002A4E01294D00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00294D01294D01284C00284C00284C00284C00284C0028
-      4C00294B05294B05284A03264801264801264801244600244600244600244600
-      244600244600244600244600244600244600284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00274A00274A00264801264801264801
-      2648012648012446002446002446002446002844022844022844022844022844
-      0228440228440228440228440228440228440228440228440228440228440228
-      4402244300244300244300244300244300244300244300244300254401244300
-      2443002342002443002443002443002342002443002443002342002443002442
-      01244201244201234100264000264000264000253E00253E00243D00243D0024
-      3D00254000254000253E00253E00243D00243D00233E00243F00264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000244600244600264801274A00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00274B00274902264802264801274A
-      002A4E022F5307305309315C012F5A002E58002D57002F56012E55002E55002E
-      55002A4E02294D01294D01284C00284C002A4E012D51052D51053461003A6B01
-      2C65023D6B0139650C5B8645D6F6DD3B582B31640A305D002B5900295300244B
-      00274B00284F01274902284C00284C00284C00284C00284C00284C00284C0028
-      4C00285100274E002A4E02294D01284C002A4E012E54022F5601336101315D00
-      879D846C966739761642791647862843862B47862A509747498A45AFE3BB65B1
-      6A489A51379F403C9E44489954529A6586D5A2CCF1C9F3FDECFBFFF9FEFAFFFF
-      F5FDB2E3BD78B88472B1798DC7975786473B7927427719326A013B6B01376502
-      3361013362003762013D63093A6D0B377618457731BAD9C486AA86396C0A3B6A
-      03305C012A52002B4D06274902294F032951002C5B003462092C5902426E1567
-      A257F5FFF36A95682276283B90453C914765A675C9DACDFEFDFFF7FFFEC1E7CB
-      6D95653B78282E71081C63032E5A002D4F02284C00284C00284C00284C00284C
-      00284C00284C00284C00264D002C4F052F56012C5A013864013C6400416F1665
-      A357A4C8AA43782F4F7A1F44831B3983192D74173C852946883779AC86D8F7DA
-      F6FEFEF4F6FEECF3F09CB4964A78302D80243C6D0B3877173573073A77153975
-      17467830B2D3B0436C17346B083169022F5B00225902275901255900265A0031
-      5B033460012B5900285A02326307306309356A09397209388218CAE4D69EB497
-      406E153B6B01366302345E062654022C52062B50002A4E01294D00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C002A4E02294D01294D01284C00284C00284C00284C0028
-      4C00284A04294B05284A04264801264801264801244600244600264802254701
-      244600244600244600244600244600244600284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00274A00274902264801264801264801
-      2648012648012446002446002446002446002844022844022844022844022844
-      0228440228440228440224430024430024430024430024430024430024430024
-      4300244201244201244201244201244201244201244201244201244201244201
-      2442012442012442012341002442012442012442012442012442012442012341
-      00234100234100224000254000254000243F00233E00233E00233E00243F0023
-      3D01243F00254000243D00243D00243D00243D00233E00233E00264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801274A00274A00274A00284C00284C00274A00284C00
-      284C00284C00294D01294D01284C00274A00254603274902264801244901284F
-      002F5503385B013B640239630C2C740431670333630A2063022E6601345A002A
-      5400274D01284F01264D00204B02264D022B5100305400355B03427309366502
-      3671082F7308376B17D8E9DB879E822C7108386400335C002D5202294B042A4C
-      06274C04254C01234D00214E00274E022C4D03294805294803314C032C510927
-      4C062D4E042C4F002852002F55032B4900294F032C51012B59002D58012C5107
-      49772EB3D2B387B489527B4847772F45772F4888363B8935489954B2E4BA76A6
-      7653975678B07BA7C8B3E7ECF5FFF5FDFFFFFFF5FFFEF1FFFBD5F6DB8BC69965
-      A45446984646974883BE929FCFB746831B407819376B17316902305C012E5800
-      2C58002A5700355B093362063B6C0A38751A4D8526B7CDBB9DB397356C093A6B
-      03335C012D53012956002E4E002945032C52062D56012F5B003D6B01396409AF
-      CEAD8BC7973B792537832B38852A4889443A9246469A528FE1ACFBFFFFF4F6FE
-      AAC8B54689442E75183D6B012C5200265108295000264D00254B00264C00294D
-      01294C02274902254A022B4705285100305C012F4D01335C012A72072D6911C7
-      D9CC76B07954863853853743862B3984283A9246478C53B3D2B1FDEFFBFFFBFC
-      ECFCF5B3E5BB48A3542E7F284379183169043361013A6B033A6B01376B0D3973
-      07366A17E0F0DF3965003462023361012E58002A52002950022A4E012B4F022C
-      51012D59002A520432520B3059082E66013B6C04396B17598548F2FFFE5B8647
-      437918326902275B01305C013054002F4903284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00274A00264900274A00274A00244600244600
-      244600244600244600244600244600244600264801264802284A03294C022A4E
-      02284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00274B00274A00264801264801264802274A00264801
-      2648012446002648012648012547012446002544012443002544012743012743
-      0128440228440227430126400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      264000264000264000264000264000264000243F00243F00243F00243F00243F
-      00243F00243F00243F00253E00253E00253E00253E00253E00253E00253E0025
-      3E00253E00253E00253E00253E00253E00253E00253E00253E00233E00254001
-      263F01264000264000264000253F002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801274A00274A00274A00284C00284C00284C00284C00
-      284C00284C00284C00284C00274A00264900224700264C04234800224C002A52
-      00375C00376403416903437A17367206356C1781B771396A18316904385C0233
-      5C012B5000285100274E00254C00254C002A5401385B003E5D023D6B014E791E
-      3B771946862686B489E2F0DE517C432B6402296402335C012A5401294D012F4B
-      05274903274D01215102214D002C52062A4C00324D033352072C4F002E510128
-      55003054072D59002C55002B5500284B01284D032850022952002D5801336200
-      21510343782E79A269C9F3CAD1EFD29AB9A496BB9992BB96A3BAABE1ECE4D5EA
-      DBE7FBE8EBFDF6FBFFFFF0FEF8F2FFFAECFDF2B8D7BA78A77656854648873746
-      923A46913B44883589B487B2CDB9437A17356C092F62063461002E58002B5500
-      2B52002D55032A5700305C01346A093F73074F7B1EB8D9B789AA873269023B6C
-      00315D002F5503275000294D012948032C5101325500305C0131690238630CB4
-      CDB977A5763B792739821B3777143D78273B84283B8936559B66E3F8EFFCFDFF
-      E5FBE866A4683985273169043362002B5502284F00284F01264C00274D01274D
-      01274C02264B01254A002B4803264C002E5A013A640C446B152A7207678F55F4
-      FEED598647518636468837479A453B9045588C56CEF0D2F5FFF3FEFAFFF5FAF9
-      A6C6AD578B553A86283176152A6601346001315D04386401326A00346902396A
-      0249772EE8FCE93A6B013361013361012F59012A5101284F01284C002A4E012B
-      50002E55002B51002C5107356005336900326804356B1865A367E5F6F2527B48
-      407409346901325B002D58012F5601324D03284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00274A00274A00274A00274A00244600244600
-      244600244600244600244600244600244600264801264802284A03294C02294D
-      01284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00274B00274A00264801264801264802274A00254700
-      2547012446002648012648012547012446002443002443002844022743012844
-      0228440228440227430126400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      264000264000264000264000264000264000243F00243F00243F00243F00243F
-      00243F00243F00233E00253E00253E00253E00253E00253E00253E00253E0025
-      3E00253E00253E00253E00253E00253E00253E00253E00253E00233E00243F00
-      263F012640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801274A00274A00274A00284C00284C00294D01284C00
-      284C00284C00284C00274A00274A00264801244502274700264704264B013254
-      00335D06426A05437A174485293B79256E9567F3FFED77A5763A6B153A6B0336
-      5F032C56002A52002A4E02284D032C4F00305400345E073C650A437A1744831B
-      468836538B56D1F2D0A7C7B44678322E7207346902315D022E5402284D052A4C
-      06284B01264D02234D00234D002850022847022D51003155012B540034630131
-      62002F5B00356104315D002D5900254B002B4B0A2B4C022951002953002D5900
-      34600334600132640658854687B58ADAF8E5FAFEF3F3FFF3ECF8F8FFF9FFFDF8
-      FFF5FFF9F0FFF7ECF3F0ADD4AE74B179588C5646792F4775333A86282F7F242E
-      8027448627387B2682B687B6DAC43774062E6601345E072E5800265401295002
-      294D002C52002E5402305D003469023C6D0B3A7618CAE3D587AC843B6C0A3469
-      023059002D5900294F03284F002847022C4F002F5902315C013068013C6C0CB8
-      D7BC568D56396A183273063B6C0A3A7715387618398329478B4498B9A4F9FFF9
-      FDFEFC9AC9A3398A353076192F6A02315503295000295002274D01264C00264C
-      00264C00274C02254A002C4B062F5C00315C013F6806446F14356B1895BE8BE0
-      F0DE5086395098453D91493790466AA578D3F6DBFAFFFAFFFFFFECFFF0B0CCAF
-      568D54397A242C761834690B3462002E5A012E50032E5A012C65022C65023573
-      09527B48ECFDF23C6B043361013361012E5A01295000274E00284C00284C0029
-      4D002750002B4C01274E00325A022C6503316703467733AAD5AAC7DACB487634
-      357307326804315C012B55002A5000304D04284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00274A00274A00264900264801264801
-      264801264801264801264801264801264801264801264801274902284B01284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00274A00274A00264801264801264801274902254700
-      2446002446002648012547002446002446002443002743012844022743012844
-      0228440227430125440126400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000253E00253E00
-      253E00253E00253E00253E00253E00253E00233E00233E00233E00233E00233E
-      00233E00233E00233E00253E00253E00253E00253E00253E00253E00253E0025
-      3E00253E00253E00253E00253E00253E00253E00253E00253E00243F00233E00
-      253E002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801274A00274A00274A00284C00284C002A4E01294D00
-      284C00284C00284B01274A00264801264801214602274C002A4B00294E00375A
-      0333630A426D164D7A1D3D912B568546B2CDB9FFFEFFCEF2CE45772F417A1732
-      69022D59002A54002852002A4F002E52002E5A013B64093A6D0C4D78213C8626
-      458D519BBBA2F6FEFD9BBC9947883338831B346A092F6103295600274E00294F
-      03254B03294D01274D01285205244B00274E002952012953003462023D6A032C
-      6601396502306900316902335B03284F032E5003204C05285002284A042A4F05
-      365D07255A00286503326B08366A1645772F6E956786B5879BC8A1E0EBE8B2CD
-      B97AB68668A369517949468836478628397517306B09346C072D64012D720938
-      811A3B79253A782489AA87B5CBB82F6A02346001315B062D5702265300284F00
-      294D002750002C5500315D0432690242730B397517E3FFF089AA883C6A0A3169
-      022956002D56052951002D4D00254A06294E002D59002E5D002A66023B6C0AB9
-      D7BA6C96673976143875073F6A033665002C650237821A398A33539B66DBF7E4
-      FEFFFBDEF1DE448A443986252B66003956002B5202295002274E00264C00274D
-      01274E00274D01264B012A4B01315C01315C013C6C02416D14527C47C8F2C9A7
-      BBA84DA4543992434BA45558AA75DAF8E5FDFEFCF1F4F2FEFAFF98D5A9589857
-      3D7925437918306803335C01345E06294902284D092B5500356201326A013573
-      07639254EDFEF13864003362003361012D5900285100274D01264C00284C0029
-      4D002B4D00284F012251022A66022B6401326307578745E6FDE79BB9A6387A21
-      3573073169022D5801284F002A4E012A5103284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00274A00274A00264801264801
-      264801264801264801264801264801264801264801264801264801284B01274B
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00274A00274A00274A00264801264801264801264801244600
-      2446002446002547002547002446002446002844022844022844022743012844
-      0228440224430024430026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000253E00253E00
-      253E00253E00253E00253E00253E00253E00243F00243F00243F00243F00243F
-      00233E00233E00233E00253E00253E00253E00253E00253E00253E00253E0025
-      3E00253E00253E00253E00253E00253E00253E00253E00253E00243F00233E00
-      253E00263F012640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801274A00274A00274A00284C00284C002A4E01294D00
-      294D01284C00274A00274A002648012648012348002949022D4D00315600355F
-      083B64093877174786283A933694BB8DFDFFFFF6F6FCF1FFF886B48939852739
-      751733630A2659012952012C52003054002D5B02396C043F7307508528469748
-      549B63E4F7F4FBFFFFD0EFD2509747498F2B3878153564082E59002A52002E50
-      03284C00274C02264E002D5100204B022F5B00335B03335C0132630732630750
-      8327407A15356B0A3D6B003361012956002A4D03264B012B4F02304C10264A04
-      2B4F032751003362002965013469023973073B7925479946438D51BAE6C765A6
-      753789363A902C398428367108336C09306801326902346001336101316B0035
-      6D083A771737792789AA87B6CCB92E65023B6402315A05315B03285200264D01
-      2649002A4E012C5700315C01306A0B4475074F7B1EF0FEFC88AA853A6C0E3268
-      042A55042D5406285100284F00294A072750002F5901325B002A6602396C0AAE
-      CDAE85A97B397A25427408386203305C032D65002C7207397517399046B9D8BB
-      FFFAF9FFFFFB77A5763B8936346804405C032B5202284F00274E00254D00264E
-      00284F01274E00274D012750002B55003069004079163B79277AA16AE4FEF077
-      AD823B9E4248A96657A766D6F5DAFFFCF8FFFBFFF4FEFEB4CDB94499453B8935
-      2F76162E65023460012E5A012A52002B4C022B4D062E5500316003356A0C4074
-      09629153EEFEFD326A0B3461003362002D5900275000264C00274B00284C0028
-      4F01254A062E5604245A013469012864003A6B1977A16CF3FFF977A5773A7717
-      3973073462022951032650022C4B00264C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00264801264801
-      264801264801264801264801264801264801264801264802254700274A00274B
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00274A00274A00274902264801264801264801264801244600
-      2446002446002446002446002446002446002844022844022844022743012844
-      0225440124430024430026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000233E00233E00
-      233E00233E00233E00233E00233E00233E00243F00243F00243F00243F00243F
-      00243F00243F00243F00253E00253E00253E00253E00253E00253E00253E0025
-      3E00253E00253E00253E00253E00253E00253E00253E00253E00233E00233E00
-      243D00253E002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801274A00274A00274A00284C00284C00294D00294D01
-      284C00274A00274A00274A00274A00274A00274902284C002B50003859043665
-      003B6B0B377616478527558C55D8F7DCF0FFF9E2F7EFF7FFF8D5F5DC458B4539
-      7A24346A092E5D002956002F5601385B013361013E6B0E43771944902B4B8848
-      9DD0B5F1FFFEF4F9F7F3FEF486B58746883744831D3D6C0A305C032E55002D50
-      00264C00284C00254C012A4C002950002D59002A6601326A0B386A16457731A7
-      CA926E946A3B77293E6D0A3169022E5800284F00254A00254C01234A002B5100
-      2B50062B5105254F02265901346B08336801336C0A368836457632E7FCE668A3
-      693081243A801B2A72082E6601325F02305D002E55003057023A5A013561043A
-      6301356C094F7A1F83AA76B4D9C53467053A6B03345A082E5A01295103274D01
-      284B012C4D022F5300335C00386D0C437817387826EDFFFD89AA8F346B083268
-      04345909325A08264E002850022449032850003158022B59003168013C6D0B99
-      BA98A8D6AB4776323B6C0A396500326100326805306B02427817378A3586B489
-      FAFFFDFFFDFFB2D3B02B87342C76164268082D54042A5101295000274E00284F
-      01295000284F00284E02295600325A023A6B03387618557B47B4CEB7E1FFF252
-      9A6636A74F55B06BB4E5C5FFFFFAFFFAFFFEF9F8D9F6DC468D5439842838821C
-      326A012D59002D59002C54022B4E002C51072C4B062D56013260003168014474
-      0A6E9666F3FFFF4B7A1D3663023461002E5A01285100264C00284C00284C0028
-      4F012B4F03325400275B01266400326902518538B2D2AFF5FEFB538B56397818
-      3873033361012950042A4E01285002254D00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00264801264801
-      264801264801264801264801264801264801264801264802264801274A00274B
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00274A00274A00264801254700254700254701264801244600
-      2446002446002446002446002446002345002844022844022844022844022844
-      02244300244300244201243D00243D00243D00243D00243D00243D00243D0024
-      3D00243D00243D00243D00243D00243D00243D00243D00243D00233E00233E00
-      233E00233E00233E00233E00233E00233E00233E00233E00233E00233E00243F
-      00243F00243F00243F00253E00253E00253E00253E00253E00253E00253E0025
-      3E00253E00253E00253E00253E00253E00253E00253E00253E00233E00233E00
-      243D00253E00263F012640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801274A00274A00274A00284C00284C00294D01284C00
-      274B00274A00274A00274A00274A00274A00244A022D4E032E55003864014169
-      033C6D0B3A782646883696BC98EDFEF3B4D9C5AFE4BDF8FDEEF9FEFF6DAC8037
-      79273A72093365072D58012F5601375B0139660043730946831B39922B6B9566
-      EEFFFCE5F6F2E2F0DEFEFFFAC5E6CB458D514486273A76183363032D57002B53
-      01294D00254A002B4E042E4E013054002E580336690143791648792F89A986E3
-      FCE8B9D6BC6491524278173A69023162002A5401285200244B002E5200234C01
-      254B032D54042A5004285002205002355F07396D093E792949772FF3FEEA6A95
-      68346B142D72093962003163002D5C002F54042D51002F50002D5700305C0138
-      6400316A0842781787B688D6E9DA3B6C043269022E5505295901295103264E00
-      294D01274F01325602375F073D6C0A427A15377927EBFFFA9EB6983C6B093B6A
-      03325A08305604295201284F01264C042953002D5900245A0034690232690C88
-      9F83E6FDE7578648426D163B6A0D33630A2B66002B6401437A173A933665A268
-      F5FFFFFFFEFFE3FDE5498B443080253765022E55052C5402295000274D01274E
-      00295000285100285002295600345D083E6D0A3975176E9568E4FDF9BCE8D14A
-      A35454B6748BC896EEFFF3FCFEFEFDFFFFDCF8E567A3663A913942841A2B6500
-      275A02335E072D5000254B002A4B00254D00324D032E5500386401326A014074
-      086C9568E9FFFA5986473A66033461002E5A01295201274E00284C00284C0027
-      4E002F50052D5900275A002C65023878156F9367E6FCE9C6E6D54A7732397106
-      3469022B59002E4E07284F03284C001F4D00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00264801264801
-      264801264801264801264801264801264801264801264802264802274902274A
-      00274B00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00294D01274A00274A00264801244600244600254701264801244600
-      2446002446002446002446002446002344012743012844022844022844022743
-      01244300244201244201243F00243F00243F00243F00243F00243F00243F0024
-      3F00243F00243F00243F00243F00243F00243F00243F00243F00233E00233E00
-      233E00233E00233E00233E00233E00233E00233E00233E00233E00233E00233E
-      00243F00243F00243F00253E00253E00253E00253E00253E00253E00253E0025
-      3E00253E00253E00253E00253E00253E00253E00253E00253E00233E00233E00
-      243D00243D00253E002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264801264801264801274A00274A00274A00284C00284C00284C00274B00
-      264900274A00274A00274A00274B00284C00264B012C4C002F56013A64004273
-      0936751738852944923AE6F7F3F3FFF884CBA37BB886FAFEF2F9FCFFB9E7D147
-      8A45377717366B0A305C01385A03405C023D690642730B44841A3D902EA4C8AA
-      F2FFFFB2CDB9D3E6CDFDF8F9E9FEFB68BA8548902C4379183263072E5A012A52
-      00274D012949022B4D07304E033A5E042C65023E7A1646821D629152B6DAC4EE
-      FEFDE2FDF977A6755084263E730B316902325D022E55002A4B012C47052C4E08
-      284C00295100204D002B59001F4D00346307316902346A09467830F4FFEB6E94
-      6A376A1A346902396502275804215200264D00264906264B032C50032D590029
-      650037740638761897BF88E6FEF23E7409316A01305A07315D00245108254E03
-      274A002C4D022E55003361013A6D0C437A173A7826F0FFFBA4C7AC4278173A6D
-      0B2B52042851002E5505275100264C04275502315B03265B003B6B01346B086C
-      9667F3FFF977A2694F8427396C153463072B64022F6A023D6B0B378428488C55
-      E2EDE3FEFDFFF3FEF467A16A3B89353D6C0A2D54042D5503295000284E02284F
-      01284F00285200274F01245A003A640C427916478F2F87B688F1FFFD98B9A453
-      C47468BA79D8F8E5FCFEFFFFFAFFF2FFFD8BC896458B4538811A326902325E01
-      2B59002C51072B4C01294D01294F03284E02304E032E5A003764033D6C09417A
-      186B9467F3F8FF6291523965023461002E5A01295201274E00284C00284C0027
-      4E002E4E002D59002F6A022E751544852984A977F6FFF2A5BAAB397A252A7305
-      2C66012D59002D4D06254A06244900225102284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00264801264801
-      264801264801264801264801264801264801264801264802274903274902274A
-      00274A00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00264900274902264801244600244600244600264801254701
-      2446002446002446002446002145002144012844022844022844022844022743
-      01244300244201224000233E00233E00233E00233E00233E00233E00233E0023
-      3E00233E00233E00233E00233E00233E00233E00233E00233E00243F00243F00
-      243F00243F00243F00243F00243F00243F00233E00233E00233E00243F00243F
-      00243F00243F00243F00253E00253E00253E00253E00253E00253E00253E0025
-      3E00253E00253E00253E00253E00253E00253E00253E00253E00233E00233E00
-      253E00243D00243D00253F002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000234401284A04244600264801274903214600264B01274B002E4E07284B01
-      284B01285000285000274902264801284906304C102956003B64023B64094E7B
-      1E2E7515477631A1BBA9FDF5FFC9F2D749B87446B774E8FCE9FFF8FBEDFFF26C
-      95683A87263976162062033E5D0240690730720840791742831D578B55E8FBEC
-      FDFEFA65BC7A6CC996FBFEFFF4FFEBD2E5CC3A91474686263964032B65002855
-      002D49033253091E4C002E55002F5B002E720738811B50964984B587F3FEF4FF
-      FEFDFFF9FFB9E7D1488C5339821B3B6B012D5B09225B00245200284F00274E00
-      284C00274E002750002B51002855002E59022D65002E6502397616F0FFF96E94
-      6A3169043169022E5A012956002A53002A4E01274A00274A00265100315B0332
-      69023773073B7828C6D7CCFFFFFB386A16326B08345E072C55042A5300274D01
-      2A4B08274A002B58012E58003B6B0B4F7921477632FFFEF9C7DACB3775173469
-      022959002A5C04334D11244C04284C00284C002B52072D59003A640042781747
-      8A45FFFBFFCFF1D32E88353876183673052A6503326804416806508426488E52
-      A6D7B7EEF9F7FEFEFE98C8A44689462E7518326A01245A00275000294B042A4C
-      05274D01224C00245902346001326C143B7927458B44E1F1E0F5FEF453C37554
-      B572C9E3D5F3FCF9FFF7FFFBFFFFB7E6C5489A523789362E7108345F042E5A01
-      2A53002950002850022851002950002750002A4E02295600265E0D3A640C4279
-      16629152FCFDF4568D54396D013360033058002654072A50042A4B012B51002B
-      50002A5406375B0134670533821A527C45E9EAF4FBFEFC78A36A387717326902
-      305C012C55002A4B01264A04284E02295000274B00294D01294D00284C00284B
-      01284B01294C022A4E02244901294C022C4E012A4E01284C00284C002A4E022C
-      5003274D012A4F002B4F02294D01274E00264D00294D002D5100274B00284C00
-      2A4E012A4E01284C00284C00274D01274E00284F00234901264D01264D022851
-      002A5200264C00274D01284906284A03284A042849062A4C06274A00274A0027
-      4D01284C00284C00284C00284B01274A00264900264B01274C02294E00294D01
-      2A4E022B4F02284C00274A00274A00294D01284C00274A002A4D03274B00274A
-      002B4F03274A00284C00284B01294D012A4D032C5003294D01294D01284A0325
-      4701284C00294D01284C00284B01284C00284C00294D01284C002950002A5200
-      274E00284F00274D01244901264D00274902254A002A4E02264A042648012648
-      01284906294D01264D00274E00274E00274E00274E00274E00274E00274E0027
-      4E00264C00284C00284B01264C00264C00284B01284C00264C00284C00274D01
-      284B01284A03284801284A04294B05284D05284C00274A00264900274B00284B
-      01284A03284A04264801284C002C50042B4F02284C00274B00294D002C500327
-      4B002B4D07284A04284A04284A03264801264801264801264802284605274601
-      2746032443002645022547002648022043002742022742022641012842022640
-      00264000264000253F00253E04253E04253E04253E04253E04253E04253E0425
-      3E04243F00243F00254000254000254000243F00233E00233E00253E00263F01
-      264000254000254000243F00243F00233E00263F01274002263F01253E00253E
-      00253E00253E00253E00233E00253E00264000264000264000264000253E0023
-      3E00254000254000254000254000254000254000254000254000253E00243F00
-      233E00243E02243E02243F00254001263F012640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000284A042B4D072648022A4904284A03234800274902264801244600264801
-      264B01264D00264C00254A00254603224201324D033162003A6302426D164484
-      1A38902C498A45E2EFDFFAFFFF9CD6A637B46545B567A6D8B6FCFFFAF5FFF8B0
-      CCAE46863A3B7927296713426A044268042D751549862B45842699BBA3FEFEF2
-      D7EADB57B06B53C375D9F7E4FCFEF8F2FFF465B16A45893443821C356A032E58
-      002D4A01264C0028560430540032690238831B478E2D539756C7E6C9F4FDFFFE
-      FEFEFDFEFCEDFFEF69A575449338427408345F042F5902315600274E02254C00
-      274C02284D05274D052A4E022A5302325A082F6A02316801447A17F9FFFA889D
-      843B6C00326902315E012F510A284F042A4C052649062D4D002F5600315C012D
-      6500377307448736C6DBCCFDFFF93B7828387408326000286602295000254A00
-      284A03284B013562013161013B6A0D4E7B1E408727FEFFFDB9D6BC376B173473
-      052B6401275905284C06254D0030540239630B1F4E023D6C0A3A6B0342841B49
-      8A45DBE2E5EDFEF377A7733B79253978183A72073260003F6A0144831B479947
-      97C7A3FDFEFCFFFCFFC5E0BE4A8C442F8023447A173263072E5A002C4E012B4C
-      012C50042D50002953003A6B032E741746883777A675FDFFF7E5FBE94FC47568
-      B988E6FFF0F9FFFEFFFBFFEEFFF279B78946923A2E77152B64012F54042A5103
-      274D01274D01274E00294D00264C00254A002A50002B58012C69113B6C0A4683
-      1B579756FFFEF6558C553D6A033361012E5B00285500284E02224B002B4C0132
-      4D032D5900345E00437B1639852787AB87F7FBFCE5FBE8529747397517346804
-      305C012E58012E4F042B4D07284F042952012F55032C51012A4E01294D00294E
-      002B4F022B4F022A4E02254A00284C00294D00294D00274E00284C002A4E012C
-      5003274D012A4E022A4E01294D00284B01284C00284C002A4B01294C02284C00
-      284C00284B01284B01284C002A4E022C50032C5504275100285002254C012850
-      022D5406274F012750002B4D06294B042A4D032C50042D5104284C00274A0028
-      4B013054082D51052A4E01294D002A4E012C50032C50032A4E012B4F02294D00
-      284C002B4F022B4F02294D01294D012C50042E5505274B00284F01264C002A4F
-      002B5305294A00274E00274E00274E00264D00264D00274C02264C00264D0027
-      4E002C51012A50002A4E01294E00294D012A4E012D4F022F5005264B012A4F05
-      284C002B4F032B4E04294D012C4F05294C02284F002951002C5004294D01284C
-      002D4E032850002B4F02284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284B01284C00284C00284B01284C00284C00274902284B01
-      2A51032B4F02274D01274A00274902264802274A002648012648022648012649
-      00264801264802264802274B00284B012A4E01294D00284C002A4E012A4E0126
-      4900264801264801264802264802244600254700264801264801284704274603
-      2746012442012645002547012547002144012640002742022540002640002640
-      00264000264000264000243D00243D00243D00243D00243D00243D00243D0024
-      3D00253E00243D00264000264000253E00243D00233E00243F00253E00253E00
-      253E00253E00263F01253E00253E00253E00243F00243F00243F00233E00233E
-      00233E00233E00233E00243F00243D00253E00253F00253F00253E00243D0024
-      3F00254000254000254000254000254000254000254000254000253F00253E00
-      233E00233E00243F00233E00253E002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000244901254A02254603264802264801234800264B012446002246002C5206
-      325A082E55072B52042C5107294E042648013A5303355B01386B034279163675
-      173B852B76B079F8FFFAF3FDEC65BA7C37A65046A8666AAC82F0FEF2FFF9FAE1
-      FCE864A468449846397A25377616437A17377927398837468836DAF9E4FFFDFF
-      8BC69948A8623BB26793CEAFFFFFFFFFFCFFA8D7B6478A473380252B6401385B
-      013A54002851002A5401315503426C15438827478A4577AC84F2FEF8FFFFFEFF
-      FDFFD5EADBF1FFFDB4D9C55796582D7614356A0C3B53003B5400274E00244B00
-      274A00214C03264A04254C012C5101305505306803357307407917FCFEF299AD
-      963168012A6503325F022C51072C53082A4C062E4F04294F03315501305B002D
-      6500458319478A45C7D8CBF4FFF43A78243773072E64002062032751042C4D02
-      2E4E002C51013A6B033169023C6E0A508327388726FEFCF4C5E0BF2D74173469
-      022C6601265B002A4E012A54013965023664012965003C6D0B3D730844831B38
-      8934A5BBA9F6FFFAC7D8CD547A482C82242D7106326A013B6A0D37811B3C902A
-      78B17EFBFFF9FBFFFFF5FEEA55965836933840862925600B2952012C4B002D50
-      002E54023155012C56033C6D0B308025539448B3D2B1FFFEFEB5E8C347B672A8
-      E6C2FAFEFFFEFDFFF6FFFFC7E6CB468E52378428356B083361012A53022B5000
-      295000274F01264D00264E00264D01294C02295306335C00397616406E154683
-      1B66A369FAFDF4689668326804316902336000285800275103274D012D4C0731
-      5208305C03336A0345811C46913BC6DEBEFFFFFFB7D5BC2076283876182C6502
-      2559002E5500254C00264802274D01285100345A082E54022A4E01284F002A51
-      012C53052A5101264C00284F012B50002C52002A52002A51012A51012C52002C
-      5402274D012B4E042C4F05284B01294B042D51052D5104274B00294F03284E02
-      274D01264C00264C00284E02294E042A4C052E5309284E02274E00254A022B4D
-      063053092A4D03294F032B4F03284C002A4F002B52042C53052B5000294E0028
-      4E023053092C4F052A4B01274A00294C02284D03284B01274A0030520B2C4F05
-      2D4E042E4F052E4F052B4C01284B01294C02345E062950002951002B50002B55
-      002E54022851002A5200284E022B50002B50002A4F00295100294D00274D0127
-      4D01315B062D57022B5502295201295100284E02274E00274D012749022B4E04
-      274B00294C02294C022648012B4D07284A032A53002C5500295000284C00284C
-      002B51002E55002A5101284A04284A04284A04284A04284A04284A04284A0428
-      4A042A4C00264D00264C00294D00294D00264C00264D002A4C00284C002A5200
-      2D55032A53022A4F00254B00264801274B00264801254700274A00274A002648
-      01254701254700264900264900274A00284C00284C00284C00294D00284C0027
-      4B00274A00274A00264801264801264801274902244900254A00274603284704
-      2746032645022746012648012547002446002741012641012641012640002640
-      00264000264000253F0025400025400025400025400025400025400025400025
-      4000253E00243D00264000264000243D00243D00253E00253E00253E00243D00
-      243D00253F00264000253E00243D00253E00253E00243D00243D00243D00253E
-      00264000264000264000243F00253E00253E00264000264000253E00253E0024
-      3F00254000254000254000254000254000254000254000254000264000264000
-      253E00253E00253E00253E00253F002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000234A00295000274D012A4F002951002950002C55002C52002950002E5801
-      3159072E58002D57002D56012B54002A52003C54003C650A4379163979274688
-      3759854AD2E6C9FCFFFBD1E5CE55996237A85145A86256A975CAF1D7FEFEFEFB
-      FFFF8FC697479B534776313977194588335486383B904685B787F4FEFEF4F9FA
-      509B6347AA6445B67355BA87F9FAFEFFFBFFE4FDE96AAD803991453979273057
-      022D51002C56003B6409426C15397A25509545558B56D1F0D3FDFFFFFEFEFEF8
-      FBFF65BF94E6FFF1EBF1F078AC873B7927367305355B01385708315C012C5300
-      2A4F002A52002953002C55002B58012B5A003269023D7925477631EBFFF29AAB
-      963063072B64013364082956002956003054002D50002651002B5400345E0633
-      6B1851953C498A45C6DACEF0FEFD45883737821A3A76182063002E5A012B5400
-      2A53003159013A6A042C6502336C0A518636558C53F8FEF9C9DACD3679242E76
-      16326B092F65022B5500346001386401305C003E792838781539792752954A3C
-      91467BBF96F3FFF9FFFAFF9ABB993B88372C7616326B0839691A3D912B368934
-      4F9B65F5FFF3FEFAFFFBFFF97BAC86389246529747245E0D265100355B033A5A
-      01315501315A09346A17436E133A8F2D569759EDF2F0F5F8FF8ADCB268BA85EC
-      FEFDFFFAFFF5F6FAECFFFB78AD853887362A7207336C09385A032950022A5200
-      2B5500295300284F00284F002750002852002D54002E5A013A7717436D164278
-      17579853FFFEF688AA852C7305326B092C65032B55002950002B5204254D002B
-      5204416D1438831946923A77B17AEBFFF2F8FFFC96BB9B3081243776161F6201
-      2B5500295600264C00254A022B5204315C01315D002D56012A52002A52002C56
-      002C56002C52002B4F022C55002C56002F56002E58012D58012E58012D57002E
-      58002950002850002950002A4E01284D002A52002B5204254A002F56012C5200
-      2C51012B50002C52003054003155013155012E5A002B52022A5300274E002D57
-      00335D062D57002E5A012B4F02274E002750002D56012B54002953002A54012A
-      52003054072B5204284F012950002C52002F53012C5200295000325B06305702
-      2F56012F56012E54022B51002B50002A4F0039630B284F00274D012850002F55
-      032E57022B50002C55002C56002E54023057022F56012F56012C52002C530028
-      4F00315C01315D002D59002B56002A5200284F00284F00284F01284F002C5500
-      2B50002C51012C51012A4E022D51042C50032E5A012C5600295100284C00284C
-      002A52002E55002C55002C52002C52002C52002C52002C52002C52002C52002C
-      52002B4D00274E002A4E012C51012C51012A4E01274E002B4D002850002D5601
-      2F5B02335C012C54022C5101284F002B4F03274A00284C002A4E01294D01274A
-      00264801264900274B00284B01284C00284C00284C00284C002C50032B4F022A
-      4E02274E00294D00284C00284C00284C00284C00284C00294D00274603284702
-      284704284702284A04294C02274A00274A002845002744002746012744002845
-      0027440029450327430128440228440228440228440228440228440228440228
-      4402243D00243D00253F00264000243F00243F00254000254000254000254000
-      254000264000274101264000253F00243D002640002640002640002640002640
-      0026400026400028400025400025400025400026410126410125400025400025
-      4000264200264200264200264200264200264200264200264200264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      00002E5902336101335F00396403335F00305B00366401386401315B03315D00
-      346001346100336000315B033462003B6A0436640B61903A56963C458B4467A8
-      7794AC94F8FFFFFAFFFDA4C9A954A975539B6657A97455B989A0CFB5FFFEFAFF
-      FFFFC9F1D856A877488A4239893667A25768A468529A65D1EFD2FAFFFDB5CEBA
-      3C92444AA35454B77346B773E1EEE6FFF9FFFFFFFEA5E5C249A7665096493A62
-      0A345D083462023964035186364F964669B26986B587F5FFFFF5F6FAFAFFFFC8
-      E3D939C98E9ED9CAFAFFFFC8DACD488A432D74172C650229690F40730B336200
-      315D02325F023462003764033B6304396502336A07478A45598A56ECFFFBA6C9
-      B54688374493384589343972093672063C6C023A6B013664013A650A4D791E53
-      863654973B4A8846C5DACBF2FEFE559C635195485786473979273168013B6C00
-      3965023864003F7609326902396B175985487AB588FCFAFFC9E4D4488B464689
-      34438936377616325A083B6C0A436D164D8834459139448A43659156A9D5AC53
-      9C6456B987E5FBE8FEFAFFE1F7F265A36746893437761846883649A253519C64
-      6AA676E2F6F1FFFAFFFFFFFFA6D6B9489954529747245E0D2B5500436D16426E
-      13436C174E782065A35554863839913787BC95FEFAFFF1FFFD84DBAF9EDDB6F9
-      F9FFFEFAFFF7FAFFDDF8E4488E513984282C66013E6A0B405F04346003346100
-      396502386302346202336003346001386302345E0631630B4485294D7A1D4682
-      1D6C9667FDFEFAA5CAAA468837397A253B76143965083A640C38640B3162003B
-      65004F8637519646519D63B7E5D2F8FDFEF7FFFE67A5753B9046468529396C0A
-      336101345E072D510B284C063055053A640C2E5A012E5A012F5B002F59012E57
-      022F5601305402315501315C01315C01325D02315C01305D00315D00305B0031
-      5C01335F06335F0639630C39630C355F083964093964092F5B02345F04315B03
-      315B03305B00305B00325D02345E06365D07346003335F00346100315D003765
-      023A650A315C013361012A5200274E00284F002E59022E5902315B04345E062E
-      5902305A02345F04356005345F04315B03315B03345E06365E06305C032D5900
-      2E5800315C01346003315B03315B03345F04396409295100284F002C5600365D
-      07345E062F5601305A022E5A00315B03335D06325A08315C012E55002A520028
-      4F002C56002E58002E58002F5901315B03315D00315C01305B00315D00346001
-      305B00315B03315C01315B03345F04315D00315C012F5B022E5500284F00284F
-      002F5503305A02335D00315C01315C01315C01315C01315C01315C01315C0131
-      5C012C5101294D002D50002D54042D54042D5000294D002C51012C54022D5900
-      335B03315B033056002C56002F56012D58012B4F032D51052E52062C4F05294C
-      02274A00274A00274A002C50042A4E02274B00274A00284C002C50032D51042C
-      50042B52022A51012A51012B50002A4F002A4E01294D002A4E01254701274603
-      2746012A49042A4E022C4F052A4E022A4E022A47022948052746032B47052A46
-      042C48062A46042B47052C49002C49002C49002C49002C49002C49002C49002C
-      4900243F002540012641012743012844022945032A46042945032945032A4604
-      2945032844022743012641012540002540002746032746032847042746032645
-      0227430126410125400027430128440228440228440228440228440228440227
-      4301284402284402284402284402284402284402284402284402264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000315C013765023965023E6A05396403315D003965023A6400346100335F00
-      3561043664013765023665003B6A034376074F7A1F57864756985755A76666A4
-      74C6E5D6F7FAFEEBF7FB6DAD7F6AA676549A6558A76454B57268AD82F5FFF3FF
-      FDFEF2FFF778BE9649995648974665B26867A57579AC86F4FFF9FEFFFA87AB87
-      3988373C8A3649984944B4669BD0B5FEFDFFFCFAFFD7F6DB559C64428B43245F
-      0B2A5D053A62033D6A0352863965A05669BB86B7D9C1FFFEFFFFFBFFE4FEF178
-      BF943AC9926BBA89D7F8E3F3F9F87196682D761438811A368629407408386302
-      3260003B64023562013965003A6B03356703326B09478B4465A367ECFFFCA2B9
-      AA488737498A453B79273875073973074275063E6B043765023B640947763262
-      8F39509545588C57C9E6D6F6FEFE7AAC845597565586484677333A6B033D6C0A
-      3A690D3765023D720A2F6A023C7929538C5598BC98F7FAFFC9E6D6458C534689
-      465587393978283A640C316408508633639254589759578B56A7BBA8E2FFF076
-      B88443B667B2E4BAFAFFFEFBFFFFBAD7BD4B8A453B852748A3545AA976549A65
-      67A575B9E6D3FEFEFEFEF6FDD6F7DC49A96367A3553A7A283B6B0B4E791E4D7B
-      1B416D144A783065A35547975449A455BBE7D0FCFBFFE4FEF06BC895D9F8E3FD
-      FCFFFEF7FEECFDF29FCDBA3C91462D80242B64022D57002F56013B6B01396A00
-      3A6B013B6B013B6B013B6A033C6B053D6C0A3864093B6B0B5085285385374286
-      276F946CFFFEFAB5CEBA44894647893839792731640A335F00386401315D0032
-      6902598B5568A36988B388F3FFFFF9FAFEC3E6CB488E523C89355585373A7618
-      326B08375F072F4F082B4E043257013161012C55002F5901345E07345E07325A
-      0831580A325A08325A08305C01315C01315C01315C01305D00315D00315C0131
-      5C013361012D5900326000376502315D00315D00335F002E5A01366302346100
-      346001346001346100366401386401386401386302366500346001315B033864
-      013965022E58003561042F5601284F002B5202345A08335907345E0639650836
-      5E06305C01346001386401396502346001336003376403396500336101305C01
-      305D00346100376403346001346001376403335D052A51012C52002F5503335D
-      05395E08325C05365E06305C01325B06345A08325A08345A082E54022B51002B
-      4F022E5500305702305A02325A08345D08345D08325B06325A08336200366502
-      305D00315D00305B002F5901346003305C00335D05335D062E54022A4F002E52
-      05335808345E06315D00315C01315C01315C01315C01315C01315C01315C0131
-      5C012D5202284F012E51012E55052E55052E5101284F012D52022E58002F5902
-      2F59023055002F55033054002E5801315C052D51042F54042F53062E52062C50
-      04284C00284C002649003054082B4F03274A00274A00284C00294D002B4F022C
-      50042B52042B52022A51012B50002A4F002A4F002C4E012C4E01264802254701
-      2648022B4B042E4F042C50042A4E022A4E022C47052B47052843032B47052A46
-      042F4C072B47052C46062C47052C47052C47052C47052C47052C47052C47052C
-      4705243F002540002642002844022A46042A46042B47052A4702294805294805
-      2847042945032844022642002540002540002746032847022948032847042746
-      0327430126410125400027430128440227430128450028450027430128440227
-      4301284402284402284402284402284402284402284402284402264000264000
-      264000253F00253F002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      00002E5402345B062E55003156002F56012C53002E55003054002C56002C5500
-      2F56002E55002E56002E58003461003B6B05436D16426C17498B444DA35577A7
-      77F1FCFAFFFEFDB6D7BC469846478A45468C4545903A4AA35454A868C2E6C8FF
-      FEFFF7FFFFB3DAC14899544AA35348A453549966B6CDB7FEFAFFF6FEED459853
-      3B89363679243885294B985465BB7BFDFEF5FFFAFFF6FFFAAAD5AA57A7663991
-      45366A16386401407506387826469B476CAC82DBF9E6FFF6FCFEFDFFB3E2BB46
-      B7733BB16852A763B3D4B1F8FEF9A3BAAB2274292C771542730B366500335B03
-      315C013361012E58012D590039650232610032690251853879A877F2FFF797BB
-      A3367826397A252D74173169003A64053664013A630131600334620938761851
-      8636478A45588D54D3E8D9F9FEFF73B378498A4549772F387618316003315C01
-      315A092E5500336200275A00376B184787277AAC84FEFAFFCAE4D6478A473B79
-      2539691730680142690730680153832A478A4757975666A468D4E8DBEFFFFD8D
-      C69942B56578BE96E5FFF1FFFBFDF7FFF87BAB87478B44469846489855389246
-      529C6289C799F4FFFDFEF6FFF1FFF357A97552963F377717346A09417A174F7B
-      1E51842843913A57A66749A45568B97AECFFFBFEF4FFA9E5C362C097F6FFFCFE
-      F9FFFFFEFAF1FEF667BB8557A7662D8024336A03264F00254C002B58012D5801
-      2D58012D58012E5A012D59002D59002E59023054003362003C75184C791C4588
-      276B9467FFFBFA98B9A42D86363B79253B79253161013462023A630129660041
-      750A458C536AA578C7DFBFFEFDFFFAFFFE87B688388934377B282A68142C5B05
-      2659002B5A002A51032B4E043159073462023054003055002F56002F56002D55
-      032D54062C55042A53022D58012D56012E55002D57002E58002E58002D57002C
-      5500315B032950002F5902345F042F56002E55002F59012C56002F59012D5900
-      2D59002D59002D59002F59012E5800305A022B54002E5A002D59002851002D59
-      002E5A00254D002D5801315A052A4D032B4F022E58012C56002F5503335A052C
-      54023054002D57002D59002F59012F56013054022F56012D5801315C012F5901
-      2F5901315B032E58012D56012D56012E58012F59022A52002C55002A51013155
-      01325B063155012E58012F55033155013054002F56012F56012E52002B4D0029
-      4D002F56012E55002E55002F56012F55032F56002D53012B51002F5902315B03
-      2C54022C55002A5200284F012D56012A51012D55032E55002B52042A4E022C50
-      042E54082F56012C54022C56002C56002C56002C56002C56002C56002C56002C
-      56002C5101284F012E51012D54042D54042E5101284F012C51012E55002D5700
-      2E55002A53002F56012B53012A51032B5204284F012B50002C51012C50032D51
-      042A4E01284C00274A00305408294D01264900274902284C00274B00284C0029
-      4D012B4F032B4F032A4E02284C00294D01294D01284C00284C00264801244600
-      2648022B4C012D4E04294D01274902274A002C48022845002946012744002B49
-      022B49022B490228440028440228440228440228440228440228440228440228
-      4402254000264101264200274301274301284402284402274301254401254401
-      2844022844022844022844022641012641012743012743012844022844022844
-      0227430126410125400026410126420026420026420026420026420026420026
-      4101264200264200264200264200264200264200264200264200264000264000
-      264000253E00253E002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000254A02264906234401264802284C00274E00284D03264801294C022E5107
-      2E4E0D294A07264802264B012A53002B55002B65004E791E43862A3B923A8BC6
-      99FFFFFBFDFEF486B58729942037720A377616308025478E2D489A528EC898FC
-      F6F7FFFDFFEDFFF245AB7444B46748A45344A965F6FFF4FEFAFFB2CCBA2E8224
-      3B7A244F7A1F4587282D873439A552C5DACBFFFDFFFFFFF1B6D7BC458E504997
-      573B79273A6B0346841A45902E3B904579B789ECFFFCFFFBFFFFFAF968A67613
-      A547478D513D92486B9566FEFFFBE5F6F2487732316C0A436A04315D002E5500
-      325A08315B062950002A5302385D073765023D6A0343773184A977FBFFF49DB3
-      962F68132B6713316902245206274B00264D0129510028520027570033630A3B
-      7925548539517B44C9E6D6F7FEF963A368397927376B182063022F59012A5000
-      264F04274E00335C012C650235740639821B78A26DFDFAF6C5E0BF3080232D75
-      152A6913255B023A65004F842738782653963A52974798D6A8EAFFFDF2FFFDA9
-      D5AE47B66649AC748FCFACFFFDFFFDFAFFDBF8E1539C6446913B3A91393A9336
-      4498466DAC84F4FEF8FFFBFDF5FFF96BAD8352973C478727397517426E154F79
-      2145883746994449A45544B5658AD4A4EAFFFBFCFBFF88D4A48AD4A4FDFFFEFF
-      FEF9FDFFF3C8E5D63F925E4CA2542D74172B55002C5600265108275000295000
-      274F01264D01274D01284F01285100284F00295300336200306309436C174486
-      2768A366FEFDFF88AB91217527307415387618305C03335C0139650234690251
-      842A498D5278B785F4FFEBFFFEFFF4FEED498A452E81252D6813265A00245A01
-      2B5600285500294D01284C002955022B55002B5500295000274E00274D012C51
-      012B5100284C002648012A54012A51012A4F002A52002D56012C55002A520029
-      50022C5004224700294F03345A082C5003274A002B4F03295002264900284C00
-      2A4E02264C00264B01284B01284C002A4E01264C002B5105285100244B002B52
-      042C5107274E00315B06325A08254A00274D012A5200264D00284F012B520226
-      4C002A50042A4E022A4B00284C00284C00284F01284C002A4B00264C00254B00
-      254B002A4D03284C00274B00284C002C5003275000264E00295002294D00264C
-      002C5101284E022950002C50032D50002A4F002A4F00264B01284C00294D0127
-      4E00295002284F00284F01284F01274E00274D01284F01284B013054082F5208
-      2C50032C50032A4D03284C002C50042A4E022A4E01295100284C00274B002A4E
-      022C50042951002449002A4E022A4E022A4E022A4E022A4E022A4E022A4E022A
-      4E022D5000264E002B50002E55052E55052B5000264E002D50003155012C5200
-      284F00295000284F00295000284F01264B01264D00284C00284C00284B012A4E
-      012A4F00274B00264802305408284C00264801264802274B00274B00274A0027
-      4A00274B00274A00274A00264801274902274A00274A00284C00274902244600
-      2648012A4B012B4C012848012446002446002944022641012240002641012844
-      02284702274301264200253E00253E00253E00253E00253E00253E00253E0025
-      3E00264101264200264200274301264200254000264101254000243F00254000
-      2540002541002642002844022743012642002240002341002642002642002743
-      01264200234100224000223F00243F00254000264101264101254000243F0022
-      3F00254000254000254000254000254000254000254000254000264000264000
-      263F01253E00253E00263F01264000264000253E00253E00253E00253E00253E
-      00253E00253E00253E0026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274B00264802264704224201244600254700264801264801274E00254A00
-      254C00234A00254B032C51092C500330540831610138811A458728478D50F3F4
-      F2FEFDFFF4FFEB3F925B3882183772093B6A03417509478628498A4567A577E3
-      FFF1F7FFFEFFFAFB85D5A040BF6A44AA6288CCA3FFFAF9F1FFFE67A366397927
-      3D6C0A386917427A1546842A51964668BB87FDFFF9FBFFFFFCFAF96DAC84439A
-      444E791E2E8125468837439139498A45B6D9C5FEFAFFFDFEFAAEE4B945974544
-      923B37893648893444923AAFE2BCFCFFFB889D843B79272C7207335C012B5A00
-      335C0139630B2A51012E55003263013361012A720744841A84A977F5FFF6A7BA
-      AB2D76142A7207436905265106254D062B5207284E022850002E5A0132610040
-      7409508528478B44E7FDFBFBFFFA6E956838811B357307206302315B03244A02
-      244D022651082451021F62012C650338771767A367FFFDFCB6D7BC3C85292D75
-      15316A012E6502326307437A1746923A37904786B686EEFFF2FCFAFAFAFFFEDD
-      E1E645B56741B66746A866D4F8DAFFFEFEFCEEFAD6E9DA499B533B9E423B9F40
-      35A75344AA63E5FFF1FFF8FFFBFEF587CBA24A9D3A4693385585373989363A90
-      2A3CA04155A76657AA76B4CDB9DCF7E7FFFFF9F6FEED67BA86A6E6C3ECFDF2F1
-      FFFEFFFFFB97C8A256B26B398936326B092659012A4F002F4C032752012E5200
-      24480234520B2547002E59002E5402285100304E03415D032261053776164485
-      2965A268F1FFFBA5BBA83976163A7A28488836265E0B325C07325E033B792547
-      933B559756CFEED1FFFAFFFBFFFE98C8A438862839821C2B6500325A08295002
-      274F012B5202264B01254C00264B01294C02274D012950022B5202264C002B52
-      042B5204244B00285002284E02264E002B4F032C5107305408284E02274A0026
-      4C00274F01264C002A5200325A082A5300274E00264B01264C04284F01274D01
-      264D01274D01264D01274D01264C00274D01284C00294D00254A00294E062B52
-      02264C00284F00325B062E56042951032A50042D5208264B03244900284F0326
-      4B01284E02284E02274D01274D01264C00264C00264C00264C00274C04274A00
-      234A00274D01264D02214B00274D01285100264A04284F012850022852002851
-      00295000274E02254A04274D01274D01274D01274D01274D01274D01274D0127
-      4D012750002851002950022A5103284E02274C02294C02294C022A5200284F00
-      295002274E00274D01284F01264C00264C00274C02264D00274E00274D01264B
-      01274D01294D01274A00274D01264C00254C00254C00274D01284E02264C0025
-      4C00264C00274D01284F002E55072D54042B52022850002950022E55052D5404
-      2A5302285002295002274E00274E00284F01284E02284C00274A00284B012A50
-      042D53072B4F03274B002F56002A4E01284C00284C00264801264801284A0324
-      4600274B00274A00274A00254700244600254701264802254700284402274603
-      284704284704284402264200264101264101254401254000243F00253E02263F
-      01264102274203264004264000264000274002253E00253E00263F0126400025
-      3F00233E00233E00233E00243F00253E00253E00233E00243F00233E00253E00
-      264000284202284202274101264000254001274002263F012540012945032A46
-      04254001253E00274101233E00254001264101254000243F00243F0025400126
-      4101233E00233E00233E00233E00233E00233E00233E00233E00274200264000
-      2640002540002540002642002844022744002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274A00264802284A03294908284A03284A04294D01284C00234C01214901
-      2B4E04274F01284F00274E002F4F023159073A640038811A45863777A576F5FA
-      F9FFFFFFD0E3CE478A4739821C346902336101316A01437918458736589857B1
-      E2BCFEFAFFFAFFFDBEF2CD52C27554B674D0F1CFFDFFFFE8EAF552964938751A
-      366802326000386D0C44831D46933855A766DDF7E7FDF9F8FFFEFF9BD0B53C90
-      4846883644862748883649933B549A65DBFAE5FFF9FEF6FFF57BB8863A914738
-      78263C85294487263B792587B587F9FEFCC7D8CA4678323672063462092D5801
-      2F5C0039630B2851002E55002B58013B640230741546852982AA7AF2FEFEB5CE
-      BA377B242C72072E5C032D5B08215100284B01274E002E51012D5900385E0440
-      79163A85293A9147E7FEF9FBFFF977A2693883194273093361012B56002D5503
-      2D51052446002D5503316902356B0A427916519C64FFFFFBC7DACB45772F3975
-      1737740628730737751B488F2E47923C64B97BD7F6D9FDFEFFFFFFFFF4F9F7F0
-      FFF846B4663CB26946A96375B27AEDFEF3FFFEFEEDFDF6AFE4BC46995436A750
-      36A75047A963CAF1D8FFFFFEFDFEFAB6D8C753A766399E423CA04047A3525198
-      4857A7669CDAB6EDFDF2FBFFF9F8FFF9F5FFF8E4FEF059BA88BBE7D0FFFFFAFC
-      FEFEF3FFF986BD963B90452C76182B64012A5401285200254A022A4E01224600
-      324E12294E062C50042343022951002B52072E4F053E5C032E72073B79254287
-      2668A26BF8FFF6C5D9CD387B2639761646821D2965012C6503366A1643883748
-      923A96C9A3EEFDF5F9F9FFEDFFF276A5773784282C72072B64022A5200254B00
-      2A5101295002264C00274D01274C02274C02284F012950002A5101274E002B52
-      042A5103244B002A5302274E022750002A51032C52062C5206294F03274D0127
-      4E00274D01274E002C54023159072C5500295002294E04274C04274E00254D00
-      264D00264E00274E00264D00274D01264D002B5204294E042950022A51032950
-      00264D00295002325A08285100234901264C00284F04254B03274C02284F0326
-      5000284E02284E02274D01264C00274E00284F01284F01284F01294F03294D01
-      264E00294F03284F01254C00274E00275000274C04264C00254C01274F012950
-      02274E00264C00274D05274D01274D01274D01274D01274D01274D01274D0127
-      4D01274E00264D00254C00244B00244B00244900244900294C02285200284E02
-      284E02274D01295100295002295002284F032850022750002851002851002750
-      00275000285100295000285100274E00274D01284F01275000285100284F0127
-      4D01294E04284F002C53032D55032E5505294F03284F012950002B52042B5204
-      285002274F01274E00274E00264D00254C002B4F02284C00274B00284C002A4E
-      022D4F022A4E01284C002D51042A4E012A4E012A4E01274A00264802284A0426
-      4801294C02284B01274A00264801254700264801264801264801274603284704
-      254603274603274603284402284402274202284500264101253E00243D00263F
-      01263F01253E00243E02253E00263F01263F01253E00253E00263F01253E0025
-      3E00243F00233E00243D00253E00263F01264000264000264000243F00243F00
-      254000264101274202264101264101254000253E00253E00243F002641012742
-      02243F00253E00264000253E00243D00264000264000243D00243D00253E0024
-      3D00233E00233E00233E00233E00233E00233E00233E00233E00243F00254000
-      254000243F00254000243F002641012844022640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264802264900294B04264900254800294D01254C00274E00264D00264D01
-      2952012A4E012753002A54002B5500305D00326B0844831B478A45B0CDACF3FF
-      FEFFFDFC95BA98378B333A7717346100316101396502397306488737488E5185
-      BC95FFFEFFF9FFFEF6FEF36ABB8467BA86FFFDF5ECFFFCA9C9B13989362F7216
-      316B002B67023A6B00427309478E2E499952B1DBC4FFFFF9FCFEFED5F5DC488E
-      512E843647923C4689444497486AAC82FCFDF9FFFEFFE4FAE83C915D3C91473A
-      77173776164377193C7A286C9568D6E9DAEDFEF3558C55407917387618235A00
-      2E5A01305701254D00305B002C5902416C153B792748862C76A168F5FFFEB7D6
-      B93979272E72073362003268042659012C59022D59003355012D59003B640952
-      83274B9F39498D52FBFFFAFBFEF577A8762C7E253A7618315C012D59002C5500
-      3048002D490337590239650032690237792768A468FFFFFBE6FCE9488A434687
-      2B46821D46841A4785273A923855A864B7E6C6EBFEFBFAFCFDFFFCFEFBFEFFF5
-      FFF953C47446B46638A7514B985499B9A6ECFFFCF5FFFEFBFEFC97BE8A55B168
-      38A85048B7739BDBB8EBFFFAFEFEFEF1F3F346B77356B2694CA25438A85068BA
-      86D8F6DDFDFFF7FDFFFFFBFEFCFEFFFDF8FBFFF5FFFE9FCFB7D6F9E5FDFEFCFF
-      FDFFDCF8E568A6762B87362B6810325B002D58012B5A002851002B4F032E5206
-      2C5107204500345E062D58013055052C510734520B3D5D042C76163776164688
-      367CB785F6FFFAC7D8CB38811A2A7305316C0A2C65033C811A38852952944565
-      B169DAF9E4FAFFF6FDFFFCB4D9C54A89442F7F262965003362002B5400295002
-      2952002E5505295000274E00274E00264C00274E00284F002B5202274E00264D
-      00295002274D012A5101264F00275000285002294F03264E00284F00264F0025
-      4D00284F01274D012A52002C55002A5200264C00284E02274C02284F002C5206
-      2B5204285200295000285002295002284F012A51052C5206284F00264D002950
-      00284F01295000325A08284F00264C002A4E01284D03274C022A5000284F0029
-      5000254C00254C00264D01264E00264E00285002274F01285002295002274D01
-      275000294F03295002264E00264C00264E00294F03274D01264E002750002951
-      002B52042B5204284E0227500027500027500027500027500027500027500027
-      50002B52042950022850022850022850022850022950022B5204275000285002
-      285002284F00284F01254C01254C01254D00295000295002284E02284F01274E
-      00284F012950022B5204274D01264D00264F00274F01274D01264C00274E0027
-      5000295000284F01294F032A52042A5204284F00274D01295100284F01295002
-      275000284F002950002950002950002851002C4E01274B00274A00274A00264A
-      00294B00284C00284C00274D01264C002A4E022B4F02274B00264A00284B0127
-      4902284B01274A00264900274902264801254700254701254701264802264802
-      254701254701274603294503274301264101284402264101263F01253E002640
-      00253F00243D00243D01243D01263F01264000264000253F00254000243F0024
-      3E02243D00243D00243D00253E00263F01264000264000264000253E00253E00
-      253E00264000284202264000263F01263F01253E00233E00233E002540002540
-      00243F00233E00253E00253E00253E00264000264000253E00253E00243D0024
-      3D00264000264000264000264000264000264000264000264000254001254001
-      243F00233E002540012540002540002540002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264D00274D01264801254603264802274902264C00254A02224C002D5406
-      2F5404274E002D59003C6B04326804296500397209478628459854E0F0DFF2FE
-      FEF3FFF066A3692F7F24326307346100335B0333620034680438872646913B57
-      A863FFFAF9FDFFFFFFFFF99DCFB79AD5A8FDFEFAEAFFFB9BB9A62D8024297309
-      2A65033168013369053772093A85294598546AB986FFFFFAFEFDFFFBFFF777B3
-      77279A4B48A45366BA7A53B16AA4C8AAFFFFFEFEFFFDA9D8B82E88353791453B
-      792731690439720944883368A369A6C7B2EDFFFE97C9A1457731458735275F0C
-      2659012756002750003C650A38620A4F8427458728387A216C946AF4FEFEB5D9
-      C32076282E7318396B1737750433610133610139650C346A092C691339792751
-      963B56A867548B52FFFFFBFFF7F497BE8A3B923A2F80232C6713316408285002
-      2D5100375C00385B002D650038761838883565A577FFFFFFF5FFF3479B533989
-      363689343B902E3A933653A767AAD7B6F3FFF9F8FBFFF8F4FFFFFEFFFEFEFEF6
-      F4F363BD994399533B933948A4533D935D9DCFB7EDFEF1FFFEFFEEFEF395C8A3
-      44A96549B77787D2A6E5FFF9FEFAFFFEFAFF6CC99646B77353B57398D6A8D7F7
-      E6FFFEFFFEFAFFFEFBFDE5FEFAFCFEFFFFFAFFF2FEFFF4FCFCFCFFFDFEF6F6F2
-      FFFDBDEFCF3F935D2277272C6810315C01336101326804265901285100244A02
-      1F5000326902255A003C6D0B3864092A540032530939650C47902E46772D4989
-      378CC79BF9FFFACAE4D62F7F242E7616346A092A73054CA03A3B904575B27AAE
-      E3BBFDFEFAFAFFFFEDFEF377AC853B89352D7106326A053763002C5500295000
-      2C55002D55032D5503295002274E00264E002950002950002C5303284F01284F
-      01284F00264D002D5404254C00295000285100264C00234A00284F01274F0126
-      4E002A51032A53002A5300295002295000274E00274D01264D00274F01305505
-      2C56032B5100295300295000264E00274E00244901295100295000274D012950
-      002A52002C56002F59022A540029530028510027500027500028500227500028
-      5100274E00274E00284F01284F00295000295000284F01295002274F01264B01
-      274F01284F01284E02285000274D01284F00295000295002274F012A52002E58
-      002D55032A5200264D0029500029500029500029500029500029500029500029
-      5000264D01264C00274E00295000284F00275000285100264E00295002284F00
-      295002284F00284E02274E00264C00274D01295000284F01274D01274E00254E
-      00264E002850022A5302274D01274D01274E00274E00274D01274D01274D0127
-      4E00284E02274D01254C00285200275000264E00264D00284F00274E00284F01
-      2950002A51012A52002A52002A5101295201284C00284C00284C00284C00254A
-      00254A00254B00284C00264801264802294D002A4E01274A00264801284C0027
-      4A00274B00274B00274A00274A00264801244600234500234401264801254700
-      2547002446002645002645022443002341002540002540002641012641012642
-      00254100254000233E0025400127420226410125400025400027420225400024
-      3F00243F00243F00243D00253E00253E00253E00253E00243D00253E00253E00
-      253E00253E00263F01253E00243D00243D00254000243F00233E00243F002540
-      00254000243F00233E00243D00264000264000264000253F00253E00253F0026
-      4000254000254000254000254000254000254000254000254000254000243F00
-      2540002540002540002540002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      00002C5500284F00254A002648012A4E022A51012C56002C5500244B00275700
-      2E58002B4F022D59003B6A03326C073773073A8628458B456AA676FEF6F6F0FE
-      FCDFF2DF4C8C5139821C396409346001305C0332610032620247852750974748
-      A256D5EADBFFFEFFFAFFFED8F9E4D6F6DDF8FFFAE2F6F169AE813C8A362A6711
-      2965012E5800315B03326B09397A24569857549A65E6FEE6FAFBFFFFFEFFA7D6
-      B635A75354A76356B57256B987D5F6DBFFF9FAFCFEFE6BAD833C91473A883437
-      6B17426A04387206397A255A965978AD86ECFEF1E0F8E6537A46488C532B6810
-      235E0D2F5B00295100386400365D075084264587364F873676A577F7FFFDB5D9
-      C3477631318225397927436D16316507386917487830448835388A373789363C
-      A04148B67447AE75F2FDFAFFFEFA98D6A63892462D87342076283869172D6814
-      335D053462021D61022E75183A88343D92487ABE95F6FBFEEBFEF557A766529B
-      63499A5537A65047A865B8D9C4F3FFF3FAFFFBF6FFFCC4D9CAFFFEFFFFFBFAF9
-      FFFA91D0A94799583990383B91393A9246478D51A8D5AAF4FFFDF9FEFFDEF1DE
-      84BC9346B77464C097E5FFF0FDFEFAFDFFFF88D5A288D3A5B7E6C6EFFDF2FFFB
-      FCFBF6FFF7F5FBFCFFF5F3FFFFF7FFFDFFF7F79CDAC8FEFEFEF6FEFEFCF8FDEC
-      FFFBB7E6C53C915D2D86372E7715315C01375A043168013066022D57002D5900
-      2659012A63012C660146781A335B14365C14386A16346307449338478A455184
-      3A8EC79AF9FFFDDBE2E53789363D79253878263C8938449A5440945D97C6A5E7
-      FEFAFFFAFDF6FEFEB8E8D0568D563A88343877173469013A62032952002A5200
-      2D55032D55032E5505295000264D01274F012C55002C5402325B062C54022A52
-      002D56012C5402325B062A51032D54042D56052A4E01264D01284F002952012A
-      5103325A08325A082F58032C56002C54022A5101284F00274E00284F012D5900
-      3158022A53022B56002C56002652002A5200274D012D57002C55002950002B56
-      002E59022E5A002D59002F59012C5500284F00274E00274E002950002A51012C
-      55002C55002C55002C55002C55002C55002C55002A52002A5200254C00244B00
-      2B52022A52002A51012E58012A51012C56002C5600284F00264D012950002C56
-      002D56012D56012A510129500029500029500029500029500029500029500029
-      5000274F01284F01274E00284F012951002953002B55002855002950022A5101
-      2C55002B52022A51012950022950002A51012C5402295000284F002A5101284F
-      00284F002950002D5404284F002B53012C55002A53002950002950002A52002A
-      5300295000274D01264D01275000295201274F012A53002D5700274E00284F01
-      2A51012A51012A52002953002A52002A51012A4F002B50002B52042B52042950
-      022950002A4F002B50002648012648012A4E012C5004294C02284B012A4F0028
-      4C00284C00284C00284C00284C00284B01264801254700244600294A00274A00
-      274A00274A002648012547012446002446002642002743012844022844022844
-      022642002540002640002A46042B470529450325400025400028440229450327
-      4301274301274202274202264101254000254000243F00243F00264000254000
-      2540002641012641012641012540002640002844022641012540002540002641
-      0128440226410125400025400026420028440228440226410126410126410127
-      4301264200264200264200264200264200264200264200264200264200264200
-      2743012743012642002642002843012742002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000335D062D5700264C00295200345A08335D063964093A660932620A386308
-      3E6A053F69044269073068013E6C0C478E2D53963B559756A7C9ABFFFCFEF7FF
-      FEA6D7B7498B4440791750791D4274083261003964033B6C0A618E3764B36A56
-      B16CA9D8B8FFFCFEF4FFFFFAFEF8FCFFFAF2FDFBC5DACB44AC755597563C7A26
-      37771439630B436D16628F3965A35573B17B55B673C4E5CAFCFEFEFDFAFCD9F9
-      E856B88A53C37646B77359A875EEFFF2FFFDFFF1FFF8519C6446A7643A8A3728
-      66124E7A1D47902E2D812367A3556AA578C8E4D7F4FFF3859E82489A52378937
-      3B7828427408346301335F003A660952833955965865A35598C7A6F2FFFCC8D9
-      CE4598544498464B8947519548468944588546549857569857458C543C914658
-      A76456B9875FBF97E5FFF9F7FFFFA8E5C146B67647AC7546AC75498B44468946
-      37792738771739821B30802546995555BA87C1E1BEFFFAFFE6FDF93BBA833BBC
-      8361BE9786C9A4B0E5BAFDFEF5FDFEFAF7FFF8B8E8D09CBCA3FDFEFAFEFEFEF5
-      FFFDABD8B751964547933B4AA256449A523984285C8748A5C8B4E5F7F0FDFFF9
-      E9FDEA87D4A165BD99E5FFF1FDFFF9F5FFFFA8E4C6E3FDE6FBFFFAFAFAFFF7F9
-      FFFAFFFEDFEDE7BEF0CEFFFBFFFFFCFFD9F8E33BCB909FDCC8EAFFFCFFFAFFFE
-      FDFFB4E7C5589A6748985545852B416B063A6302306400305B00264C042D5404
-      548638568638558B56527B4877A16AC7DFBF558747346A0945933C5596586392
-      5498C8A4F9FAFEDBE2E555A76648995457A667469A52549A6578AD82D7EADBFB
-      FFFFFEFEFEEAFFFC89CAA353996445933C518527336200366500315B04345E07
-      335D06345E07325B062A5300284F012A5302345F042D5700355F07345E062E58
-      00305B00315B03345E062F5A00325B06325A082D56012C56002C56002E580132
-      5A08315808355F07345F04345E06345E06315B032A5200274E002B5500345E06
-      356005305A02345E06326209375E083662092C5600345D08345F042F5901315E
-      01305C012C58002D5900326000325C042B5500294F032D5404305C03315B0336
-      6207315C01325D02315C01315C01315C01315C012F59012E5800285100274E02
-      325B062C55002D57003560052D5900315C01345E062E58012A51012950002C54
-      02315907355F07315B03315C01315C01315C01315C01315C01315C01315C0131
-      5C012E56042B5204274E02254D002952012D5801305C03345F04315C01335C07
-      335B093159072D5700285000295002295002345B062F56012F5601335A052F55
-      032C52002C5402325B062D5700315907325B0A305A072D56012C56002E570230
-      5A072B5202294F03284F002C55042E5A012F59022D56012E58012B56002D5700
-      2E58012E5A012D59002D59002E58002E58003055002F56013159073159072F56
-      013054002F56012D5601284C00284C002C50032E51072C52002C52002E55002C
-      52002D51052D51052C50042C50032C50032A4E02284C00274B002C4E012C4E01
-      2B4F022B4F032A4E02294C02284B01264B032C48022B48032A47022A46042844
-      02254000263F01263F012B48032A47022945032540002540002844022B48032A
-      47022B48032B48032A47022945032743012743012642002641012B47052B4705
-      284704284704274603284704284402284402284402274301254000243F002641
-      012A460428440225400026420028440229450329450328440227430127430128
-      4402264200264200264200264200264200264200264200264200274301284402
-      2744002845002844022844022642002642002540002540002540002540002540
-      0025400025400025400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      00003A650A2B5400254B002D55033964093964093765023C6A072E5A07315E01
-      3A62033B64033A63012B5A002C671353963B56975953A864C7F1D8FFFEFEFEFF
-      F878B686398A353A761842831D4279162C66013D6A03426E1361903A68A36955
-      A8647ABF94E3FFF2F6F9FEFDFFFEFEFDFFFFFFF998CAA23BB2675597563A8529
-      4379163B630B3964095184284F873658985766BA7A85CCA1FAFFFFFCFBFFEEFE
-      F387CBA239C88F3DBA8284CBA3F9FFF9FFFDFCC3E8C842925D4CA3534685292C
-      77154C7B1E50943D48923A66A46868A678A5C9B3FFFFF3BBD6BC509B63469A52
-      3C7A2846841A386C01396500507A1B50873865A35567A367B0CDACF7FFFFC8D9
-      CB559C644CA156469A52509B635797566C966776A57787B58698BC98A6C8AAB4
-      E6C6D0F1CEC9F2D7F6FEFDFEFAFFB9E7D162C0975AB9873EBA864AA256369146
-      2274273A86283784293988376AA874A0DAC8E0EFE1FFF8FEE5FFF13ACA8F6CC8
-      979FDAC6DDF8E8F9FFFAFFFEFFFAFDF4B7F9D665BE9755B888EEFEF3FFFEFFF1
-      F9FFC8E4D7478C532B87344498573D7827437A1738751A65A3679FCFB7D9F9E8
-      F2FEF2DAF7E7B6DAC2E3F8F0FFFEFAFEFFFBFBFEFCF7FFFDFEFEFEFDFEFADBF7
-      E489DBB086CCA4DAF9E4FFFAFFFEFEFEBAFAD73DC7916AC996F7FFF6FFFBFFFF
-      FEFFB1E3BB559C64469954468934396C0A406A053461002E5A012B52042B5605
-      5F8E3843782F568D54B6D8BAD5F6DB889E824689443D78274AA35366A5675397
-      5697BB97FFFEFFF5FAF857B57547A96355BA8645AC7379BF97C0E6C8FEFFFDFE
-      FDFFF9FFFABBE7D057A978469A52488836508426315D023965023964093A650A
-      3A650A345E06345E062C5600284F002D5704315C012D5700325E05305C012E58
-      00315D00315C01315B032E58002E5902305A022D59002C56002B55002D580133
-      5F042E5801345E06345E06325D02345E06345F042C55002950022D590039650C
-      386308345D023262093A640C3262093A650A315C01345E07345F04315D003461
-      00335F02315D042F5B02346100335D052B56002A5101325B06346007335D0537
-      65022D5900305C01315C01315C01315C01315C012F5B002E5A01284F00275000
-      345D082E5902315D003964092E5A00315B0339630B3560052C55002850002E55
-      07325A08345F04346202345E06345E06345E06345E06345E06345E06345E0634
-      5E062B5204274D01244B00244C002953002E5902305B00315C01345E06345E07
-      3159072F59022B5202274E00284E02295000305C032D59002E5A01335F042D58
-      012953002A5400305C032E5A01315B03335E03315C012D59002D59002F590132
-      5D022E55072A5200284F002E5604315A05325A082E58012E5800315C01315C01
-      315C01305C01305C01305C01315C01315C013155032D57002E5A012F59022E54
-      023054023156003059002B4D06294C022C50032D50062C51012D51042E54022C
-      51012C50042C50042D51042D51042B4F022A4E02284C00274A002E51012E5003
-      2B4F022B4F022A4E02294D01294C02294C022B49022B49022A47022A46042641
-      01243F0026400026400028470428470229450326410126410127430129460128
-      44022B47052B47052B47052945032844022844022844022743012B48032B4705
-      2847042746032746032746032844022743012845002844022641012540002641
-      012A470229450325400026420028440228440227430128440226420026420028
-      4402284402284402284402284402284402284402284402284402264200284402
-      2844022844022844022642002540002540002642002642002642002642002642
-      0026420026420026420026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      00003964092951002245022C5500345E06315C01305900335B03225B002E5800
-      325D023765023A630139630B39792765A35556985757A975EFFCF4FFFEFFFAFE
-      F3559B663A86283574062E66012965002558003E63033E5C0344783257864748
-      8C5157A975C8F3D8FEFAFFF5FFFEFBFFFFFFFFFB65A577279A4B2B8736226103
-      3169042D59002D59003B6B0B376B1858985757A66756A975EAF6FCFFFAFFFAFF
-      FEA5E5C13CC8923AC990BBE7D0FDFEF5FDFEFAA5BBA9458C532F802329761522
-      60023956062E75182D7515478A45488E5288A987FAF6F5F5FFF93F935D478A47
-      255C0D356C09376600315B04436D16457731498A45568D5498B8A5F5FFFFC5D9
-      CC3F935D379047478D50479853488E5268A676A8C7B8DAF8E5FBFFFAF9FFFAFB
-      FFFFFEFFFDF4FDFFFDF7FCFFFAFFF8FFF9DCF6E8C0F2D09AD0B346A9653F935D
-      39914544923B48923A65A355B0D4B0E7FEFA9ADBB4F2FBFFF9FFFAB7E6C6DEEC
-      E6FEFAFFF6FFFCF9F9FFFCFBFDE5EDE657B7883DCA913AC990DAF8E5F2F3EFF7
-      F9FFCAF2D93A91472D8833478A4539691A3965023971062B7515468F516C946A
-      A8C7AAF4F5F3F9FEFFF7FAFFFFFFFFFFF9FFF1F9FFFDF5FFFEEEF9A7D5B855BA
-      8646B77378BE95E7FEF9F3F9FEFEF9FA87DCB03CBB843BBA83FFFEF4E3F7F2FA
-      FFFDA7D5AB3E905F2A88342D7515315C013B6402346003305C012D5801426D16
-      39792752863879AD85E5FBE9A8C8A93858293779273A77173B8936498A455985
-      4896BB9BFCFEFFF7F9F944AA6337A6543BB16849AB75A7E4C2EDFEF3FFFEFAFC
-      FAF9E6FCE983BD943E915D3C91473B79273A640C305701305D002E5800315B03
-      2E59002C55002F59012A52002A51033259092F59022953002E59022E59022B56
-      002F5A002F59012C56002B55002A54012D57002D59002A5101284F032953002E
-      5A012C5600305B002F59022A54002E5803315C012C56002A5101295201346100
-      305C002A54012D5900295A002D5900305C012E5800315C012F59022E58013461
-      00315D00305C00315C01305C01315B03285200284F002C55002D59002F59012D
-      59002A54002D58012D58012D59002E5A012D59002E5A012E5902295000275000
-      325A082D59002E5A01345E062B56002C5500325C042E58002A51012950002B52
-      042C55002F59012E5A012C55002C55002C55002C55002C55002C55002C55002C
-      5500285002264E00284F002C5500315B03346003356104315C01284F01295000
-      2A5400295201274F01264D012A51012E56042D59002B56002E5801325D022C56
-      002950022851002D59002C54022C56002D59002D59002C55002A52002B54002E
-      5A012E55052950002950002C5402325A082F59012C55002A52002E57022C5500
-      2C55002A54002A54002B55002C55002C55002C55002C54022953002A52002A52
-      002E55002E55002F5601274D01244802264C00284D032850002A52002B550028
-      4D03294D002A4E012B4F022B4F03284C00274A002648012446002C4E012A4E01
-      294D00284C00284C00294A00294A002648012744002A47022645022645022443
-      0025410026420028450026440328470428440226420026420028440228440226
-      4101274101264101264101264200264200264200264200264200294402284402
-      2743012642002743012642002642002742002844022743012540002340012341
-      0029460128440225400025400026420028440228440227430126420026420026
-      4200284402284402284402284402284402284402284402284402264000254000
-      264200274301264101264101254000233E002642002642002642002642002642
-      0026420026420026420026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      00003D6906255100255000284F003A640C244E002852002C5004295002264D01
-      2A5204265200395C022E58002A691363A35748984585BD92FEFDFFFFFAFCD8F5
-      DB4499552D81234268043158082D52022E51012B50002C56003263073B741751
-      922C47A4538BC699F6FFF2FFFBFFFCFAFFC7F1D84BA3573C86283E6C0C305B00
-      2B5502294D00274A00295300436D1565A3573B902E5496479CDAB6FFFFFAFBFA
-      FEFCF6F754B5733EC067D9E2E5FDF9F8F4FFF366A36B398A353A74073864012F
-      59012F56012B590035630A427817458728498B43D5F6DBFFFDFF84A977457731
-      296501326902355F072E55003B640340740945862A47872799BA98FEFBF7DBE2
-      E53C923A2C85364892383A902C6C9667D9E2E6FEFFFAF3FFEDE7FBE8BFF2CDBE
-      F1CFEAFFFCF6FFF5FEFFFDFFFBFFFEF6FFF7FAFFFAFBFFFDFEFAE5FBE8D0E6CA
-      A5BBA8A5BBA9D1E5CEF5FFF3C9F2D79CDAB69ADAB7F7FFFEFEF6FDFFFFFFFEFD
-      FFFEFEFEFFFFFAF4FEEE8BC89646A86635A8514AA35456B474BFF1CFFDFFF7FF
-      FEFEE3FDE6498B442B8736468837396C0B315C0132620A39630B38730A407916
-      46883648A35466BA796CCA94E5FFF1FEFEFEF7FFFF89D4A13DC0693DC1673DBF
-      6A44B565A6D8B6FEF6FDFFFFFFEDFEF353C37552C27447B777FFFEF4FDFFF9F2
-      FFFD8AD4A43990462E76162D64013A5708284A031D4C002D5900396403377406
-      2F7518517B46D8E9DCF3FFF3507B482D75153B6A03366B034076054486274B89
-      479AC8A4F1FFF8FFFEFE36A75041B66746AD7493D0ACEDFEF3FFFAF9FFFEFEF1
-      FFFE88D5A249A766399F403886282C64003D6309234A00275306285100285100
-      284F00274E00274D01284E022B52042E55052E55052A5101274E00274E00284F
-      012B52042A5103284E0229500029500029500029500029500029500029500029
-      50002950002950002950002950002950002950002950002950002A4E012A4E01
-      2A4E012A4E012A4E012A4E012A4E012A4E012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      50002950022B5204295100264B012B5301325A082E5801284F00275000295201
-      284F00274E002950003159072E56042950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000274E00284F01274E002950022B52042A5103274D01244A00284C00284C00
-      284C00284C00284C00284C00284C00284C002A4E022A4E022A4E022A4E022A4E
-      022A4E022A4E022A4E022A4E012A4E012A4E012A4E012A4E012A4E012A4E012A
-      4E01274D01274D01274D01274D01274D01274D01274D01274D01295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      00295000295000295000284C00284C00284C00284C00274A0026480126480226
-      4802274A00274A00274A00264801264802244600244600244600274A00264801
-      2648012645002544012443002342002442012640002640002640002640002640
-      00253E00243D00243D0126400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000274202264101
-      254000233E00233E00233E00243F002540002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      00003E6B0A2B55002E59022D5601396409285100285200274E002D4C01244903
-      285002295000355B033965023B7A2463B26849A455A9D8B8FBFDFDFFF7FEC3E5
-      C749A4552E8125406908355C062C4F002F4F022B4D002C55003460033A6E0A52
-      912946984678B686F6FFF4FDF9FEF8FDFCB7E6C6489A513585283268042A5C00
-      2C56002A4F00284C00285002336108508527488F2E5196468BC699FBFFF9FEFD
-      FFFFF9F968BC863EC067F6F9FFFFFFFEECFCF1598D57308025346B0033610129
-      56003355012F5A00336200447A17448529458837B8D7BAFAFBFFB9D6BC43782F
-      3D76142C6201315D0431550138630239730646872B48902C95BA98FDFEFAEBF8
-      FA4397453A933644923A488944C0E7C7F6FFFFC7DFBC83A87A549759549A6563
-      B26956BB87AAD6B9F9FEFCFFFBFDFBFDFEF5FFFEFFFDFCFFFEF4FEFDFFFAFFFF
-      F8FDFEF4FFFEEDFEF5B7D9C17BBE995FBF97A9D5B6F8FFFCFFFEFFF3FFF2E5FE
-      FAE7FEFAB3D8C478A36A68A3592D873438923847994647AA62A5D6B6FFFDF5FC
-      FDFFEDFEF5448B422D86364887373B6C0A2757002753002A56002B6600356C09
-      3775173A88344CA25456B473C7F1D8FEFAFFF8FEFD88D5A23FBE683BC0693CC1
-      6547B567BFF2CDFEFAFFFFFDFFDBF7E346B7744FC47548B674F4FEEDFFFFFFF4
-      FEFE98C8A43A91472B7517336A03325B002B4F03234D002E5A00366500377209
-      468626639156F3FFF3E3F8EF4877323B821B3E6A053368003B74173885294889
-      449AC9A3F1FFFBFFFDFF51C3763CB2696FC994D9F6E6FFFEFAFCFFFAF4F5FFFE
-      FAFF98D6A853A8644798533A86283A730A2D5900426D16244900275000285100
-      295000274E00264D00274E002950022B52022D55032A5101274E00274E002950
-      022B5204295002284F0129500029500029500029500029500029500029500029
-      50002950002950002950002950002950002950002950002950002A4E012A4E01
-      2A4E012A4E012A4E012A4E012A4E012A4E012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295002295002285000274C022950002E55052C5500284F00284F002A5101
-      295002274E00284F012F56062D54042950022950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F00284F00264D00284F002B52022D54062E55072D5406284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C002A4E012A4E012A4E012A4E012A4E012A4E012A4E012A
-      4E01274E00274E00274E00274E00274E00274E00274E00274E00295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      00295000295000295000294D01284C00284C00284C00284C0026490026480126
-      4802274A00274A00274A00274902264801244600244600244600274A00264801
-      2648012747002645022743012443002442012640002640002640002640002640
-      00263F01253E00243D0026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000274202264101
-      264101243F00243F00243F00243F002540002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000335F062B5500315C012E5801345E06274E00284F00274E002C5300265003
-      285204265100375B014268043C792965A35753A864D7F5DCFFFEFFFFFBFD98C7
-      A64998472E75153965002D58012C52002C4F002C4E012C51012B5801346A094F
-      8427499847549B63E7FBE8FFFAFFFEFDFFB8D9C4488D542D8024326902265A00
-      2A51012A4C00264D002950002956003D6C0941882846913D68A676EDFDF2FFFE
-      FFFFFFF99CD5A853C474FEFDFFFDFEFAD8F7DC468946317F27326B093561022B
-      55002E4E01285500315D023F710B45851B47893895BA98FAFFFEE3FFF1578647
-      4587282A66013460012B590039650842750646852747902E98BC98FDFEFAFAFF
-      FE4699553CA04153943E8AAA91EEFDFFC8D9CC6C966746994447A25335A95043
-      B56840C06797D7A9FBFFFAF3F6FBD8F7DC9ADAB7BFF1CFDAF9E4FAFFFEF5FFF9
-      E3FDE6C8E6D397C7A366A77647AC7558B987B6E5C5F0FFFBFAFEFFE5FFF2A7E4
-      C267BB85599656398A354F84272F7616388628469338469A5298C7A6FFFFF8FD
-      FFFFFBFFFA5698573B89364589343E6C0C335C002A5B072D5801315C01366207
-      326B0839811D3A933648A354B6D8C7FFFAFFFBFFFF9ADAB647B66639B16A3DBF
-      6866BA7AE6FAE7FFFBFFFDFFFFB9E6C543B66742B56645B974E3FCE8FFF9FAFB
-      F9FF9AC6A7448A442E7514326A00385B012B4F022151002D59003262093A7715
-      4589347AAB85F6FFFCE1EDE756864438821C427506397307367819398625458B
-      459AC8A4F2FEF8FDFFFF49AB777ABF94E4FFEFF1FFF9FAFFFFFEFDFFFFFBFDFF
-      F6FCE7FCE6A7D3AE479A553A92383671092E5C033B64081E4C00275000275000
-      295000284F01274E00284F012950022950002D55032A5101274E00274E002950
-      022A5103295002274E0029500029500029500029500029500029500029500029
-      50002950002950002950002950002950002950002950002950002A4E012A4E01
-      2A4E012A4E012A4E012A4E012A4E012A4E012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000274E00295002295000274D01284F002D54042C5500284F00274E00295002
-      295002274E002950022D54042B5202274E002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F01274E00264D00274E002950002D54042E55052E5604284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C002A4E012A4E012A4E012A4E012A4E012A4E012A4E012A
-      4E01274E00274E00274E00274E00274E00274E00274E00274E00295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      00295000295000295000284C00284C00284C00284C00284C00274A0026490026
-      4801274A00274A00274A00274A00264801244600244600244600274A00264801
-      2648012848012645022844022642002442012640002640002640002640002640
-      00264000263F01253E0026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000274101264000
-      264000253E00253E00243D00253E002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      00002850022950002D57002951002E5604284B01295002274D012C4F002C5004
-      2954032B5500346001386E0A38772753954667A367EDFFF2FEFDFFFBFEFC6CA6
-      76398A352A72083561022E55072B50002A4E01294D012A51012E5A0132690244
-      831B46913D468E52B6E7C7FDFEFAFFFFFFE5F1DF57965830812434690B2E5A01
-      295300254A022749022D51002D59003C6C0C47862844923A559855D4F9D9FCFE
-      FEFEFDFFBFF2D069C895FAFCFDF5FFF9C2E7C7478B4438821C3C6D0B31610122
-      5300254A002652002F59013C6C0C44831B44873668A678F8FFF9F1FFFE74A775
-      4487362A7207316900335B0338630C40791747862842923997BA98FFFFF7F7FF
-      FD4899543D9D424D9646B2CDB9ECFEF16E95683689343D9E402A973144B56544
-      B4663EBF6A7ABE95FFFEFFFEFEFEBFF2CD54B57344B67658B16C529B63569966
-      578B55457731467733448A444BA45446A965A9D8B8F0FFF5F0FFF998D6A856B2
-      693D91433B92363D912B426D16326B0936761638821C3A914787BC94F9FEFCFE
-      FAFFF3FFF95698572F80232B7515315B032854012A52002B50002F55032B5900
-      2D59003473053D902D48985598C7A6FFFEFDFFFEFFB7E5C845B5673CBF6847B8
-      7587CBA2EEFFF6FDF9FFF7FEFB85CBA247A86547A96345A961C8F2D9FFFAF7FF
-      FBFDA6C8A9438B453A801B3269022F56003151042650022B580134630738811D
-      46863A95BF8AF7FFFEF7FFFE86B4892F7F243A7A2836761638821C398A355196
-      4598C8A4F5FFF9FFFAFF86CBA6E5FBE8FEF9FAFDFFFEEDFEF5F8FDFBFBFFFFF7
-      FAFFFFFFFAE5FFF26AAD8048984537821A437607315B03365E06284F00295000
-      295000284F00284F01284F01284F01284F012D55032A5101274E00274E002950
-      02295002284F01264E0029500029500029500029500029500029500029500029
-      50002950002950002950002950002950002950002950002950002A4E012A4E01
-      2A4E012A4E012A4E012A4E012A4E012A4E012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F01295002284F00274D01284F002B52022A5200295002284F01295002
-      295002274E002950022A5101295000264D002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000285002274F01264E00254C00254C00264E00274F01274F01284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284F00284F00284F00284F00284F00284F00284F00284F00295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      00295000295000295000284C00284C00284C00284C00284C00284C00284C0027
-      4A00274A00274A00274A00274A00274902254701244600244600274A00264801
-      2648012547002645022743012845002844022640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000274101264000
-      264000253E00253E00243D00253E002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000234A00274E002C5101274D01295002284C002D5104274F01274A00274C02
-      2853022C56003763044278174587284698467BAD85F7FEF9FFFFFFEDFEF1538E
-      542F7F24336C0A305C002E55072951002A5103284C002D4F0232560233600043
-      7A17478F2B4799468BC797F9FFFAFFFAFFF8FFFF67A268358627346B08335B03
-      295600244B00264801305100315C01396D09447A1751953C489857B7E5C8FAFF
-      FFFFFFFEE6F9E899D7A9FFFEFFF7FEF9ABD7B8498B432B7614376403375B0123
-      51002D4E032D55032B58013E6B0445821A478B38568A54EEFDF5F9FEFFB2D2AF
-      4A77323A761832680433610032620A4379164287374794389AC8A4FBF9F8F5FF
-      FF4698463B9F40519646E1EFE49AC8A4478A45398A353E9F414CA35348A35457
-      A9753EC26578BE95F5FCFFFEFDFFC0F3CE51C4753DC06936A750399F403A8628
-      2D73183A771543831947902E48923A479947A6C7ACF5FFFEEEFFF268A7753990
-      4646913B47862A316904405C032A67003A6B003973073A923872B07CF7FFF8FE
-      FAFFF8FFFE65A2682C88352C69132F5C002E5A01305505264B01254D00285200
-      29560031690438811B46923A79AC86FFFFF9FFFFFFD7F7E655B16A3DC16757B5
-      74B6E4C7F3FFF6FCFFFBEEFEF36DAD834BA35048A5544DA355AEE1BBFDFEFAFF
-      FEFFB9D6BD468A433684193268052D57002A5204254C002C55003263073B8319
-      46883684B589FAFFFFF9FFFEC2E6C84989473984282E7616317F273B912B4797
-      549BD6A9F1FFFBFEFCFCF7FFF8F7FFFFFFFFFFFEF9FAF6FFF19CDAB6B8E6D3EC
-      FFFBFEF8F9F9FFFACAF2D967A3674688374279163E6503275600284F00284F00
-      284F00284F00284F00284F00284F01274E00295100295000284F00284F002950
-      0228500227500027500029500029500029500029500029500029500029500029
-      50002950002950002950002950002950002950002950002950002A4E012A4E01
-      2A4E012A4E012A4E012A4E012A4E012A4E012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000264D00284E02284F01264C00284F00295000295000295002284F01284F00
-      284F01274E00284F01284F00284F00284F012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000285100275000274F01254C00244B00234A00234A00244B00284C00284C00
-      284C00284C00284C00284C00284C00284C00274B00274B00274B00274B00274B
-      00274B00274B00274B00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284F00284F00284F00284F00284F00284F00284F00284F00295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      00295000295000295000284C00284C00284C00284C00284C00284C00284C0028
-      4C00274A00274A00274B00274A00274902264801264802254701274A00264801
-      2648012648012645022743012845002844022640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000253F00
-      264000253E00253E00253E00263F012640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264D012A50042C5305284D03275000274E002950002851002B4F02284C00
-      2A52042F59013D6402437918478F2B439945A5C9ABFFFFFAFEFEFED7F6DB488B
-      4638811A326B08315C012951032A5004294F03284C002F4D01305400325D0242
-      6C1443882748974674AF7CF5FEFBFEF8FDF8FEFD87B6883989363672062F6200
-      2D5900284F00254B002C4D022F5404345E07427A1546913B54954986D5A2F8FD
-      FBFBF9FFFFFEFABAE8D1FEFDFFF3FFF998C7A63C88362E75183A640030540026
-      51082950002953002B5A00386401447A17468D2D468F51D8F7DCF7FAFFE5FCE6
-      57854A3676163773073169003369054279164A8737479139B3D3B0F9FFF9F1FF
-      FE4A9A55399F4048923AD9F7E475A876459139459647448E5465A57798C9A3A7
-      E5C1B7F7D9D7E9DCFFF6FFF5F4FEBDEFCD69BA7B44B56535A9503C902A377717
-      346A093269022F71072E812539913748A354A7C9ABEFFEFFEBF8F669A4774792
-      3E378625407409426A05375A0332610042690743730938923868A468F4FFF7FF
-      F9FFFAFFFE75B17B3C88362968123460012B59002C5109244900284E06295103
-      375A003864013A740837913866A567F3FFF3FFFAFFEDFEF364BB773EC06964B9
-      7BDCF7E7FCF9FFFFFEFAD7F6DB44A9654998474AA2564AA35486CCA3FFFFFAFC
-      FEFEC8E5D6478A473A811A3469022D57002C52061F4E002B5204305C033A7717
-      45912C589857F0FFF7F8FBFFE6FCEA72B07A3789363181242D7F26399339489A
-      5298D5A9F1FFF6FFF8FFFFFFFFFEFDFFFBFFF9EFFFF499C8A267BA7C69B887B9
-      F9D6FEFFFAF8FFF8F3FFFFA8D7B64B8A4537821A3773073361012B52022A5101
-      295002295000295000295000284F01274E00284F00295000284F002950002850
-      02274F0127500028510029500029500029500029500029500029500029500029
-      50002950002950002950002950002950002950002950002950002A4E012A4E01
-      2A4E012A4E012A4E012A4E012A4E012A4E012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000264C00284E02294F03274D01274E00284F01295000274E00275000285100
-      285100284F01284F00284F00284F00274E002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000264D00284E02294F03284E02274D01264C00254B00254B00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00274E00274E00274E00274E00274E00274E00274E00274E00295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      00295000295000295000294D00294D00284C00284C00284C00284C00284C0028
-      4C00274A00274A00274B00274A00274A00264801264801254700274A00264801
-      2648012648012746032645022845002544012741012640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000263F01264000
-      274101264000263F01263F012640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000294F032A50042A5004274C02285100295000284F002851002C51012B5000
-      265604315D003B6B0142841B51963B469846CAE5D5FEFAFFFDFFFFA8D7B73B90
-      463A751A3269022D5702295100264D00284C00254800294D01305400335C013A
-      6D0B51842846984654A965F0FEF3FDF5FFFFFDFFA8D6A83889343A77172D6401
-      2E59002A5204284C002B4E002C5600375A034074083D902D51954868BA85F9FE
-      FCFAFAFFFDFFFFE4F5F1FAFAFFEDFDF283BE92378A3530731736650031550120
-      5200264B01214E002E550031620042740839902E488C51C5E0BFFAFAFFF3FEFB
-      77A5763984283772093C6D05316900437B16458735449338AFE2BCFFFEFFF2FF
-      FD4699553CA04048913BE5FEF4498B4446923A569759A6C8A9E5FCE6F6FFF4F4
-      FFFDFCFFFAFFFCFFFFFAFFFFFFFFEDFFFE9ADAB654B888249C4B3B7927397517
-      3D69063E6A053368012D7515378936469846B7D9C1FDFEFFFBFFFF6D95653784
-      2937821A316902385B002E51012D58013665023472083D912B478D51F4FFF3FF
-      FAFFF6FAFF74B07A3989362E7515376502315B042D5307274D01224C00274C02
-      375C00315C012C72073D902D579658D8F7DAFFFFFFF2FEF88BC79748B6766CCA
-      94F2FEFEFEFBFDFEFFF8A6D6B943995346923A48A13951964657A975F5FDF6FC
-      FFFAE3F8F0578C5335821A377307315D00305407224D002B5305385B04387205
-      3E912B468944C5E0BFF7FAFFF6FDFFC4E2BF4899543688353B8C374797444AA3
-      549BD6AAF0FEFAFEFAFFFAFFFEFBF9F8E5FBE884CAA654B16C4BA25254A86744
-      B873E7FBE8FDFFFFFFF7FEF0FEF868A7753D922A2C72073962062E55052B5202
-      284F01274E00284F00295000284F00274E00284F01295000284F00284F002851
-      00274F0127500027500029500029500029500029500029500029500029500029
-      50002950002950002950002950002950002950002950002950002A4E012A4E01
-      2A4E012A4E012A4E012A4E012A4E012A4E012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284E02284D03284D03284E02284F01274E00274E00274E00285002285100
-      274F01285002275000295000295000284F012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000274C02294E042A4F05294E04284E02274D01264D00264D00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00274E00274E00274E00274E00274E00274E00274E00274E00295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      002950002950002950002A4E01294D00294D00284C00284C00284C00284C0028
-      4C00274A00274A00274B00274A00274A00264801264801264801264900254701
-      2547002648022847042746032847022847042842022741012640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000253E00253E00
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274C02274C02274C02284D03285100274F01274E02254C002E4E01294A00
-      295201345E073C6C0C47821A51953C469846E1EEE6FDF9FFFFFFFF9AC7A63893
-      362F76163162002E59021F4D00254C00284B012645002A4B002C520030540042
-      69075283273D912B489954EBFFF3FFF5FDFEFAFFC8F2C93C933944831B2A6601
-      2C5402295004294E002E5200315600345A0040730B35821A46994456A975FCFF
-      FBF9FBFCFEFBFDF6FEFDFFFEFEF0FFF878B7853B89352D75153965023054001E
-      4D01274C04284C002B5900375A044074093B8428488E51A5C9ABFCFBFFF3FFF9
-      9CC8A34688363574063469023B6B0141821C46883646913DC4E6C8FCFFFDF3FA
-      FD479A55399F4044923AB6DAC4478B4448923A9AC9A3F5FEFFFFFAFAFDFEFCFD
-      F5FFFFFDFFFEFEFEF9FFFAFAF9FFFFFFFFF6FFFCC9F1D869A4773888352C6913
-      305D003864013B6C0439751744862753963BC3E7C9FBFFFFFAFFFE77A7773C8F
-      2C2F7209296500315C012A50042B5700385B003B6C003C8F2D458D51F3FFF3FF
-      FFFFFDFFFF76B27C3889343877173B6A032C56002849062B4D07225200214C01
-      2F5700375A0434690238902C498A45C2E5CAFCF9FFF1FFF991E1AC49B77585D5
-      A0F5FFFDFFFBFDF3FDED88BD95279A4A46913B3A902A5297473F915DDEF1DEFF
-      FFF9F2FDFA598B5536831B3872063461002D5406214C012B52023C5301326902
-      37821A53953C869F85FEFFFDFFFFFFF6FFF257B06B469A524698464798494BA4
-      5498D6A8F3FFF9FFFBFDFEFFFBCAE4D66DAD834898553B92362896303B9F4038
-      A75178BE96F1FFF9FEF6FDFFF9FFA7D5AB3B9F4038811A3864003259092D5404
-      295002284F01284F00295000284F00284F01274E00284F01284F002851002851
-      00274F0127500027500029500029500029500029500029500029500029500029
-      50002950002950002950002950002950002950002950002950002A4E012A4E01
-      2A4E012A4E012A4E012A4E012A4E012A4E012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000264C00284D03294E04284F01295002274E00274E00284F01285002285002
-      285002295103274F01285100285002284F032950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000274E02284F03295004274E03244B00234A00244B00254C01284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00274D01274D01274D01274D01274D01274D01274D01274D01295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      00295000295000295000294D002A4E01294D00284C00284C00284C00294D0128
-      4C00274A00274A00274B00274A00274A00264801264801264801264801264802
-      2449012648022647042746032847042847042842022842022741012640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000253E02243D00
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000295000295000295000295000295000295000295000295000235100295300
-      2E55003E5C034175094686264889344AA354FBFFFAFFFFFFF2FFFD86B4893989
-      36346B083562012956002A4E01294D01274B00284B01284C00294D002E550036
-      5E0644841A48923A589759BBE7D0F9FFFDFCFEFEEEFDF5568D563A8628336C0A
-      2B59002F4F00254A04264900285100315D0032690246841852964953A766DCF8
-      E5FBFFFFFEFEFEFDFEFCFFFEFFFDFEF467BB7B3B92383A73062766002C550027
-      50002F56002C53002952013965023D740755912C4F97458AD4A4F5FFFEFAFEFF
-      D5E9DC547A4838862832690240740851842A488F2E489746C5E0BEFFFDFFFEFF
-      FD54A66547994746994482BA6D55854A889E82F5FFF2E5FAEBB8DAC284CAA255
-      C3756CC897A5E5C2FFFFFFFFFEFFFFFEFAE5FFF0FDFEFAF8EEFA5786482B7515
-      2B6401265A003965083A771747902E489746CBE4D6F9FEFFF6FFFA77A5763784
-      282C72073462002A5B072253003C53012E5900396B0D388529478D51F5FFF3FE
-      FAFFFFFFF86CAC82398837417A172D64012F56012F4C032A5302284C00264D01
-      3055052D5900426A054D7A1D5096498AD5A2FFFAFFF8FFF8BFF2CD3AB26BD8F7
-      DCEAF7F9FEFAFFFFFBFA57A7663B883745862A46862636862948A453A5C9ABFF
-      FDFFF7FFF888A9873B7927377209326A012D57022B5600245A01245A00305C01
-      437A1747862A49A455B1E3B9F7FEF9FEF9FFBFF1CF559C644EA25437A75345A8
-      64B5CFB8FAFEFFF5FFF987DCB054A5664CA353468F2D437A1737792744831B51
-      912D4BA552A5E5C2FBFFF7FEFAFFF7FAF867A2683B89363D6A033361012D5900
-      2E55002E5101274902294D00285204234D002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C002950002950002950002950002950
-      0029500029500029500028510028510028510028510028510028510028510028
-      5100284C00284C00284C00284C00274A00264801264802264802274A00274A00
-      2649002446002446002446002648012648012844022844022844022743012443
-      0022420121410023400126400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000295000295000295000295000295000295000295000295000215100234D00
-      305001415D0342730947902E45933C65B169FEFFFBFFFDFEF1FFF979AD853984
-      28397209335F00295000284C00284C00274B00284B01284C002A4E012F560136
-      5E0640791647902E489A52B7E6C6FBFFFFFFFFFFF3FFF269A5753B8527316D09
-      2E58002E5101254C01244B002A51032D5C003D6A0347831E52973C559C64C7F1
-      D8F9FEFDFFFFFFFDFEFAFFFAFFFFFEF464B87D3A92383671092966003155012A
-      4F051D4B03295103315503315C0132690241852653984798D5A9F4FAF9FFFDFF
-      EDFFF264A46836852A3782184379183D792548912D439745C3E1BEFEFDFFF9FF
-      F655AA7844994549923C46913B5A8C56D5F7D9BBD6BC6C9667458C533E945E55
-      B16A56B4739ADAB6FFFEFFFEFEFEFEFFFBB8E5C4E9FCE9FFFEFF97BE8A3A7826
-      326A012B64013A6301387618428627449944C5D9CDFBFFFFF7FFF878A6773885
-      292B70093360032950001F53003C5400305C033469023885293C9244E7FAE9FE
-      F5FFFDFFF96AAF843C88364379153469022B59002F4D022C5101284F01254C01
-      2C56002E550038640043781A458A476BC895FEFDFFF5FFFED9F6DD54B985E5FB
-      E9F5FFFEFEFBFDEDF2F04499453687264278173976163B912B47923E76A574F5
-      FFFFF2FFFDAECDAC497631387814276501315B03274E002753002252002F5B02
-      3B640247862A43913976B986EEFFF2FFFBFCEEFEF396C9A44AA4513DBF6A48AB
-      63B8D8C5FBFFFFFAFEF985CCA14999543688352F75182B6702326307346A093B
-      821B3D8F466DAD83ECFDF4FBF6FFFAFFFEA7D8B843933638751A3460032D5801
-      305402285000274B00284F03285205214D002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C002950002950002950002950002950
-      00295000295000295000284F00284F00284F00284F00284F00284F00284F0028
-      4F00294D01284C00284C00284C00284C00264900264801264802274A00274A00
-      274A002547002446002446002648012648012645022844022844022743012443
-      0024420123410022400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274E00274E00274E00274E00274E00274E00274E00274E00205100274E00
-      2E520038640041730D498F2B4F94496BBB86FFFFF7FCFEFFEFFEFA69A6743785
-      27377504315B03275201284C00284C00274B00284B01284C00294D002F560136
-      5E0642740846913D479B53A5D6B6FCFEFFFFF9FFF5FEF485B6883885292D7515
-      315C01315600274C021F4B002A52002E5A003A6B0343781751953E469A52BBE6
-      D1F5FFF9FFFEFDFFFDFEFFFDFFFDFFF968BB84378A353B6C0A3562013354032C
-      50001C4D012750052A5302305B003E6D0B4A8E2F5795598AD4A4FFFEFDFFF9FF
-      F6FEFD87BC943B842844841A39751744852943923B469846C8E0C0FEFEFEFFFE
-      F966B97B4397453A923838912A68A775D5F6DB62915245772F46923A44994546
-      A96555B1689CDBB4F8FEF9FDFFFFFDFEF47ABE95A6D7B7F0FEFAD1EFD2467832
-      2965013A6B013862034479184388274DA257C9E6D7FEFEFEF0FFF87AA6773784
-      2938730A3965002A52002A54003D54003161013468043B8428469846E0F0DEFF
-      FFFFFCFFFB6AAC833B893546821D3269022F5B00304E03284F00295100274C02
-      2952002B54003965003E6B0A46883667BB7BFFFAFFF1FFFDECFDF29BC9A5EFFD
-      F2F9FEFFFFFAFFB8D8C73A913938811A3876183A6D0B458329378527478A45C4
-      E6C8F7FFFED3EFD2517A4739821B316A013461002A5701284E02264D00325A08
-      315D00427719378527589759C4E6C8F9FFFEFBFFFFDCF7E769BB8639BE6753C3
-      75B7E6C6F5FFFEFFFEFF89CBA2478C533B8428306C08235801285B002C650234
-      7206488F2F4C9545B8E5C4F9FFFEFFFFFFE5FBE8568C572F8023316801325E01
-      285500305100284C00254C012751042150012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00294C02294C02294C02294C02294C
-      02294C02294C02294C02284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00274E00274E00274E00274E00274E
-      00274E00274E00274E00284F00284F00284F00284F00284F00284F00284F0028
-      4F00284C00284C00284C00284C00284C00274A00264900264801274A00274A00
-      274A002648012547012446002648012648012645022743012844022844022642
-      0024420123410022400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274E00274E00274E00274E00274E00274E00274E00274E002C52002A4E01
-      2E550041640D3F78164587285097478DC896FCFDF9FEFDFFEDFDF2519C662F7F
-      24357307335C01285302294D01284C00284C00294C02284C00284C002F560136
-      5E0643740A498E2D45974599C8A7FBFFFEFFF9FFF8FFFA9AC9A33A8E2F397614
-      3162002959002950021F4D002A4E0131560039650243791648923A489954AFE4
-      BCF1FFFBFCFDFFFFFEFFFAFEFFFDFFF96CB9863B89363D6B0B3460032E55002E
-      53002854012956002D5601366100377406448F2D48A25694E2ACFEFDFFFEF8FD
-      FBFFFFB7E6C6468A37468529397616398A3548923A479947C7E0BEFFFFFFFFFE
-      FE67B88744984646923A468837ABD8B786AA7630610B46781A3C8F2C3A923848
-      974658B16B91E0AFF6FFFFFFF9FFFCFDF345AD7667B887B3E3B9EDFEFA558845
-      2965013D6B003A6301407916458728469846CBE5D5F8FFFAF7FEFB78B7853C89
-      383673053A6B012D59002D57023953003063073776163B922A459854DAF8E5FE
-      FEFEFCFFFB6DAC84398A354079162F6904335C01304D042850022D51002A4E01
-      2850022F5503306000386C0E3D842755B168FEFEFEF2FEFEFEFFF8D4E8DBF3FE
-      FBFEFDFFFEFDFF78BF973A92382F7616396C0A436907447A1747821944883575
-      B27AF4FFFDEBFFF26E9567397A252E7205326804325B002E4D08295000315503
-      345F0431690439831951964687B489F0FDF5FEF7FEF7FFFEB3E2BB43B66752C2
-      75B8E7C7FCFDFFFFFDFF88D5A2458A473D7925316A012E59022E580131620036
-      6B0A43821A48923A6CAE84ECFDF2FEFAFFFBFEFC86B587398A353675072D6500
-      285500285100284C00274E002B5202274E022950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00274E00274E00274E00274E00274E
-      00274E00274E00274E0028500228500228500228500228500228500228500228
-      5002284C00284C00284C00284C00284C00284C00284C00274A00274A00274A00
-      274A002648012547012547012648012648012645002544002744002844022743
-      0124430023410023410026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274E00274E00274E00274E00274E00274E00274E00274E002E4F04254C01
-      2F56013964094379154486274F95489AD6A6FAFFFDFDFFFFECFDF2578D52327F
-      243A72072B59002A5204284C00284C00284C00294C02284C00284C002E550034
-      5E063B6A0345862A3A914782BD91F9FEFCFCFDFFFBFFF9B8D8C5479139377618
-      336200325B002C51011E4C002A5004325302386401407917468F2D4BA4549BD3
-      A8F8FFF9FFFEFFFAFFFFFAFAFFFDFEF566BB893B92383A76182C6503385B0031
-      5503315D002D5900315C013A6C0E37821A4B9E3B53A86492E2ADFFFAFFFDF9FE
-      FFFFFFD8F4DD46894644831D39831939832954973C459744CFE5CCFFFEFFFEFE
-      FE6DBA873A914746933845772FECFDF2508528386C013B6B0B38730B3A832749
-      9F3B48A45388DCB2FCFFFDFFFEFFFEFCF448B77343B66661B269E3F7F26D9663
-      32620A3169023D64024173074886283B9046CAE5D5FBFDFDF8FFFC85BD924591
-      3938811A3B6C0A2E5A07265B00385C022A69133C84243B933948A157F7FDECFF
-      FFFFFDFEFA6CAC823C8A374278172B64012E5A012F4C03294D002E51012A5103
-      2650022D5400346301356B073A852949A455F5FBF6F9FEFFFFFEFFFDFEF4F0FF
-      FEFFFDFFF1FFF857A877478F2F3366043463013F68063A6B01417A18488F2E47
-      8A47C3D9CDF2FFF9B2D3AE4776312C73052F6A022E5D013054082E55002A4E01
-      345F08325B0039821B44913D569956B5E6C6FAFAFFFFFDFFE5FDE56DBA874AB7
-      72B4F8D5FBFFFFFEFAFF8DC7974588373A76183169002D59002F56012D590031
-      6200437509498D2E458D51BBEAD0FCFEFFFEFEFEC5E0BF478A45397616296501
-      2B59002A5400264C00284E022951032750002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00274E00274E00274E00274E00274E
-      00274E00274E00274E0028500228500228500228500228500228500228500228
-      5002284C00284C00284C00284C00284C00284C00284C00284C00274A00274A00
-      274A002648012648022547002648012648012547012746012544002744002743
-      0126420024420124420126400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274D01274D01274D01274D01274D01274D01274D01274D01294D012C4C00
-      2F5503366401437918488F2E579756B1E3B9FAFFFFFFFCFEF6FFF3478D513883
-      193167032E5A012A5004284C00274B00284C00294C02284C00284C002B540031
-      5B033B6B0145882749974479B886FAFEF9FEFAFFFCFEFFC6E5D64498463B7925
-      356806335C012C5101214E002A4F002A5200365F03437A17468F2B48A3549BC9
-      A5F5FFF9FFFEFFFCFEFEFFFEFFFFFFFA6BC895389147447A172A6300305D002C
-      5902366500336101346B083B79273B922A47984963B26999D9B5FEFEFEFEFAFF
-      FFFEFEE5FFF264A5564079173A811A37852753953C459947D0F1CFFFFAFFFFFF
-      FF67B9853C914746923A437731F4FEF83460013B6B012E5D014074093A771746
-      8F2B46984598DAB7FCFFFDFFF9FFF3FFF34BB77546A963479853C7D8CD7BA26B
-      346A092965003B6B0143740A44902B3C9147C8E5D6F9FFF9F7FFFE92CFAB4999
-      523D902D3676162968122D69113665092E75153B923C3CA04046AA62F7FFF5FF
-      F9FCFDFFF967AF803A88344279162C66012E5A01324E022151022B5100274F01
-      274F012B5600315C013167033686294AA354D5EBD9FCFBFFFEF8F9FEFEFEF2FF
-      FDFDF6FDDBF8E848985139821B326902305D003C640C3F680639730745821A39
-      79276C9667E6F9E8EBFFF36790573869173068012D6302325A082E59022A4B00
-      2F500034630137720946821E55994678B686F0FFFBFFFFFEF5FEFBB6E5C558AA
-      76B7F8D8FAFFFEFFFEFE89D3A34688363A76183768062D59002E54022E590031
-      5B03346A0944831D41994578B785F2FEFEFFFAFFE6FCE9458C533B811C2D6C06
-      285A022E55002A4F002B4D00284F002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C
-      00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00274D01274D01274D01274D01274D
-      01274D01274D01274D0129500029500029500029500029500029500029500029
-      5000294D00294D00284C00284C00284C00284C00284C00284C00274A00274A00
-      274A002648012648012648012648012648012648022648022446002645002844
-      0227430124430024420126400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000254C00254C00254C00254C00254C00254C00254C00254C00294D01274D01
-      325400336101407916478F2F569759B5E6C6FBFFFFFEFDFFF4FEF1468E523883
-      1B316A012E5A01265108284C00274B00294D01294C02284C00264C002A530030
-      5B003C6B0444852947994776B079F8FFF9FEFAFFFEFDFFE0ECE64698462E8027
-      306803305C01285500244E012A4D032C4E01375C0042740848902C43984485BD
-      94F5FFF3FFFFFEF9FFFDFFFAFDFFFDFC87D6A34BA4554587352F7717346A0934
-      6A092F73063976163988373B8A3346995465A57797CAA4E4EBE8FDFEFAFFFEFE
-      FFFDFFE5FFF276A16842791638771736862944923A489A52E5FBE9FFF9FEFEFD
-      FF68BA86479B4345903A4F8427ECFFFC427309396A02375F073673053D792544
-      87364CA254B8E6C9FEFAFFFDF7FCF3FEF466BA7A4AA3543B9D43A5BBA878A469
-      3772092867013673053B74193B902E469A52E2EDE3FEFDFFF4FEFEA9D8B854A6
-      654AA3533A91393080252E8224397927398A354898454AA35457BA8AF0FFF1FF
-      FBFFFFFFFA7AB6863B903B36831B2B6600315B032A5000245200285200254F02
-      274E02325500325B002E66003882183B9E42BCE6D4FDFFF9FAFFFDFFFEFFF4FF
-      FDFFFEFFB6E5C5439846387717326804336200365E064369073E750843740643
-      7918397A2595BF88EEFEF3B2CCBA5485473A7408346902336200335C01255100
-      294C02345E07326902387507479139569857B5E6C6F8FDFBFFFDFFE6FCEA7ABE
-      95C8F3D8F9FEFFFFFFFE8AD5A24586373878153063092B560028510029500029
-      55022D650037761846923A579755D9F6DCFFFEFFF7FFF868A77545821A357406
-      325F022B5900295000254C002550002851002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C002A4E012A4E012A4E012A4E012A4E
-      012A4E012A4E012A4E01284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00254C00254C00254C00254C00254C
-      00254C00254C00254C00284F01284F01284F01284F01284F01284F01284F0128
-      4F012A4E01294D00294D00284C00284C00284C00284C00284C00274A00274B00
-      274A002648012648012648012648012648012648012648012446002645002645
-      0228440226420023420026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264D01264D01264D01264D01264D01264D01264D01264D01344D032B4D00
-      2D5801335C013A7717468F2D5A9659B9E7D1FDFFFFFBF9FFF4FFF4478D513881
-      1B3268042B5900265106284C00264A00294D01294C02284C00264C002A530031
-      5C013B6A0338831944994577B17BF5FEFBFEFAFFFEFDFFF0FEF24898452E8027
-      3469013362002B5500274E002B4C012E4E01385B013F750A498D2E47994778B7
-      85F4FFF3FEFDFFFCFEFFFCFAFFFFFEF98ADCB143A86454963D46852744831B3A
-      852946852937943944984656B47491E1ACDCF8E5EEFFFCFCFBFDF3FFF0FFFEFF
-      FBF9FFA6C8AA477631396C0A4479183B8329468837469A52F3FEF4FFFBFFFEFE
-      FE68BC8648A3543B893644841AE5FFF9538438336A03416D142D730842862749
-      894749A455BFF2CDFDF7FCFFFAFFF3FFF96AC9974AA3543B92368AA99465A357
-      2D7308316902437A1743821A3A913B47AA64F4FFF5FFFEFFF1F9FFA0DAC854B6
-      7445B5674AA2563A92463D9E4053953C48A3544AA45155B06B6BC895F5FFF2FF
-      F9FFFFFEFA78B68646984544831B326A01335C012C5300215001284F00284F03
-      284D052B5204305C032B64013A811A3B9F40A9E5C3FDFEFAF7FFFDFEFAFFFDFF
-      FFFFFAFA88D4A43A91373877172D6401346003295300375B0143740A3B6A033A
-      6D0B2E741745772FC6D8CBFAFEF86A95683B75162A72072A65032965002C5600
-      2E54082E550534600137730738862846984668A678F7FFF3FCFEFEF3FFF2B7E6
-      C6BCE8D1FCFFFDFEFFFD9AD5A8468C453976163063092D54002950022C520029
-      56001E630241771646821D489954B6D7BCFFFFFFF6FEF398C8A4458728357307
-      2E65022F59012A4E01284F01294E00284E022950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C002A4E012A4E012A4E012A4E012A4E
-      012A4E012A4E012A4E01284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00264D01264D01264D01264D01264D
-      01264D01264D01264D01274D01274D01274D01274D01274D01274D01274D0127
-      4D01294D002A4E01294D00284C00284C00284C00294D01284C00264900274B00
-      274A002648012648012648012648012648012648012648012446002446002645
-      0028440227430124430026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000284C00284C00284C00284C00274B00274B00274B00274A00274E002C4E01
-      2E550033630A4074083C8F2D478D50D6E9DAFFFDF5FEFDFFEFFEFA478D503882
-      1C326902345E07254B00264C00254B00274D01274F01275000284F012A4E012E
-      55053A6C0050791E54954946A866F9FAFEF9FFF9FFFEFAFDFFF9489A512F7F24
-      336C0A3462002C5500264B01255100274D011B620142730948902C53953C67BB
-      85FCFAFFFFF9FFFDFEFAFFFEFFFEFAF9CAF3D844B67637A8503E9F4152974646
-      99554699548DC896C7F1D8F5FFF8FFFAFFFEFBFDFFFDFFFDFFFFE5FFF9B9E5C8
-      77B07D4391393A72072C710834720844831B3B8935579756F5FFFEF9FAFEFFFE
-      F67ABE9548974638923945772FCBF2CC659154396C0B35740637751749883848
-      9E38549A65D2E5CAFEF6FDF8FBFFE9FEFB7DBF964AA354458A4797BD8B558747
-      376B183B79273A852938923837A8503EC069F3FFF9FCFEFFFDFCFEE6FCEA85CB
-      A289CAA3A5E4C4C8E5D5E9ECF4FFF9FFFFFBFDFFFFFFFDFDF7E2F1DCFBFFFFFE
-      F5FFF1F8FF85BD924CA25428931F2A66013864092A51032659002C5300285100
-      295100305003365D013B65063B79273A9147ABD7B8F4FFFDF4FFFCFAFFFEFDF5
-      FFEAFFFC63B269478A473B6B013462002D58012B52042D54043760053B6A043B
-      6B01377209407408568539D5F6DBDCF9E2558747326B09397307235E0D265A00
-      2E59002C51012F5208375B1538771753922C469954AFE4B9F8FFF9F4FEFEF2FE
-      FEDBE2E5FFFFF8F5FFFFA8D7B6498B4438811B2A65032D5900225200274E0030
-      54083054003D6B0B417B1653953C75B17BECFFFCF3F4F2D1E5CE3A902C3B8319
-      346902305B043155012B4E042749032852002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000274E00274E00
-      274E00274E00264D01264D01264D01254C00274E00274E00264D01254C00274D
-      01274E0029500028510029500029500029500029500029500029500029500029
-      5000274E00274E00274E00274E00274E00274E00274E00274E00295000284F00
-      274E00274E00274E00274E00274D01274D01284C00284C00284C00284C00284C
-      00294D01284C00274B00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C002648012648012648022648022648
-      0225470124460024460028440228440228440227430124430022420121410023
-      4001264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000284C00284C00284C00284C00284B01274A00274A00274A00244D022C4F00
-      2B51002C5A07396C0A39922B469A52E5FFF2FCFEF8FFFBFDF1FFF65797563985
-      272C6503315B082B5000274D01254B00264C00274F01275000284F012A4E012D
-      54043B6A03437A174591394AA354FFFFFFF7FEF9FFFFFFFFFDFF4497483B852B
-      346B083460012B5600274D012951032850002E65024169034485294D9E3D7ABD
-      96FDF9FEFFFDFEFCFFFAF3F6FBFBFFFEC8F0D748AC7854C27467BB7B86BF92A7
-      E4C2E5FFF2EDFDF2F9FEFCFFFFFFFEFDFFF7FAFFF3FEFBEDFCF48DC89668A676
-      5386363777173269022B6401316D094378174598494AA353F4FFFDF8F9FFFCFE
-      F887CBA24599473B933939792765A268A7D5AA396917377307478E2D3A902C4A
-      A35346A963CEF1CFFFFEFFFEFEFEF4FFFA69C9933BB1683CA0414698463C8935
-      398A353C923A43974549A55457B06A55B673FDF6FDFEF5FFFDFCFEFBFDFEF1FF
-      F6EFFFF8FDFFFFFBF7FDF9FFFEF5FFF9F8FFFFECF5F9FAFFFFFBFFFFFBF9F8FF
-      FEF4FFFAFFC7E6D767A3663784284378172D56013B630B2052002B5600285002
-      275103305001375A033765023876183C91479AD6A6FBFEFCFCFEF2FFFFFBFFF9
-      FFC5F2D84899543A85293B6A033461002B56002B52042E5505335D053765023B
-      6B0137740641750A3B6B0B609153D7E9DCCAE4D6517A472C65023169042C6601
-      355D052D55032C5A012B64013876184589343EA04086BC91EDFEF3F7FFFDF3FC
-      F9F2F4F4FEFDFFFCFEFFBAE8D246974837821A2B6500315B082A54002951002F
-      4C03375B0132620228730747862866A369E6FDF9FBFFFFF2F6F146913B37821A
-      3269022D59002A52003253092C4D022B50002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000274E00274E00
-      274E00274E00274D01254C00254C00264D01274E00274E00264D01254C00274D
-      01274E0029500028510029500029500029500029500029500029500029500029
-      5000284F01284F01284F01284F01284F01284F01284F01284F01295000284F00
-      274E00274E00274E00274E00274D01274D01284C00284C00284C00284C00284C
-      00284C00274B00274A00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C002648012749022648012547002648
-      0226480224460025470126450228440228440227430124430024420123410022
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000284C00284C00284C00294D01284C00274A00274A00274A00254C012E5200
-      2751002B5C06426D163D8F2C499956F1FFFBFFFFFFFFF9FFF0FEF8478D513687
-      28316902365E06285002274D01254B00264C00285002285100284F012950022E
-      55052C660143821A4899444BA455FFFCFDFBFFFFFEFDFFFFFDFF4799473A8327
-      306C08356104285100214C01284F03284F00265A004069084685274BA03868BC
-      86FFF9FEFFFBFAFDFEF5FFF6FFFDF8FFFBFFFFB9D9BAB9E5C6F0FDEDF8FEF9F2
-      FEFEFFFBFDFFFBFFFFFAFFFFFEFFF7FFFFE5FCF8A7D9B76AA77567A257518537
-      387B263472063269022B64013069003877173A923848A453F3FFF8F7FFFEFDFF
-      F68FCEAE4698453A913543821A467830BBD6BC9AC9A3448A443C912F3A9E3F47
-      A8653EC069BEF0CEFEFFFAFDFEFAF3FFF28EC89843B66738A8503B9E423CA041
-      3C914748995466A3698EC997B7E4C9D6F9E5FCFEFFFEFAFFF7FAFFFBFFFEFFFA
-      FBFCFEF8FEF5FFFEF5FFCAE4D6A5D6B685CBA386CCA486CDA2BAE8D2EDFEF3F3
-      FEEAFEF6FDF3FFFFE4FEF198C089386B14436D161F4D013064062E59022C5200
-      2853022E5200375B013965003A731644943B6CC996F3FEF4FFFFF3FDF6F3F6FB
-      FEB1E2BC4B9F3939821B3B6A043361012B55002B52042E5505315B033663023B
-      6A033D6B013361013B6C0A466F146B9369C8E5D5C6E0C245772F3973062D6401
-      365D0139620D3362002D64012E7207478E2E4AA35457A766B5E6C6F7FFFDFFFE
-      FFE8F7F9F7FFFDFCFEFEC7F2D75398483882183460012F5C062855002652002D
-      49033255002E59022E700A3B821B578648C9E7D4F5FFFFFFF8FB5898563A8529
-      346908325D022953002E5101284F03274C042950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000274E00274E00
-      274E00274E00274E00264C00254C00264D01274E00274E00264D01254C00274D
-      01274E0029500028510029500029500029500029500029500029500029500029
-      5000274E00274E00274E00274E00274E00274E00274E00274E00295000284F00
-      274E00274E00274E00274E00274D01274D01284C00284C00284C00294D01284C
-      00284C00274A00274A00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00264900274A002648012648012648
-      0126480224460024460026450227430128440228440226420024420123410022
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000284C00284C00284C00284C00284C00274B00274B00274A00254A022F4E00
-      284F002A5B053B6D0937821A478C53EDFFF2FFFAFFFFFAFFF1FFF9478A453984
-      28316904325C05295002274D01264C00274D01285002275000274E002950022D
-      54042B6402447A1645933B4CA254FFFBFFFFFEFEFDFFFFFFFDFF46984539821C
-      356C092D5C00265100224F00274C022A4F00255B02416806438925499E3C57B0
-      6AFCFEFFFFFFF9FEFFF8FEFEFEF6F6FCF1FFFDE6FDF8F9FEFFFFFEFEF5F4FDF7
-      FAFFFEF5FFFFFBFEFFFFFFF2FEF2B5E5C879B78755975646984648902C42841B
-      4578173B6B01365F0334630133630A3675173A902C499954F4FEF8F7FFFEFDFF
-      F384CAA246913B358A3546821D397517558747DAFAE2B6DAC464B26B549B6357
-      A97846B773C1F1CDFFFEF9FFFFF9F3FDF085BD9446B77359B57453A86475B17B
-      8CC997C4E6C8E0FEF1F3FFF9EFFBFBF7FFFEFBF9F9FDFFFFF2FFFDE7FEFAC7F1
-      D8D8F7DAD9F7E4EAFFFBE1F6F393D1AD66BA7A3DBF6A46B774A8E7C0F3FFF9FC
-      F5FAF8FFFA9AB9A49AC9A2C5F2D8B0E3BD47782E355C06255B022D59002B5204
-      2852052A4F0031550139640337761843933654B573F7FEF9FFFEFEFCF7F6F6FD
-      FF87BD924B9F394074093461002E5A002852002850022B52022E5801335F0037
-      6502316B00396C0B3B630440730B316408558747C6E5CAD8F7DC4F8637376C15
-      36630233610133610133630A346A09397307388F2D46AA6290CFAFF6FEFDFEFE
-      FEEEF7FAF2FFFFFFF6FCC6F4D75196463A831D3160033058002252002050012B
-      4C022D570031580238720638831B468A37A6C8A9F4FEFEFFFFFE65A268457731
-      3A6D0C3864002B51002B5202265002274D012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F01284F01
-      284F01274E00274E00274E00274D01264D01274E00274E00264D01254C00274D
-      01274E0029500028510029500029500029500029500029500029500029500029
-      5000295002295002295002295002295002295002295002295002295000284F00
-      274E00274E00274E00274E00274D01274D01284C00284C00284C00284C00284C
-      00274A00274A00274A00284C00284C00284C00284C00284C00284C00284C0028
-      4C00284C00284C00284C00284C00284C00284C00284C00284C00284C00284C00
-      284C00284C00284C00284C00284C00284C00274B002649002649002648012648
-      0126480126480125470026450025440027440028440227430124430023410023
-      4100264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000284C00284C00284C00274A00274A00274A00274A00274A002449002C4A03
-      254A00285200426A0439821B458E50F5FFF9F6FAFFF9F9FFDDEEE04B89373780
-      19335C012E5200335501264C00254C00254C00284F01284F00274E002950022D
-      54043268042C7207478F2B48A354FEFAFFF9FAFEFAFFFFF8FFF848923A387815
-      336703315C01245102244A00294F032E4D022D5B08406B0448831B469D3B55A7
-      66F7FAFFFFFFFAFDFEF4F2FEF8D4E8DBEFFFFDF2FFFFFEF6FDFEEDFBFEFAFFF4
-      FCFCECFFFCE5FFF1B5E6C684B58758985750963C488F2E468527377307347208
-      3D6B013260002D5900305C003263073A7717469338559658F8FAFAF4FFFDFBFE
-      F586CCA446913B39832938771744831B396917899E85F1FFFDECFDF4C5E6CBA7
-      C8B379BE99D6E9DAF7F4FDFDFFFFF5FEF4A8D7B798DBB6BFF2CDE2FFF0F4FEFE
-      F1FFFEF2FBFFFDF9FEFFF9FFFEFAFFFFFAFDF7FFFEFAFFFEEFFCFABBE5C669AE
-      8346B77365BC8485CBA2F8FEEBEEFEF3E5FFF09DD5AA87B587D1F2D0FFF5F7FB
-      F7FCAFE3BB538C55488D54548C5789A986C7DFBF4678302D59002E5A012A5204
-      2651082751003155013A630139730748852A68BA85F4FAF9FFFEFEFCFEFEF3FF
-      FD6AA5793984283A6301315C012D58012953002850022B52022C55002F5A0034
-      60012C59033C6C023A6B013B6C02437309346200366A1792BD8AEEFDFF89A986
-      3F6E122A66023469022C640030640A5083274A9E3848A45385CDA3F0FEF8FFFF
-      FFE5F5EEF7FFFEFFF9FFBBE7D049894738821839650231550123510022510234
-      4D032E4E012951002C670029720B44852988A986F1FBFBF9FEFF75A575487732
-      33680B3B64033159012953002B51052A53022950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000275000284F00
-      284F01284F01274E00274E00274E00274E00274E00274E00264D01254C00274D
-      01274E0029500028510029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000284F00
-      274E00274E00274E00274E00274D01274D01284C00284C00284C00274B00274A
-      00274A00274A00274A00274A00274A00274A00274A00274A00274A00274A0027
-      4A00274A00274A00274A00274A00274A00274A00274A00274A00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00274B00274A00274A002547
-      0025470026480125470025470127460125440027440027430126420024420124
-      4201264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      00002648012648012648012547002547002648012648012648012045002C4A00
-      284A032B510542690737811B458B45EDF2F0F7FAFEFAFFFED1E6CD4385262D73
-      083361012F5503295300274E00264D01254C00284F01274E00264E00284F012B
-      520233610131690445862A4BA038FEFEFEFBFFFFF0FDFBE3FCE843862A3B7516
-      3765022D58012951001E4A03264B052C4E01215200415D044D791E4B9F394BA4
-      55FDFAF6FEFFFBF7FEF9F2FEEA87B688A8D4ABF3FFEBFBFFF9FEFFFAF9FFFAE2
-      F0DE8FE1AD78B07B478C53478A454591394588273E7409357307357406346901
-      386401355B032E5A00315B0329650037761646783266A369F4F3FCFBFEFFFDFE
-      FA8DC896498E2D367714326A0B48831A447A173B582A8DAA93E1EFE4F2FFFDF1
-      FFF3E3FFF1FFFCFFFEFAFFF4FBFEFBFFFFE1F6EEE2FEF1FEFFFAFFF9FFFFFBFF
-      F9FBFCFAFFFFF6FEFEF4FFFDF4F5F3F6FBFCF7FAFFFFF7FEFFFDFDCAE5D545AB
-      7426994F37A6504A9956529C62A6D8B8ECF5F8FAFBFFEFF4F2F5FAF9F7FFFEDD
-      E2E555A766489746378218296910265419547B47A3C98F325D022D59002A5300
-      2452062850022F5601336101326B084486276AAC82F7FFFFFDFEFCF5FEF4C5E7
-      C9478D5036831B3A650A2E58012A5400275000284F002950002A52002C560031
-      5C01365B153362003A72073368013A6B0140740834690139650C649152B3D3B0
-      C4E8CA6D9467365B15326B08437918377714468837579755BBE5D4EDFFFDECF1
-      F2E1EDE7F3F4F2FDFFFFC3E6CB458A4737821A386B033A59042050012152002B
-      4F022A5101325B062B64013774063A77176C9568F0FEF8F6FEFE82BC6E448529
-      346B083A6301315C012B52022A51032151002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000275000285100
-      295000284F01284F01274E00274E00274E00274E00274E00264D01254C00274D
-      01274E0029500028510029500029500029500029500029500029500029500029
-      5000285100285100285100285100285100285100285100285100295000284F00
-      274E00274E00274E00274E00274D01274D01284C00284C00274B00274A002649
-      00274A00274A00274A00274A00274A00274A00274A00274A00274A00274A0027
-      4A00274A00274A00274A00274A00274A00274A00274A00274A00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00274A00274A00274A
-      0026480124460024460026480226480224460026450028440227430124430024
-      4201264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264802264802264802254701244600244600244600244600234302264801
-      294C0230550539650834831C478735C8D9CCF3FFFEF1FCECAAC99238821C2971
-      07306309385708214B00284E02254C00254C00274E00274E00264E00284F012B
-      52042F560032680446821D39902EFCFEFFF9FDF7D1F0CF9ABB9938831B386B0A
-      3261002F5A00215001224905254C01294E002850023F5C06417A1851922C4499
-      45FEFFFAF7FEF9E5FFF188D4A447A76744AA6379B787CDF2CABEF1CC8DC89665
-      B16949994648984545933B38831B367305366804316902386401346100325B00
-      335C003155012C54022F5B00356102377209649152A9D6ABFFFBFFFFFEFDFFFE
-      FA85BD924587283D6B0B3575042D640135740646831B4E791E78A26DC4E5CAEB
-      FEF5F3FFF3FFFFFFFFF6FCF8FBFFFEFDFFF9FFFAF2FFFDFEF5FFF7FFFEF0FEF8
-      EEFFF6D9F9E1AAD4AB86B686A6D6BAE6FEF2F6FFFCF5FFF2F1FFF3AFE2BC4CA2
-      543992353789364488353A902C5596586A956ACAD8CDEEF7FAE6FDF9C6F4D76A
-      A6763B842844852936831B36720633630A365B17294B04315A093156002C5004
-      2351052751032D590033610134690245831976A676FBFFFAE8FCE9A7D5AB77A2
-      693B78162B710639630C2D5503284F00275000295000284F002950002B53012D
-      5700304F042B59003460013B6A04316003325E004273093B6B013B6A03376A1A
-      70946AB6D6BDC9F3CA84A977467530487830588C5695BB97E5FFF2D8F8E5D4E9
-      DAFEFFF4FFFEFAF1FFFEC2E6C8478937397517376600365A002650022051002F
-      4F002C4C0033530C2D5900316902326B08578648F4FDE8E6FCE9519548427A15
-      3C6D013A6301355C002D56012B51002150012950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000285100285100
-      285100284F00284F01274E00274E00274E00274E00274E00264D01254C00274D
-      01274E0029500028510029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000284F00
-      274E00274E00274E00274E00274D01274D01284C00284C00274A00274A00274A
-      00274A00274A00274A00274A00274A00274A00274A00274A00274A00274A0027
-      4A00274A00274A00274A00274A00274A00274A00274A00274A00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00274B00274A00284B
-      0127490225470024460026480126480124460026450026450228440226420023
-      4200264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000244600244600254701244600244600244600244600254701204604284402
-      244600264E00385B0138771745772FC8D9CCE1EDE799AE9545772F2C72072B65
-      002B5801344D032D5104284E02254C00254C00274E00294D00264D00274E002D
-      51043F5C0634620039720938912AFFFFF7C7D8CB869F8545772F39821B326902
-      315D042D5900264C04214A072D4E042F4D01245A00406B0442740846831B498A
-      45FDFFF9D8E9DC8AAA9163A455279A4B37A851498B446A9667588C5747913938
-      902C52912939821B306A0B346B083C6C0C3361012C5A01315C01355B01315404
-      2C55042B54032B5202355B033461003B6C04A9D6ABE8FAE9FBF6FFF3F5FDFDFF
-      F986B587407917326B0934680431690232690234730539821C478F2B5A8D5386
-      B48AB6DAC4FCF8F7FFFEFFFEFDFFFDFFF9FDFEF4ECFEFDEAECF4C2E6C898C8A4
-      67A5774BA45548A35455A76661B36866BA7987B68877A57675B27A5596582E75
-      15417C144278173C761746831B46831B489238478A4776B884D6F6DD79A16A3B
-      7927437A17346A093168013D6A03346A00305C03345E062E50032F5601295201
-      2350072851062B590033610131690040791695BB97E0F0DE84A97748913B5184
-      284583192D7209385B012B5202295002285002295000284F002B4F022A51012C
-      55002E5C03375B15304D0E315C013169023A63013E640C316200335F063B6A03
-      326804356C0958854685AB87B6CCB9EDFEF3E5FFF1E2EFDFB2CEB7A7C7B4F6FE
-      EDFDFFF3FFFFFAEAFFFCB6DAC247763139730734600131550121510022520028
-      4C002F560131510A2956003269022C6502366A17C8E1BF6A95682E72072A6503
-      386B033D6A03375C002E54082E5505265A002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000285100285100
-      275000275000284F01274E00274E00274E00274E00274E00264D01254C00274D
-      01274E0029500028510029500029500029500029500029500029500029500029
-      5000284F00284F00284F00284F00284F00284F00284F00284F00295000284F00
-      274E00274E00274E00274E00274D01274D01284C00274A00264900274A00274A
-      00274A00274A00274A00274A00274A00274A00274A00274A00274A00274A0027
-      4A00274A00274A00274A00274A00274A00274A00274A00274A00284C00284C00
-      284C00284C00284C00284C00284C00284C00284B01284C00274B00274A00274A
-      0027490226480124460026480126480124460024460026450028440227430124
-      4300264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274603284704274603264502284402284402284402284402264101244201
-      274805284D032E560439630B4D7920628F395084264479183B6B0B335F042D58
-      012B5301294E00294D01274D01274D01274E00274E00274E00274E00284F0029
-      50002D59003360033B6B0B4379165F903C52912950842A4379183B6B01376502
-      315B032A5200274E002A4E022A4E02294C022F59012B58013A6D0C4277195185
-      2767A35553922A51922C478E2D468F2D4A902C498D2E488F2E42862745872847
-      862A40720C3D6C09336101305C012F59022C55002B5202284F01285002295004
-      2950052A51032950002C5500335C00396502608F3951853854863850932A478E
-      2D46791834690B316300385B013962003766003C6D0136720646821D48902C53
-      963B46984548A45366B26A64BB7B68B87B56B47348A4554CA3534AA354469846
-      46923A47913744913D48913B46933844923A51932A4686263F7B173973073068
-      012E65023169043A6C0037730743781744831D48821D46821D44841A40740837
-      7307336101325F02315C01305B002E58002F59022C55002A52002B52042A5103
-      2950002B50002E5500315C0138640143730952974753963B53922A50842A427A
-      15386C01345F042D590029500029500029500029500029500029500029500029
-      50002C50042C50032E54022F5600335C01315D0035620136640131640A346306
-      3663023766003B6A033D6A033A6B013A6B0138811A468F2D52974763A35767A2
-      6853A86446995448984555922A46821D3369082D64012A5B002B550028500226
-      4D00284E022851002B56002E5A00305C033662093967073A6B03365E06345E06
-      315B03305B00315C012F59012D59002E5A012A52002A5200295000284F002850
-      0228500228500228500229500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F00284F00284F00284F00284F00284F00284F00284F00295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F00295000
-      285100295000295002274E00284F01274E00274E00274E00274E00274E00274E
-      00274E00274E00274E0029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00284B01284C00284C00284C00274B
-      00264900264801264801274A00274A00274A00274A00274A00274A00274A0027
-      4A00264801264801264801274A00274A00264900274A00274A00274A00274A00
-      274A00274A00284B012B4C022B4C022B4C02274A00274A00274A00274A00274A
-      00274A00274A00274A0026480126480226480127470025440128440228440224
-      4201264101264200264200264200264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000254401264502284402284402284402284402284402284402244300244300
-      244600284A042C4F052D5404335E07426E1537650C3362062E5A012B55002C54
-      022D53012E52002D5000274D01274D01274E00274E00274E00274E00284F0029
-      50002B54002B5801336200326B094378173F7B174079163A76183B6B01366401
-      2F59012C5200294D002A4E022A4E02294C022A4E012D57003766003D6C0A3B6A
-      0344831B346A093B7419437B16437918427817497A1E447918447A174273093E
-      75083D6C09366503315D002E58002B54002C54022C5303295002284F01284F03
-      2950042A51032950002C5500315C01366401426E15447A1745821A45841C3883
-      193772093269023863022E5500385B04305B00346001306B0336720645821A4E
-      8528478E2D48903D53963B52974654964747933B45903A468F2D47862A43821C
-      417B163A7717437817407916427817417A1838751A377307356A092C6503275B
-      01305C00305A022F5B022C6502316904306C083B6C0A3D6C0A336B0C2B640126
-      5A00305D00315C01315B032F59022C56002A5300295100295000294F032B5204
-      2C53032D51002E5402325C0436640141750944841A4E7A21437915427309396C
-      0A3361012D59002A560029500029500029500029500029500029500029500029
-      50002C50042C50032E53032F5601305A02315C01336101336101345E06346003
-      3360003B64023965003A6B033B6A033D6B013973074379185083275287375896
-      3C53963B48902C488F2F42831D4079163C6D013460032D590028550026500229
-      51002750002851002B55002D59002D5900315D04325F02336200315C01315C01
-      305B002F5A002E5A002D59002E5A012E5A012A52002A5200295000284F002850
-      0228500228500228500229500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F00295000
-      285100295000295002274E00284F01274E00274E00274E00274E00274E00274E
-      00274E00274E00274E0029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00284C00284C00284C00274B002649
-      00274A0027490226480124490124490124490124490124490124490124490124
-      4901264802264802264802264802264801264801264801264801274A00274A00
-      274A00274A00274A00284B01294C02294C02274A00274A00274A00274A00274A
-      00274A00274A00274A00274A0026480226480128480126450228440228440228
-      4303264101264200264200264200264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000284402274301284402284402284402274301264200264200223E02224000
-      234500284A032C4F052E52052850002B53012854012A5400285200275000284F
-      01274E002A4E01284C00274D01274D01274E00274E00274E00274E00284F0029
-      50002C55002F5404335C00325D023B6B0B3C6D014074094274083B6A03366302
-      3058002C52002A4E012A4E022A4E02284C002B5100395C02396200406B043660
-      01336C09315C013864093D6A033C6B043F6A03426A053F6A03406A0541690442
-      6A05336101315D002D57002B54002951002B52022B5204295002284F01294F03
-      294F03295002284F002C5500315C013461003864013973074274084074093774
-      063068013562013460012E52002E55002F59022F5901305D003B6402396C0A42
-      781746821E42841A46831B45841E44831B4079164379184373093B6D093B6B01
-      3568003564023564023965003766003A63012A5B072E5B052D59002958022B59
-      003054002F56002E5801305C01345D02336200326307326202326100325C042E
-      58012F59022C56002C5500295100295100284F00295002284E02295000295103
-      2850022950002B5400315C013D64023F6A0341750A43730944740A3B6B013664
-      012D59002A4F07294E0629500029500029500029500029500029500029500029
-      50002C50032B4F022C51012C54022D57002D5900305C01305C01305C01305D00
-      3361013461003461003362003965023A63013A6B0141750A43740C4D7A1D5083
-      274E832547831E42831D4379153E74093B6B01335F00325C042E54022E550031
-      55032750002851002952012B55022B56002D58012D59002F59012D59002E5A01
-      2E59022D58012D58012D58012E59022D58012A52002A5200295000284F002850
-      0228500228500228500229500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000285100285100285100285100285100285100285100285100295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F00295000
-      285100295000295002274E00284F01274E00274E00274E00274E00274E00274E
-      00274E00274E00274E0029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00274B00274B00274A00274A002649
-      0026480126480126480226480126480126480126480126480126480126480126
-      4801264801264801264801264801264801264801264801264801264900274A00
-      274A00274A00274A00274A00274A00274A00274A00274A00274A00274A00274A
-      00274A00274A00274A00274A0026480126480126480226450227430128450028
-      4402264101264200264200264200264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274301264200264101264101264101264000264000264000253F03243F00
-      244201274603284A032C4F05284E02284F01274E02284F01295000285002274D
-      01254B00254A00274A00274D01274D01274E00274E00274E00274E00284F0029
-      5000335501305402385B01365B003965023B6B013B6B013D6A03376502335F00
-      2F56002C51012A4E012A4E022A4E02284C003152012E54022F5404396502315B
-      03355F082D5900365E06315D003361013A63023B64023965003B640239650238
-      64012D59002E5A012A5400285200285100285100274F01274F01295000295002
-      284E02284E02284F012B53012E5800315D003665003B6A033D6A033A6B033B6A
-      03396502335C012B55002B4E042A52042A50042C56002E5900385A033A640042
-      6A043B6A033C6C023F6806416703406A053D6A03326400336101335F00305C03
-      315C01315D00305C03315C01365E00385B012E55002C55002C56002C56002E52
-      052D54002C52002E51012E54022E56003155013155012E55002D54002E550029
-      5201295000284F00295000274E00274E00274D01274D01264B01284F01284F01
-      284F012A4F002C5200335B033C62023E6B0443720B4369053F6A033A6400335C
-      00305400265200264D0129500029500029500029500029500029500029500029
-      50002A4E01294D002A4E012A51012A52002C55002F59022E5A01335C01335C01
-      335C00305D002D5C00315C01305C01315C013965023A63013F6904406A054074
-      0944750B4172084273094268043D6B013663023462022E58003055002F560031
-      5503285100275000274F012851002953002A53002A53002B53012A52002A5200
-      2A52002B53012C55002E55002E55002E55002A52002A5200295000284F002850
-      0228500228500228500229500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F00295000
-      285100295000295002274E00284F01274E00274E00274E00274E00274E00274E
-      00274E00274E00274E0029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00274A00274A00274A00274A002648
-      0126480125470026480226480126480126480126480126480126480126480126
-      4801274700274700274700274700264801264801264801264801264802264802
-      264802264802264802274903284A04284A042648012648012648012648012648
-      01264801264801264801274A0026480126480126480227460328440228450027
-      4301264101264200264200264200264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264000264000264000264000264000264000264000264000274200274301
-      274301234001234001224300224400224700284702294A00284C00284C002A4C
-      00284C00284F012D5104274D01274D01274E00274E00274E00274E00284F0029
-      50002C4F002C4F002B5100355B03375B01386401396502386302346001315C01
-      2F56012C51012A4E022A4E02284C00284C002B50002C52002F4F02345B00355C
-      003157002F56012D51002756002956002C59032D57002D58012B59002E58002B
-      59002E58012C5500295300285100285100285100285100275000295000295002
-      284F01274D01274D012950002B56002E5A01315C01326100336200375B013A5B
-      00325E052E5505284B01274F01294F032B51052D50002F5601305400375A033E
-      5D02336200305C01335C01325C042E58012F5B002B58012B5502275300275201
-      2851002950002A54012A52002D5000305100274E00294D002A4E02294D01294D
-      00294C022A4C002C4B002E4E00284F012C4E012D4D002C4E012A4F002A4E012A
-      4F002A5004294F03284E02274D01264C00284E02284E022A5004274E00274E00
-      284F012A4E012B50002F5600375C003A6302376600366401336003385A032C56
-      002850022951002B550029500029500029500029500029500029500029500029
-      5000284C00284C002A4E012B4F022C51012C52002F56012D54002C5A012C5A01
-      2E58002D59002D58012F59022D58012E58012B59002C5A01335C00345D013362
-      00366205356A033B6B01396403386400375B01375B013056003156002E55002C
-      5101295002295000284F002950022950002950002951002A5101275000285100
-      2750002950002A52002B53012B54002D56012A52002A5200295000284F002850
-      0228500228500228500229500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295002295002295002295002295002295002295002295002295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F00295000
-      285100295000295002274E00284F01274E00274E00274E00274E00274E00274E
-      00274E00274E00274E0029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C00274A00284B01274A002547002648
-      0126480126480226480227430127430127430127430127430127430127430127
-      4301284402264502254401254401264502274603274603284704264801254700
-      2648012749022648012648012648012547002648012648012648012648012648
-      01264801264801264801274A0026480126480126480227460328440228450027
-      4301264101264200264200264200264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264000264000264000264000264000264000264000264000243D00264000
-      284301254100223F002140012242012242012642002744002848012648022648
-      01274A00264C00284F01274D01274D01274E00274E00274E00274E00284F0029
-      50002A5204274B00284F00315600315501375C00375902385C02315C012E5800
-      2E54022C50032B4F032A4E02284C00284F012E50032B5200295200325C043A5A
-      013057023350012D5601214D002350012751032D56052855062957052954032B
-      56052C55002A52002A51012A5101284F00295000284F00284F00295000284F00
-      284F01274D01274D01284F012A52002B55002C55002D5900375B012F55032E56
-      002D5409314D08284A04264C00264E00284B012A4B012D4F022B50002C550031
-      5503315B042D58012E59002C5B002D58012B55002B54032A5603214D00214E00
-      234D00214D00284F01274F01284D03284D03284F012D5000284C00284B01274E
-      00264C00294D002A4F002C5004304E05314F062D51042F50052E4F042C50042D
-      5105294E04294F03274D01284E02284E022A51032950022A5103285100274F01
-      254C00294F032950002D5400395B04375B01385A03385B013155032D50002A4F
-      002953002A510128540129500029500029500029500029500029500029500029
-      5000284C00284C00294D00294D002A4F002A4F002E52002D51002E5500305500
-      2F56003355013155012B54002E55002E55002951032A54062757052C5C042F59
-      01335C00305C01325B00385B01375A03385B002F55032D55032A540029530028
-      4F01295000295000295000284F002950002950002950002B5100284F00284F00
-      284F01284F01284F012950022B50002C51012A52002A5200295000284F002850
-      0228500228500228500229500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000274E00274E00274E00274E00274E00274E00274E00274E00295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F00295000
-      285100295000295002274E00284F01274E00274E00274E00274E00274E00274E
-      00274E00274E00274E0029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C002749022749022648012547002648
-      0126480226480225470128440228440228440228440228440228440228440228
-      4402284402284402284402274301274301284402284402284402284801284801
-      2848012848012547002547002547002648012648012648012648012648012648
-      01264801264801264801274A0026480126480126480226450227430128450028
-      4402264101264200264200264200264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000253F00264000264000264000264000264000264000264000243E02274002
-      284202254001243F002543022644032443002742022645022746032546032445
-      02234701264B03234A00274D01274D01274E00274E00274E00274E00284F0029
-      5000275103284F032B4C012C54062C5101315A09365C02355B012E58012D5601
-      2D52022C50032A4E02294D01284C00274E00234802224C00274E022655002B56
-      002952012950002C50032951032852042A50042A52042A54072A51032B52062A
-      51032B52022A51012B52042B5204295000295000284F00274E002A5101284F00
-      284F01264B01274C022950022950002A51012856032F5901385A033354033055
-      00305001274E02284E02264C00244E01274B00254A04244A02294D002750002C
-      51012C50032A4D032C55002B56002C55002A5200294E04254B03275103295002
-      265002274E02274E032D4E032A5004294F032C50032C4D032B5204295002284F
-      012A52042A5204275103285100285100275000285100284F01285002284F0328
-      4F03294F03294F03295002295002295002284F01284F002A5101274F01295002
-      284F012C4E012C50032B52022E55002E5800335C002D59002A55042F50052950
-      042A5103284F032B500029500029500029500029500029500029500029500029
-      5000294D002A4E01294D00294D00294D002A4E012C50032C50032C55002E5500
-      2C55003155033054022C53032C52002D5100255203295002284F03274F012B51
-      002B52003152012A51032B50002F56013155012C51012B50002C530527520122
-      4E012C51012B50002B50002A4F002950002C50032B4F022B5000285002285002
-      295103285002284F03295004284F03284F032A52002A5200295000284F002850
-      0228500228500228500229500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000284F01284F01284F01284F01284F01284F01284F01284F01295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F00295000
-      285100295000295002274E00284F01274E00274E00274E00274E00274E00274E
-      00274E00274E00274E0029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C002648012547002446002648012648
-      0124460024460024460028440228440228440228440228440228440228440228
-      4402274301284500284500284500284500284500284500274400284402284402
-      2645022746032847042847042746032647042648012648012648012648012648
-      01264801264801264801274A0026480226480128480126450228440228440228
-      4303264101264200264200264200264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000274002274002274002263F01263F01264000264000264000254000274202
-      253E00233E00243F00264101243F00243F00263C012742022844022B4803284A
-      03274A00294D01234A00274D01274D01274E00274E00274E00274E00284F0029
-      5000234D001F4E00264D012D57042848012C50042E4F053151042C55002C5402
-      2B52022C50042A4D03284C00284C00274E00265108254D002952012B4F022854
-      01315503285100274E00294D002C51012E51012E52002B50002C52002D4D002E
-      4E00284F01295002285002295103285100284F00295002274E002A5101285000
-      295002264B01274C02294F032950022950002955022852002C52002952003155
-      012C56002652002351002950022B5100284B01244A02264C04254B0324520020
-      51002F51042E52002C53002C51012C53002A4F002A4E02284F042951002B4F02
-      2C4E01274E00284F01294D012E4E012C5200274E00294D002750002851002951
-      00264C00274E00214C01284F04275100264E00264C00254C00255100284F0327
-      5201284F032850022851002750002851002750002851002953002950002A5103
-      284E022B4F032B4F022C5101335403315501245A01245200215100274C042C4B
-      082A4C06294D012A4B0029500029500029500029500029500029500029500029
-      50002B50002B5000294D002A4E012A4E012C50032B4F032C50042B55002E5500
-      3054002B53012B52042C50042C50042C50042F51042950002C51012E52002E4E
-      002C4E01314C03304D042E4E012C50042C50032950002850022C54062752091F
-      4D002C52002B4F022C50032A4F002A4E012A4E022A4D032A4E022B52042A5103
-      2B52042B52042851002851002750002750002A52002A5200295000284F002850
-      0228500228500228500229500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000274E00274E00274E00274E00274E00274E00274E00274E00295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F00295000
-      285100295000295002274E00284F01274E00274E00274E00274E00274E00274E
-      00274E00274E00274E0029500029500029500029500029500029500029500029
-      5000284F00295000285100295000295002274E00284F01274E00284C00284C00
-      284C00284C00284C00284C00284C00284C002446002446002446002547002547
-      0024460025470124460024420124420124420124420124420124420124420124
-      4201244201254401264502284402274301284402284402284402284402284402
-      2743012844022847042847042746032746032648022648022648022648022648
-      0226480226480226480226480126480226480127470025440128440228440224
-      4201264101264200264200264200264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002442012442012743012645002847
-      02264801274A00274A00274A00284C00284C00284C002A4E01294D01284C0029
-      4D01295000295000295000295000295000295000295000295000274E00284F01
-      274E00295002295000285100295000284F002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F00284F00
-      284F00284F00284F00284F00284F00284F002950002950002950002950002950
-      00295000295000295000274E00284F01274E0029500229500028510029500028
-      4F00295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      50002950002950002950002950002950002950002950002950002A52002A5200
-      2A52002A52002A52002A52002A52002A52002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      295000295000295000295000295000295000284F00284F00284F00284F00284F
-      00284F00284F00284F0029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000284F00274E00274E00274E00274E00274D01274D01284C00284C00
-      294D01284C00274A00274A00274A00274A002449012648022749032746032544
-      0126450226450224430026410126410126410126410126410126410126410126
-      4101264101264101264101264101264101264101264101264101274301274301
-      2743012743012743012743012743012743012446002446002446002446002446
-      0024460024460024460023480023480024490126480125470024460024460024
-      4600284402284402274301264200264200264200264101254000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002442012642002844022844022746
-      01264801274902274A00274A00284B01284C00294D012A4E012A4E02284C0028
-      4C00295000295000295000295000295000295000295000295000274E00284F01
-      274E00295002295000285100295000284F002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      00295000295000295000274E00284F01274E0029500229500028510029500028
-      4F00295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      50002950002950002950002950002950002950002950002950002A52002A5200
-      2A52002A52002A52002A52002A52002A52002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000284F00274E00274E00274E00274E00274D01274D01284C00294D01
-      284C00274B00264900274A00274A00274A002648012547012746032844022743
-      0128440226450224430026420026420026420026420026420026420026420026
-      4200264200264200264200264200264200264200264200264200284402284402
-      2844022844022844022844022844022844022246002246002246002246002246
-      0022460022460022460026480226480225470125470124460024460024460024
-      4600284402274301274301264200264200264101254000254000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002443002642002844022743012645
-      00254701264801264801264801274A00284B01284C00284C00284C00284C0028
-      4C00295000295000295000295000295000295000295000295000274E00284F01
-      274E00295002295000285100295000284F002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000285100285100
-      2851002851002851002851002851002851002950002950002950002950002950
-      00295000295000295000274E00284F01274E0029500229500028510029500028
-      4F00295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002851002851002851002851002851
-      0028510028510028510029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000284F00274E00274E00274E00274E00274D01274D01284C00294D01
-      284C00274B00274A00274A002749022648012847022746012844022743012844
-      0228440225440123410026420026420026420026420026420026420026420026
-      4200264200264200264200264200264200264200264200264200284402284402
-      2844022844022844022844022844022844022844022844022844022844022844
-      0228440228440228440225440125440126450226450226450226450226450226
-      4502274301264200264200264200264200274101264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002342002443002743012544012645
-      02264500274601284702244600254700274A00284C00284C00284C00284C0029
-      4D01295000295000295000295000295000295000295000295000274E00284F01
-      274E00295002295000285100295000284F002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      00295000295000295000274E00284F01274E0029500229500028510029500028
-      4F00295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F00284F00
-      284F00284F00284F00284F00284F00284F002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000284F00274E00274E00274E00274E00274D01274D01284C00284C00
-      274B00274A00274A002648012547002446002544002844022844022743012743
-      0124430023410024420126420026420026420026420026420026420026420026
-      4200264200264200264200264200264200264200264200264200264200264200
-      2642002642002642002642002642002642002844022844022844022844022844
-      0228440228440228440228440228440227430127430127430127430127430128
-      4402274301264200264200274200274101264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002443002443002443002443002544
-      01274301284402264500244600244600254700274A00284C00284C00284C0028
-      4C00295000295000295000295000295000295000295000295000274E00284F01
-      274E00295002295000285100295000284F002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295002295002
-      2950022950022950022950022950022950022950002950002950002950002950
-      00295000295000295000274E00284F01274E0029500229500028510029500028
-      4F00295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000285002285002
-      2850022850022850022850022850022850022950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950022950022950022950022950
-      0229500229500229500229500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000284F00274E00274E00274E00274E00274D01274D01284C00284C00
-      274B00274A002648012446002446002446002443002442012442012442012443
-      0024420123410023400126400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264200264200
-      2642002642002642002642002642002642002443002443002443002443002443
-      0024430024430024430027430128440228440228440228440225440124430024
-      4300264200264200264200264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002341002242012242012443002743
-      01284402284402274301244600244600244600264900284B01294C02284C0029
-      4D01295000295000295000295000295000295000295000295000274E00284F01
-      274E00295002295000285100295000284F002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000274E00274E00
-      274E00274E00274E00274E00274E00274E002950002950002950002950002950
-      00295000295000295000274E00284F01274E0029500229500028510029500028
-      4F00295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000285002285002
-      2850022850022850022850022850022850022950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      295000295000295000295000295000295000274E00274E00274E00274E00274E
-      00274E00274E00274E0029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000284F00274E00274E00274E00274E00274D01274D01284C00284C00
-      274A002648012446002446002446002345002341002442012442012341002240
-      00224000223F00233F0326400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264200264200
-      2642002642002642002642002642002642002443002443002443002443002443
-      0024430024430024430028440226450225440124430024430024430024420124
-      4201274301264200264000253F00264000264000264000243F00264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002341002442012242012443002443
-      00264200264200244201244600254701264802274902284B01284B01294C0229
-      4D01295000295000295000295000295000295000295000295000274E00284F01
-      274E00295002295000285100295000284F002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000284F01284F01
-      284F01284F01284F01284F01284F01284F012950002950002950002950002950
-      00295000295000295000274E00284F01274E0029500229500028510029500028
-      4F00295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000285002285002
-      2850022850022850022850022850022850022950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      295000295000295000295000295000295000284F01284F01284F01284F01284F
-      01284F01284F01284F0129500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000284F00274E00274E00274E00274E00274D01274D01284C00274B00
-      2649002446002446002446002345002244002240002341002340012240002341
-      00234001233F03233F0326400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264200264200
-      2642002642002642002642002642002642002240002240002240002240002240
-      0022400022400022400024430024430024430024430023410023410022400022
-      4000264200264200264000264000264000264000254000254000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      264000264000264000264000264000264000264000264000264000264000263F
-      01263F01263F01263F0126400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      0000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002540012341002341002443002342
-      00244300244201244201234500244600254701264801264801284B01294C0229
-      4C02295000295000295000295000295000295000295000295000274E00284F01
-      274E00295002295000285100295000284F002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000274E00274E00
-      274E00274E00274E00274E00274E00274E002950002950002950002950002950
-      00295000295000295000274E00284F01274E0029500229500028510029500028
-      4F00295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000285002285002
-      2850022850022850022850022850022850022950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      295000295000295000295000295000295000274E00274E00274E00274E00274E
-      00274E00274E00274E0029500029500029500029500029500029500029500029
-      5000295000295000295000295000295000295000295000295000295000295000
-      2950002950002950002950002950002950002950002950002950002950002950
-      0029500029500029500029500029500029500029500029500029500029500029
-      5000295000284F00274E00274E00274E00274E00274D01274D01284C00274B00
-      264900244600244600244600234500234500223F002340012340012340012340
-      01223F00243E02253E0426400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264200264200
-      264200264200264200264200264200264200223F00223F00223F00223F00223F
-      00223F00223F00223F00264200264200244201244201234100223F0023400122
-      3F00264200264200264000264000264000254000243F00254000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      2640002640002640002640002640002640002640002640002640002640002640
-      0026400026400026400026400026400026400026400026400026400026400026
-      4000264000264000264000264000264000264000264000264000264000264000
-      264000264000264000264000264000264000264000264000264000253F00253E
-      00243D00243D00243D00243D00243D00243D00243D00243D00243D00243D0024
-      3D00243D00243D00243D00243D00243D00243D00243D00243D00243D00243D00
-      0000}
-  end
-  object TopBevel: TBevel
-    Left = -9
-    Top = -1
-    Width = 443
-    Height = 89
-  end
-  object InfoLabel1: TLabel
-    Left = 48
-    Top = 96
-    Width = 369
-    Height = 33
-    AutoSize = False
-    Caption = 
-      'This tool will import your Wolfpack definition files and create ' +
-      'a new categories.db for the WP GM Tool.'
-    WordWrap = True
-  end
-  object WolfpackIcon: TImage
-    Left = 8
-    Top = 96
-    Width = 32
-    Height = 32
-    AutoSize = True
-    Picture.Data = {
-      055449636F6E0000010006001010020000000000B00000006600000010100000
-      0000000068050000160100001010000000000000680300007E06000020200200
-      0000000030010000E60900002020000000000000A8080000160B000020200000
-      00000000A80C0000BE1300002800000010000000200000000100010000000000
-      8000000000000000000000000000000000000000FFFFFF0000000000FFFFB9BC
-      FFF70E15E7FD0E0FFFFE07F5FF8300009FA300FBCB39FFADFF67FFFFF7EFFBF6
-      FBEF0000FF9FF500FE3F2B07F8FFF607F17F1614EDFF0D07DEFF000003FFB9BC
-      00030E1500010E0F000007F500000000000000FB0001FFAD0007FFFF000FFBF6
-      000F0000001FF500003F2B07007FF607007F16140C7F0D071E7F000028000000
-      1000000020000000010008000000000040010000000000000000000000000000
-      0000000000000000000008000008080000081000080810000810100008101800
-      0018210010182100102121000818290018293100212931003131310021293900
-      183139002131390029313900213142002939420029394A0029424A0031424A00
-      2942520031425200314A5200314A5A00394A5A0039525A003152630039526300
-      42526300425A6300425A6B00425A7300426373004A6373004A637B004A6B7B00
-      526B7B004A6B8400527384005A7384005A738C005A7B8C00637B8C005A7B9400
-      6384940063849C006B8C9C006B8CA5006B94A5007394AD007B9CAD007B9CB500
-      7BA5B5007BA5BD0084A5BD009CADBD0084ADC6008CADC6008CB5C6008CB5CE00
-      94B5CE009CBDCE00A5C6DE00ADCEDE00BDD6E700ADD6EF00B5DEEF00D6E7EF00
-      DEF7FF00FFFFFF00000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000016000308002900000000000000000000120B03181F00101F27292929
-      2F290000121F1F3332080005050000000000370023272329120815230C101F0C
-      0C12033A29231F161818161F29343B333B44000D1F2F361818231615292F292F
-      394117100C18372F1C2F1F0B343D181C293241001C001523181F1818321D2937
-      3F0000001C080B1F2E1C00101203232F0000000008000016232F1D1218072200
-      000000000000050910122923283F000000000000000012120B181F3441000000
-      0000000018290000233D41432E000000000000000512150F4300371D34000000
-      0000000000121D3D000036072900000000000000102D41000000002F1F000000
-      0000000003FFB9BC00030E1500010E0F000007F500000000000000FB0001FFAD
-      0007FFFF000FFBF6001F0000003FF500007F2B07007FF607047F16140C7F0D07
-      1E7F000028000000100000002000000001001800000000004003000000000000
-      00000000000000000000000030434D020307090E10121B210003065E77860000
-      000000000000000000000000000000000000000000000000000000002A39431E
-      2A32090F14394D58445A6800020628373F44576151697A5F7B8B597587597788
-      6484975B78880000000000002D3D46455C694358676F93A66A8CA1141C23050A
-      0E0810140B121701060A00000006090B0103050002007BA0B50000004F697A50
-      6D7D4D67755975862C3D47141F262F414B4C6775222F3827343D435A67222F37
-      202D362C3D48000C149FAEB95A7687476070455B6A31434F374C583548543141
-      4C445A685672827195A984AAC16D90A389AEC4A9D2EA000000343332435B6763
-      8194789AB13A4E5A3345504D667530424C2E404A567484638395597687638294
-      85A6BAA1C4DA2A42512D363C222F373749527EA4BB6584963C535E648396445D
-      6A1E2B337496AB8EB5CC3346523A515C5C788A688DA6A2C5DA0000003C515E00
-      00002F404B4A6371374B56475F6F354854384C596B8EA03F56655876857FA2B7
-      90B5CB0000000000000000003C505E111A211D2A31465F6E5F7F903C505D0000
-      00233038283D430D0F124D6878618399000000000000000000000000161E2400
-      0000070C0E30404D4963706A8B9E3F55632B3A463B4E5A071A25405F74D2E7EF
-      0000000000000000000000000205040000000E161B16202624323A2F3F4A5472
-      814864784E6F8399BACDDEF6FF00000000000000000000000000000003050606
-      090B2A3B452C3C471D2D36364E5C415C6D7797A9A1C3D8000000000000000000
-      0000000000000000000000003244505876870000000000004962708BB0C2A1C4
-      DAB7DAEF5D7D920000000000000000000000000000000000000000000E161A2E
-      3E492D404B1A303FBDD6E10000007FA4BB3351637E9DAF000000000000000000
-      0000000000000000000000000000002234403F57648FB6CD0000000000007B9D
-      B00E1F2A58738400000000000000000000000000000000000000000026313A64
-      7988ACCCDE000000000000000000000000658698465F6E000000000000000000
-      00000000000000000000000003FFB9BC00030E1500010E0F000007F500000000
-      000000FB0001FFAD0007FFFF000FFBF6000F0000001FF500007F2B07007FF607
-      047F16140C7F0D071E7F00002800000020000000400000000100010000000000
-      0001000000000000000000000000000000000000FFFFFF0000000000FFEFFFFF
-      FFF7FFFFFFF9FFFFFFFFFF9FFF7FFFF7FCFFFFFFFEFFFFFFFFFFF7DFFFFFC10E
-      7FFF790F73FFE80FC3FF9F86E1EF8F91F9EF8F8FFFEF983FFFFE72FFFFFFF5FF
-      FF9FF5FFFFCF3DFFFFFFF9FFFFFB61FFFFFF87FFFFFE0FFFFFFC3FFFDFB0BFFF
-      DF80BFFFFF82BFFFF7037FFFFEF7FFFFF9F3FFFFF7FDFFFF6FFEFFFF000FFFFF
-      0007FFFF0001FFFF0000001F0000000700000007000000030000000100000000
-      000000000000000000000000000000010000000F0000003F000000FF000001FF
-      000001FF000001FF000001FF000001FF000007FF00000FFF00003FFF00003FFF
-      00003FFF00003FFF00007FFF00F07FFF01F07FFF07FC7FFF0FFE7FFF28000000
-      2000000040000000010008000000000080040000000000000000000000000000
-      0000000000000000000008000008080000081000080810000810100008101800
-      0818180010181800101821001021210018212100102129001821290018292900
-      1821310018293100212931002131310021293900083139001831390021313900
-      293139002131420029314200213942002939420029394A0029424A0031424A00
-      31425200314A5200394A5200394A5A0039525A0042525A003952630042526300
-      395A6300425A6300395A6B00425A6B004A5A6B0042636B004A636B005A636B00
-      426373004A6373004A637B004A6B7B00526B7B0052737B004A6B8400526B8400
-      527384005A73840052738C005A738C005A7B8C00637B8C005A7B9400637B9400
-      6384940063849C006B849C00638C9C006B8C9C00738C9C006B8CA5006B94A500
-      7394A5007B94A5006B94AD007394AD00739CAD007B9CAD00849CAD007B9CB500
-      7BA5B50084A5B50084A5BD0084ADBD008CADBD0084ADC6008CADC600A5B5C600
-      8CB5CE0094B5CE0094BDCE009CBDCE0094BDD6009CBDD600A5BDD600A5C6D600
-      A5C6DE00A5CEDE00ADCEDE00B5CEDE00ADCEE700ADD6E700B5D6E700B5D6EF00
-      BDD6EF00C6DEEF00BDDEF700C6DEF700DEEFF700CEEFFF00D6EFFF00DEEFFF00
-      D6F7FF00DEF7FF00E7FFFF00F7FFFF00FFFFFF00000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000018120900080A080F0A0F2F0000000000000000000000000000000000
-      000000001F1F0A00000F09090508050000000000000000000000000000000000
-      000000000A1E120003111226120A08001D3F0000000000000000000000000000
-      00000000121F1F1209121233373718000505091E2C373C372637372C333F3F00
-      000000000A232326182326333F372311090A050000030505050912181D12051F
-      0000000012262F1F26373F46371F0A050512180F091818050000000000000000
-      2C000000233333262F37373F3718050A18232F2F1F09000518120F0A0A0A0A09
-      1137000026372F2C2F251F26120A1E261211261F1F181F373F372F2626333F37
-      18001F0037363737262F1F1F1F1E121E1E1F2F261F333E5050453F333F3F5054
-      120000003E251D372F231F26262F1F1F1F1F182F3F372F37373F453750505858
-      0300002E3F2F18373F3E261F122F26262C181E2C372F373F37474E4747586C50
-      120A000018263F47453F331F122337231E1F18181F3F3F37332F37333745544F
-      47353C562309264747473C2F261F263E261F181F37454745262526232F3F4536
-      475E00002F0F00183C3F45372326373E2625121837505B4E1F25332F374F544E
-      000000001F1805031F262F372F26334533231218334745262F3F4F47584E0000
-      00000000261D11030A25121F1F1218252312183F543718123F3F365800000000
-      000000002F1811050A1F26262F261F0A000018371400001F581F440000000000
-      000000001F0F120F0818251F3C3F471E0300000A3424001F47123F0000000000
-      000000001205050500121E1F2F263F471F1F0A183F3F052618265E0000000000
-      0000000011000000000918121F252F3737252F261F0A18262657000000000000
-      000000000A00000000051809121E1F18333F2C333F2F3D475B00000000000000
-      00000000050000000A0A0908181F181F2F3736333746636F0000000000000000
-      00000000000000000A261F180F1E1F2F2625253D4E6500000000000000000000
-      00000000080305050A1818180F23262F37334765625000000000000000000000
-      00000000180A452F0000090A093F372F455B6C682F4500000000000000000000
-      000000000A1E4E18000000001857585E645B5E502F5800000000000000000000
-      00000000051818000F1F18153C0000005E463745375D00000000000000000000
-      00000000000812263F2636265000000054462F263F0000000000000000000000
-      0000000000001F26121D375800000000582F1E18370000000000000000000000
-      0000000000001F18124465000000000065471F18370000000000000000000000
-      0000000000000F1F5E0000000000000000005425370000000000000000000000
-      000000004D18376B0000000000000000000000452F0000000000000000000000
-      00000000001FFFFF001FFFFF0003FFFF0000001F0000000F0000000700000003
-      0000000100000001000000000000000000000000000000030000000F0000003F
-      000000FF000001FF000001FF000001FF000003FF000007FF00000FFF00003FFF
-      00003FFF00003FFF00003FFF00703FFF00707FFF00F07FFF01F07FFF07FC7FFF
-      0FFE7FFF2800000020000000400000000100180000000000800C000000000000
-      0000000000000000000000002A3A4223303A131C2302050610191C1D282F1019
-      1C1C27301A252A1C28314E667800000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000374956374B561A252D0202020202021D2932131C
-      23141F2509111410191D0B151B49637000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000018232830414D27343D060A0F070F12202E372230
-      3942576425333D18222A10191C0202062E414D00000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000022303737495534475126343E131C2224323A2835
-      3F506C7B5C7A8E5571812D3C46050A0E0C14180C151C111C2300000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000001923293A505B3D515D4459692F3F4B3C505D4259
-      66506C7B6585975D7A8D3C505D202D35131C2019242A091013020507050A0F09
-      0F140912180F181D0B1318131E25233038283A432F414B26353F0E181D3A4C56
-      00000000000000000000000025333C435A674963703548534258665774856383
-      966F92A55B788A3346521B272E0F151A0F1A1D25333C293B431F2D35141D232C
-      3C452939420E161B050A0E02020202020205070A040508020202020202020202
-      4F626F0000000000000000003C505F506B79526E7F4359664C64725976865976
-      856B8B9F5672832D3D470B11151620282838433C505D4F6B7B49627134465213
-      1C230202020B111429394328373F1F2D321622261823281B242A182229151F25
-      202D35597788000000000000465F6B5A77894C657447606D4B65743F55623345
-      5141576526353E1C292F31424E42586526353D232F39475F6B3446523548552F
-      3F4B3B4F5D5672836383955C788A4B6574415563415765516E7C658397557082
-      2D3E48020202384B56000000587284536F805A77885570824158654E66773C4F
-      5C384B573A4E5A30434E24343C32454F30424B354852496271475F6D34475252
-      6E7C617E9084AABF80A5BB6D8DA2678599526D7E60809261819583A4BB88ADC2
-      24343C020202020202000000617F903E56622F414C5772834C65753B505B384E
-      5A435867465F6C4C6474374855384B583346503345502C3C464C65756A8A9F59
-      76864C64755F7C8E59768567869A6E8FA157718285A7B985A5BB95B8CA95B9CD
-      070F150202020202025F656969899D4C66752E3D465770826A899E617F904257
-      63374C5723313A496271445C6A445A6747606C2C3D4631444E47606E5570804F
-      69795D7A8B6C8D9F5672827296A97B9EB2799CAF7698AD99BBCFC9E8F982A8BC
-      24313B18252C0204090202022C3C46435966638496769AAE6F8FA3618092536E
-      7E37485327333D3D515F5672833C515D30424C3547552E3F482D3E493A4F5962
-      819367869A5C7A8B536D7E4F69785C788A526C7B5C7A8D6F8FA38CADC27EA0B6
-      7094A94E6C80627C8BA0B4C03D525F111B20445B697496AB7194A97294A9607F
-      8F4B6371425A69384D58455B6A617F92445C6A3549562E3E473A4F5B5A76866C
-      8CA0789DAF6C8CA04257643F5662455C6B3C515C4D66766A899A6D8EA2516E82
-      7497ABAACADE0000000000004C63721F2D34020202283841617E8F6585986D8C
-      A25A77863D525D465D6C597586617F92465F6D3E556127353F2E3D485A778883
-      A5BB96B9D07C9FB4374B563F5561526E7C4E6A785772847FA2B688ACC3799EB4
-      0000000000000000000000003B4F5A2D3D470E1519080F13344650445B6B4C62
-      70537080486170415763506B7A6C8DA0516D7B3C515D233039273741516B7C72
-      96AB6A8BA0455D6D4B62716280937CA1B6789CAF90B3C87B9DB1000000000000
-      000000000000000000000000455C6B2E414B222E35070E111B262D3E55622535
-      3D394D59394D592332392C3D473E53623A505C24323D2938426B899C83ACC156
-      70802A3C46203038698999678899536E8097B9CD000000000000000000000000
-      0000000000000000000000004D6575283841222F370C12161923283C4F5B455F
-      6B485F6E4F6A79465D6D394C581A252D0406090202022E3B445C778808353902
-      020202020232465297BBCF3A4F5C708C9E000000000000000000000000000000
-      000000000000000000000000384B581D2A3224323C1C2930111B1F2A3B473F55
-      63394E5A607E8F6685987195A932434E080E1202020202020216202657707B43
-      525D0202023749557994A522313B698B9F000000000000000000000000000000
-      00000000000000000000000026353F0F151B0E151A0E151A06080C2230383344
-      4F3848564C6472455B6A6180927193A73A4E593446531B252E2C3B4864819064
-      81930E151B415765243541435C6EA1C0D0000000000000000000000000000000
-      000000000000000000000000222F38020202020202020202020202131D232C3A
-      4524303A384D573D55624E67785977865774853F5562486170465D6B32445019
-      252C263842435D6D415C6F8AB3CB000000000000000000000000000000000000
-      0000000000000000000000001822280202020202020202020207070A11162939
-      42151E2425343C30434C3444502E3D48516C7A61809249616F506A7A62829546
-      60715D7E907198AE000000000000000000000000000000000000000000000000
-      0000000000000000000000000B111402020202020204060819232A192429141E
-      23121B1E2C3945384C562F3F4B3A4E5A4B64725C798B556F80516B7E5B7B8F6D
-      90A4ACCDE2000000000000000000000000000000000000000000000000000000
-      000000000000000000000000020608020202020202020202182328455C6B394D
-      592839431F2D3533444F394D584C6575475F6E3F57643D58665F7F937F9EB2B1
-      D1E4000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000111A1E0A0F120910130F181C19262D2D3E492C3C
-      462E3F491D2A313B515F445B674D6777577486516C7F7294A7B4D4E6B1CDDE8C
-      ACBD000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000002839411620276D8DA34F6978020608020206141D
-      23182227131D2365889C5776894F6A7A6B8DA299BCD1CDEBFEC0DEEF4662746F
-      8EA1000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000018232A30424C799EB32A3B450202020202020202
-      020202022E3F4B8BB3CA93B6CCA4C6D8AFD1E198BBD0A5C8DB83A7BD4966789A
-      B9CD000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000E13182737422A3B450202061F2A313548552837
-      411F313B637C8B000000000000000000A2C0D36E90A75371836F8FA4557284A1
-      BED0000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000002020211191E25333D435A67608090435867526F
-      81425F6E82A2B400000000000000000089ADC16E93A9486270425C6B65849700
-      0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000020202020205394E58455C6C24333A2E414E5977
-      8994B7CC00000000000000000000000093B6CB48657730434F2637425F7A8D00
-      0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000002020205080A374C5626374220313D718E9E0000
-      00000000000000000000000000000000BBD7E97B9CAF384F5C2535415F7A8C00
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000202050205091B27323449560000000000000000
-      000000000000000000000000000000000000000000008CAEC13D596A59728300
-      0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000859FAE2A3B445A72810000000000000000000000
-      000000000000000000000000000000000000000000000000006F8EA247627200
-      0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000001FFFFF000FFFFF0007FFFF0001FFFF0000000F
-      0000000700000003000000010000000100000000000000000000000000000003
-      0000000F0000003F000000FF000001FF000001FF000001FF000003FF00000FFF
-      00001FFF00003FFF00003FFF00003FFF00003FFF00703FFF00707FFF00F07FFF
-      03F07FFF0FFC7FFF1FFE7FFF}
-  end
-  object CancelButton: TButton
-    Left = 344
-    Top = 248
-    Width = 75
-    Height = 25
-    Caption = '&amp;Cancel'
-    TabOrder = 0
-    OnClick = CancelButtonClick
-  end
-  object NextButton: TButton
-    Left = 264
-    Top = 248
-    Width = 75
-    Height = 25
-    Caption = '&amp;Next'
-    TabOrder = 1
-    OnClick = NextButtonClick
-  end
-  object GroupBox1: TGroupBox
-    Left = 48
-    Top = 136
-    Width = 369
-    Height = 89
-    Caption = 'Wolfpack Installation Folder'
-    TabOrder = 2
-    object InfoLabel2: TLabel
-      Left = 8
-      Top = 56
-      Width = 284
-      Height = 13
-      Caption = 'Please select the wolfpack.xml of your Wolfpack installation.'
-    end
-    object WolfpackPath: TEdit
-      Left = 8
-      Top = 24
-      Width = 265
-      Height = 21
-      TabOrder = 0
-    end
-    object BrowseButton: TButton
-      Left = 280
-      Top = 24
-      Width = 75
-      Height = 21
-      Caption = 'Browse'
-      TabOrder = 1
-      OnClick = BrowseButtonClick
-    end
-  end
-  object XPManifest: TXPManifest
-    Left = 384
-    Top = 104
-  end
-  object OpenFolderDialog: TOpenFolderDialog
-    Title = 'Please select your Wolfpack installation folder.'
-    Options = [flReturnOnlyFSDirs, flShowStatusText]
-    OnSelectionChange = OpenFolderDialogSelectionChange
-    Left = 8
-    Top = 152
-  end
-end

Deleted: trunk/WPGM/ImportDefinitions/Main.~pas
===================================================================
--- trunk/WPGM/ImportDefinitions/Main.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/ImportDefinitions/Main.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,108 +0,0 @@
-unit Main;
-
-interface
-
-uses
-  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
-  Dialogs, ExtCtrls, StdCtrls, XPMan, OpenFolderDialog;
-
-type
-  TMainForm = class(TForm)
-    BottomBevel: TBevel;
-    CancelButton: TButton;
-    NextButton: TButton;
-    TopImage: TImage;
-    TopBevel: TBevel;
-    InfoLabel1: TLabel;
-    WolfpackIcon: TImage;
-    XPManifest: TXPManifest;
-    GroupBox1: TGroupBox;
-    WolfpackPath: TEdit;
-    BrowseButton: TButton;
-    InfoLabel2: TLabel;
-    OpenFolderDialog: TOpenFolderDialog;
-    procedure CancelButtonClick(Sender: TObject);
-    procedure BrowseButtonClick(Sender: TObject);
-    procedure OpenFolderDialogSelectionChange(Sender: TObject);
-    procedure FormCreate(Sender: TObject);
-    procedure NextButtonClick(Sender: TObject);
-  private
-    { Private declarations }
-  public
-    { Public declarations }
-  end;
-
-var
-  MainForm: TMainForm;
-
-implementation
-
-{$R *.dfm}
-
-uses Registry, WpConfiguration;
-
-{
-  Close the wizard.
-}
-procedure TMainForm.CancelButtonClick(Sender: TObject);
-begin
-  Close;
-end;
-
-{
-  Let the user select a directory.
-}
-procedure TMainForm.BrowseButtonClick(Sender: TObject);
-begin
-  if OpenFolderDialog.Execute then
-    WolfpackPath.Text := OpenFolderDialog.Folder;
-end;
-
-{
-  Show the user if the directory he selected is valid or not.
-}
-procedure TMainForm.OpenFolderDialogSelectionChange(Sender: TObject);
-begin
-  if FileExists(IncludeTrailingPathDelimiter(OpenFolderDialog.Folder) + 'wolfpack.xml') then
-    OpenFolderDialog.StatusText := 'This is a valid Wolfpack installation directory.'
-  else
-    OpenFolderDialog.StatusText := 'This is not a valid Wolfpack installation directory.';
-end;
-
-(*
-  Query the Wolfpack installation directory from the uninstallation database
-  @ HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{44306150-2736-4554-ACD5-957D5F12604B}}_is1
-*)
-procedure TMainForm.FormCreate(Sender: TObject);
-var
-  Registry: TRegistry;
-begin
-  Registry := TRegistry.Create;
-  Registry.RootKey := HKEY_LOCAL_MACHINE;
-
-  // Open the Uninstall Key.
-  if not Registry.OpenKeyReadOnly('SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{44306150-2736-4554-ACD5-957D5F12604B}}_is1') then begin
-    Registry.Free;
-    exit;
-  end;
-
-  // Read Installation Directory
-  WolfpackPath.Text := Registry.ReadString('Inno Setup: App Path');
-
-  Registry.Free;
-end;
-
-procedure TMainForm.NextButtonClick(Sender: TObject);
-var
-  WpConfiguration: TWpConfiguration;
-begin
-  // Try to load the configuration file
-  try
-    WpConfiguration := TWpConfiguration.Create(IncludeTrailingPathDelimiter(WolfpackPath.Text) + 'wolfpack.xml');
-    WpConfiguration.Free;
-  except
-    Application.MessageBox('An error occured while loading the wolfpack.xml file from your Wolfpack installation directory', 'Error', MB_OK+MB_ICONERROR);
-  end;
-end;
-
-end.

Deleted: trunk/WPGM/ImportDefinitions/Strlib.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/ImportDefinitions/WpConfiguration.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/ImportDefinitions/WpConfiguration.~pas
===================================================================
--- trunk/WPGM/ImportDefinitions/WpConfiguration.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/ImportDefinitions/WpConfiguration.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,110 +0,0 @@
-unit WpConfiguration;
-
-interface
-
-uses Classes;
-
-type TWpConfiguration = class
-  protected
-    procedure processOption(Group: String; Name: String; Value: String);
-
-  public
-    ImportDefinitions: TStringList;
-
-    constructor Create(Filename: String);
-    destructor Destroy; override;
-end;
-
-implementation
-
-uses SysUtils, XmlReader, StrLib;
-
-{
-  Helper Function
-}
-function LoadFile( FileName: String ): String;
-var
-	Input: TStream;
-	StringStream: TStringStream;
-begin
-	Input := TFileStream.Create( FileName, fmOpenRead+fmShareDenyNone );
-	StringStream := TStringStream.Create( '' );
-  StringStream.CopyFrom( Input, Input.Size );
-  Result := StringStream.DataString;
-  StringStream.Free;
-  Input.Free;
-end;
-
-{
-  Constructor for the Wp Configuration class.
-}
-constructor TWpConfiguration.Create(Filename: String);
-var
-  XmlReader: TXMLStringReader;
-  Document, Outmost, Group, Option: TXMLNode;
-  i, j: Integer;
-  Content, GroupName, OptionName, OptionValue: String;
-begin
-  ImportDefinitions := TStringList.Create;
-
-  Content := LoadFile(Filename);
-
-  XmlReader := TXMLStringReader.Create(Content);
-  Document := XmlReader.ParseDocument;
-
-  // Get outmost node
-  Outmost := Document.FindNode('preferences');
-
-  for i := 0 to Outmost.NodeCount - 1 do begin
-    Group := Outmost.Nodes[i];
-
-    // We found a group
-    if (Group.Name = 'group') and (Group.NodeType = xntElement) then begin
-      GroupName := '';
-      Group.LookupBasicData('name', GroupName);
-
-      if GroupName = '' then
-        continue; // Skip this group without a name.
-
-      // Parse options
-      for j := 0 to Group.NodeCount - 1 do begin
-        Option := Group.Nodes[j];
-
-        if (Option.Name = 'option') and (Option.NodeType = xntElement) then begin
-          OptionName := '';
-          Option.LookupBasicData('name', OptionName);
-
-          if OptionName = '' then
-            continue; // Skip option without a name.
-
-          Option.LookupBasicData('value', OptionValue);
-          processOption(GroupName, OptionName, OptionValue);          
-        end;
-      end;
-    end;
-  end;
-
-  Document.Free;
-  XmlReader.Free;
-end;
-
-{
-  Destructor for the configuration class.
-}
-destructor TWpConfiguration.Destroy;
-begin
-  ImportDefinitions.Free;
-  inherited;
-end;
-
-{
-  Process a wp configuration node.
-}
-procedure TWpConfiguration.processOption(Group: String; Name: String; Value: String);
-begin
-  if (Group = 'General') and (Name = 'Definitions') then begin
-    StrLib.Split(Value, ';', ImportDefinitions);
-  end;
-end;
-
-end.

Deleted: trunk/WPGM/ImportDefinitions/XmlReader.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/ImportDefinitions/XmlReader.~pas
===================================================================
--- trunk/WPGM/ImportDefinitions/XmlReader.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/ImportDefinitions/XmlReader.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,772 +0,0 @@
-{:
-PURPOSE AND IMPLEMENTATION:
-	This unit defines classes for parsing a well-formed standalone XML document in
-  to a tree of nodes describing the data therein.  These classes only support a
-  subset of the XML 1.0 recommendation and have not been analyzed for
-  conformance with the recommendation.  This module also only supports 8-bit
-  character sets and makes no special allowances for UTF-8.  Nor has any support
-  for the &quot;&lt;!DOCTYPE&quot; node been implemented.  Parsing of the XML declaration
-  lazily uses the attribute parsing code which is not correct (but works).  This
-  module also freely trims element whitespace which is not always correct.
-
-  Q:  Why use this module instead of Microsoft's XML parser or the OpenXML
-      project?
-
-  A:  I wrote this module to be free of dependencies on outside libraries and to
-      be small and fast.  Neither of the above libraries met that criteria.  I
-      didn't like the idea of requiring my users to install Microsoft's XML
-      library (and the potential compatibility problems that arise).  Nor did I
-      like the idea of adding 135 kb (OpenXML) to my executable just to load files
-      in XML format.  Instead this unit only uses about 7 kb.
-
-  This was written for Delphi 5.  It may work for other versions, but does
-  require method overloading which was introduced in Delphi 4.
-
-HISTORY:
-	09/12/00 - Created by Colin Patrick Sarsfield
-
-DISCLAIMER:
-  Use at your own risk.
-
-COPYRIGHT:
-	Released into the public domain by Colin Sarsfield 9/13/00
-}
-unit XMLReader;
-
-interface
-
-uses
-  Classes;
-
-type
-  CharSet = set of Char;
-
-  TXMLNode = class;
-
-  TXMLNodeType = (xntDocument, xntElement, xntAttribute, xntProcessingInstruction,
-      xntXMLDeclaration);
-
-  TXMLReader = class
-  private
-    CurChar: Char;
-    function ParseAttribute(Node: TXMLNode): Boolean;
-    function ParseAttValue(var AttValue: String): Boolean;
-    function ParseCDSect(Node: TXMLNode): Boolean;
-    function ParseCharData(Node: TXMLNode): Boolean;
-    function ParseComment: Boolean;
-    procedure ParseContent(Node: TXMLNode);
-    procedure ParseDocTypeDecl(Node: TXMLNode);
-    function ParseElement(Node: TXMLNode): Boolean;
-    function ParseEq: Boolean;
-    function ParseETag(Node: TXMLNode): Boolean;
-    function ParseMisc(Node: TXMLNode): Boolean;
-    function ParseName(var Name: String): Boolean;
-    function ParseProcessingInstruction(Node: TXMLNode): Boolean;
-    function ParseProlog(Node: TXMLNode): Boolean;
-    function ParseReference: Char;
-    function ParseWhitespace: Boolean;
-    procedure ParseXMLDecl(Node: TXMLNode);
-    procedure ReportError(Err: String);
-  protected
-    function DoesStreamMatchString(Str: String): Boolean;
-    function EndOfData: Boolean; virtual; abstract;
-    procedure FreeState(State: TObject); virtual; abstract;
-    procedure ReadChar; virtual; abstract;
-    procedure ReadCharAndCheckForEnd;
-    procedure RestoreState(State: TObject); virtual; abstract;
-    function SaveState: TObject; virtual; abstract;
-  public
-    function ParseDocument: TXMLNode;
-  end;
-
-  TXMLStringReader = class(TXMLReader)
-  private
-    FData: String;
-    FPosition: Integer;
-  protected
-    function EndOfData: Boolean; override;
-    procedure FreeState(State: TObject); override;
-    procedure ReadChar; override;
-    procedure RestoreState(State: TObject); override;
-    function SaveState: TObject; override;
-  public
-    constructor Create(AData: String);
-  end;
-
-  TXMLNode = class
-  private
-    FData: String;
-    FName: String;
-    FNodes: TList;
-    FNodeType: TXMLNodeType;
-    function GetNodeCount: Integer;
-    function GetNodes(Index: Integer): TXMLNode;
-    function GetTotalNodeCount: Integer;
-    function GetAsInteger: Integer;
-    function GetAsSingle: Single;
-    function GetAsDateTime: TDateTime;
-  public
-    constructor Create; virtual;
-    destructor Destroy; override;
-
-    function AddNode(Node: TXMLNode): Integer;
-    function Description: String;
-    function FindNode(const Name: String; const Index: Integer): TXMLNode; overload;
-    function FindNode(const Name: String): TXMLNode; overload;
-    function FindNodeExc(const Name: String): TXMLNode;
-    function HasNode(const Name: String): Boolean;
-    procedure LookupBasicData(const Name: String; var LData: String); overload;
-    procedure LookupBasicData(const Name: String; var LData: TDateTime); overload;
-    procedure LookupBasicData(const Name: String; var LData: Integer); overload;
-    procedure LookupBasicData(const Name: String; var LData: Smallint); overload;
-    procedure LookupBasicData(const Name: String; var LData: Boolean); overload;
-    procedure LookupBasicData(const Name: String; var LData: Single); overload;
-    procedure LookupBasicData(const Name: String; LData: TStrings); overload;
-    procedure RemoveNode(Index: Integer); overload;
-    procedure RemoveNode(Node: TXMLNode); overload;
-
-    property AsDateTime: TDateTime read GetAsDateTime;
-    property AsInteger: Integer read GetAsInteger;
-    property AsSingle: Single read GetAsSingle;
-    property Data: String read FData write FData;
-    property Name: String read FName write FName;
-    property NodeCount: Integer read GetNodeCount;
-    property Nodes[Index: Integer]: TXMLNode read GetNodes;
-    property NodeType: TXMLNodeType read FNodeType write FNodeType;
-    property TotalNodeCount: Integer read GetTotalNodeCount;
-  end;
-
-const
-  TXMLNodeTypeStrings: array[TXMLNodeType] of String = ('Document', 'Element',
-      'Attribute', 'ProcessingInstruction', 'XMLDeclaration');
-
-implementation
-
-uses
-  SysUtils, Strlib;
-
-const
-  LetterSet: CharSet = ['A'..'Z', 'a'..'z'];
-  WhitespaceSet: CharSet = [' ', #9, #10, #13];
-  CombiningCharSet: CharSet = [];
-  DigitSet: CharSet = ['0'..'9'];
-  ExtenderSet: CharSet = [#$b7];
-  FirstNameCharSet: CharSet = ['_', ':', 'A'..'Z', 'a'..'z'];
-var
-  NameCharSet: CharSet;
-
-type
-  TXMLStringReaderState = class
-  public
-    Position: Integer;
-    CurChar: Char;
-  end;
-
-{ TXMLNode }
-
-constructor TXMLNode.Create;
-begin
-  FNodes := TList.Create;
-end;
-
-destructor TXMLNode.Destroy;
-var
-  i: Integer;
-begin
-  inherited;
-  for i := 0 to Pred(NodeCount) do
-    Nodes[i].Free;
-  FNodes.Free;
-end;
-
-function TXMLNode.AddNode(Node: TXMLNode): Integer;
-begin
-  Result := FNodes.Add(Node)
-end;
-
-function TXMLNode.Description: String;
-begin
-  Result := Name + ': ' + TXMLNodeTypeStrings[NodeType];
-  if Data &lt;&gt; '' then
-    Result := Result + ' = ' + Data
-end;
-
-function TXMLNode.FindNode(const Name: String): TXMLNode;
-begin
-  Result := FindNode(Name, 0)
-end;
-
-function TXMLNode.FindNode(const Name: String;
-  const Index: Integer): TXMLNode;
-var
-  i, ThisIndex: Integer;
-begin
-  ThisIndex := 0;
-  for i := 0 to Pred(NodeCount) do
-    if Nodes[i].Name = Name then begin
-      if ThisIndex = Index then begin
-        Result := Nodes[i];
-        Exit;
-      end;
-      Inc(ThisIndex);
-    end;
-  Result := nil;
-end;
-
-function TXMLNode.FindNodeExc(const Name: String): TXMLNode;
-begin
-  Result := FindNode(Name, 0);
-  if Result = nil then
-    raise Exception.Create('Node &quot;' + Name + '&quot; not found');
-end;
-
-function TXMLNode.GetAsDateTime: TDateTime;
-begin
-  Result := StrToDateTime(Data)
-end;
-
-function TXMLNode.GetAsInteger: Integer;
-begin
-  try
-    Result := StrToInt(Data);
-  except
-    raise Exception.Create('Node &quot;' + Name + '&quot; does not contain a valid integer');
-  end;
-end;
-
-function TXMLNode.GetAsSingle: Single;
-begin
-  try
-    Result := StrToFloat(Data);
-  except
-    raise Exception.Create('Node &quot;' + Name + '&quot; does not contain a valid floating point value');
-  end;
-end;
-
-function TXMLNode.GetNodeCount: Integer;
-begin
-  Result := FNodes.Count
-end;
-
-function TXMLNode.GetNodes(Index: Integer): TXMLNode;
-begin
-  Result := TXMLNode(FNodes[Index])
-end;
-
-function TXMLNode.GetTotalNodeCount: Integer;
-var
-  i: Integer;
-begin
-  Result := 1;
-  for i := 0 to Pred(NodeCount) do
-    Result := Result + Nodes[i].TotalNodeCount;
-end;
-
-function TXMLNode.HasNode(const Name: String): Boolean;
-begin
-  Result := FindNode(Name, 0) &lt;&gt; nil
-end;
-
-procedure TXMLNode.LookupBasicData(const Name: String; var LData: String);
-var
-  Node: TXMLNode;
-begin
-  Node := FindNode(Name);
-  if Node &lt;&gt; nil then
-    LData := Node.Data
-  else
-    LData := ''
-end;
-
-procedure TXMLNode.LookupBasicData(const Name: String; var LData: TDateTime);
-var
-  Node: TXMLNode;
-begin
-  Node := FindNode(Name);
-  if Node &lt;&gt; nil then
-    LData := Node.AsDateTime
-  else
-    LData := 0
-end;
-
-procedure TXMLNode.LookupBasicData(const Name: String;
-  var LData: Smallint);
-var
-  L: Integer;
-begin
-  LookupBasicData(Name, L);
-  LData := L
-end;
-
-procedure TXMLNode.LookupBasicData(const Name: String; var LData: Integer);
-var
-  Node: TXMLNode;
-begin
-  Node := FindNode(Name);
-  if Node &lt;&gt; nil then
-    LData := Node.AsInteger
-  else
-    LData := 0
-end;
-
-procedure TXMLNode.LookupBasicData(const Name: String; var LData: Boolean);
-begin
-  LData := HasNode(Name)
-end;
-
-procedure TXMLNode.LookupBasicData(const Name: String; var LData: Single);
-var
-  Node: TXMLNode;
-begin
-  Node := FindNode(Name);
-  if Node &lt;&gt; nil then
-    LData := Node.AsSingle
-  else
-    LData := 0
-end;
-
-procedure TXMLNode.LookupBasicData(const Name: String; LData: TStrings);
-var
-  i: Integer;
-  Node, SubNode: TXMLNode;
-begin
-  LData.Clear;
-  Node := FindNode(Name);
-  if Node = nil then Exit;
-  for i := 0 to Pred(Node.NodeCount) do begin
-    SubNode := Node.Nodes[i];
-    if (SubNode.Name = 'S') and (SubNode.NodeType = xntElement) then
-      LData.Add(SubNode.Data);
-  end;
-end;
-
-procedure TXMLNode.RemoveNode(Index: Integer);
-begin
-  RemoveNode(Nodes[Index])
-end;
-
-procedure TXMLNode.RemoveNode(Node: TXMLNode);
-begin
-  FNodes.Remove(Node);
-end;
-
-{ TXMLStringReader }
-
-constructor TXMLStringReader.Create(AData: String);
-begin
-  FPosition := 1;
-  FData := AData;
-end;
-
-function TXMLStringReader.EndOfData: Boolean;
-begin
-  Result := FPosition &gt; Length(FData)
-end;
-
-procedure TXMLStringReader.FreeState(State: TObject);
-begin
-  State.Free;
-end;
-
-procedure TXMLStringReader.ReadChar;
-begin
-  if FPosition &gt; Length(FData) then
-    CurChar := #0
-  else begin
-    CurChar := FData[FPosition];
-    Inc(FPosition)
-  end
-end;
-
-procedure TXMLStringReader.RestoreState(State: TObject);
-var
-  XSRState: TXMLStringReaderState;
-begin
-  XSRState := (State as TXMLStringReaderState);
-  FPosition := XSRState.Position;
-  CurChar := XSRState.CurChar;
-end;
-
-function TXMLStringReader.SaveState: TObject;
-var
-  XSRState: TXMLStringReaderState;
-begin
-  XSRState := TXMLStringReaderState.Create;
-  XSRState.Position := FPosition;
-  XSRState.CurChar := CurChar;
-  Result := XSRState;
-end;
-
-{ TXMLReader }
-
-function TXMLReader.DoesStreamMatchString(Str: String): Boolean;
-var
-  i: Integer;
-  State: TObject;
-begin
-  if Str = '' then begin Result := False; Exit end;
-  State := SaveState;
-  i := 1;
-  repeat
-    Result := Str[i] = CurChar;
-    Inc(i);
-    ReadChar;
-  until (not Result) or EndOfData or (i &gt; Length(Str));
-
-  if not Result then
-    RestoreState(State);
-  FreeState(State);
-end;
-
-
-function TXMLReader.ParseAttribute(Node: TXMLNode): Boolean;
-var
-  Name, AttValue: String;
-  ThisNode: TXMLNode;
-begin
-  Result := False;
-  if not ParseName(Name) then Exit;
-  if not ParseEq then
-    ReportError('Equals sign missing in attribute');
-  if not ParseAttValue(AttValue) then
-    ReportError('Attribute &quot;' + Name + '&quot; missing value');
-  ThisNode := TXMLNode.Create;
-  ThisNode.NodeType := xntAttribute;
-  ThisNode.Name := Name;
-  ThisNode.Data := AttValue;
-  Node.AddNode(ThisNode);
-  Result := True;
-end;
-
-function TXMLReader.ParseAttValue(var AttValue: String): Boolean;
-var
-  QuoteChar: Char;
-begin
-  QuoteChar := CurChar;
-  Result := False;
-  if not (CurChar in ['&quot;', '''']) then Exit;
-  ReadCharAndCheckForEnd;
-
-  while CurChar &lt;&gt; QuoteChar do begin
-    if CurChar = '&lt;' then
-      ReportError('Invalid character &quot;' + CurChar + '&quot; in attribute value')
-    else if CurChar = '&amp;' then
-      CurChar := ParseReference;
-    AttValue := AttValue + CurChar;
-    ReadCharAndCheckForEnd;
-  end;
-  ReadCharAndCheckForEnd;
-  Result := True;
-end;
-
-function TXMLReader.ParseCDSect(Node: TXMLNode): Boolean;
-var
-  CData: String;
-begin
-  Result := False;
-  if not DoesStreamMatchString('&lt;![CDATA[') then Exit;
-  repeat
-    CData := CData + CurChar;
-    ReadCharAndCheckForEnd;
-  until Right(CData, 3) = ']]&gt;';
-  Node.Data := Node.Data + Left(CData, Length(CData) - 3);
-  Result := True;
-end;
-
-function TXMLReader.ParseCharData(Node: TXMLNode): Boolean;
-var
-  CharData: String;
-begin
-  while not (CurChar in ['&lt;', '&amp;', #0]) do begin
-    CharData := CharData + CurChar;
-    ReadChar;
-  end;
-  if Pos(']]&gt;', CharData) &lt;&gt; 0 then
-    ReportError('Character data cannot contain &quot;]]&gt;&quot;');
-  Node.Data := Node.Data + CharData;
-  Result := CharData &lt;&gt; '';
-end;
-
-function TXMLReader.ParseComment: Boolean;
-var
-  Comment: String;
-  Terminated: Boolean;
-begin
-  Result := False;
-  if not DoesStreamMatchString('&lt;!--') then Exit;
-  repeat
-    Comment := Comment + CurChar;
-    Terminated := Right(Comment, 3) = '--&gt;';
-    if EndOfData then Break;
-    ReadChar;
-  until Terminated;
-  if Right(Comment, 4) = '---&gt;' then
-    ReportError('Comments cannot end in &quot;---&gt;&quot;');
-  Result := True;
-end;
-
-procedure TXMLReader.ParseContent(Node: TXMLNode);
-var
-  FoundContent: Boolean;
-begin
-  repeat
-    FoundContent := True;
-    if ParseCDSect(Node) then
-    else if ParseProcessingInstruction(Node) then
-    else if ParseComment then
-    else if ParseElement(Node) then
-    else if ParseCharData(Node) then
-    else if CurChar = '&amp;' then
-      Node.Data := Node.Data + ParseReference
-    else
-      FoundContent := False;
-  until not FoundContent;
-end;
-
-procedure TXMLReader.ParseDocTypeDecl(Node: TXMLNode);
-begin
-  if not DoesStreamMatchString('&lt;!DOCTYPE') then Exit;
-  ReportError('DocTypeDecl parsing not yet implemented');
-end;
-
-function TXMLReader.ParseDocument: TXMLNode;
-begin
-  ReadCharAndCheckForEnd;
-  Result := TXMLNode.Create;
-  Result.Name := '';
-  Result.NodeType := xntDocument;
-  if not ParseProlog(Result) then
-    ReportError('Missing prolog');
-  if not ParseElement(Result) then
-    ReportError('Missing element');
-  while ParseMisc(Result) do
-    ;
-end;
-
-function TXMLReader.ParseElement(Node: TXMLNode): Boolean;
-var
-  Name: String;
-  ThisNode: TXMLNode;
-  State: TObject;
-begin
-  Result := False;
-  if CurChar &lt;&gt; '&lt;' then Exit;
-  State := SaveState;
-  ReadCharAndCheckForEnd;
-  if not ParseName(Name) then begin
-    RestoreState(State);
-    FreeState(State);
-    Exit;
-  end;
-  
-  FreeState(State);
-
-  ThisNode := TXMLNode.Create;
-  Node.AddNode(ThisNode);
-  try
-    ThisNode.Name := Name;
-    ThisNode.NodeType := xntElement;
-    repeat
-      ParseWhitespace;
-    until not ParseAttribute(ThisNode);
-
-    if CurChar = '/' then begin
-      // EmptyElemTag
-      ReadCharAndCheckForEnd;
-      if CurChar &lt;&gt; '&gt;' then
-        ReportError('Tag not terminated properly');
-      ReadCharAndCheckForEnd;
-    end else if CurChar = '&gt;' then begin
-      // STag
-      ReadCharAndCheckForEnd;
-      ParseContent(ThisNode);
-      ThisNode.Data := TrimChars(ThisNode.Data, [' ', #9, #13, #10]);
-      if not ParseETag(ThisNode) then
-        ReportError('No ending tag for ' + Name);
-    end else
-      ReportError('Tag not terminated properly');
-  except
-    Node.RemoveNode(ThisNode);
-    ThisNode.Free;
-    raise;
-  end;
-  Result := True;
-end;
-
-function TXMLReader.ParseEq: Boolean;
-begin
-  ParseWhitespace;
-  Result := CurChar = '=';
-  ReadCharAndCheckForEnd;
-  ParseWhitespace;
-end;
-
-function TXMLReader.ParseETag(Node: TXMLNode): Boolean;
-var
-  Name: String;
-begin
-  Result := False;
-  if not DoesStreamMatchString('&lt;/') then Exit;
-  if not ParseName(Name) then Exit;
-  if Name &lt;&gt; Node.Name then
-    ReportError('End tag name &quot;' + Name + '&quot; does not match start tag name &quot;' + Node.Name + '&quot;');
-  ParseWhitespace;
-  if CurChar &lt;&gt; '&gt;' then
-    ReportError('End tag missing &quot;&gt;&quot;');
-  ReadChar;
-  Result := True;
-end;
-
-function TXMLReader.ParseMisc(Node: TXMLNode): Boolean;
-begin
-  Result := ParseWhitespace;
-  if Result then Exit;
-  Result := ParseComment;
-  if Result then Exit;
-  Result := ParseProcessingInstruction(Node);
-end;
-
-function TXMLReader.ParseName(var Name: String): Boolean;
-begin
-  Result := False;
-  if not (CurChar in FirstNameCharSet) then Exit;
-  Result := True;
-  Name := '';
-  repeat
-    Name := Name + CurChar;
-    ReadCharAndCheckForEnd;
-  until not (CurChar in NameCharSet);
-end;
-
-function TXMLReader.ParseProcessingInstruction(Node: TXMLNode): Boolean;
-var
-  Name, Chars: String;
-  ThisNode: TXMLNode;
-  Terminated: Boolean;
-begin
-  Result := False;
-  if not DoesStreamMatchString('&lt;?') then Exit;
-  if not ParseName(Name) then
-    ReportError('Processing instruction does not contain valid name');
-  if Name = 'xml' then
-    ReportError('Processing instruction cannot have the reserved name &quot;xml&quot;');
-  ThisNode := TXMLNode.Create;
-  try
-    ThisNode.Name := Name;
-    ThisNode.NodeType := xntProcessingInstruction;
-    ParseWhitespace;
-    repeat
-      Chars := Chars + CurChar;
-      Terminated := Right(Chars, 2) = '?&gt;';
-      if EndOfData then break;
-      ReadChar;
-    until Terminated;
-    if not Terminated then
-      ReportError('Unterminated processing instruction');
-    ThisNode.Data := Left(Chars, Length(Chars) - 2);
-  except
-    ThisNode.Free;
-    raise;
-  end;
-  Node.AddNode(ThisNode);
-  Result := True;
-end;
-
-function TXMLReader.ParseProlog(Node: TXMLNode): Boolean;
-begin
-  ParseXMLDecl(Node);
-  while ParseMisc(Node) do
-    ;
-  ParseDocTypeDecl(Node);
-  while ParseMisc(Node) do
-    ;
-  Result := True;
-end;
-
-function TXMLReader.ParseReference: Char;
-var
-  RefStr: String;
-begin
-  Result := #0; // silence compiler warning
-  if CurChar &lt;&gt; '&amp;' then
-    ReportError('All references must begin with &quot;&amp;&quot;');
-  ReadCharAndCheckForEnd;
-  while CurChar &lt;&gt; ';' do begin
-    RefStr := RefStr + CurChar;
-    ReadCharAndCheckForEnd;
-  end;
-  if Left(RefStr, 2) = '#x' then
-    try
-      Result := Chr(StrToInt('$' + Right(RefStr, Length(RefStr) - 2)));
-    except
-      ReportError('Invalid integer in reference &amp;' + RefStr + ';');
-    end
-  else if Left(RefStr, 1) = '#' then
-    try
-      Result := Chr(StrToInt(Right(RefStr, Length(RefStr) - 1)));
-    except
-      ReportError('Invalid integer in reference &amp;' + RefStr + ';');
-    end
-  else if RefStr = 'amp' then
-    Result := '&amp;'
-  else if RefStr = 'lt' then
-    Result := '&lt;'
-  else if RefStr = 'gt' then
-    Result := '&gt;'
-  else if RefStr = 'quot' then
-    Result := '&quot;'
-  else if RefStr = 'apos' then
-    Result := ''''
-  else
-    ReportError('Unrecognized reference');
-
-  ReadCharAndCheckForEnd;
-end;
-
-function TXMLReader.ParseWhitespace: Boolean;
-begin
-  Result := False;
-  while (CurChar in [' ', #13, #10, #9]) do begin
-    Result := True;
-    ReadChar;
-    if EndOfData then Exit;
-  end;
-end;
-
-procedure TXMLReader.ParseXMLDecl(Node: TXMLNode);
-var
-  ThisNode: TXMLNode;
-begin
-  if not DoesStreamMatchString('&lt;?xml') then Exit;
-  ThisNode := TXMLNode.Create;
-  ThisNode.NodeType := xntXMLDeclaration;
-  try
-    repeat
-      ParseWhitespace;
-    until not ParseAttribute(ThisNode);
-    ParseWhitespace;
-    if not DoesStreamMatchString('?&gt;') then
-      ReportError('XML declaration not terminated with &quot;?&gt;&quot;');
-  except
-    ThisNode.Free;
-    raise;
-  end;
-  Node.AddNode(ThisNode);
-end;
-
-procedure TXMLReader.ReadCharAndCheckForEnd;
-begin
-  if EndOfData then
-    ReportError('Unexpected end of data');
-  ReadChar;
-end;
-
-procedure TXMLReader.ReportError(Err: String);
-begin
-  raise Exception.Create(Err);
-end;
-
-initialization
-  NameCharSet := LetterSet + CombiningCharSet + DigitSet + ExtenderSet
-      + ['.', '-', '_', ':'];
-end.

Deleted: trunk/WPGM/Main.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Main.~ddp
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Main.~dfm
===================================================================
--- trunk/WPGM/Main.~dfm	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/Main.~dfm	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,1417 +0,0 @@
-object frmMain: TfrmMain
-  Left = 365
-  Top = 496
-  Width = 612
-  Height = 199
-  Caption = 'Wolfpack - GM Tool'
-  Color = clBtnFace
-  Font.Charset = DEFAULT_CHARSET
-  Font.Color = clWindowText
-  Font.Height = -11
-  Font.Name = 'MS Sans Serif'
-  Font.Style = []
-  OldCreateOrder = False
-  Position = poDesktopCenter
-  ShowHint = True
-  OnClose = FormClose
-  OnCreate = FormCreate
-  OnDestroy = FormDestroy
-  PixelsPerInch = 96
-  TextHeight = 13
-  object Pages: TPageControl
-    Left = 0
-    Top = 0
-    Width = 604
-    Height = 165
-    ActivePage = tsTags
-    Align = alClient
-    RaggedRight = True
-    TabOrder = 0
-    object tsCommands: TTabSheet
-      Caption = 'Commands'
-      ImageIndex = 3
-      object GroupBox1: TGroupBox
-        Left = 8
-        Top = 8
-        Width = 185
-        Height = 121
-        Caption = 'Toggle Flags'
-        TabOrder = 0
-        object btnCmdAllmove: TButton
-          Left = 8
-          Top = 24
-          Width = 75
-          Height = 25
-          Hint = 'Toggle moving immovable objects.'
-          Caption = 'Allmove'
-          TabOrder = 0
-          OnClick = btnCmdAllmoveClick
-        end
-        object btnCmdAllshow: TButton
-          Left = 8
-          Top = 56
-          Width = 75
-          Height = 25
-          Hint = 'Toggle showing logged out characters.'
-          Caption = 'Allshow'
-          TabOrder = 1
-          OnClick = btnCmdAllshowClick
-        end
-        object btnCmdInvisible: TButton
-          Left = 8
-          Top = 88
-          Width = 75
-          Height = 25
-          Hint = 'Toggle the invisible status.'
-          Caption = 'Invisible'
-          TabOrder = 2
-          OnClick = btnCmdInvisibleClick
-        end
-        object btnCmdStaff: TButton
-          Left = 96
-          Top = 56
-          Width = 75
-          Height = 25
-          Hint = 'Toggle the GM mode flag.'
-          Caption = 'Staff Flag'
-          TabOrder = 3
-          OnClick = btnCmdStaffClick
-        end
-        object btnCmdInvul: TButton
-          Left = 96
-          Top = 24
-          Width = 75
-          Height = 25
-          Hint = 'Toggle invulnerability.'
-          Caption = 'Invulnerable'
-          TabOrder = 4
-          OnClick = btnCmdInvulClick
-        end
-        object btnCmdPageNotify: TButton
-          Left = 96
-          Top = 88
-          Width = 75
-          Height = 25
-          Hint = 'Be notified about incoming pages.'
-          Caption = 'Page Notify'
-          Enabled = False
-          TabOrder = 5
-          OnClick = btnCmdStaffClick
-        end
-      end
-      object GroupBox2: TGroupBox
-        Left = 200
-        Top = 8
-        Width = 233
-        Height = 121
-        Caption = 'System Commands'
-        TabOrder = 1
-        object btnCmdShutdown: TButton
-          Left = 8
-          Top = 24
-          Width = 105
-          Height = 25
-          Hint = 'Close the server.'
-          Caption = 'Shutdown'
-          TabOrder = 0
-          OnClick = btnCmdShutdownClick
-        end
-        object btnCmdReloadPython: TButton
-          Left = 8
-          Top = 56
-          Width = 105
-          Height = 25
-          Hint = 'Reload the python scripts.'
-          Caption = 'Reload Python'
-          TabOrder = 1
-          OnClick = btnCmdReloadPythonClick
-        end
-        object btnCmdReloadScripts: TButton
-          Left = 8
-          Top = 88
-          Width = 105
-          Height = 25
-          Hint = 'Reload the definitions and python scripts.'
-          Caption = 'Reload Definitions'
-          TabOrder = 2
-          OnClick = btnCmdReloadScriptsClick
-        end
-        object btnCmdReloadAccounts: TButton
-          Left = 120
-          Top = 56
-          Width = 105
-          Height = 25
-          Hint = 'Reload the accounts.'
-          Caption = 'Reload Accounts'
-          TabOrder = 3
-          OnClick = btnCmdReloadAccountsClick
-        end
-        object btnCmdReloadAll: TButton
-          Left = 120
-          Top = 88
-          Width = 105
-          Height = 25
-          Hint = 'Reload everything.'
-          Caption = 'Reload All'
-          TabOrder = 4
-          OnClick = btnCmdReloadAllClick
-        end
-        object btnCmdServertime: TButton
-          Left = 120
-          Top = 24
-          Width = 105
-          Height = 25
-          Hint = 'Show the current servertime.'
-          Caption = 'Show Servertime'
-          TabOrder = 5
-          OnClick = btnCmdServertimeClick
-        end
-      end
-      object Button1: TButton
-        Left = 440
-        Top = 16
-        Width = 97
-        Height = 25
-        Caption = 'Pattern Tilecolor'
-        TabOrder = 2
-        OnClick = Button1Click
-      end
-    end
-    object tsItems: TTabSheet
-      Caption = 'Items'
-      ImageIndex = -1
-      DesignSize = (
-        596
-        137)
-      object Label7: TLabel
-        Left = 162
-        Top = 118
-        Width = 39
-        Height = 13
-        Anchors = [akLeft, akBottom]
-        Caption = 'Z Level:'
-      end
-      object pnlItems: TPanel
-        Left = 0
-        Top = 0
-        Width = 594
-        Height = 112
-        Anchors = [akLeft, akTop, akRight, akBottom]
-        BevelOuter = bvNone
-        TabOrder = 0
-        object spItems: TSplitter
-          Left = 201
-          Top = 0
-          Height = 112
-        end
-        object vtCategories: TVirtualStringTree
-          Left = 0
-          Top = 0
-          Width = 201
-          Height = 112
-          Align = alLeft
-          Header.AutoSizeIndex = 0
-          Header.Font.Charset = DEFAULT_CHARSET
-          Header.Font.Color = clWindowText
-          Header.Font.Height = -11
-          Header.Font.Name = 'MS Sans Serif'
-          Header.Font.Style = []
-          Header.MainColumn = -1
-          Header.Options = [hoColumnResize, hoDrag]
-          IncrementalSearchStart = ssAlwaysStartOver
-          ScrollBarOptions.AlwaysVisible = True
-          TabOrder = 0
-          TreeOptions.PaintOptions = [toShowButtons, toShowRoot, toShowTreeLines, toThemeAware, toUseBlendedImages]
-          OnChange = vtCategoriesChange
-          OnExpanding = vtCategoriesExpanding
-          OnGetText = vtCategoriesGetText
-          Columns = &lt;&gt;
-        end
-        object vtItems: TVirtualStringTree
-          Left = 204
-          Top = 0
-          Width = 305
-          Height = 112
-          Align = alClient
-          Header.AutoSizeIndex = 0
-          Header.Font.Charset = DEFAULT_CHARSET
-          Header.Font.Color = clWindowText
-          Header.Font.Height = -11
-          Header.Font.Name = 'MS Sans Serif'
-          Header.Font.Style = []
-          Header.Options = [hoColumnResize, hoDrag, hoShowSortGlyphs, hoVisible]
-          Header.SortColumn = 0
-          ScrollBarOptions.AlwaysVisible = True
-          ScrollBarOptions.ScrollBars = ssVertical
-          TabOrder = 1
-          TreeOptions.AutoOptions = [toAutoDropExpand, toAutoScrollOnExpand, toAutoSort, toAutoTristateTracking, toAutoDeleteMovedNodes, toAutoFreeOnCollapse]
-          TreeOptions.PaintOptions = [toHideFocusRect, toShowButtons, toThemeAware, toUseBlendedImages]
-          TreeOptions.SelectionOptions = [toDisableDrawSelection, toFullRowSelect, toMultiSelect]
-          OnChange = vtItemsChange
-          OnCompareNodes = vtItemsCompareNodes
-          OnDblClick = btnAddItemClick
-          OnGetText = vtItemsGetText
-          OnHeaderClick = vtItemsHeaderClick
-          Columns = &lt;
-            item
-              Position = 0
-              Width = 197
-              WideText = 'Name'
-            end
-            item
-              Position = 1
-              WideText = 'ID'
-            end&gt;
-        end
-        object imgItemPreview: TImage32
-          Left = 509
-          Top = 0
-          Width = 85
-          Height = 112
-          Align = alRight
-          BitmapAlign = baCenter
-          Scale = 1.000000000000000000
-          ScaleMode = smNormal
-          TabOrder = 2
-        end
-      end
-      object btnAddItem: TButton
-        Left = 0
-        Top = 114
-        Width = 75
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Add'
-        Enabled = False
-        TabOrder = 1
-        OnClick = btnAddItemClick
-      end
-      object btnRemoveItem: TButton
-        Left = 80
-        Top = 114
-        Width = 75
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Remove'
-        TabOrder = 2
-        OnClick = btnRemoveItemClick
-      end
-      object btnTileItem: TButton
-        Left = 249
-        Top = 114
-        Width = 75
-        Height = 21
-        Hint = 'Fill a rectangle with items at the given z level.'
-        Anchors = [akLeft, akBottom]
-        Caption = 'Tile'
-        Enabled = False
-        TabOrder = 4
-        OnClick = btnTileItemClick
-      end
-      object eZLevel: TEdit
-        Left = 208
-        Top = 114
-        Width = 35
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        TabOrder = 3
-        Text = '0'
-      end
-      object btnCmdItemNuke: TButton
-        Left = 329
-        Top = 114
-        Width = 75
-        Height = 21
-        Hint = 'Nuke a rectangle of items.'
-        Anchors = [akLeft, akBottom]
-        Caption = 'Nuke'
-        TabOrder = 5
-        OnClick = btnCmdNukeClick
-      end
-      object cbStatic: TCheckBox
-        Left = 413
-        Top = 116
-        Width = 49
-        Height = 17
-        Anchors = [akLeft, akBottom]
-        Caption = 'Static'
-        TabOrder = 6
-      end
-    end
-    object tsItemManip: TTabSheet
-      Caption = 'Item Manipulation'
-      ImageIndex = 4
-      object GroupBox3: TGroupBox
-        Left = 8
-        Top = 8
-        Width = 145
-        Height = 121
-        Caption = 'Change Color'
-        TabOrder = 0
-        object eItemHue: TEdit
-          Left = 8
-          Top = 24
-          Width = 97
-          Height = 21
-          TabOrder = 0
-          Text = '0'
-          OnChange = eItemHueChange
-        end
-        object btnChangeItemHue: TButton
-          Left = 109
-          Top = 23
-          Width = 28
-          Height = 23
-          Caption = '...'
-          TabOrder = 1
-          OnClick = btnChangeItemHueClick
-        end
-        object btnCmdDye: TButton
-          Left = 8
-          Top = 88
-          Width = 57
-          Height = 25
-          Caption = 'Set'
-          TabOrder = 2
-          OnClick = btnCmdDyeClick
-        end
-        object pbHuePreview: TPaintBox32
-          Left = 8
-          Top = 56
-          Width = 128
-          Height = 25
-          TabOrder = 3
-          OnPaintBuffer = pbHuePreviewPaintBuffer
-        end
-        object btnCmdItemTileColor: TButton
-          Left = 72
-          Top = 88
-          Width = 67
-          Height = 25
-          Hint = 'Tiles this color over an area of items.'
-          Caption = 'Tile'
-          TabOrder = 4
-          OnClick = btnCmdItemTileColorClick
-        end
-      end
-      object GroupBox4: TGroupBox
-        Left = 160
-        Top = 8
-        Width = 185
-        Height = 121
-        Caption = 'Commands'
-        TabOrder = 1
-        object btnCmdDupe: TButton
-          Left = 8
-          Top = 24
-          Width = 75
-          Height = 25
-          Hint = 'Create an exact duplicate of the item.'
-          Caption = 'Dupe'
-          TabOrder = 0
-          OnClick = btnCmdDupeClick
-        end
-        object btnCmdInfo: TButton
-          Left = 8
-          Top = 56
-          Width = 75
-          Height = 25
-          Hint = 'Show an info dialog for the item.'
-          Caption = 'Info'
-          TabOrder = 1
-          OnClick = btnCmdInfoClick
-        end
-        object btnCmdRemove: TButton
-          Left = 8
-          Top = 88
-          Width = 75
-          Height = 25
-          Hint = 'Remove the item.'
-          Caption = 'Remove'
-          TabOrder = 2
-          OnClick = btnCmdRemoveClick
-        end
-        object btnCmdLock: TButton
-          Left = 96
-          Top = 24
-          Width = 75
-          Height = 25
-          Hint = 'Attach a lock to the item.'
-          Caption = 'Lock'
-          TabOrder = 3
-          OnClick = btnCmdLockClick
-        end
-        object btnCmdNuke: TButton
-          Left = 96
-          Top = 56
-          Width = 75
-          Height = 25
-          Hint = 'Wipe an area from its items.'
-          Caption = 'Nuke'
-          TabOrder = 4
-          OnClick = btnCmdNukeClick
-        end
-        object btnCmdMoveUp: TBitBtn
-          Left = 96
-          Top = 88
-          Width = 33
-          Height = 25
-          Hint = 'Move the item up by 1 point of z.'
-          TabOrder = 5
-          OnClick = btnCmdMoveUpClick
-          Glyph.Data = {
-            32010000424D3201000000000000360000002800000009000000090000000100
-            180000000000FC000000120B0000120B00000000000000000000FFFFFFFFFFFF
-            FFFFFF000000000000000000FFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFF00
-            0000000000000000FFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFF0000000000
-            00000000FFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFF000000000000000000
-            FFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000
-            000000000000FFFFFF000000000000000000000000000000000000000000FFFF
-            FF00FFFFFFFFFFFF000000000000000000000000000000FFFFFFFFFFFF00FFFF
-            FFFFFFFFFFFFFF000000000000000000FFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF
-            FFFFFFFFFFFF000000FFFFFFFFFFFFFFFFFFFFFFFF00}
-        end
-        object btnCmdMoveDown: TBitBtn
-          Left = 136
-          Top = 88
-          Width = 33
-          Height = 25
-          Hint = 'Move the item down by 1 point of z.'
-          TabOrder = 6
-          OnClick = btnCmdMoveDownClick
-          Glyph.Data = {
-            32010000424D3201000000000000360000002800000009000000090000000100
-            180000000000FC000000120B0000120B00000000000000000000FFFFFFFFFFFF
-            FFFFFFFFFFFF000000FFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFF00
-            0000000000000000FFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF0000000000000000
-            00000000000000FFFFFFFFFFFF00FFFFFF000000000000000000000000000000
-            000000000000FFFFFF0000000000000000000000000000000000000000000000
-            000000000000FFFFFFFFFFFFFFFFFF000000000000000000FFFFFFFFFFFFFFFF
-            FF00FFFFFFFFFFFFFFFFFF000000000000000000FFFFFFFFFFFFFFFFFF00FFFF
-            FFFFFFFFFFFFFF000000000000000000FFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF
-            FFFFFF000000000000000000FFFFFFFFFFFFFFFFFF00}
-        end
-      end
-      object GroupBox5: TGroupBox
-        Left = 352
-        Top = 8
-        Width = 177
-        Height = 121
-        Caption = 'Properties'
-        TabOrder = 2
-        object Label1: TLabel
-          Left = 10
-          Top = 60
-          Width = 30
-          Height = 13
-          Caption = 'Value:'
-        end
-        object cbItemProperty: TComboBox
-          Left = 8
-          Top = 24
-          Width = 153
-          Height = 21
-          ItemHeight = 13
-          TabOrder = 0
-          OnChange = cbItemPropertyChange
-          Items.Strings = (
-            'amount'
-            'baseid'
-            'color'
-            'decay'
-            'health'
-            'id'
-            'movable'
-            'maxhealth'
-            'name'
-            'newbie'
-            'owner'
-            'ownervisible'
-            'pos'
-            'secured'
-            'serial'
-            'spawnregion'
-            'totalweight'
-            'type'
-            'visible')
-        end
-        object eItemPropValue: TEdit
-          Left = 56
-          Top = 56
-          Width = 105
-          Height = 21
-          TabOrder = 1
-        end
-        object btnCmdItemSet: TButton
-          Left = 8
-          Top = 88
-          Width = 75
-          Height = 25
-          Hint = 'Set the value of the selected property'
-          Caption = 'Set'
-          Enabled = False
-          TabOrder = 2
-          OnClick = btnCmdItemSetClick
-        end
-        object btnCmdItemShow: TButton
-          Left = 88
-          Top = 88
-          Width = 75
-          Height = 25
-          Hint = 'Show the value of the selected property.'
-          Caption = 'Show'
-          Enabled = False
-          TabOrder = 3
-          OnClick = btnCmdItemShowClick
-        end
-      end
-    end
-    object tsNpcs: TTabSheet
-      Caption = 'NPCs'
-      ImageIndex = 6
-      DesignSize = (
-        596
-        137)
-      object Label8: TLabel
-        Left = 242
-        Top = 118
-        Width = 36
-        Height = 13
-        Anchors = [akLeft, akBottom]
-        Caption = 'Radius:'
-      end
-      object Label9: TLabel
-        Left = 330
-        Top = 118
-        Width = 46
-        Height = 13
-        Anchors = [akLeft, akBottom]
-        Caption = 'Min. Time'
-      end
-      object Label10: TLabel
-        Left = 426
-        Top = 118
-        Width = 49
-        Height = 13
-        Anchors = [akLeft, akBottom]
-        Caption = 'Max. Time'
-      end
-      object pnNpcs: TPanel
-        Left = 0
-        Top = 0
-        Width = 594
-        Height = 112
-        Anchors = [akLeft, akTop, akRight, akBottom]
-        BevelOuter = bvNone
-        TabOrder = 0
-        object Splitter1: TSplitter
-          Left = 201
-          Top = 0
-          Height = 112
-        end
-        object Splitter2: TSplitter
-          Left = 496
-          Top = 0
-          Height = 112
-          Align = alRight
-        end
-        object vtNpcCategories: TVirtualStringTree
-          Left = 0
-          Top = 0
-          Width = 201
-          Height = 112
-          Align = alLeft
-          Header.AutoSizeIndex = 0
-          Header.Font.Charset = DEFAULT_CHARSET
-          Header.Font.Color = clWindowText
-          Header.Font.Height = -11
-          Header.Font.Name = 'MS Sans Serif'
-          Header.Font.Style = []
-          Header.MainColumn = -1
-          Header.Options = [hoColumnResize, hoDrag]
-          IncrementalSearchStart = ssAlwaysStartOver
-          ScrollBarOptions.AlwaysVisible = True
-          TabOrder = 0
-          TreeOptions.PaintOptions = [toShowButtons, toShowRoot, toShowTreeLines, toThemeAware, toUseBlendedImages]
-          OnChange = vtNpcCategoriesChange
-          OnExpanding = vtNpcCategoriesExpanding
-          OnGetText = vtCategoriesGetText
-          Columns = &lt;&gt;
-        end
-        object vtNpcs: TVirtualStringTree
-          Left = 204
-          Top = 0
-          Width = 292
-          Height = 112
-          Align = alClient
-          Header.AutoSizeIndex = 0
-          Header.Font.Charset = DEFAULT_CHARSET
-          Header.Font.Color = clWindowText
-          Header.Font.Height = -11
-          Header.Font.Name = 'MS Sans Serif'
-          Header.Font.Style = []
-          Header.Options = [hoColumnResize, hoDrag, hoShowSortGlyphs, hoVisible]
-          Header.SortColumn = 0
-          ScrollBarOptions.AlwaysVisible = True
-          ScrollBarOptions.ScrollBars = ssVertical
-          TabOrder = 1
-          TreeOptions.AutoOptions = [toAutoDropExpand, toAutoScrollOnExpand, toAutoSort, toAutoTristateTracking, toAutoDeleteMovedNodes, toAutoFreeOnCollapse]
-          TreeOptions.PaintOptions = [toHideFocusRect, toShowButtons, toThemeAware, toUseBlendedImages]
-          TreeOptions.SelectionOptions = [toDisableDrawSelection, toFullRowSelect]
-          OnChange = vtNpcsChange
-          OnCompareNodes = vtNpcsCompareNodes
-          OnDblClick = btnAddNpcClick
-          OnGetText = vtNpcsGetText
-          OnHeaderClick = vtNpcsHeaderClick
-          Columns = &lt;
-            item
-              Position = 0
-              Width = 197
-              WideText = 'Name'
-            end
-            item
-              Position = 1
-              WideText = 'ID'
-            end&gt;
-        end
-        object pbNpcPreview: TPaintBox32
-          Left = 499
-          Top = 0
-          Width = 95
-          Height = 112
-          Align = alRight
-          TabOrder = 2
-          OnPaintBuffer = pbNpcPreviewPaintBuffer
-        end
-      end
-      object btnAddNpc: TButton
-        Left = 0
-        Top = 114
-        Width = 75
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Add'
-        Enabled = False
-        TabOrder = 1
-        OnClick = btnAddNpcClick
-      end
-      object btnRemoveNpc: TButton
-        Left = 79
-        Top = 114
-        Width = 75
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Remove'
-        TabOrder = 2
-        OnClick = btnRemoveNpcClick
-      end
-      object eSpawnRadius: TEdit
-        Left = 288
-        Top = 114
-        Width = 35
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        TabOrder = 3
-        Text = '0'
-        OnExit = eSpawnRadiusExit
-      end
-      object eSpawnMin: TEdit
-        Left = 384
-        Top = 114
-        Width = 35
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        TabOrder = 4
-        Text = '0'
-        OnExit = eSpawnMinExit
-      end
-      object eSpawnMax: TEdit
-        Left = 480
-        Top = 114
-        Width = 35
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        TabOrder = 5
-        Text = '0'
-        OnExit = eSpawnMaxExit
-      end
-      object btnNpcSpawn: TButton
-        Left = 159
-        Top = 114
-        Width = 75
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Spawn'
-        Enabled = False
-        TabOrder = 6
-        OnClick = btnNpcSpawnClick
-      end
-    end
-    object TabSheet1: TTabSheet
-      Caption = 'Multis'
-      ImageIndex = 7
-      DesignSize = (
-        596
-        137)
-      object Panel1: TPanel
-        Left = 0
-        Top = 0
-        Width = 594
-        Height = 112
-        Anchors = [akLeft, akTop, akRight, akBottom]
-        BevelOuter = bvNone
-        TabOrder = 0
-        object vtMultis: TVirtualStringTree
-          Left = 0
-          Top = 0
-          Width = 594
-          Height = 112
-          Align = alClient
-          Header.AutoSizeIndex = 0
-          Header.Font.Charset = DEFAULT_CHARSET
-          Header.Font.Color = clWindowText
-          Header.Font.Height = -11
-          Header.Font.Name = 'MS Sans Serif'
-          Header.Font.Style = []
-          Header.Options = [hoColumnResize, hoDrag, hoShowSortGlyphs, hoVisible]
-          Header.SortColumn = 0
-          ScrollBarOptions.AlwaysVisible = True
-          ScrollBarOptions.ScrollBars = ssVertical
-          TabOrder = 0
-          TreeOptions.AutoOptions = [toAutoDropExpand, toAutoScrollOnExpand, toAutoSort, toAutoTristateTracking, toAutoDeleteMovedNodes, toAutoFreeOnCollapse]
-          TreeOptions.PaintOptions = [toHideFocusRect, toShowButtons, toThemeAware, toUseBlendedImages]
-          TreeOptions.SelectionOptions = [toDisableDrawSelection, toFullRowSelect]
-          OnChange = vtMultisChange
-          OnCompareNodes = vtMultisCompareNodes
-          OnDblClick = btnAddMultiClick
-          OnGetText = vtMultisGetText
-          OnHeaderClick = vtMultisHeaderClick
-          Columns = &lt;
-            item
-              Position = 0
-              Width = 197
-              WideText = 'Name'
-            end
-            item
-              Position = 1
-              WideText = 'ID'
-            end&gt;
-        end
-      end
-      object btnAddMulti: TButton
-        Left = 0
-        Top = 115
-        Width = 75
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Add'
-        Enabled = False
-        TabOrder = 1
-        OnClick = btnAddMultiClick
-      end
-      object btnRemoveMulti: TButton
-        Left = 79
-        Top = 115
-        Width = 75
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Remove'
-        TabOrder = 2
-      end
-      object btnPreviewMulti: TButton
-        Left = 158
-        Top = 115
-        Width = 75
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Preview'
-        Enabled = False
-        TabOrder = 3
-        OnClick = btnPreviewMultiClick
-      end
-    end
-    object tsTags: TTabSheet
-      Caption = 'Object Manipulation'
-      ImageIndex = 5
-      object GroupBox6: TGroupBox
-        Left = 8
-        Top = 8
-        Width = 233
-        Height = 121
-        Caption = 'Manage Tags'
-        TabOrder = 0
-        object Label2: TLabel
-          Left = 10
-          Top = 60
-          Width = 30
-          Height = 13
-          Caption = 'Value:'
-        end
-        object Label3: TLabel
-          Left = 10
-          Top = 28
-          Width = 31
-          Height = 13
-          Caption = 'Name:'
-        end
-        object eTagValue: TEdit
-          Left = 56
-          Top = 56
-          Width = 97
-          Height = 21
-          Hint = 'The new tag value if you use set.'
-          TabOrder = 0
-        end
-        object btnTagSet: TButton
-          Left = 8
-          Top = 88
-          Width = 49
-          Height = 25
-          Caption = 'Set'
-          Enabled = False
-          TabOrder = 1
-          OnClick = btnTagSetClick
-        end
-        object eTagName: TEdit
-          Left = 56
-          Top = 24
-          Width = 169
-          Height = 21
-          Hint = 'The name of the tag you want to set.'
-          TabOrder = 2
-          OnChange = eTagNameChange
-        end
-        object btnTagShow: TButton
-          Left = 64
-          Top = 88
-          Width = 49
-          Height = 25
-          Caption = 'Show'
-          Enabled = False
-          TabOrder = 3
-          OnClick = btnTagShowClick
-        end
-        object btnTagDelete: TButton
-          Left = 120
-          Top = 88
-          Width = 49
-          Height = 25
-          Caption = 'Delete'
-          Enabled = False
-          TabOrder = 4
-          OnClick = btnTagDeleteClick
-        end
-        object cbTagType: TComboBox
-          Left = 160
-          Top = 56
-          Width = 65
-          Height = 21
-          Hint = 'The type of the tag value.'
-          Style = csDropDownList
-          ItemHeight = 13
-          ItemIndex = 0
-          TabOrder = 5
-          Text = 'String'
-          Items.Strings = (
-            'String'
-            'Integer'
-            'Float')
-        end
-        object btnTagInfo: TButton
-          Left = 176
-          Top = 88
-          Width = 49
-          Height = 25
-          Caption = 'Info'
-          TabOrder = 6
-          OnClick = btnTagInfoClick
-        end
-      end
-      object GroupBox7: TGroupBox
-        Left = 248
-        Top = 8
-        Width = 137
-        Height = 121
-        Caption = 'Move Relatively'
-        TabOrder = 1
-        object Label4: TLabel
-          Left = 16
-          Top = 18
-          Width = 29
-          Height = 13
-          Caption = 'X Axis'
-        end
-        object Label5: TLabel
-          Left = 16
-          Top = 42
-          Width = 29
-          Height = 13
-          Caption = 'Y Axis'
-        end
-        object Label6: TLabel
-          Left = 16
-          Top = 66
-          Width = 29
-          Height = 13
-          Caption = 'Z Axis'
-        end
-        object eMoveX: TEdit
-          Left = 80
-          Top = 16
-          Width = 41
-          Height = 21
-          TabOrder = 0
-          Text = '0'
-        end
-        object eMoveY: TEdit
-          Left = 80
-          Top = 40
-          Width = 41
-          Height = 21
-          TabOrder = 1
-          Text = '0'
-        end
-        object eMoveZ: TEdit
-          Left = 80
-          Top = 64
-          Width = 41
-          Height = 21
-          TabOrder = 2
-          Text = '0'
-        end
-        object btnCmdMove: TButton
-          Left = 8
-          Top = 88
-          Width = 65
-          Height = 25
-          Caption = 'Move'
-          TabOrder = 3
-          OnClick = btnCmdMoveClick
-        end
-      end
-      object GroupBox8: TGroupBox
-        Left = 392
-        Top = 8
-        Width = 137
-        Height = 121
-        Caption = 'Manage Scripts'
-        TabOrder = 2
-        object btnCmdAddEvent: TButton
-          Left = 8
-          Top = 56
-          Width = 57
-          Height = 25
-          Caption = 'Add'
-          Enabled = False
-          TabOrder = 1
-          OnClick = btnCmdAddEventClick
-        end
-        object btnCmdRemoveEvent: TButton
-          Left = 72
-          Top = 56
-          Width = 57
-          Height = 25
-          Caption = 'Remove'
-          Enabled = False
-          TabOrder = 2
-          OnClick = btnCmdRemoveEventClick
-        end
-        object btnCmdShowEventlist: TButton
-          Left = 8
-          Top = 88
-          Width = 121
-          Height = 25
-          Caption = 'Show Eventlist'
-          TabOrder = 3
-          OnClick = btnCmdShowEventlistClick
-        end
-        object cbEventName: TComboBox
-          Left = 8
-          Top = 24
-          Width = 121
-          Height = 21
-          ItemHeight = 13
-          TabOrder = 0
-          OnChange = eEventNameChange
-        end
-      end
-    end
-    object TravelMap: TTabSheet
-      Caption = 'Travel'
-      ImageIndex = 2
-      DesignSize = (
-        596
-        137)
-      object pnlTravel: TPanel
-        Left = 0
-        Top = 0
-        Width = 594
-        Height = 112
-        Anchors = [akLeft, akTop, akRight, akBottom]
-        BevelOuter = bvNone
-        TabOrder = 0
-        object spTravel: TSplitter
-          Left = 201
-          Top = 0
-          Height = 112
-        end
-        object spMap: TSplitter
-          Left = 441
-          Top = 0
-          Height = 112
-          Align = alRight
-        end
-        object vtLocCategories: TVirtualStringTree
-          Left = 0
-          Top = 0
-          Width = 201
-          Height = 112
-          Align = alLeft
-          Header.AutoSizeIndex = 0
-          Header.Font.Charset = DEFAULT_CHARSET
-          Header.Font.Color = clWindowText
-          Header.Font.Height = -11
-          Header.Font.Name = 'MS Sans Serif'
-          Header.Font.Style = []
-          Header.MainColumn = -1
-          Header.Options = [hoColumnResize, hoDrag]
-          IncrementalSearchStart = ssAlwaysStartOver
-          ScrollBarOptions.AlwaysVisible = True
-          TabOrder = 0
-          TreeOptions.PaintOptions = [toShowButtons, toShowRoot, toShowTreeLines, toThemeAware, toUseBlendedImages]
-          OnChange = vtLocCategoriesChange
-          OnExpanding = vtLocCategoriesExpanding
-          OnGetText = vtCategoriesGetText
-          Columns = &lt;&gt;
-        end
-        object vtLocItems: TVirtualStringTree
-          Left = 204
-          Top = 0
-          Width = 237
-          Height = 112
-          Align = alClient
-          Header.AutoSizeIndex = 0
-          Header.Font.Charset = DEFAULT_CHARSET
-          Header.Font.Color = clWindowText
-          Header.Font.Height = -11
-          Header.Font.Name = 'MS Sans Serif'
-          Header.Font.Style = []
-          Header.Options = [hoColumnResize, hoDrag, hoShowSortGlyphs, hoVisible]
-          Header.SortColumn = 0
-          ScrollBarOptions.AlwaysVisible = True
-          ScrollBarOptions.ScrollBars = ssVertical
-          TabOrder = 1
-          TreeOptions.AutoOptions = [toAutoDropExpand, toAutoScrollOnExpand, toAutoSort, toAutoTristateTracking, toAutoDeleteMovedNodes, toAutoFreeOnCollapse]
-          TreeOptions.PaintOptions = [toHideFocusRect, toShowButtons, toThemeAware, toUseBlendedImages]
-          TreeOptions.SelectionOptions = [toDisableDrawSelection, toFullRowSelect]
-          OnChange = vtLocItemsChange
-          OnCompareNodes = vtLocItemsCompareNodes
-          OnDblClick = Go1Click
-          OnGetText = vtLocItemsGetText
-          OnHeaderClick = vtLocItemsHeaderClick
-          Columns = &lt;
-            item
-              Position = 0
-              Width = 197
-              WideText = 'Name'
-            end&gt;
-        end
-        object pbMap: TPaintBox32
-          Left = 444
-          Top = 0
-          Width = 150
-          Height = 112
-          Align = alRight
-          PopupMenu = pmTravel
-          TabOrder = 2
-          OnMouseDown = pbMapMouseDown
-          OnPaintBuffer = pbMapPaintBuffer
-        end
-      end
-      object btnTravel: TButton
-        Left = 0
-        Top = 114
-        Width = 75
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Travel'
-        TabOrder = 1
-        OnClick = Go1Click
-      end
-      object btnSend: TButton
-        Left = 80
-        Top = 114
-        Width = 75
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Send'
-        TabOrder = 2
-        OnClick = btnSendClick
-      end
-      object Button2: TButton
-        Left = 160
-        Top = 114
-        Width = 89
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Teleport Self'
-        TabOrder = 3
-        OnClick = Button2Click
-      end
-      object btnCmdSendOther: TButton
-        Left = 254
-        Top = 114
-        Width = 89
-        Height = 21
-        Anchors = [akLeft, akBottom]
-        Caption = 'Teleport Other'
-        TabOrder = 4
-        OnClick = btnCmdSendOtherClick
-      end
-      object btnCmdWhere: TButton
-        Left = 348
-        Top = 114
-        Width = 75
-        Height = 21
-        Hint = 'Show your current position.'
-        Anchors = [akLeft, akBottom]
-        Caption = 'Where'
-        TabOrder = 5
-        OnClick = btnCmdWhereClick
-      end
-      object btnMapOverview: TButton
-        Left = 428
-        Top = 114
-        Width = 75
-        Height = 21
-        Hint = 'Show your current position.'
-        Anchors = [akLeft, akBottom]
-        Caption = 'Overview'
-        TabOrder = 6
-        OnClick = btnMapOverviewClick
-      end
-    end
-    object tsSettings: TTabSheet
-      Caption = 'Settings'
-      ImageIndex = 1
-      object gbSettingsGeneral: TGroupBox
-        Left = 8
-        Top = 8
-        Width = 241
-        Height = 97
-        Caption = 'General Settings'
-        TabOrder = 0
-        object lblCommandPrefix: TLabel
-          Left = 45
-          Top = 64
-          Width = 76
-          Height = 13
-          Caption = 'Command Prefix'
-        end
-        object cbAlwaysOnTop: TCheckBox
-          Left = 16
-          Top = 24
-          Width = 97
-          Height = 17
-          Caption = 'Always on top'
-          TabOrder = 0
-          OnClick = cbAlwaysOnTopClick
-        end
-        object eCommandPrefix: TEdit
-          Left = 15
-          Top = 60
-          Width = 25
-          Height = 21
-          TabOrder = 1
-        end
-        object btnSave: TButton
-          Left = 152
-          Top = 56
-          Width = 75
-          Height = 25
-          Caption = '&amp;Save'
-          TabOrder = 2
-          OnClick = btnSaveClick
-        end
-      end
-      object btnRegions: TButton
-        Left = 264
-        Top = 16
-        Width = 75
-        Height = 25
-        Caption = 'Regions'
-        TabOrder = 1
-        OnClick = btnRegionsClick
-      end
-    end
-    object TabSheet2: TTabSheet
-      Caption = 'Build'
-      ImageIndex = 8
-      DesignSize = (
-        596
-        137)
-      object GroupBox9: TGroupBox
-        Left = 0
-        Top = 0
-        Width = 89
-        Height = 137
-        Anchors = [akLeft, akTop, akBottom]
-        Caption = 'Settings'
-        TabOrder = 0
-        object Label11: TLabel
-          Left = 8
-          Top = 18
-          Width = 10
-          Height = 16
-          Caption = 'Z'
-          Font.Charset = DEFAULT_CHARSET
-          Font.Color = clWindowText
-          Font.Height = -13
-          Font.Name = 'MS Sans Serif'
-          Font.Style = [fsBold]
-          ParentFont = False
-        end
-        object cbBuildZ: TComboBox
-          Left = 23
-          Top = 16
-          Width = 58
-          Height = 21
-          ItemHeight = 13
-          TabOrder = 0
-          Text = '0'
-          Items.Strings = (
-            '0'
-            '5'
-            '7'
-            '10'
-            '15'
-            '17'
-            '20'
-            '25'
-            '27'
-            '30'
-            '35'
-            '37'
-            '40')
-        end
-      end
-      object gbBuild: TGroupBox
-        Left = 96
-        Top = 0
-        Width = 489
-        Height = 137
-        Anchors = [akLeft, akTop, akRight, akBottom]
-        Caption = 'Build'
-        TabOrder = 1
-        DesignSize = (
-          489
-          137)
-        object sbBuild: TScrollBox
-          Left = 8
-          Top = 16
-          Width = 473
-          Height = 113
-          HorzScrollBar.Smooth = True
-          HorzScrollBar.Tracking = True
-          VertScrollBar.Smooth = True
-          VertScrollBar.Tracking = True
-          Anchors = [akLeft, akTop, akRight, akBottom]
-          BevelOuter = bvNone
-          BevelKind = bkSoft
-          TabOrder = 0
-          OnClick = sbBuildClick
-          OnMouseWheelDown = sbBuildMouseWheelDown
-          OnMouseWheelUp = sbBuildMouseWheelUp
-          OnResize = sbBuildResize
-        end
-      end
-    end
-    object tsCustom: TTabSheet
-      Caption = 'Custom'
-      ImageIndex = 9
-      OnResize = tsCustomResize
-    end
-  end
-  object XPManifest1: TXPManifest
-    Left = 572
-    Top = 28
-  end
-  object pmTravel: TPopupMenu
-    Left = 572
-    Top = 25
-    object Go1: TMenuItem
-      Caption = '&amp;Go'
-      OnClick = Go1Click
-    end
-    object Send1: TMenuItem
-      Caption = '&amp;Send'
-      OnClick = btnSendClick
-    end
-    object Center1: TMenuItem
-      Caption = '&amp;Center'
-      OnClick = Center1Click
-    end
-    object N1: TMenuItem
-      Caption = '-'
-    end
-    object Felucca1: TMenuItem
-      Caption = 'Felucca'
-      Checked = True
-      GroupIndex = 1
-      RadioItem = True
-      OnClick = Felucca1Click
-    end
-    object Trammel1: TMenuItem
-      Caption = 'Trammel'
-      GroupIndex = 1
-      RadioItem = True
-      OnClick = Trammel1Click
-    end
-    object Ilshenar1: TMenuItem
-      Caption = 'Ilshenar'
-      GroupIndex = 1
-      RadioItem = True
-      OnClick = Ilshenar1Click
-    end
-    object Malas1: TMenuItem
-      Caption = 'Malas'
-      GroupIndex = 1
-      RadioItem = True
-      OnClick = Malas1Click
-    end
-    object SamuraiEmpire1: TMenuItem
-      Caption = 'Samurai Empire'
-      GroupIndex = 1
-      OnClick = SamuraiEmpire1Click
-    end
-  end
-  object animtimer: TTimer
-    Enabled = False
-    Interval = 100
-    OnTimer = animtimerTimer
-    Left = 572
-    Top = 24
-  end
-  object ontopTimer: TTimer
-    Interval = 100
-    OnTimer = ontopTimerTimer
-    Left = 572
-    Top = 24
-  end
-  object btnCustomPopup: TPopupMenu
-    Left = 572
-    Top = 56
-    object AddButton1: TMenuItem
-      Caption = '&amp;Add Button'
-      OnClick = AddButton1Click
-    end
-    object Change1: TMenuItem
-      Caption = '&amp;Change'
-      OnClick = Change1Click
-    end
-    object Remove1: TMenuItem
-      Caption = '&amp;Remove'
-      OnClick = Remove1Click
-    end
-  end
-end

Deleted: trunk/WPGM/Main.~pas
===================================================================
--- trunk/WPGM/Main.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/Main.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,2398 +0,0 @@
-unit Main;
-
-interface
-
-uses
-  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
-  VirtualTrees, ComCtrls, ImgList, ExtCtrls, SQLite, SQLiteTable, UOTiledata,
-  GR32, GR32_Image, UOArt, UOAnim, StdCtrls, uConfig, XPMan, UOMap, UOStatics, UORadarCol,
-  Menus, UOHues, Buttons, SyncObjs;
-
-type TNode = record
-    Id: Cardinal;
-    Name: WideString;
-end;
-
-type TLocationNode = record
-   Id: Cardinal;
-   Name: WideString;
-   LocId: String;
-   PosX: Cardinal;
-   PosY: Cardinal;
-   PosZ: ShortInt;
-   PosMap: Byte;
-end;
-
-type TItemNode = record
-    Id: Cardinal;
-    Name: WideString;
-    ArtId: Word;
-    Color: Word;
-    AddId: String;
-end;
-
-type TMultiNode = record
-    Id: Cardinal;
-    Name: WideString;
-    AddId: String;
-    MultiId: Word;
-end;
-
-type TNpcEquipment = record
-  Layer: Byte;
-  Anim: Word;
-  Color: Word;
-end;
-
-type TNpcNode = record
-    Id: Cardinal;
-    Name: WideString;
-    BodyId: Word;
-    Skin: Word;
-    AddId: String;
-    Equipment: Array of TNpcEquipment;
-end;
-
-type PMultiNode = ^TMultiNode;
-type PItemNode = ^TItemNode;
-type PNPCNode = ^TNPCNode;
-type PLocationNode = ^TLocationNode;
-type PNode = ^TNode;
-
-type
-  TfrmMain = class(TForm)
-    Pages: TPageControl;
-    tsItems: TTabSheet;
-    tsSettings: TTabSheet;
-    pnlItems: TPanel;
-    spItems: TSplitter;
-    vtCategories: TVirtualStringTree;
-    vtItems: TVirtualStringTree;
-    XPManifest1: TXPManifest;
-    gbSettingsGeneral: TGroupBox;
-    cbAlwaysOnTop: TCheckBox;
-    btnAddItem: TButton;
-    btnRemoveItem: TButton;
-    lblCommandPrefix: TLabel;
-    eCommandPrefix: TEdit;
-    TravelMap: TTabSheet;
-    imgItemPreview: TImage32;
-    pnlTravel: TPanel;
-    vtLocCategories: TVirtualStringTree;
-    vtLocItems: TVirtualStringTree;
-    pbMap: TPaintBox32;
-    spTravel: TSplitter;
-    spMap: TSplitter;
-    pmTravel: TPopupMenu;
-    Go1: TMenuItem;
-    btnTravel: TButton;
-    btnSend: TButton;
-    tsCommands: TTabSheet;
-    GroupBox1: TGroupBox;
-    btnCmdAllmove: TButton;
-    btnCmdAllshow: TButton;
-    btnCmdInvisible: TButton;
-    btnCmdStaff: TButton;
-    btnCmdInvul: TButton;
-    btnCmdPageNotify: TButton;
-    GroupBox2: TGroupBox;
-    btnCmdShutdown: TButton;
-    btnCmdReloadPython: TButton;
-    btnCmdReloadScripts: TButton;
-    btnCmdReloadAccounts: TButton;
-    btnCmdReloadAll: TButton;
-    btnSave: TButton;
-    tsItemManip: TTabSheet;
-    tsTags: TTabSheet;
-    GroupBox3: TGroupBox;
-    eItemHue: TEdit;
-    btnChangeItemHue: TButton;
-    btnCmdDye: TButton;
-    pbHuePreview: TPaintBox32;
-    GroupBox4: TGroupBox;
-    btnCmdDupe: TButton;
-    btnCmdInfo: TButton;
-    btnCmdRemove: TButton;
-    btnCmdLock: TButton;
-    btnCmdNuke: TButton;
-    GroupBox5: TGroupBox;
-    cbItemProperty: TComboBox;
-    eItemPropValue: TEdit;
-    btnCmdItemSet: TButton;
-    btnCmdItemShow: TButton;
-    Label1: TLabel;
-    btnCmdItemTileColor: TButton;
-    GroupBox6: TGroupBox;
-    Label2: TLabel;
-    eTagValue: TEdit;
-    btnTagSet: TButton;
-    eTagName: TEdit;
-    Label3: TLabel;
-    btnTagShow: TButton;
-    btnTagDelete: TButton;
-    cbTagType: TComboBox;
-    btnTagInfo: TButton;
-    GroupBox7: TGroupBox;
-    Button2: TButton;
-    btnCmdSendOther: TButton;
-    Send1: TMenuItem;
-    eMoveX: TEdit;
-    eMoveY: TEdit;
-    eMoveZ: TEdit;
-    btnCmdMove: TButton;
-    Label4: TLabel;
-    Label5: TLabel;
-    Label6: TLabel;
-    btnCmdMoveUp: TBitBtn;
-    btnCmdMoveDown: TBitBtn;
-    btnTileItem: TButton;
-    eZLevel: TEdit;
-    Label7: TLabel;
-    btnCmdItemNuke: TButton;
-    GroupBox8: TGroupBox;
-    btnCmdAddEvent: TButton;
-    btnCmdRemoveEvent: TButton;
-    btnCmdShowEventlist: TButton;
-    btnCmdWhere: TButton;
-    btnCmdServertime: TButton;
-    cbEventName: TComboBox;
-    tsNpcs: TTabSheet;
-    pnNpcs: TPanel;
-    Splitter1: TSplitter;
-    vtNpcCategories: TVirtualStringTree;
-    vtNpcs: TVirtualStringTree;
-    btnAddNpc: TButton;
-    btnRemoveNpc: TButton;
-    Splitter2: TSplitter;
-    pbNpcPreview: TPaintBox32;
-    animtimer: TTimer;
-    TabSheet1: TTabSheet;
-    Panel1: TPanel;
-    vtMultis: TVirtualStringTree;
-    btnAddMulti: TButton;
-    btnRemoveMulti: TButton;
-    btnPreviewMulti: TButton;
-    N1: TMenuItem;
-    Felucca1: TMenuItem;
-    Trammel1: TMenuItem;
-    Ilshenar1: TMenuItem;
-    Malas1: TMenuItem;
-    Center1: TMenuItem;
-    SamuraiEmpire1: TMenuItem;
-    cbStatic: TCheckBox;
-    btnMapOverview: TButton;
-    ontopTimer: TTimer;
-    Label8: TLabel;
-    eSpawnRadius: TEdit;
-    Label9: TLabel;
-    eSpawnMin: TEdit;
-    Label10: TLabel;
-    eSpawnMax: TEdit;
-    btnNpcSpawn: TButton;
-    btnRegions: TButton;
-    Button1: TButton;
-    TabSheet2: TTabSheet;
-    GroupBox9: TGroupBox;
-    cbBuildZ: TComboBox;
-    Label11: TLabel;
-    gbBuild: TGroupBox;
-    sbBuild: TScrollBox;
-    tsCustom: TTabSheet;
-    btnCustomPopup: TPopupMenu;
-    Remove1: TMenuItem;
-    Change1: TMenuItem;
-    AddButton1: TMenuItem;
-    procedure FormCreate(Sender: TObject);
-    procedure FormDestroy(Sender: TObject);
-    procedure vtCategoriesGetText(Sender: TBaseVirtualTree;
-      Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
-      var CellText: WideString);
-    procedure vtCategoriesChange(Sender: TBaseVirtualTree;
-      Node: PVirtualNode);
-    procedure vtItemsGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
-      Column: TColumnIndex; TextType: TVSTTextType;
-      var CellText: WideString);
-    procedure vtCategoriesExpanding(Sender: TBaseVirtualTree;
-      Node: PVirtualNode; var Allowed: Boolean);
-    procedure vtItemsCompareNodes(Sender: TBaseVirtualTree; Node1,
-      Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
-    procedure vtItemsHeaderClick(Sender: TVTHeader; Column: TColumnIndex;
-      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-    procedure btnAddItemClick(Sender: TObject);
-    procedure vtItemsChange(Sender: TBaseVirtualTree; Node: PVirtualNode);
-    procedure btnRemoveItemClick(Sender: TObject);
-    procedure cbAlwaysOnTopClick(Sender: TObject);
-    procedure btnSaveClick(Sender: TObject);
-    procedure FormClose(Sender: TObject; var Action: TCloseAction);
-    procedure pbMapPaintBuffer(Sender: TObject);
-    procedure pbMapMouseDown(Sender: TObject; Button: TMouseButton;
-      Shift: TShiftState; X, Y: Integer);
-    procedure vtLocCategoriesExpanding(Sender: TBaseVirtualTree;
-      Node: PVirtualNode; var Allowed: Boolean);
-    procedure vtLocCategoriesChange(Sender: TBaseVirtualTree;
-      Node: PVirtualNode);
-    procedure vtLocItemsGetText(Sender: TBaseVirtualTree;
-      Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
-      var CellText: WideString);
-    procedure vtLocItemsCompareNodes(Sender: TBaseVirtualTree; Node1,
-      Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
-    procedure vtLocItemsHeaderClick(Sender: TVTHeader;
-      Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X,
-      Y: Integer);
-    procedure vtLocItemsChange(Sender: TBaseVirtualTree;
-      Node: PVirtualNode);
-    procedure Go1Click(Sender: TObject);
-    procedure btnSendClick(Sender: TObject);
-    procedure btnCmdAllmoveClick(Sender: TObject);
-    procedure btnCmdAllshowClick(Sender: TObject);
-    procedure btnCmdInvisibleClick(Sender: TObject);
-    procedure btnCmdStaffClick(Sender: TObject);
-    procedure btnCmdInvulClick(Sender: TObject);
-    procedure btnCmdShutdownClick(Sender: TObject);
-    procedure btnCmdReloadAllClick(Sender: TObject);
-    procedure btnCmdReloadConfigClick(Sender: TObject);
-    procedure btnCmdReloadAccountsClick(Sender: TObject);
-    procedure btnCmdReloadPythonClick(Sender: TObject);
-    procedure btnCmdReloadScriptsClick(Sender: TObject);
-    procedure btnCmdDyeClick(Sender: TObject);
-    procedure pbHuePreviewPaintBuffer(Sender: TObject);
-    procedure eItemHueChange(Sender: TObject);
-    procedure btnChangeItemHueClick(Sender: TObject);
-    procedure btnCmdDupeClick(Sender: TObject);
-    procedure btnCmdInfoClick(Sender: TObject);
-    procedure btnCmdRemoveClick(Sender: TObject);
-    procedure btnCmdLockClick(Sender: TObject);
-    procedure btnCmdNukeClick(Sender: TObject);
-    procedure btnCmdItemSetClick(Sender: TObject);
-    procedure btnCmdItemShowClick(Sender: TObject);
-    procedure cbItemPropertyChange(Sender: TObject);
-    procedure btnCmdItemTileColorClick(Sender: TObject);
-    procedure btnTagInfoClick(Sender: TObject);
-    procedure eTagNameChange(Sender: TObject);
-    procedure btnTagSetClick(Sender: TObject);
-    procedure btnTagShowClick(Sender: TObject);
-    procedure btnTagDeleteClick(Sender: TObject);
-    procedure btnCmdSendOtherClick(Sender: TObject);
-    procedure Button2Click(Sender: TObject);
-    procedure btnCmdMoveClick(Sender: TObject);
-    procedure btnCmdMoveUpClick(Sender: TObject);
-    procedure btnCmdMoveDownClick(Sender: TObject);
-    procedure btnTileItemClick(Sender: TObject);
-    procedure btnCmdShowEventlistClick(Sender: TObject);
-    procedure eEventNameChange(Sender: TObject);
-    procedure btnCmdAddEventClick(Sender: TObject);
-    procedure btnCmdRemoveEventClick(Sender: TObject);
-    procedure btnCmdWhereClick(Sender: TObject);
-    procedure btnCmdServertimeClick(Sender: TObject);
-    procedure vtNpcCategoriesExpanding(Sender: TBaseVirtualTree;
-      Node: PVirtualNode; var Allowed: Boolean);
-    procedure vtNpcCategoriesChange(Sender: TBaseVirtualTree;
-      Node: PVirtualNode);
-    procedure vtNpcsCompareNodes(Sender: TBaseVirtualTree; Node1,
-      Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
-    procedure vtNpcsGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
-      Column: TColumnIndex; TextType: TVSTTextType;
-      var CellText: WideString);
-    procedure btnRemoveNpcClick(Sender: TObject);
-    procedure btnAddNpcClick(Sender: TObject);
-    procedure vtNpcsChange(Sender: TBaseVirtualTree; Node: PVirtualNode);
-    procedure vtNpcsHeaderClick(Sender: TVTHeader; Column: TColumnIndex;
-      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-    procedure pbNpcPreviewPaintBuffer(Sender: TObject);
-    procedure animtimerTimer(Sender: TObject);
-    procedure vtMultisGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
-      Column: TColumnIndex; TextType: TVSTTextType;
-      var CellText: WideString);
-    procedure vtMultisCompareNodes(Sender: TBaseVirtualTree; Node1,
-      Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
-    procedure vtMultisHeaderClick(Sender: TVTHeader; Column: TColumnIndex;
-      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-    procedure vtMultisChange(Sender: TBaseVirtualTree; Node: PVirtualNode);
-    procedure btnPreviewMultiClick(Sender: TObject);
-    procedure btnAddMultiClick(Sender: TObject);
-    procedure Felucca1Click(Sender: TObject);
-    procedure Trammel1Click(Sender: TObject);
-    procedure Ilshenar1Click(Sender: TObject);
-    procedure Malas1Click(Sender: TObject);
-    procedure Center1Click(Sender: TObject);
-    procedure SamuraiEmpire1Click(Sender: TObject);
-    procedure btnStaticItemClick(Sender: TObject);
-    procedure btnMapOverviewClick(Sender: TObject);
-    procedure ontopTimerTimer(Sender: TObject);
-    procedure btnNpcSpawnClick(Sender: TObject);
-    procedure eSpawnRadiusExit(Sender: TObject);
-    procedure eSpawnMinExit(Sender: TObject);
-    procedure eSpawnMaxExit(Sender: TObject);
-    procedure btnRegionsClick(Sender: TObject);
-    procedure Button1Click(Sender: TObject);
-    procedure sbBuildResize(Sender: TObject);
-    procedure clickBuildButton(Sender: TObject);
-    procedure sbBuildClick(Sender: TObject);
-    procedure sbBuildMouseWheelDown(Sender: TObject; Shift: TShiftState;
-      MousePos: TPoint; var Handled: Boolean);
-    procedure sbBuildMouseWheelUp(Sender: TObject; Shift: TShiftState;
-      MousePos: TPoint; var Handled: Boolean);
-    procedure customButtonClick(Sender: TObject);
-    procedure customButtonMouseDown(Sender: TObject; Button: TMouseButton;
-      Shift: TShiftState; X, Y: Integer);
-    procedure Remove1Click(Sender: TObject);
-    procedure Change1Click(Sender: TObject);
-    procedure AddButton1Click(Sender: TObject);
-    procedure tsCustomResize(Sender: TObject);
-  private
-    { Private-Deklarationen }
-    UpdateMutex: TCriticalSection;
-  public
-    { Public-Deklarationen }
-    procedure pixelCombine(F: TColor32; var B: TColor32; M: TColor32);
-    procedure loadMultis;
-    procedure addBuildButton(Id: String; ItemId: Word; Text: String);
-    procedure rebuildBuildMenu;
-    procedure reorderCustomButtons;
-    procedure loadCustomButtons;
-    procedure saveCustomButtons;
-    procedure changeCustomButton(Button: TButton; NewButton: Boolean = False);
-  end;
-
-var
-  frmMain: TfrmMain;
-  SQLiteDb: TSQLiteDatabase;
-  ItemCategory: Cardinal;
-  Tiledata: TTiledataReader;
-  Art: TArtReader;
-  Anim: TAnimReader;
-  Maps: Array[0..4] of TMapReader;
-  Statics: Array[0..4] of TStaticReader;
-  Hues: THuesReader;
-  RadarCol: TRadarcolReader;
-  Config: TConfig;
-  MapCenterX, MapCenterY: Cardinal;
-  MapCenterZ: ShortInt;
-  MapCenterMap: Byte;
-  MapId: Cardinal;
-  npcPreview: Array of TAnimation;
-  npcPreviewFrame: Integer;
-  BuildCurrentX: Integer;
-  BuildCurrentY: Integer;
-
-implementation
-
-uses UOUtilities, uChooseHue, Math, uCenter, Overview, Spawnregions,
-  uPatternColor;
-
-{$R *.DFM}
-
-procedure TfrmMain.FormCreate(Sender: TObject);
-var
-    RootQuery: TSQLiteTable;
-    CountQuery: TSQLiteTable;
-    Node: PNode;
-    TreeNode: PVirtualNode;
-    UOPath: String;
-    i: Integer;
-    value: String;
-begin
-    inherited;
-
-    UpdateMutex := TCriticalSection.Create;
-
-    npcPreview := nil;
-    npcPreviewFrame := 0;
-    Tiledata := TTiledataReader.Create;
-    Art := TArtReader.Create;
-    Anim := TAnimReader.Create;
-    Config := TConfig.Create;
-    Hues := THuesReader.Create;
-    Art.hues := Hues; // Tell the art reader about the hues
-    Anim.hues := Hues; // Tell the anim reader about the hues
-    
-    MapCenterX := 0;
-    MapCenterY := 0;
-    MapCenterZ := 0;
-    MapCenterMap := 0;
-
-    // Should be updated to support multiple maps
-    for i := 0 to 4 do begin
-      Maps[i] := TMapReader.Create;
-      Statics[i] := TStaticReader.Create;
-    end;
-    RadarCol := TRadarColReader.Create;
-
-    Config.Load(ExtractFilePath( Application.ExeName ) + 'config.ini');
-
-    vtCategories.NodeDataSize := sizeof( TNode );
-    vtNpcCategories.NodeDataSize := sizeof(TNode);
-    vtLocCategories.NodeDataSize := sizeof(TNode);
-
-    vtItems.NodeDataSize := sizeof( TItemNode );
-    vtLocItems.NodeDataSize := sizeof(TLocationNode);
-    vtNpcs.NodeDataSize := sizeof( TNpcNode );
-    vtMultis.NodeDataSize := sizeof( TMultiNode );
-
-    eSpawnRadius.Text := Config.getString('SpawnRadius', '5');
-    eSpawnMin.Text := Config.getString('SpawnMin', '5');
-    eSpawnMax.Text := Config.getString('SpawnMax', '10');
-    eCommandPrefix.Text := Config.getString('Command Prefix', '''');
-    cbAlwaysOnTop.Checked := Config.getBool('Always On Top', False);
-    cbAlwaysOnTopClick(nil); // Refresh the Status
-    UOPath := getUoPath;
-
-    // Query initial count of Items
-    try
-    	SQLiteDb := TSQLiteDatabase.Create( 'categories.db' );
-        SQLiteDb.ExecSQL( 'PRAGMA default_cache_size = 10000;' );
-        SQLiteDb.ExecSQL( 'PRAGMA default_synchronous = OFF;' );
-        SQLiteDb.ExecSQL( 'PRAGMA full_column_names = OFF;' );
-        SQLiteDb.ExecSQL( 'PRAGMA show_datatypes = OFF;' );
-
-        RootQuery := TSQLiteTable.Create( SQLiteDb, 'SELECT id,name FROM categories WHERE type = 0 AND parent = 0 ORDER BY name ASC;' );
-        while not RootQuery.EOF do
-        begin
-          TreeNode := vtCategories.AddChild( nil );
-          Node := vtCategories.GetNodeData( TreeNode );
-          Node.Id := StrToInt( RootQuery.Fields[0] );
-          Node.Name := UTF8Decode(RootQuery.Fields[1]);
-          TreeNode.States := [ vsInitialized ] + TreeNode.States;
-
-          // Check for Children
-          CountQuery := SQLiteDb.GetTable( Format( 'SELECT COUNT(*) FROM categories WHERE type = 0 AND parent = %u', [ Node.Id ] ) );
-
-          if StrToInt(CountQuery.Fields[0]) &gt; 0 then
-            TreeNode.States := [ vsHasChildren ] + TreeNode.States;
-          CountQuery.Free;
-          RootQuery.Next;
-        end;
-        RootQuery.Free;
-
-        RootQuery := TSQLiteTable.Create( SQLiteDb, 'SELECT id,name FROM locationcategories WHERE type = 0 AND parent = 0 ORDER BY name ASC;' );
-        while not RootQuery.EOF do
-        begin
-          TreeNode := vtLocCategories.AddChild( nil );
-          Node := vtLocCategories.GetNodeData( TreeNode );
-          Node.Id := StrToInt( RootQuery.Fields[0] );
-          Node.Name := UTF8Decode(RootQuery.Fields[1]);
-
-          TreeNode.States := [ vsInitialized ] + TreeNode.States;
-
-          // Check for Children
-          CountQuery := SQLiteDb.GetTable( Format( 'SELECT COUNT(*) FROM locationcategories WHERE type = 0 AND parent = %u', [ Node.Id ] ) );
-
-          if StrToInt(CountQuery.Fields[0]) &gt; 0 then
-            TreeNode.States := [ vsHasChildren ] + TreeNode.States;
-          CountQuery.Free;
-          RootQuery.Next;
-        end;
-        RootQuery.Free;
-
-        RootQuery := TSQLiteTable.Create( SQLiteDb, 'SELECT id,name FROM npccategories WHERE type = 0 AND parent = 0 ORDER BY name ASC;' );
-        while not RootQuery.EOF do
-        begin
-          TreeNode := vtNpcCategories.AddChild( nil );
-          Node := vtNpcCategories.GetNodeData( TreeNode );
-          Node.Id := StrToInt( RootQuery.Fields[0] );
-          Node.Name := UTF8Decode(RootQuery.Fields[1]);
-          TreeNode.States := [ vsInitialized ] + TreeNode.States;
-
-          // Check for Children
-          CountQuery := SQLiteDb.GetTable( Format( 'SELECT COUNT(*) FROM npccategories WHERE type = 0 AND parent = %u', [ Node.Id ] ) );
-
-          if StrToInt(CountQuery.Fields[0]) &gt; 0 then
-            TreeNode.States := [ vsHasChildren ] + TreeNode.States;
-          CountQuery.Free;
-          RootQuery.Next;
-        end;
-        RootQuery.Free;
-
-        loadMultis;
-
-        { Load UO Files }
-        Tiledata.Open(Config.getString('Tiledata.mul Path',
-          UOPath + 'tiledata.mul'));
-        Art.Open(Config.getString('Artidx.mul Path', UOPath + 'artidx.mul'),
-          Config.getString('Art.mul Path', UOPath + 'art.mul'));
-        Anim.Open(Config.getString('Anim.idx Path', UOPath + 'anim.idx'),
-          Config.getString('Anim.mul Path', UOPath + 'anim.mul'),
-          Config.getString('Anim2.idx Path', UOPath + 'anim2.idx'),
-          Config.getString('Anim2.mul Path', UOPath + 'anim2.mul'),
-          Config.getString('Anim3.idx Path', UOPath + 'anim3.idx'),
-          Config.getString('Anim3.mul Path', UOPath + 'anim3.mul'),
-          Config.getString('Bodyconv.def Path', UOPath + 'bodyconv.def'),
-          Config.getString('Body.def Path', UOPath + 'body.def'));
-        RadarCol.Load(Config.getString('Radarcol.mul Path',
-          UOPath + 'radarcol.mul'));
-        Hues.Load(Config.getString('Hues.mul Path',
-          UOPath + 'hues.mul'));
-
-        Maps[0].Open(Config.getString('Map0.mul Path', UOPath + 'map0.mul'));
-        Statics[0].Open(
-          Config.getString('Staidx0.mul Path', UOPath + 'staidx0.mul'),
-          Config.getString('Statics0.mul Path', UOPath + 'statics0.mul'));
-        Maps[1] := Maps[0];
-        Statics[1] := Statics[0];
-        Maps[2].Open(Config.getString('Map2.mul Path', UOPath + 'map2.mul'));
-        Statics[2].Open(
-          Config.getString('Staidx2.mul Path', UOPath + 'staidx2.mul'),
-          Config.getString('Statics2.mul Path', UOPath + 'statics2.mul'));
-        Maps[3].Open(Config.getString('Map3.mul Path', UOPath + 'map3.mul'));
-        Statics[3].Open(
-          Config.getString('Staidx3.mul Path', UOPath + 'staidx3.mul'),
-          Config.getString('Statics3.mul Path', UOPath + 'statics3.mul'));
-        Maps[4].Open(Config.getString('Map4.mul Path', UOPath + 'map4.mul'));
-        Statics[4].Open(
-          Config.getString('Staidx4.mul Path', UOPath + 'staidx4.mul'),
-          Config.getString('Statics4.mul Path', UOPath + 'statics4.mul'));
-    except
-    	on E: Exception do
-        begin
-	    	Application.MessageBox(PChar(E.Message), 'Error', MB_OK+MB_ICONERROR );
-	        PostQuitMessage( 0 );
-	        Exit;
-        end;
-    end;
-
-  // Load Position
-  Left := Config.getInt('Window Position X', Left);
-  Top := Config.getInt('Window Position Y', Top);
-  Width := Config.getInt('Window Width', Width);
-  Height := Config.getInt('Window Height', Height);
-  Pages.ActivePageIndex := Config.getInt('Current Page', 0);
-
-  if Left &gt; Screen.Width then
-    Left := Screen.Width - Width;
-
-  if Top &gt; Screen.Height then
-    Top := Screen.Height - Height;
-
-  for i := 0 to Config.getInt('EventCount', 0) - 1 do
-  begin
-    Value := Config.getString(Format('Event%u', [i]), '');
-
-    if Value &lt;&gt; '' then
-      cbEventName.Items.Add(Value);
-  end;
-
-  rebuildBuildMenu;
-  loadCustomButtons;    
-end;
-
-{
-	Handler for WM_DESTROY
-}
-procedure TfrmMain.FormDestroy(Sender: TObject);
-begin
-	SQLiteDb.Free;
-    Tiledata.Free;
-
-    Art.Close;
-    Art.Free;
-
-    Anim.Close;
-    Anim.Free;
-
-    Maps[0].Close;
-    Maps[0].Free;
-
-    Statics[0].Close;
-    Statics[0].Free;
-
-    RadarCol.Free;
-    Hues.Free;
-
-    Config.Save;
-    Config.Free;
-
-  UpdateMutex.Free;
-
-  inherited;
-end;
-
-procedure TfrmMain.vtCategoriesGetText(Sender: TBaseVirtualTree;
-  Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
-  var CellText: WideString);
-begin
-  if TextType = ttNormal then
-  	CellText := PNode( Sender.GetNodeData( Node ) ).Name;
-end;
-
-{
-	An Item Category has been selected.
-}
-procedure TfrmMain.vtCategoriesChange(Sender: TBaseVirtualTree;
-  Node: PVirtualNode);
-var
-	MyData: PNode;
-    ItemData: PItemNode;
-	Query: TSQLiteTable;
-    TreeNode: PVirtualNode;
-begin
-    vtItems.Clear;
-    btnAddItem.Enabled := False;
-    btnTileItem.Enabled := False;
-
-    if Node = nil then
-        Exit;
-
-    MyData := Sender.GetNodeData(Node);
-    try
-      Query := TSQLiteTable.Create( SQLiteDb, Format( 'SELECT id,name,artid,addid,color FROM items WHERE parent = %u ORDER BY name;', [ MyData.Id ] ) );
-      while not Query.EOF do
-      begin
-        TreeNode := vtItems.AddChild( nil );
-        ItemData := vtItems.GetNodeData( TreeNode );
-
-        ItemData.Id := StrToInt( Query.Fields[0] );
-        ItemData.Name := UTF8Decode(Query.Fields[1]);
-        ItemData.ArtId := StrToInt( Query.Fields[2] );
-        ItemData.AddId := Query.Fields[3];
-        ItemData.Color := StrToIntDef( Query.Fields[4], 0);
-
-        Query.Next;
-      end;
-      Query.Free;
-      vtItems.SortTree(vtItems.Header.SortColumn, vtItems.Header.SortDirection);
-    except
-    	on E: Exception do
-        begin
-	    	Application.MessageBox( PChar( 'Error retrieving ChildCount: ' + E.Message ), 'Error', MB_OK+MB_ICONERROR );
-	        PostQuitMessage( 0 );
-	        Exit;
-        end;
-    end;
-end;
-
-procedure TfrmMain.vtItemsGetText(Sender: TBaseVirtualTree;
-  Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
-  var CellText: WideString);
-var
-	MyData: PItemNode;
-begin
-	MyData := Sender.GetNodeData( Node );
-
-    case Column of
-		0:
-        begin
-        	if Length( MyData.Name ) = 0 then
-            	CellText := Tiledata.getItemName( MyData.ArtId )
-            else
-		        CellText := MyData.Name;
-        end;
-
-        1: CellText := MyData.AddId;
-    end;
-end;
-
-procedure TfrmMain.vtCategoriesExpanding(Sender: TBaseVirtualTree;
-  Node: PVirtualNode; var Allowed: Boolean);
-var
-	MyData: PNode;
-    RootQuery, CountQuery: TSQLiteTable;
-    TreeNode: PVirtualNode;
-begin
-	// Children Already Added
-    if ( Sender.ChildCount[ Node ] &gt; 0 ) or not ( vsHasChildren in Node.States ) then
-    	exit;
-
-	// Add the Children
-    MyData := Sender.GetNodeData( Node );
-
-	try
-        RootQuery := TSQLiteTable.Create( SQLiteDb, Format( 'SELECT id,name FROM categories WHERE type = 0 AND parent = %u ORDER BY name ASC;', [ MyData.Id ] ) );
-
-        while not RootQuery.EOF do
-        begin
-	        TreeNode := vtCategories.AddChild( Node );
-            MyData := vtCategories.GetNodeData( TreeNode );
-            MyData.Id := StrToInt( RootQuery.Fields[0] );
-            MyData.Name := UTF8Decode(RootQuery.Fields[1]);
-            TreeNode.States := [ vsInitialized ] + TreeNode.States;
-
-            // Check for Children
-            CountQuery := SQLiteDb.GetTable( Format( 'SELECT COUNT(*) FROM categories WHERE type = 0 AND parent = %u', [ MyData.Id ] ) );
-
-			if StrToInt( CountQuery.Fields[0] ) &gt; 0 then
-            	TreeNode.States := [ vsHasChildren ] + TreeNode.States;
-
-            CountQuery.Free;
-
-            RootQuery.Next;
-        end;
-
-        RootQuery.Free;
-    except
-    	on E: Exception do
-      begin
-        Application.MessageBox( PChar( E.Message ), 'Error', MB_OK+MB_ICONERROR );
-        PostQuitMessage( 0 );
-        Exit;
-      end;
-    end;
-end;
-
-procedure TfrmMain.vtItemsCompareNodes(Sender: TBaseVirtualTree; Node1,
-  Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
-var
-	MyData1, MyData2: PItemNode;
-begin
-	MyData1 := Sender.GetNodeData( Node1 );
-	MyData2 := Sender.GetNodeData( Node2 );
-
-    case Column of
-        0: Result := CompareStr( MyData1.Name, MyData2.Name );
-        1: Result := CompareStr( MyData1.AddId, MyData2.AddId );
-    end;
-end;
-
-procedure TfrmMain.vtItemsHeaderClick(Sender: TVTHeader;
-  Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X,
-  Y: Integer);
-begin
-	// When changing we keep our sort direction
-    if Sender.SortColumn = Column then
-    begin
-		if Sender.SortDirection = sdAscending then
-        	Sender.SortDirection := sdDescending
-        else
-            Sender.SortDirection := sdAscending;
-        exit;
-    end;
-
-  	Sender.SortColumn := Column;
-    Sender.SortDirection := sdAscending;
-end;
-
-procedure TfrmMain.btnAddItemClick(Sender: TObject);
-var
-	NodeData: PItemNode;
-  Node: PVirtualNode;
-begin
-  Node := vtItems.RootNode.FirstChild;
-  while Node &lt;&gt; nil do
-  begin
-    if vsSelected in Node.States then
-    begin
-      NodeData := vtItems.GetNodeData(Node);
-      if cbStatic.Checked then
-        SendCommand('static ' + NodeData.AddId, true)
-      else
-        SendCommand('add ' + NodeData.AddId, true);
-      exit;
-    end;
-    Node := Node.NextSibling;
-  end;
-end;
-
-procedure TfrmMain.vtItemsChange(Sender: TBaseVirtualTree;
-  Node: PVirtualNode);
-var
-	MyItemData: PItemNode;
-  btmap: TBitmap32;
-begin
-  // Display a Preview Item
-  if Node &lt;&gt; nil then
-  begin
-    MyItemData := Sender.GetNodeData(Node);
-    btmap := Art.GetTile(MyItemData.ArtId, MyItemData.Color);
-    imgItemPreview.Bitmap.SetSizeFrom(btmap);
-    imgItemPreview.Bitmap.Clear(Color32(clBtnFace));
-    btmap.DrawTo(imgItemPreview.Bitmap, 0, 0);
-  end else begin
-    imgItemPreview.Bitmap.SetSize(0, 0);
-  end;
-
-  btnAddItem.Enabled := False;
-  btnTileItem.Enabled := False;
-
-  // See if there is some selected node
-  Node := vtItems.RootNode.FirstChild;
-  while Node &lt;&gt; nil do
-  begin
-    if vsSelected in Node.States then
-    begin
-      btnAddItem.Enabled := True;
-      btnTileItem.Enabled := True;
-      exit;
-    end;
-    Node := Node.NextSibling;
-  end;
-end;
-
-procedure TfrmMain.btnRemoveItemClick(Sender: TObject);
-begin
-    SendCommand('remove', true);
-end;
-
-procedure TfrmMain.cbAlwaysOnTopClick(Sender: TObject);
-var
-  lastpage: Integer;
-begin
-  lastpage := Pages.ActivePageIndex;
-
-  if not cbAlwaysOnTop.Checked then
-    frmMain.FormStyle := fsNormal
-  else
-    frmMain.FormStyle := fsStayOnTop;
-
-  Pages.ActivePageIndex := lastpage;
-end;
-
-procedure TfrmMain.btnSaveClick(Sender: TObject);
-begin
-  Config.setBool('Always On Top', cbAlwaysOnTop.Checked);
-  Config.setString('Command Prefix', eCommandPrefix.Text);
-  Config.Save;
-end;
-
-procedure TfrmMain.FormClose(Sender: TObject; var Action: TCloseAction);
-var
-  i: Integer;
-begin
-  // Save Position
-  Config.setInt('Window Position X', Left);
-  Config.setInt('Window Position Y', Top);
-  Config.setInt('Window Width', Width);
-  Config.setInt('Window Height', Height);
-  Config.setInt('Current Page', Pages.ActivePageIndex);
-
-  // Save the history of event names
-  Config.setInt('EventCount', cbEventName.Items.Count);
-  for i := 0 to cbEventName.Items.Count - 1 do
-  begin
-    Config.setString(Format('Event%u', [i]), cbEventName.Items[i]);
-  end;
-
-  inherited;  
-end;
-
-procedure TfrmMain.rebuildBuildMenu;
-var
-  i: Integer;
-begin
-  if sbBuild.ControlCount &gt; 0 then begin
-    UpdateMutex.Enter;
-    BuildCurrentX := 8;
-    BuildCurrentY := 8 - sbBuild.VertScrollBar.Position;
-
-    for i := 0 to sbBuild.ControlCount - 1 do begin
-      // Reposition
-      sbBuild.Controls[i].Left := BuildCurrentX;
-      sbBuild.Controls[i].Top := BuildCurrentY;
-
-      Inc(BuildCurrentX, sbBuild.Controls[i].Width + 8);
-
-      // If the next button wouldn't fit anymore, go to the next row
-      if BuildCurrentX + sbBuild.Controls[i].Width + 8 &gt; sbBuild.ClientWidth then begin
-        BuildCurrentX := 8;
-        Inc(BuildCurrentY, sbBuild.Controls[i].Height + 8);
-      end;
-    end;
-    UpdateMutex.Leave;
-    exit;
-  end;
-
-  BuildCurrentX := 8;
-  BuildCurrentY := 8;
-
-  // Add Build Table
-  addBuildButton('woodenboardse', $4ab, 'Floor');
-  addBuildButton('woodenboardsn', $4b5, 'Floor');
-
-  addBuildButton('woodenplankse', $4c7, 'Floor');
-  addBuildButton('woodenplanksn', $4d5, 'Floor');
-
-  addBuildButton('woodenlogse1', $507, 'Floor');
-  addBuildButton('woodenlogse2', $505, 'Floor');
-
-  addBuildButton('woodenlogsn1', $4c2, 'Floor');
-  addBuildButton('woodenlogsn2', $4c4, 'Floor');
-
-  addBuildButton('redfloor', $4f3, 'Floor');
-  addBuildButton('bluefloor', $4f2, 'Floor');
-
-  // Walls
-  addBuildButton('wall1', $1c, 'Wall');
-  addBuildButton('wall1small', $25, 'Wall');
-  addBuildButton('wall1tiny', $2f, 'Wall');
-  
-  addBuildButton('wall2', $58, 'Wall');
-  addBuildButton('wall2small', $5f, 'Wall');
-  addBuildButton('wall2smaller', $63, 'Wall');
-  addBuildButton('wall2tiny', $69, 'Wall');
-
-  addBuildButton('wall3small', $2ce, 'Wall');
-
-  addBuildButton('wall4', $c8, 'Wall');
-  addBuildButton('wall4small', $de, 'Wall');
-
-  addBuildButton('wall5', $1d0, 'Wall');
-  addBuildButton('wall5small', $1e9, 'Wall');
-
-  addBuildButton('woodenwall1', $c, 'Wall');
-  addBuildButton('woodenwall1small', $12, 'Wall');
-  addBuildButton('woodenwall1tiny', $16, 'Wall');
-  addBuildButton('woodenwall2', $a8, 'Wall');
-  addBuildButton('woodenwall2small', $b7, 'Wall');
-  addBuildButton('woodenwall2tiny', $bf, 'Wall');
-
-  addBuildButton('plasterwall1', $12e, 'Wall');
-  addBuildButton('plasterwall1wrecked', $389, 'Wall');
-  addBuildButton('brickwall', $34, 'Wall');
-  addBuildButton('brickwallsmall', $3e, 'Wall');
-  addBuildButton('brickwalltiny', $42, 'Wall');
-
-  // Roofs
-  addBuildButton('slateroofe', $5a1, 'Roof');
-  addBuildButton('slateroofn', $595, 'Roof');
-  addBuildButton('stonetileroofe', $193d, 'Roof');
-  addBuildButton('stonetileroofn', $193e, 'Roof');
-  addBuildButton('thatchroofe', $5a8, 'Roof');
-  addBuildButton('thatchroofn', $5a5, 'Roof');
-  addBuildButton('tileroofe', $5bf, 'Roof');
-  addBuildButton('tileroofn', $5b3, 'Roof');
-  addBuildButton('woodenshinglese', $5ce, 'Roof');
-  addBuildButton('woodenshinglesn', $5c2, 'Roof');
-  addBuildButton('palmroofe', $593, 'Roof');
-  addBuildButton('palmroofn', $590, 'Roof');
-  addBuildButton('logroofe', $5fc, 'Roof');
-  addBuildButton('logroofn', $5f0, 'Roof');
-  addBuildButton('hayroofe', $26ea, 'Roof');
-  addBuildButton('hayroofn', $26da, 'Roof');
-  addBuildButton('woodenslatee', $28d8, 'Roof');
-  addBuildButton('woodenslaten', $28c8, 'Roof');
-  addBuildButton('barkroofe', $2708, 'Roof');
-  addBuildButton('barkroofn', $26f8, 'Roof');
-
-  // Carpets
-  addBuildButton('bluecarpet1a', $abe, 'Carpet');
-  addBuildButton('bluecarpet1b', $abd, 'Carpet');
-  addBuildButton('bluecarpet1c', $abf, 'Carpet');
-  addBuildButton('bluecarpet1d', $ac0, 'Carpet');
-  addBuildButton('bluecarpet2', $ad1, 'Carpet');
-  addBuildButton('bluecarpet3a', $aec, 'Carpet');
-  addBuildButton('bluecarpet3b', $aed, 'Carpet');
-  addBuildButton('browncarpet', $ada, 'Carpet');
-
-  addBuildButton('redcarpet1a', $ac8, 'Carpet');
-  addBuildButton('redcarpet1b', $ac6, 'Carpet');
-  addBuildButton('redcarpet1c', $ac7, 'Carpet');
-  addBuildButton('redcarpet2', $aeb, 'Carpet');
-  addBuildButton('grayrug', $1df7, 'Carpet');
-  addBuildButton('greenrug1', $ab3, 'Carpet');
-  addBuildButton('greenrug2', $1dea, 'Carpet');
-  addBuildButton('greenrug3', $1de9, 'Carpet');
-
-  addBuildButton('bearskinn', $1e37, 'Carpet');
-  addBuildButton('bearskine', $1e41, 'Carpet');
-  addBuildButton('polarskinn', $1e4a, 'Carpet');
-  addBuildButton('polarskine', $1e54, 'Carpet');
-
-  addBuildButton('stonefountain', $1e4a, 'Fountains');
-  addBuildButton('sandstonefountain', $1e54, 'Fountains');
-end;
-
-procedure TfrmMain.pbMapPaintBuffer(Sender: TObject);
-var
-  x, y: Integer;
-  mapx, mapy: Integer;
-  MapLeft, MapTop: Integer;
-  MapCell: TMapCell;
-  StaticBlock: TStaticBlock;
-  i: Integer;
-  RelX, RelY: Byte;
-  HighestZ: Shortint;
-  Map: TMapReader;
-  Static: TStaticReader;
-  Width, Height: Word;
-  Position: String;
-  TextY: Integer;
-  Color: TColor;
-begin
-  MapLeft := - (pbMap.Width div 2);
-  MapTop := - (pbMap.Height div 2);
-
-  if MapCenterMap &gt; 4 then
-    exit;
-
-  Width := Maps[MapCenterMap].getWidth * 8;
-  Height := Maps[MapCenterMap].getHeight * 8;
-
-  Map := Maps[MapCenterMap];
-  Static := Statics[MapCenterMap];
-
-  pbMap.Buffer.Clear(clBlack32);
-  for x := 0 to pbMap.Width do
-  begin
-    for y := 0 to pbMap.Height do
-    begin
-      mapx := Integer(MapCenterX) + x + MapLeft;
-      mapy := Integer(MapCenterY) + y + MapTop;
-
-      if (mapx &gt;= Width) or (mapy &gt;= Height) then begin
-        pbMap.Buffer.PixelS[x, y] := clBlack32;
-        continue;
-      end;
-
-      if (mapx &gt;= 0) and (mapy &gt;= 0) then begin
-        Map.ReadCell(mapx, mapy, MapCell);
-        pbMap.Buffer.PixelS[x, y] := RadarCol.GetLandColor(MapCell.Id);
-
-        RelX := mapx mod 8;
-        RelY := mapy mod 8;
-        HighestZ := MapCell.Height;
-        Static.ReadBlock(mapx div 8, mapy div 8, StaticBlock);
-        for i := 0 to Length(StaticBlock) - 1 do begin
-          if (StaticBlock[i].X = RelX) and (StaticBlock[i].Y = RelY)
-            and (StaticBlock[i].Z &gt;= HighestZ) then begin
-            if StaticBlock[i].Hue = 0 then
-              pbMap.Buffer.PixelS[x, y] :=
-                RadarCol.GetItemColor(StaticBlock[i].Id)
-            else begin
-              // A little more complicated
-              //pbMap.Buffer.PixelS[x, y] := Color32(Color15to24(StaticBlock[i].Hue));
-              Color := RadarCol.GetItemColor(StaticBlock[i].Id);
-              Color := Hues.translateColor(StaticBlock[i].Hue, Color);
-              pbMap.Buffer.PixelS[x, y] := Color;
-            end;
-
-            HighestZ := StaticBlock[i].Z;
-          end;
-        end;
-
-        if (Cardinal(mapx) = MapCenterX) and
-          (Cardinal(mapy) = MapCenterY) then begin
-          MapCenterZ := HighestZ;
-          pbMap.Buffer.PixelS[x, y] := clWhite32;
-          continue;
-        end;        
-      end else begin
-        pbMap.Buffer.PixelS[x, y] := clGray32;
-      end;
-    end;
-  end;
-
-  // Show the current location
-  Position := Format('%u,%u,%d,%u', [MapCenterX, MapCenterY,
-    MapCenterZ, MapCenterMap]);
-  TextY := pbMap.Height - 2 - pbMap.Buffer.TextHeight(Position);
-  pbMap.Buffer.Font.Color := clWhite;
-  pbMap.Buffer.Textout(2, TextY, Position);
-end;
-
-procedure TfrmMain.pbMapMouseDown(Sender: TObject; Button: TMouseButton;
-  Shift: TShiftState; X, Y: Integer);
-var
-  RelX, RelY: Integer;
-  Width, Height: Cardinal;
-begin
-  if MapCenterMap &gt; 4 then
-    exit;
-
-  if Button &lt;&gt; mbLeft then
-    exit;
-
-  Width := Maps[MapCenterMap].getWidth * 8;
-  Height := Maps[MapCenterMap].getHeight * 8;
-
-  RelX := X - pbMap.Width div 2;
-  RelY := y - pbMap.Height div 2;
-
-  if Integer(MapCenterX) + RelX &gt;= 0 then begin
-    MapCenterX := Integer(MapCenterX) + RelX;
-  end else begin
-    MapCenterX := 0;
-  end;
-
-  if Integer(MapCenterY) + RelY &gt;= 0 then begin
-    MapCenterY := Integer(MapCenterY) + RelY;
-  end else begin
-    MapCenterY := 0;
-  end;
-
-  if MapCenterX &gt;= Width then
-    MapCenterX := Width - 1;
-
-  if MapCenterY &gt;= Height then
-    MapCenterY := Height - 1;
-
-  pbMap.Invalidate;
-end;
-
-procedure TfrmMain.vtLocCategoriesExpanding(Sender: TBaseVirtualTree;
-  Node: PVirtualNode; var Allowed: Boolean);
-var
-	MyData: PNode;
-    RootQuery, CountQuery: TSQLiteTable;
-    TreeNode: PVirtualNode;
-begin
-	// Children Already Added
-    if ( Sender.ChildCount[ Node ] &gt; 0 ) or not ( vsHasChildren in Node.States ) then
-    	exit;
-
-	// Add the Children
-    MyData := Sender.GetNodeData( Node );
-
-	try
-        RootQuery := TSQLiteTable.Create( SQLiteDb, Format( 'SELECT id,name FROM locationcategories WHERE type = 0 AND parent = %u ORDER BY name ASC;', [ MyData.Id ] ) );
-
-        while not RootQuery.EOF do
-        begin
-	        TreeNode := vtLocCategories.AddChild( Node );
-            MyData := vtLocCategories.GetNodeData( TreeNode );
-            MyData.Id := StrToInt( RootQuery.Fields[0] );
-            MyData.Name := UTF8Decode(RootQuery.Fields[1]);
-            TreeNode.States := [ vsInitialized ] + TreeNode.States;
-
-            // Check for Children
-            CountQuery := SQLiteDb.GetTable( Format( 'SELECT COUNT(*) FROM locationcategories WHERE type = 0 AND parent = %u', [ MyData.Id ] ) );
-
-			if StrToInt( CountQuery.Fields[0] ) &gt; 0 then
-            	TreeNode.States := [ vsHasChildren ] + TreeNode.States;
-
-            CountQuery.Free;
-
-            RootQuery.Next;
-        end;
-
-        RootQuery.Free;
-    except
-    	on E: Exception do
-        begin
-	    	Application.MessageBox( PChar( E.Message ), 'Error', MB_OK+MB_ICONERROR );
-	        PostQuitMessage( 0 );
-	        Exit;
-        end;
-    end;
-end;
-
-
-procedure TfrmMain.vtLocCategoriesChange(Sender: TBaseVirtualTree;
-  Node: PVirtualNode);
-var
-  MyData: PNode;
-  LocationData: PLocationNode;
-  Query: TSQLiteTable;
-  TreeNode: PVirtualNode;
-begin
- 
-
-  vtLocItems.Clear;
-  if Node = nil then
-      Exit;
-  MyData := Sender.GetNodeData(Node);
-  try
-    Query := TSQLiteTable.Create( SQLiteDb, Format( 'SELECT id,name,posx,posy,posz,posmap,location FROM locations WHERE parent = %u ORDER BY name;', [ MyData.Id ] ) );
-    while not Query.EOF do
-    begin
-      TreeNode := vtLocItems.AddChild( nil );
-      LocationData := vtLocItems.GetNodeData(TreeNode);
-
-      LocationData.Id := StrToInt( Query.Fields[0] );
-      LocationData.Name := UTF8Decode(Query.Fields[1]);
-      LocationData.PosX := StrToInt(Query.Fields[2]);
-      LocationData.PosY := StrToInt(Query.Fields[3]);
-      LocationData.PosZ := StrToInt(Query.Fields[4]);
-      LocationData.PosMap := StrToInt(Query.Fields[5]);
-      LocationData.LocId := Query.Fields[6];
-      Query.Next;
-    end;
-    Query.Free;
-    vtLocItems.SortTree(vtLocItems.Header.SortColumn, vtLocItems.Header.SortDirection);
-  except
-      on E: Exception do
-      begin
-        Application.MessageBox( PChar( 'Error retrieving ChildCount: ' + E.Message ), 'Error', MB_OK+MB_ICONERROR );
-        PostQuitMessage( 0 );
-        Exit;
-      end;
-  end;
-end;
-
-procedure TfrmMain.vtLocItemsGetText(Sender: TBaseVirtualTree;
-  Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
-  var CellText: WideString);
-var
-        MyData: PLocationNode;
-begin
-  myData := Sender.GetNodeData( Node );
-
-        case Column of
-                0:
-        begin
-                CellText := MyData.Name;
-        end;
-    end;
-
-end;
-
-procedure TfrmMain.vtLocItemsCompareNodes(Sender: TBaseVirtualTree; Node1,
-  Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
-var
-	MyData1, MyData2: PLocationNode;
-begin
-	MyData1 := Sender.GetNodeData( Node1 );
-	MyData2 := Sender.GetNodeData( Node2 );
-  Result := CompareStr( MyData1.Name, MyData2.Name );
-end;
-
-procedure TfrmMain.vtLocItemsHeaderClick(Sender: TVTHeader;
-  Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X,
-  Y: Integer);
-begin
-  // When changing we keep our sort direction
-  if Sender.SortDirection = sdAscending then
-    Sender.SortDirection := sdDescending
-  else
-    Sender.SortDirection := sdAscending;
-end;
-
-procedure TfrmMain.vtLocItemsChange(Sender: TBaseVirtualTree;
-  Node: PVirtualNode);
-var
-  LocationData: PLocationNode;
-begin
-  // Display a Preview Item
-  if Node &lt;&gt; nil then begin
-    LocationData := Sender.GetNodeData(Node);
-    MapCenterX := LocationData.PosX;
-    MapCenterY := LocationData.PosY;
-    MapCenterZ := LocationData.PosZ;
-    MapCenterMap := LocationData.PosMap;
-    pbMap.Invalidate;
-  end;
-end;
-
-procedure TfrmMain.Go1Click(Sender: TObject);
-begin
-  SendCommand(Format('go %u,%u,%d,%u',
-    [MapCenterX, MapCenterY, MapCenterZ, MapCenterMap]));
-end;
-
-procedure TfrmMain.btnSendClick(Sender: TObject);
-begin
-  SendCommand(Format('send %u,%u,%d,%u',
-    [MapCenterX, MapCenterY, MapCenterZ, MapCenterMap]));
-end;
-
-procedure TfrmMain.btnCmdAllmoveClick(Sender: TObject);
-begin
-  SendCommand('allmove');
-end;
-
-procedure TfrmMain.btnCmdAllshowClick(Sender: TObject);
-begin
-  SendCommand('allshow');
-end;
-
-procedure TfrmMain.btnCmdInvisibleClick(Sender: TObject);
-begin
-  SendCommand('invis');
-end;
-
-procedure TfrmMain.btnCmdStaffClick(Sender: TObject);
-begin
-  SendCommand('staff');
-end;
-
-procedure TfrmMain.btnCmdInvulClick(Sender: TObject);
-begin
-  SendCommand('invul');
-end;
-
-procedure TfrmMain.btnCmdShutdownClick(Sender: TObject);
-begin
-  if Application.MessageBox('Do you really want to close the Wolfpack server?',
-  'Shutdown', MB_YESNO+MB_ICONQUESTION) = IDYES then
-    SendCommand('shutdown');
-end;
-
-procedure TfrmMain.btnCmdReloadAllClick(Sender: TObject);
-begin
-  SendCommand('reload all');
-end;
-
-procedure TfrmMain.btnCmdReloadConfigClick(Sender: TObject);
-begin
-  SendCommand('reload configuration');
-end;
-
-procedure TfrmMain.btnCmdReloadAccountsClick(Sender: TObject);
-begin
-  SendCommand('reload accounts');
-end;
-
-procedure TfrmMain.btnCmdReloadPythonClick(Sender: TObject);
-begin
-  SendCommand('reload python');
-end;
-
-procedure TfrmMain.btnCmdReloadScriptsClick(Sender: TObject);
-begin
-  SendCommand('reload scripts');
-end;
-
-procedure TfrmMain.btnCmdDyeClick(Sender: TObject);
-begin
-  SendCommand(Format('dye %u', [StrToIntDef(eItemHue.Text, 0)]), True);
-end;
-
-procedure TfrmMain.pbHuePreviewPaintBuffer(Sender: TObject);
-var
-  i: Integer;
-  Width: Integer;
-  Hue: Word;
-begin
-  Hue := StrToIntDef(eItemHue.Text, 0);
-
-  if Hue = 0 then begin
-    pbHuePreview.Buffer.Clear(clGray32);
-    exit;
-  end;
-
-  Width := Ceil(pbHuePreview.Width / 32.0);
-  for i := 0 to 31 do
-  begin
-    pbHuePreview.Buffer.FillRect(i * Width, 0, (i + 1) * Width,
-      pbHuePreview.Height, Hues.getColor(Hue, i));
-  end;
-end;
-
-procedure TfrmMain.eItemHueChange(Sender: TObject);
-begin
-  pbHuePreview.Invalidate;
-end;
-
-procedure TfrmMain.btnChangeItemHueClick(Sender: TObject);
-begin
-  frmChooseHue.ShowModal;
-
-  if frmChooseHue.ModalResult = mrOk then
-  begin
-    eItemHue.Text := '0x' + IntToHex(frmChooseHue.ColorId, 0);
-    pbHuePreview.Invalidate;
-  end;
-end;
-
-procedure TfrmMain.btnCmdDupeClick(Sender: TObject);
-begin
-  SendCommand('dupe', True);
-end;
-
-procedure TfrmMain.btnCmdInfoClick(Sender: TObject);
-begin
-  SendCommand('info', True);
-end;
-
-procedure TfrmMain.btnCmdRemoveClick(Sender: TObject);
-begin
-  SendCommand('remove', True);
-end;
-
-procedure TfrmMain.btnCmdLockClick(Sender: TObject);
-begin
-  SendCommand('lock', True);
-end;
-
-procedure TfrmMain.btnCmdNukeClick(Sender: TObject);
-begin
-  SendCommand('nuke', True);
-end;
-
-procedure TfrmMain.btnCmdItemSetClick(Sender: TObject);
-begin
-  SendCommand(Format('set %s %s', [cbItemProperty.Text, eItemPropValue.Text]), True);
-end;
-
-procedure TfrmMain.btnCmdItemShowClick(Sender: TObject);
-begin
-  SendCommand(Format('show %s', [cbItemProperty.Text]), True);
-end;
-
-procedure TfrmMain.cbItemPropertyChange(Sender: TObject);
-begin
-  btnCmdItemSet.Enabled := Length(cbItemProperty.Text) &lt;&gt; 0;
-  btnCmdItemShow.Enabled := Length(cbItemProperty.Text) &lt;&gt; 0;
-end;
-
-procedure TfrmMain.btnCmdItemTileColorClick(Sender: TObject);
-begin
-  SendCommand('tilecolor ' + eItemHue.Text, true);
-end;
-
-procedure TfrmMain.btnTagInfoClick(Sender: TObject);
-begin
-  SendCommand('taginfo', True);
-end;
-
-procedure TfrmMain.eTagNameChange(Sender: TObject);
-begin
-  btnTagSet.Enabled := Length(eTagName.Text) &gt; 0;
-  btnTagShow.Enabled := btnTagSet.Enabled;
-  btnTagDelete.Enabled := btnTagSet.Enabled;
-end;
-
-procedure TfrmMain.btnTagSetClick(Sender: TObject);
-var
-  TagType: String;
-begin
-  TagType := 'string';
-  if cbTagType.ItemIndex = 1 then
-    TagType := 'int'
-  else if cbTagType.ItemIndex = 2 then
-    TagType := 'float';
-
-  if AnsiStrPos(PAnsiChar(eTagName.Text), ' ') &lt;&gt; nil then begin
-    Application.MessageBox('Tag names may not contain spaces.', 'Error',
-      MB_ICONERROR+MB_OK);
-    exit;
-  end;
-
-  SendCommand(format('settag %s %s %s',
-  [eTagName.Text, TagType, eTagValue.Text]), True);
-end;
-
-procedure TfrmMain.btnTagShowClick(Sender: TObject);
-begin
-  if AnsiStrPos(PAnsiChar(eTagName.Text), ' ') &lt;&gt; nil then begin
-    Application.MessageBox('Tag names may not contain spaces.', 'Error',
-      MB_ICONERROR+MB_OK);
-    exit;
-  end;
-
-  SendCommand(format('gettag %s', [eTagName.Text]), True);
-end;
-
-procedure TfrmMain.btnTagDeleteClick(Sender: TObject);
-begin
-  if AnsiStrPos(PAnsiChar(eTagName.Text), ' ') &lt;&gt; nil then begin
-    Application.MessageBox('Tag names may not contain spaces.', 'Error',
-      MB_ICONERROR+MB_OK);
-    exit;
-  end;
-
-  SendCommand(format('deltag %s', [eTagName.Text]), True);
-end;
-
-procedure TfrmMain.btnCmdSendOtherClick(Sender: TObject);
-begin
-  SendCommand('send', True);
-end;
-
-procedure TfrmMain.Button2Click(Sender: TObject);
-begin
-  SendCommand('tele', True);
-end;
-
-procedure TfrmMain.btnCmdMoveClick(Sender: TObject);
-begin
-  SendCommand(format('move %d,%d,%d',
-  [StrToIntDef(eMoveX.Text, 0), StrToIntDef(eMoveY.Text, 0),
-  StrToIntDef(eMoveZ.Text, 0)]), True);
-end;
-
-procedure TfrmMain.btnCmdMoveUpClick(Sender: TObject);
-begin
-  SendCommand('move 0,0,1', True);
-end;
-
-procedure TfrmMain.btnCmdMoveDownClick(Sender: TObject);
-begin
-  SendCommand('move 0,0,-1', True);
-end;
-
-procedure TfrmMain.btnTileItemClick(Sender: TObject);
-var
-	NodeData: PItemNode;
-  Node: PVirtualNode;
-  Ids: String;
-begin
-  Node := vtItems.RootNode.FirstChild;
-  Ids := '';
-
-  while Node &lt;&gt; nil do
-  begin
-    if vsSelected in Node.States then
-    begin
-      NodeData := vtItems.GetNodeData(Node);
-      if Length(Ids) &gt; 0 then
-        Ids := Ids + ',' + NodeData.AddId
-      else
-        Ids := NodeData.AddId;
-    end;
-    Node := Node.NextSibling;
-  end;
-
-  SendCommand(format('tile %d %s',
-  [StrToIntDef(eZLevel.Text, 0), Ids]), True);
-end;
-
-procedure TfrmMain.btnCmdShowEventlistClick(Sender: TObject);
-begin
-  SendCommand('show scriptlist', True);
-end;
-
-procedure TfrmMain.eEventNameChange(Sender: TObject);
-begin
-  btnCmdAddEvent.Enabled := Length(cbEventName.Text) &gt; 0;
-  btnCmdRemoveEvent.Enabled := Length(cbEventName.Text) &gt; 0;
-end;
-
-procedure TfrmMain.btnCmdAddEventClick(Sender: TObject);
-var
-  i: Integer;
-begin
-  SendCommand(format('addscript %s', [cbEventName.Text]), True);
-
-  // Add the text to the history if it's not already in there
-  for i := 0 to cbEventName.Items.Count - 1 do
-  begin
-    if cbEventName.Items[i] = cbEventName.Text then
-      exit;
-  end;
-
-  cbEventName.Items.Add(cbEventName.Text);
-end;
-
-procedure TfrmMain.btnCmdRemoveEventClick(Sender: TObject);
-var
-  i: Integer;
-begin
-  SendCommand(format('removescript %s', [cbEventName.Text]), True);
-
-  // Add the text to the history if it's not already in there
-  for i := 0 to cbEventName.Items.Count - 1 do
-  begin
-    if cbEventName.Items[i] = cbEventName.Text then
-      exit;
-  end;
-
-  cbEventName.Items.Add(cbEventName.Text);  
-end;
-
-procedure TfrmMain.btnCmdWhereClick(Sender: TObject);
-begin
-  SendCommand('where');
-end;
-
-procedure TfrmMain.btnCmdServertimeClick(Sender: TObject);
-begin
-  SendCommand('servertime');
-end;
-
-procedure TfrmMain.vtNpcCategoriesExpanding(Sender: TBaseVirtualTree;
-  Node: PVirtualNode; var Allowed: Boolean);
-var
-	MyData: PNode;
-    RootQuery, CountQuery: TSQLiteTable;
-    TreeNode: PVirtualNode;
-begin
-	// Children Already Added
-    if ( Sender.ChildCount[ Node ] &gt; 0 ) or not ( vsHasChildren in Node.States ) then
-    	exit;
-
-	// Add the Children
-    MyData := Sender.GetNodeData( Node );
-
-	try
-        RootQuery := TSQLiteTable.Create( SQLiteDb, Format( 'SELECT id,name FROM npccategories WHERE type = 0 AND parent = %u ORDER BY name ASC;', [ MyData.Id ] ) );
-
-        while not RootQuery.EOF do
-        begin
-	        TreeNode := vtNpcCategories.AddChild( Node );
-            MyData := vtNpcCategories.GetNodeData( TreeNode );
-            MyData.Id := StrToInt( RootQuery.Fields[0] );
-            MyData.Name := UTF8Decode(RootQuery.Fields[1]);
-            TreeNode.States := [ vsInitialized ] + TreeNode.States;
-
-            // Check for Children
-            CountQuery := SQLiteDb.GetTable( Format( 'SELECT COUNT(*) FROM npccategories WHERE type = 0 AND parent = %u', [ MyData.Id ] ) );
-
-			if StrToInt( CountQuery.Fields[0] ) &gt; 0 then
-            	TreeNode.States := [ vsHasChildren ] + TreeNode.States;
-
-            CountQuery.Free;
-
-            RootQuery.Next;
-        end;
-
-        RootQuery.Free;
-    except
-    	on E: Exception do
-      begin
-        Application.MessageBox( PChar( E.Message ), 'Error', MB_OK+MB_ICONERROR );
-        PostQuitMessage( 0 );
-        Exit;
-      end;
-    end;
-end;
-
-procedure TfrmMain.vtNpcCategoriesChange(Sender: TBaseVirtualTree;
-  Node: PVirtualNode);
-var
-	MyData: PNode;
-  ItemData: PNpcNode;
-	Query, SubQuery: TSQLiteTable;
-  TreeNode: PVirtualNode;
-  i: Integer;
-begin
-    vtNpcs.Clear;
-    btnAddNpc.Enabled := False;
-    btnNpcSpawn.Enabled := False;
-
-    if Node = nil then
-        Exit;
-
-    MyData := Sender.GetNodeData(Node);
-    try
-      Query := TSQLiteTable.Create( SQLiteDb, Format( 'SELECT id,name,bodyid,addid,skin FROM npcs WHERE parent = %u ORDER BY name;', [ MyData.Id ] ) );
-      while not Query.EOF do
-      begin
-        TreeNode := vtNpcs.AddChild( nil );
-        ItemData := vtNpcs.GetNodeData( TreeNode );
-
-        ItemData.Id := StrToInt( Query.Fields[0] );
-        ItemData.Name := UTF8Decode(Query.Fields[1]);
-        ItemData.BodyId := StrToInt( Query.Fields[2] );
-        ItemData.AddId := Query.Fields[3];
-        ItemData.Skin := StrToIntDef( Query.Fields[4], 0);
-
-        SubQuery := TSQLiteTable.Create(SQLiteDb, Format('SELECT layer,artid,color FROM npcequipment WHERE id = %u ORDER BY layer DESC', [ ItemData.Id ] ) );
-
-        while not SubQuery.Eof do
-        begin
-          i := Length(ItemData.Equipment);
-          SetLength(ItemData.Equipment, i + 1);
-          ItemData.Equipment[i].Layer := StrToInt( SubQuery.Fields[0] );
-          ItemData.Equipment[i].Anim := StrToInt( SubQuery.Fields[1] );
-          ItemData.Equipment[i].Color := StrToInt( SubQuery.Fields[2] );
-          SubQuery.Next;
-        end;
-
-        SubQuery.Free;
-
-        Query.Next;
-      end;
-      Query.Free;
-      vtNpcs.SortTree(vtNpcs.Header.SortColumn, vtNpcs.Header.SortDirection);
-    except
-    	on E: Exception do
-        begin
-	    	Application.MessageBox( PChar( 'Error retrieving ChildCount: ' + E.Message ), 'Error', MB_OK+MB_ICONERROR );
-	        PostQuitMessage( 0 );
-	        Exit;
-        end;
-    end;
-end;
-
-procedure TfrmMain.vtNpcsCompareNodes(Sender: TBaseVirtualTree; Node1,
-  Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
-var
-	MyData1, MyData2: PNpcNode;
-begin
-	MyData1 := Sender.GetNodeData( Node1 );
-	MyData2 := Sender.GetNodeData( Node2 );
-
-    case Column of
-        0: Result := CompareStr( MyData1.Name, MyData2.Name );
-        1: Result := CompareStr( MyData1.AddId, MyData2.AddId );
-    end;
-
-end;
-
-procedure TfrmMain.vtNpcsGetText(Sender: TBaseVirtualTree;
-  Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
-  var CellText: WideString);
-var
-	MyData: PNpcNode;
-begin
-	MyData := Sender.GetNodeData( Node );
-
-    case Column of
-		    0: CellText := MyData.Name;
-        1: CellText := MyData.AddId;
-    end;
-end;
-
-procedure TfrmMain.btnRemoveNpcClick(Sender: TObject);
-begin
-    SendCommand('remove', true);
-end;
-
-procedure TfrmMain.btnAddNpcClick(Sender: TObject);
-var
-	NodeData: PNpcNode;
-  Node: PVirtualNode;
-begin
-  Node := vtNpcs.RootNode.FirstChild;
-  while Node &lt;&gt; nil do
-  begin
-    if vsSelected in Node.States then
-    begin
-      NodeData := vtNpcs.GetNodeData(Node);
-      SendCommand('add ' + NodeData.AddId, true);
-      exit;
-    end;
-    Node := Node.NextSibling;
-  end;
-end;
-
-procedure TfrmMain.vtNpcsChange(Sender: TBaseVirtualTree;
-  Node: PVirtualNode);
-var
-	MyItemData: PNpcNode;
-  frames: TAnimation;
-  i, j: Integer;
-
-  const LayerOrder: Array[0..21] of Byte = ( 20, 5, 4, 3, 24, 23, 13, 19, 17, 22, 12, 14, 8, 7, 1, 2, 10, 16, 11, 18, 6, 21 );
-begin
-  animtimer.Enabled := false;
-
-  for i := 0 to Length(npcPreview) - 1 do
-    npcPreview[i].Free;
-
-  SetLength(npcPreview, 0);
-
-  // Display a Preview Item
-  if Node &lt;&gt; nil then
-  begin
-    MyItemData := Sender.GetNodeData(Node);
-
-    frames := Anim.GetFrames(MyItemData.BodyId, 1, MyItemData.Skin);
-    
-    if frames &lt;&gt; nil then begin
-      SetLength(npcPreview, 1);
-      npcPreview[0] := frames;
-
-      // Add Equipment
-      for j := 0 to Length(LayerOrder) - 1 do begin
-        for i := 0 to Length(MyItemData.Equipment) - 1 do begin
-          if MyItemData.Equipment[i].Layer = LayerOrder[j] then begin
-            frames := Anim.GetFrames(MyItemData.Equipment[i].Anim, 1, MyItemData.Equipment[i].Color);
-            if frames &lt;&gt; nil then begin
-              SetLength(npcPreview, Length(npcPreview) + 1);
-              npcPreview[Length(npcPreview) - 1] := frames;
-            end;
-          end;
-        end;
-      end;
-
-      npcPreviewFrame := 0;
-      pbNpcPreview.Invalidate;
-      animtimer.Interval := npcPreview[0].frameDelay;
-      animtimer.Enabled := true;
-    end;
-
-  end else begin
-    pbNpcPreview.Invalidate;
-  end;
-
-  btnAddNpc.Enabled := False;
-  btnNpcSpawn.Enabled := False;
-
-  // See if there is some selected node
-  Node := vtNpcs.RootNode.FirstChild;
-  while Node &lt;&gt; nil do
-  begin
-    if vsSelected in Node.States then
-    begin
-      btnAddNpc.Enabled := True;
-      btnNpcSpawn.Enabled := True;
-      exit;
-    end;
-    Node := Node.NextSibling;
-  end;
-end;
-
-procedure TfrmMain.vtNpcsHeaderClick(Sender: TVTHeader;
-  Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X,
-  Y: Integer);
-begin
-	// When changing we keep our sort direction
-    if Sender.SortColumn = Column then
-    begin
-		if Sender.SortDirection = sdAscending then
-        	Sender.SortDirection := sdDescending
-        else
-            Sender.SortDirection := sdAscending;
-        exit;
-    end;
-
-  	Sender.SortColumn := Column;
-    Sender.SortDirection := sdAscending;
-end;
-
-procedure TFrmMain.pixelCombine(F: TColor32; var B: TColor32; M: TColor32);
-begin
-
-end;
-
-procedure TfrmMain.pbNpcPreviewPaintBuffer(Sender: TObject);
-var
-  pb: TPaintBox32;
-  totalHeight, totalWidth, i, xpos, ypos: Integer;
-  frame: PAnimFrame;
-begin
-  if not (Sender is TPaintBox32) then
-    exit;
-
-  pb := Sender as TPaintBox32;
-  pb.Buffer.Clear(clGray32);
-
-  // Draw Centered
-  if (npcPreview &lt;&gt; nil) and (length(npcPreview) &gt; 0) then begin
-    // Measure Total Height and Width
-    totalHeight := 0;
-    totalWidth := 0;
-
-    for i := 0 to Length(npcPreview) - 1 do begin
-      totalHeight := Max(npcPreview[i].getTotalHeight, totalHeight);
-      totalWidth := Max(npcPreview[i].getTotalWidth, totalWidth);
-    end;
-
-    xpos := (pb.ClientWidth div 2);
-    ypos := (pb.ClientHeight div 2) + (totalHeight div 2);
-
-    for i := 0 to Length(npcPreview) - 1 do begin
-      frame := npcPreview[i].getFrame(npcPreviewFrame);
-
-      if frame &lt;&gt; nil then begin
-        pb.Buffer.Draw(xpos - frame.CenterX, ypos - frame.image.height - frame.CenterY, frame.Image);
-      end;
-    end;
-  end;
-end;
-
-procedure TfrmMain.animtimerTimer(Sender: TObject);
-begin
-  if (npcPreview &lt;&gt; nil) and (npcPreview[0].frameCount &gt; 0) then begin
-    npcPreviewFrame := (npcPreviewFrame + 1) mod npcPreview[0].frameCount;
-    pbNpcPreview.Invalidate;
-  end;
-end;
-
-procedure TfrmMain.loadMultis;
-var
-  Query: TSQLiteTable;
-  Node: PVirtualNode;
-  Data: PMultiNode;
-begin
-  try
-    Query := TSQLiteTable.Create(SQLiteDb, 'SELECT id,name,addid,multiid FROM multis;');
-
-    while not Query.EOF do begin
-      Node := vtMultis.AddChild(nil);
-      Data := vtMultis.GetNodeData(Node);
-
-      Data.Id := StrToInt(Query.Fields[0]);
-      Data.Name := UTF8Decode(Query.Fields[1]);
-      Data.AddId := Query.Fields[2];
-      Data.MultiId := StrToInt(Query.Fields[0]);
-
-      Query.Next;
-    end;
-
-    Query.Free;
-    vtMultis.SortTree(vtMultis.Header.SortColumn, vtMultis.Header.SortDirection);
-  except
-    	on E: Exception do
-	    	Application.MessageBox(PChar(E.Message), 'Error', MB_OK+MB_ICONERROR ); 
-  end;
-end;
-
-procedure TfrmMain.vtMultisGetText(Sender: TBaseVirtualTree;
-  Node: PVirtualNode; Column: TColumnIndex; TextType: TVSTTextType;
-  var CellText: WideString);
-var
-	MyData: PMultiNode;
-begin
-	MyData := Sender.GetNodeData( Node );
-
-    case Column of
-		    0: CellText := MyData.Name;
-        1: CellText := MyData.AddId;
-    end;
-end;
-
-procedure TfrmMain.vtMultisCompareNodes(Sender: TBaseVirtualTree; Node1,
-  Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
-var
-	MyData1, MyData2: PMultiNode;
-begin
-	MyData1 := Sender.GetNodeData( Node1 );
-	MyData2 := Sender.GetNodeData( Node2 );
-
-    case Column of
-        0: Result := CompareStr( MyData1.Name, MyData2.Name );
-        1: Result := CompareStr( MyData1.AddId, MyData2.AddId );
-    end;
-end;
-
-procedure TfrmMain.vtMultisHeaderClick(Sender: TVTHeader;
-  Column: TColumnIndex; Button: TMouseButton; Shift: TShiftState; X,
-  Y: Integer);
-begin
-	// When changing we keep our sort direction
-    if Sender.SortColumn = Column then
-    begin
-		if Sender.SortDirection = sdAscending then
-        	Sender.SortDirection := sdDescending
-        else
-            Sender.SortDirection := sdAscending;
-        exit;
-    end;
-
-  	Sender.SortColumn := Column;
-    Sender.SortDirection := sdAscending;
-end;
-
-procedure TfrmMain.vtMultisChange(Sender: TBaseVirtualTree;
-  Node: PVirtualNode);
-begin
-  if Sender.SelectedCount &lt; 1 then begin
-    btnAddMulti.Enabled := False;
-    btnPreviewMulti.Enabled := False;
-  end else begin
-    btnAddMulti.Enabled := True;
-    btnPreviewMulti.Enabled := True;
-  end;
-end;
-
-procedure TfrmMain.btnPreviewMultiClick(Sender: TObject);
-begin
-  Application.MessageBox('Not yet implemented', 'Error', MB_OK+MB_ICONERROR);
-end;
-
-procedure TfrmMain.btnAddMultiClick(Sender: TObject);
-var
-	NodeData: PMultiNode;
-  Node: PVirtualNode;
-begin
-  Node := vtMultis.RootNode.FirstChild;
-  while Node &lt;&gt; nil do
-  begin
-    if vsSelected in Node.States then
-    begin
-      NodeData := vtMultis.GetNodeData(Node);
-      SendCommand('add ' + NodeData.AddId, true);
-      exit;
-    end;
-    Node := Node.NextSibling;
-  end;
-end;
-
-procedure TfrmMain.Felucca1Click(Sender: TObject);
-begin
-  MapCenterX := 0;
-  MapCenterY := 0;
-  MapCenterZ := 0;
-  MapCenterMap := 0;
-  Felucca1.Checked := True;
-  Trammel1.Checked := False;
-  Ilshenar1.Checked := False;
-  Malas1.Checked := False;
-  SamuraiEmpire1.Checked := False;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmMain.Trammel1Click(Sender: TObject);
-begin
-  MapCenterX := 0;
-  MapCenterY := 0;
-  MapCenterZ := 0;
-  MapCenterMap := 1;
-  Felucca1.Checked := False;
-  Trammel1.Checked := True;
-  Ilshenar1.Checked := False;
-  Malas1.Checked := False;
-  SamuraiEmpire1.Checked := False;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmMain.Ilshenar1Click(Sender: TObject);
-begin
-  MapCenterX := 0;
-  MapCenterY := 0;
-  MapCenterZ := 0;
-  MapCenterMap := 2;
-  Felucca1.Checked := False;
-  Trammel1.Checked := False;
-  Ilshenar1.Checked := True;
-  Malas1.Checked := False;
-  SamuraiEmpire1.Checked := False;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmMain.Malas1Click(Sender: TObject);
-begin
-  MapCenterX := 0;
-  MapCenterY := 0;
-  MapCenterZ := 0;
-  MapCenterMap := 3;
-  Felucca1.Checked := False;
-  Trammel1.Checked := False;
-  Ilshenar1.Checked := False;
-  Malas1.Checked := True;
-  SamuraiEmpire1.Checked := False;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmMain.Center1Click(Sender: TObject);
-begin
-  frmCenter.Show;
-  frmCenter.X.Text := IntToStr(MapCenterX);
-  frmCenter.Y.Text := IntToStr(MapCenterY);
-  frmCenter.Map.ItemIndex := MapCenterMap;
-end;
-
-procedure TfrmMain.SamuraiEmpire1Click(Sender: TObject);
-begin
-  MapCenterX := 0;
-  MapCenterY := 0;
-  MapCenterZ := 0;
-  MapCenterMap := 4;
-  Felucca1.Checked := False;
-  Trammel1.Checked := False;
-  Ilshenar1.Checked := False;
-  Malas1.Checked := False;
-  SamuraiEmpire1.Checked := True;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmMain.btnStaticItemClick(Sender: TObject);
-var
-	NodeData: PItemNode;
-  Node: PVirtualNode;
-begin
-  Node := vtItems.RootNode.FirstChild;
-  while Node &lt;&gt; nil do
-  begin
-    if vsSelected in Node.States then
-    begin
-      NodeData := vtItems.GetNodeData(Node);
-      SendCommand('static ' + NodeData.AddId, true);
-      exit;
-    end;
-    Node := Node.NextSibling;
-  end;
-
-end;
-
-procedure TfrmMain.btnMapOverviewClick(Sender: TObject);
-begin
-  if not frmOverview.Generating then begin
-    frmOverview.showMap(MapCenterMap);
-    frmOverview.Show;
-  end;
-end;
-
-function IsInParent(Control: TWinControl): Boolean;
-begin
-  if Control is TCustomForm then
-    Result := True
-  else if Control.Parent &lt;&gt; nil then
-    Result := IsInParent(Control.Parent)
-  else
-    Result := False;
-end;
-
-procedure TfrmMain.ontopTimerTimer(Sender: TObject);
-begin
-  // If one of the forms is active, skip this code
-  if frmMain.Active or frmCenter.Active or frmOverview.Active then
-    exit;
-
-  if IsInParent(Screen.ActiveControl) then
-    exit;
-
-  if cbAlwaysOnTop.Checked then begin
-    if frmMain.Visible then begin
-      SetWindowPos(frmMain.Handle, HWND_TOPMOST, 0, 0, 0, 0, 3 or SWP_NOACTIVATE);
-    end;
-
-    if frmCenter.Visible then begin
-      SetWindowPos(frmCenter.Handle, HWND_TOPMOST, 0, 0, 0, 0, 3 or SWP_NOACTIVATE);
-    end;
-
-    if frmOverview.Visible then begin
-      SetWindowPos(frmOverview.Handle, HWND_TOPMOST, 0, 0, 0, 0, 3 or SWP_NOACTIVATE);
-    end;
-  end;
-end;
-
-procedure TfrmMain.btnNpcSpawnClick(Sender: TObject);
-var
-	NodeData: PNpcNode;
-  Node: PVirtualNode;
-begin
-  Node := vtNpcs.RootNode.FirstChild;
-  while Node &lt;&gt; nil do
-  begin
-    if vsSelected in Node.States then
-    begin
-      NodeData := vtNpcs.GetNodeData(Node);
-      SendCommand(Format('spawn %s %s %s %s', [NodeData.AddId, eSpawnRadius.Text, eSpawnMin.Text, eSpawnMax.Text]), True);
-      exit;
-    end;
-    Node := Node.NextSibling;
-  end;
-end;
-
-procedure TfrmMain.eSpawnRadiusExit(Sender: TObject);
-begin
-  Config.setString('SpawnRadius', eSpawnRadius.Text);
-  Config.Save;
-end;
-
-procedure TfrmMain.eSpawnMinExit(Sender: TObject);
-begin
-  Config.setString('SpawnMin', eSpawnMin.Text);
-  Config.Save;
-end;
-
-procedure TfrmMain.eSpawnMaxExit(Sender: TObject);
-begin
-  Config.setString('SpawnMax', eSpawnMax.Text);
-  Config.Save;
-end;
-
-procedure TfrmMain.btnRegionsClick(Sender: TObject);
-begin
-  frmRegions.Show;
-end;
-
-procedure TfrmMain.Button1Click(Sender: TObject);
-begin
-  frmPatternColor.Show;
-end;
-
-procedure TFrmMain.addBuildButton(Id: String; ItemId: Word; Text: String);
-var
-  BitBtn: TBitBtn;
-begin
-  BitBtn := TBitBtn.Create(sbBuild);
-  BitBtn.SetBounds(BuildCurrentX, BuildCurrentY, 70, 120);
-//  BitBtn.Caption := Text;
-  BitBtn.Glyph.Assign(Art.GetTile(ItemId));
-  BitBtn.Layout := blGlyphTop;
-  BitBtn.Hint := id;
-  BitBtn.OnClick := clickBuildButton;
-  sbBuild.InsertControl(BitBtn);
-
-  Inc(BuildCurrentX, 70 + 8);
-
-  // If the next button wouldn't fit anymore, go to the next row
-  if BuildCurrentX + 70 + 8 &gt; sbBuild.ClientWidth then begin
-    BuildCurrentX := 8;
-    Inc(BuildCurrentY, 120 + 8);
-  end;
-end;
-
-procedure TfrmMain.sbBuildResize(Sender: TObject);
-begin
-  rebuildBuildMenu;
-end;
-
-procedure TfrmMain.clickBuildButton(Sender: TObject);
-var
-  BitBtn: TBitBtn;
-begin
-  if not (Sender is TBitBtn) then
-    exit;
-
-  BitBtn := Sender as TBitBtn;
-  SendCommand(Format('build %s %d', [BitBtn.Hint, StrToIntDef(cbBuildZ.Text, 0)]), True);      
-end;
-
-procedure TfrmMain.sbBuildClick(Sender: TObject);
-begin
-  sbBuild.SetFocus;
-end;
-
-procedure TfrmMain.sbBuildMouseWheelDown(Sender: TObject;
-  Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);
-begin
-  SendMessage(sbBuild.Handle, WM_VSCROLL, SB_LINEDOWN, 0);
-  Handled := True;
-end;
-
-procedure TfrmMain.sbBuildMouseWheelUp(Sender: TObject; Shift: TShiftState;
-  MousePos: TPoint; var Handled: Boolean);
-begin
-  SendMessage(sbBuild.Handle, WM_VSCROLL, SB_LINEUP, 0);
-  Handled := True;
-end;
-
-procedure TfrmMain.reorderCustomButtons;
-var
-  currentx, currenty, i: Integer;
-begin
-  currentx := 8;
-  currenty := 8;
-
-  for i := 0 to tsCustom.ControlCount - 1 do begin
-    tsCustom.Controls[i].Left := currentx;
-    tsCustom.Controls[i].Top := currenty;
-    Inc(currenty, tsCustom.Controls[i].Height + 8);
-
-    if CurrentY + tsCustom.Controls[i].Height &gt; tsCustom.ClientHeight then begin
-      CurrentY := 8;
-      inc(CurrentX, tsCustom.Controls[i].Width + 8);
-    end;
-  end;
-end;
-
-procedure TfrmMain.loadCustomButtons;
-var
-  count, i: Integer;
-  command: String;
-  button: TButton;
-begin
-  count := Config.getInt('CustomButtonCount', 0);
-
-  // Load the custom buttons
-  for i := 0 to count - 1 do begin
-    command := Config.getString(Format('CustomButton%u', [i]), '');
-
-    button := TButton.Create(tsCustom);
-    button.SetBounds(0, 0, 129, 25);
-    button.Caption := command;
-    button.OnClick := customButtonClick;
-    button.OnMouseDown := customButtonMouseDown;
-    button.PopupMenu := btnCustomPopup;
-    button.Parent := tsCustom;
-  end;
-
-  // If no button at all was loaded, create an empty one to make
-  // adding buttons possible. (RightClick -&gt; Add Button)
-  if Count = 0 then begin
-    button := TButton.Create(tsCustom);
-    button.SetBounds(0, 0, 129, 25);
-    button.Caption := '';
-    button.OnClick := customButtonClick;
-    button.OnMouseDown := customButtonMouseDown;
-    button.PopupMenu := btnCustomPopup;
-    button.Parent := tsCustom;
-  end;
-
-  reorderCustomButtons;
-end;
-
-procedure TfrmMain.saveCustomButtons;
-var
-  count, i: Integer;
-  button: TButton;
-begin
-  count := 0;
-
-  // Account for all custom buttons
-  for i := 0 to tsCustom.ControlCount - 1 do begin
-    button := tsCustom.Controls[i] as TButton;
-    if button &lt;&gt; nil then begin
-      Config.setString(Format('CustomButton%u', [i]), Button.Caption);
-      Inc(Count);
-    end;
-  end;
-
-  Config.setInt('CustomButtonCount', count);
-end;
-
-procedure TfrmMain.customButtonClick(Sender: TObject);
-var
-  button: TButton;
-begin
-  button := sender as TButton;
-
-  if button &lt;&gt; nil then begin
-    // If it's empty, show the change gump instead
-    if button.caption = '' then begin
-      changeCustomButton(button);
-    end else begin
-      SendCommand(button.caption, True);
-    end;
-  end;
-end;
-
-procedure TfrmMain.customButtonMouseDown(Sender: TObject;
-  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-var
-  i, index: Integer;
-begin
-  if Button = mbRight then begin
-    index := -1;
-
-    // Find the index of this button in the custom ctrl
-    for i := 0 to tsCustom.ControlCount - 1 do begin
-      if tsCustom.Controls[i] = Sender then begin
-        index := i;
-        break;
-      end;
-    end;
-
-    btnCustomPopup.Tag := index;
-  end;
-
-  inherited;
-end;
-
-procedure TfrmMain.Remove1Click(Sender: TObject);
-var
-  index: Integer;
-begin
-  index := btnCustomPopup.Tag;
-
-  if (index &lt;&gt; -1) and (index &lt; tsCustom.ControlCount) then begin
-    tsCustom.Controls[index].Free;
-    btnCustomPopup.Tag := -1;
-    reorderCustomButtons;    
-    saveCustomButtons;
-  end;
-end;
-
-procedure TFrmMain.changeCustomButton(Button: TButton; NewButton: Boolean = False);
-var
-  value: String;
-begin
-  value := Button.Caption;
-  // Query the new caption from the user
-  if InputQuery('Change Custom Button', 'Please input the command to associate with this button:', value) then
-  begin
-    Button.Caption := value;
-    saveCustomButtons;
-  end;
-end;
-
-procedure TfrmMain.Change1Click(Sender: TObject);
-var
-  button: TButton;
-  index: Integer;
-begin
-  index := btnCustomPopup.Tag;
-
-  if (index &lt;&gt; -1) and (index &lt; tsCustom.ControlCount) then begin
-    button := tsCustom.Controls[index] as TButton;
-    if button &lt;&gt; nil then
-      changeCustomButton(button, False);
-  end;
-end;
-
-procedure TfrmMain.AddButton1Click(Sender: TObject);
-var
-  button: TButton;
-begin
-    button := TButton.Create(tsCustom);
-    button.SetBounds(0, 0, 129, 25);
-    button.Caption := '';
-    button.OnClick := customButtonClick;
-    button.OnMouseDown := customButtonMouseDown;
-    button.PopupMenu := btnCustomPopup;
-    button.Parent := tsCustom;
-
-    reorderCustomButtons;
-    saveCustomButtons;
-end;
-
-procedure TfrmMain.tsCustomResize(Sender: TObject);
-begin
-  reorderCustomButtons;
-end;
-
-end.
-

Deleted: trunk/WPGM/Overview.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Overview.~ddp
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Overview.~dfm
===================================================================
--- trunk/WPGM/Overview.~dfm	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/Overview.~dfm	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,34 +0,0 @@
-object frmOverview: TfrmOverview
-  Left = 441
-  Top = 292
-  BorderIcons = [biSystemMenu]
-  BorderStyle = bsSingle
-  Caption = 'Map Overview'
-  ClientHeight = 367
-  ClientWidth = 528
-  Color = clBtnFace
-  Font.Charset = DEFAULT_CHARSET
-  Font.Color = clWindowText
-  Font.Height = -11
-  Font.Name = 'MS Sans Serif'
-  Font.Style = []
-  OldCreateOrder = False
-  Position = poScreenCenter
-  ScreenSnap = True
-  OnCreate = FormCreate
-  PixelsPerInch = 96
-  TextHeight = 13
-  object Image: TImage32
-    Left = 0
-    Top = 0
-    Width = 528
-    Height = 367
-    Align = alClient
-    BitmapAlign = baTopLeft
-    Scale = 1.000000000000000000
-    ScaleMode = smNormal
-    TabOrder = 0
-    OnDblClick = ImageDblClick
-    OnMouseDown = ImageMouseDown
-  end
-end

Deleted: trunk/WPGM/Overview.~pas
===================================================================
--- trunk/WPGM/Overview.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/Overview.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,210 +0,0 @@
-unit Overview;
-
-interface
-
-uses
-  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
-  Dialogs, ExtCtrls, GR32, GR32_Image, UOMap, UOStatics, GR32_Layers;
-
-type
-  TfrmOverview = class(TForm)
-    Image: TImage32;
-    procedure ontopTimerTimer(Sender: TObject);
-    procedure FormCreate(Sender: TObject);
-    procedure ImageMouseDown(Sender: TObject; Button: TMouseButton;
-      Shift: TShiftState; X, Y: Integer; Layer: TCustomLayer);
-    procedure ImageDblClick(Sender: TObject);
-  private
-    { Private declarations }
-    Map: Integer; // Map id
-    MapPreviews: Array[0..4] of TBitmap32;
-    CurrentX, CurrentY: Integer;
-    MapHeight, MapWidth: Integer;
-
-  public
-    { Public declarations }
-    Generating: Boolean;
-    
-    procedure showMap(Map: Integer);
-  end;
-
-var
-  frmOverview: TfrmOverview;
-
-implementation
-
-uses Main, Progress;
-
-{$R *.dfm}
-
-procedure TfrmOverview.ontopTimerTimer(Sender: TObject);
-begin
-  if frmMain.cbAlwaysOnTop.Checked then
-    frmOverview.FormStyle := fsStayOnTop;
-end;
-
-procedure TfrmOverview.FormCreate(Sender: TObject);
-begin
-  // Clear the map previe fields
-  MapPreviews[0] := nil;
-  MapPreviews[1] := nil;
-  MapPreviews[2] := nil;
-  MapPreviews[3] := nil;
-  Map := -1;
-  Generating := False;
-end;
-
-procedure TfrmOverview.ShowMap(Map: Integer);
-var
-  Preview: TBitmap32;
-  x, y: Integer;
-  MapReader: TMapReader;
-  StaticReader: TStaticReader;
-  MapCell: TMapCell;
-  StaticCell: TStaticBlock;
-  HighestZ: Shortint;
-  CellColor: TColor;
-  i: Integer;
-  StaidxTime, StaticsTime, MapTime: TDateTime;
-  Prgr: TFrmProgress;
-begin
-  if Generating then
-    exit;
-
-  if (Map &lt; 0) or (Map &gt; 4) then
-    exit; // Invalid Map
-
-  Self.Map := Map; // Save Map Id
-
-  // Get a map preview...
-  if MapPreviews[Map] &lt;&gt; nil then begin
-    Image.Bitmap := MapPreviews[Map];
-    exit;
-  end;
-
-  // Try to read the map from file
-  Generating := True;
-  Preview := TBitmap32.Create;
-
-  try
-    // Try getting the modify time
-    // ModifyTime := FileDateToDateTime(FileAge(Format('map%u.bmp', [Map])));
-    MapTime := StrToDateTimeDef(Config.getString(Format('Map%uModify', [Map]), ''), Time);
-    StaticsTime := StrToDateTimeDef(Config.getString(Format('Statics%uModify', [Map]), ''), Time);
-    StaidxTime := StrToDateTimeDef(Config.getString(Format('Staidx%uModify', [Map]), ''), Time);
-
-    // Check if the loaded maps/statics have different times
-    if (Maps[Map].LastModified = MapTime) and (Statics[Map].LastDataModification = StaticsTime) and
-      (Statics[Map].LastIndexModification = StaidxTime) then
-    begin
-      Preview.LoadFromFile(Format('map%u.bmp', [Map]));
-      MapPreviews[Map] := Preview;
-      Image.Bitmap := Preview;
-      ClientWidth := Preview.Width;
-      ClientHeight := Preview.Height;
-      MapWidth := Preview.Width;
-      MapHeight := Preview.Height;
-      Generating := False;
-      exit;
-    end;
-    Preview.Free;
-  except
-    Preview.Free;
-  end;
-
-  // Create a map preview
-  Prgr := TfrmProgress.Create(self);
-  Prgr.FormStyle := fsStayOnTop;
-  Prgr.Show;
-
-  MapWidth := Maps[Map].getWidth;
-  MapHeight := Maps[Map].getHeight;
-
-  Prgr.pgBar.Max := MapWidth * MapHeight;
-
-  Preview := TBitmap32.Create;
-  Preview.SetSize(MapWidth, MapHeight);
-  Preview.Clear(clBlack32);
-
-  // Cache the readers
-  MapReader := Maps[Map];
-  StaticReader := Statics[Map];
-
-  // Create the preview
-  for x := 0 to MapWidth - 1 do begin
-    for y := 0 to MapHeight - 1 do begin
-      MapReader.ReadCell(x * 8, y * 8, MapCell);
-      CellColor := RadarCol.GetLandColor(MapCell.Id);
-
-      // Get Static Tiles
-      HighestZ := MapCell.Height;
-      StaticReader.ReadBlock(x, y, StaticCell);
-
-      for i := 0 to Length(StaticCell) - 1 do begin
-        if StaticCell[i].X &lt;&gt; 0 then
-          continue;
-
-        if StaticCell[i].Y &lt;&gt; 0 then
-          continue;
-
-        if StaticCell[i].Z &lt; HighestZ then
-          continue;
-
-        if StaticCell[i].Hue = 0 then
-          CellColor := RadarCol.GetItemColor(StaticCell[i].Id)
-        else begin
-          CellColor := RadarCol.GetItemColor(StaticCell[i].Id);
-          CellColor := Hues.translateColor(StaticCell[i].Hue, CellColor);
-        end;
-
-        HighestZ := StaticCell[i].Z;
-      end;
-
-      Preview.Pixel[x, y] := CellColor;
-    end;
-    Prgr.pgBar.StepBy(MapHeight);
-    Application.ProcessMessages;
-  end;
-
-  MapPreviews[Map] := Preview;
-  Image.Bitmap := Preview;
-
-  // Write the bitmap to a file
-  Preview.SaveToFile(Format('map%u.bmp', [Map]));
-
-  // Save the modification times of the statics and map
-  Config.setString(Format('Map%uModify', [Map]), DateToStr(MapReader.LastModified));
-  Config.setString(Format('Statics%uModify', [Map]), DateToStr(StaticReader.LastDataModification));
-  Config.setString(Format('Staidx%uModify', [Map]), DateToStr(StaticReader.LastIndexModification));
-  Config.Save;
-
-  ClientWidth := Preview.Width;
-  ClientHeight := Preview.Height;
-
-  Prgr.Free;
-
-  Generating := False;
-end;
-
-procedure TfrmOverview.ImageMouseDown(Sender: TObject;
-  Button: TMouseButton; Shift: TShiftState; X, Y: Integer;
-  Layer: TCustomLayer);
-begin
-  if (x &lt; 0) or (y &lt; 0) or (x &gt;= MapWidth) or (y &gt;= MapHeight) then
-    exit;
-
-  CurrentX := X * 8; // Save for DClick
-  CurrentY := Y * 8; // Save for DClick
-
-  MapCenterX := X * 8;
-  MapCenterY := Y * 8;
-  MapCenterMap := Self.Map;
-  frmMain.pbMap.Invalidate;
-end;
-
-procedure TfrmOverview.ImageDblClick(Sender: TObject);
-begin
-  frmMain.Go1Click(Self);
-end;
-
-end.

Deleted: trunk/WPGM/Progress.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Progress.~dfm
===================================================================
--- trunk/WPGM/Progress.~dfm	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/Progress.~dfm	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,300 +0,0 @@
-object frmProgress: TfrmProgress
-  Left = 422
-  Top = 335
-  BorderStyle = bsToolWindow
-  Caption = 'Generating...'
-  ClientHeight = 68
-  ClientWidth = 233
-  Color = clBtnFace
-  Font.Charset = DEFAULT_CHARSET
-  Font.Color = clWindowText
-  Font.Height = -11
-  Font.Name = 'MS Sans Serif'
-  Font.Style = []
-  OldCreateOrder = False
-  Position = poOwnerFormCenter
-  PixelsPerInch = 96
-  TextHeight = 13
-  object Image1: TImage
-    Left = 16
-    Top = 16
-    Width = 32
-    Height = 32
-    AutoSize = True
-    Picture.Data = {
-      055449636F6E0000010006001010020000000000B00000006600000010100000
-      0000000068050000160100001010000000000000680300007E06000020200200
-      0000000030010000E60900002020000000000000A8080000160B000020200000
-      00000000A80C0000BE1300002800000010000000200000000100010000000000
-      8000000000000000000000000000000000000000FFFFFF0000000000FFFFB9BC
-      FFF70E15E7FD0E0FFFFE07F5FF8300009FA300FBCB39FFADFF67FFFFF7EFFBF6
-      FBEF0000FF9FF500FE3F2B07F8FFF607F17F1614EDFF0D07DEFF000003FFB9BC
-      00030E1500010E0F000007F500000000000000FB0001FFAD0007FFFF000FFBF6
-      000F0000001FF500003F2B07007FF607007F16140C7F0D071E7F000028000000
-      1000000020000000010008000000000040010000000000000000000000000000
-      0000000000000000000008000008080000081000080810000810100008101800
-      0018210010182100102121000818290018293100212931003131310021293900
-      183139002131390029313900213142002939420029394A0029424A0031424A00
-      2942520031425200314A5200314A5A00394A5A0039525A003152630039526300
-      42526300425A6300425A6B00425A7300426373004A6373004A637B004A6B7B00
-      526B7B004A6B8400527384005A7384005A738C005A7B8C00637B8C005A7B9400
-      6384940063849C006B8C9C006B8CA5006B94A5007394AD007B9CAD007B9CB500
-      7BA5B5007BA5BD0084A5BD009CADBD0084ADC6008CADC6008CB5C6008CB5CE00
-      94B5CE009CBDCE00A5C6DE00ADCEDE00BDD6E700ADD6EF00B5DEEF00D6E7EF00
-      DEF7FF00FFFFFF00000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000016000308002900000000000000000000120B03181F00101F27292929
-      2F290000121F1F3332080005050000000000370023272329120815230C101F0C
-      0C12033A29231F161818161F29343B333B44000D1F2F361818231615292F292F
-      394117100C18372F1C2F1F0B343D181C293241001C001523181F1818321D2937
-      3F0000001C080B1F2E1C00101203232F0000000008000016232F1D1218072200
-      000000000000050910122923283F000000000000000012120B181F3441000000
-      0000000018290000233D41432E000000000000000512150F4300371D34000000
-      0000000000121D3D000036072900000000000000102D41000000002F1F000000
-      0000000003FFB9BC00030E1500010E0F000007F500000000000000FB0001FFAD
-      0007FFFF000FFBF6001F0000003FF500007F2B07007FF607047F16140C7F0D07
-      1E7F000028000000100000002000000001001800000000004003000000000000
-      00000000000000000000000030434D020307090E10121B210003065E77860000
-      000000000000000000000000000000000000000000000000000000002A39431E
-      2A32090F14394D58445A6800020628373F44576151697A5F7B8B597587597788
-      6484975B78880000000000002D3D46455C694358676F93A66A8CA1141C23050A
-      0E0810140B121701060A00000006090B0103050002007BA0B50000004F697A50
-      6D7D4D67755975862C3D47141F262F414B4C6775222F3827343D435A67222F37
-      202D362C3D48000C149FAEB95A7687476070455B6A31434F374C583548543141
-      4C445A685672827195A984AAC16D90A389AEC4A9D2EA000000343332435B6763
-      8194789AB13A4E5A3345504D667530424C2E404A567484638395597687638294
-      85A6BAA1C4DA2A42512D363C222F373749527EA4BB6584963C535E648396445D
-      6A1E2B337496AB8EB5CC3346523A515C5C788A688DA6A2C5DA0000003C515E00
-      00002F404B4A6371374B56475F6F354854384C596B8EA03F56655876857FA2B7
-      90B5CB0000000000000000003C505E111A211D2A31465F6E5F7F903C505D0000
-      00233038283D430D0F124D6878618399000000000000000000000000161E2400
-      0000070C0E30404D4963706A8B9E3F55632B3A463B4E5A071A25405F74D2E7EF
-      0000000000000000000000000205040000000E161B16202624323A2F3F4A5472
-      814864784E6F8399BACDDEF6FF00000000000000000000000000000003050606
-      090B2A3B452C3C471D2D36364E5C415C6D7797A9A1C3D8000000000000000000
-      0000000000000000000000003244505876870000000000004962708BB0C2A1C4
-      DAB7DAEF5D7D920000000000000000000000000000000000000000000E161A2E
-      3E492D404B1A303FBDD6E10000007FA4BB3351637E9DAF000000000000000000
-      0000000000000000000000000000002234403F57648FB6CD0000000000007B9D
-      B00E1F2A58738400000000000000000000000000000000000000000026313A64
-      7988ACCCDE000000000000000000000000658698465F6E000000000000000000
-      00000000000000000000000003FFB9BC00030E1500010E0F000007F500000000
-      000000FB0001FFAD0007FFFF000FFBF6000F0000001FF500007F2B07007FF607
-      047F16140C7F0D071E7F00002800000020000000400000000100010000000000
-      0001000000000000000000000000000000000000FFFFFF0000000000FFEFFFFF
-      FFF7FFFFFFF9FFFFFFFFFF9FFF7FFFF7FCFFFFFFFEFFFFFFFFFFF7DFFFFFC10E
-      7FFF790F73FFE80FC3FF9F86E1EF8F91F9EF8F8FFFEF983FFFFE72FFFFFFF5FF
-      FF9FF5FFFFCF3DFFFFFFF9FFFFFB61FFFFFF87FFFFFE0FFFFFFC3FFFDFB0BFFF
-      DF80BFFFFF82BFFFF7037FFFFEF7FFFFF9F3FFFFF7FDFFFF6FFEFFFF000FFFFF
-      0007FFFF0001FFFF0000001F0000000700000007000000030000000100000000
-      000000000000000000000000000000010000000F0000003F000000FF000001FF
-      000001FF000001FF000001FF000001FF000007FF00000FFF00003FFF00003FFF
-      00003FFF00003FFF00007FFF00F07FFF01F07FFF07FC7FFF0FFE7FFF28000000
-      2000000040000000010008000000000080040000000000000000000000000000
-      0000000000000000000008000008080000081000080810000810100008101800
-      0818180010181800101821001021210018212100102129001821290018292900
-      1821310018293100212931002131310021293900083139001831390021313900
-      293139002131420029314200213942002939420029394A0029424A0031424A00
-      31425200314A5200394A5200394A5A0039525A0042525A003952630042526300
-      395A6300425A6300395A6B00425A6B004A5A6B0042636B004A636B005A636B00
-      426373004A6373004A637B004A6B7B00526B7B0052737B004A6B8400526B8400
-      527384005A73840052738C005A738C005A7B8C00637B8C005A7B9400637B9400
-      6384940063849C006B849C00638C9C006B8C9C00738C9C006B8CA5006B94A500
-      7394A5007B94A5006B94AD007394AD00739CAD007B9CAD00849CAD007B9CB500
-      7BA5B50084A5B50084A5BD0084ADBD008CADBD0084ADC6008CADC600A5B5C600
-      8CB5CE0094B5CE0094BDCE009CBDCE0094BDD6009CBDD600A5BDD600A5C6D600
-      A5C6DE00A5CEDE00ADCEDE00B5CEDE00ADCEE700ADD6E700B5D6E700B5D6EF00
-      BDD6EF00C6DEEF00BDDEF700C6DEF700DEEFF700CEEFFF00D6EFFF00DEEFFF00
-      D6F7FF00DEF7FF00E7FFFF00F7FFFF00FFFFFF00000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000018120900080A080F0A0F2F0000000000000000000000000000000000
-      000000001F1F0A00000F09090508050000000000000000000000000000000000
-      000000000A1E120003111226120A08001D3F0000000000000000000000000000
-      00000000121F1F1209121233373718000505091E2C373C372637372C333F3F00
-      000000000A232326182326333F372311090A050000030505050912181D12051F
-      0000000012262F1F26373F46371F0A050512180F091818050000000000000000
-      2C000000233333262F37373F3718050A18232F2F1F09000518120F0A0A0A0A09
-      1137000026372F2C2F251F26120A1E261211261F1F181F373F372F2626333F37
-      18001F0037363737262F1F1F1F1E121E1E1F2F261F333E5050453F333F3F5054
-      120000003E251D372F231F26262F1F1F1F1F182F3F372F37373F453750505858
-      0300002E3F2F18373F3E261F122F26262C181E2C372F373F37474E4747586C50
-      120A000018263F47453F331F122337231E1F18181F3F3F37332F37333745544F
-      47353C562309264747473C2F261F263E261F181F37454745262526232F3F4536
-      475E00002F0F00183C3F45372326373E2625121837505B4E1F25332F374F544E
-      000000001F1805031F262F372F26334533231218334745262F3F4F47584E0000
-      00000000261D11030A25121F1F1218252312183F543718123F3F365800000000
-      000000002F1811050A1F26262F261F0A000018371400001F581F440000000000
-      000000001F0F120F0818251F3C3F471E0300000A3424001F47123F0000000000
-      000000001205050500121E1F2F263F471F1F0A183F3F052618265E0000000000
-      0000000011000000000918121F252F3737252F261F0A18262657000000000000
-      000000000A00000000051809121E1F18333F2C333F2F3D475B00000000000000
-      00000000050000000A0A0908181F181F2F3736333746636F0000000000000000
-      00000000000000000A261F180F1E1F2F2625253D4E6500000000000000000000
-      00000000080305050A1818180F23262F37334765625000000000000000000000
-      00000000180A452F0000090A093F372F455B6C682F4500000000000000000000
-      000000000A1E4E18000000001857585E645B5E502F5800000000000000000000
-      00000000051818000F1F18153C0000005E463745375D00000000000000000000
-      00000000000812263F2636265000000054462F263F0000000000000000000000
-      0000000000001F26121D375800000000582F1E18370000000000000000000000
-      0000000000001F18124465000000000065471F18370000000000000000000000
-      0000000000000F1F5E0000000000000000005425370000000000000000000000
-      000000004D18376B0000000000000000000000452F0000000000000000000000
-      00000000001FFFFF001FFFFF0003FFFF0000001F0000000F0000000700000003
-      0000000100000001000000000000000000000000000000030000000F0000003F
-      000000FF000001FF000001FF000001FF000003FF000007FF00000FFF00003FFF
-      00003FFF00003FFF00003FFF00703FFF00707FFF00F07FFF01F07FFF07FC7FFF
-      0FFE7FFF2800000020000000400000000100180000000000800C000000000000
-      0000000000000000000000002A3A4223303A131C2302050610191C1D282F1019
-      1C1C27301A252A1C28314E667800000000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000374956374B561A252D0202020202021D2932131C
-      23141F2509111410191D0B151B49637000000000000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000018232830414D27343D060A0F070F12202E372230
-      3942576425333D18222A10191C0202062E414D00000000000000000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000022303737495534475126343E131C2224323A2835
-      3F506C7B5C7A8E5571812D3C46050A0E0C14180C151C111C2300000000000000
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000001923293A505B3D515D4459692F3F4B3C505D4259
-      66506C7B6585975D7A8D3C505D202D35131C2019242A091013020507050A0F09
-      0F140912180F181D0B1318131E25233038283A432F414B26353F0E181D3A4C56
-      00000000000000000000000025333C435A674963703548534258665774856383
-      966F92A55B788A3346521B272E0F151A0F1A1D25333C293B431F2D35141D232C
-      3C452939420E161B050A0E02020202020205070A040508020202020202020202
-      4F626F0000000000000000003C505F506B79526E7F4359664C64725976865976
-      856B8B9F5672832D3D470B11151620282838433C505D4F6B7B49627134465213
-      1C230202020B111429394328373F1F2D321622261823281B242A182229151F25
-      202D35597788000000000000465F6B5A77894C657447606D4B65743F55623345
-      5141576526353E1C292F31424E42586526353D232F39475F6B3446523548552F
-      3F4B3B4F5D5672836383955C788A4B6574415563415765516E7C658397557082
-      2D3E48020202384B56000000587284536F805A77885570824158654E66773C4F
-      5C384B573A4E5A30434E24343C32454F30424B354852496271475F6D34475252
-      6E7C617E9084AABF80A5BB6D8DA2678599526D7E60809261819583A4BB88ADC2
-      24343C020202020202000000617F903E56622F414C5772834C65753B505B384E
-      5A435867465F6C4C6474374855384B583346503345502C3C464C65756A8A9F59
-      76864C64755F7C8E59768567869A6E8FA157718285A7B985A5BB95B8CA95B9CD
-      070F150202020202025F656969899D4C66752E3D465770826A899E617F904257
-      63374C5723313A496271445C6A445A6747606C2C3D4631444E47606E5570804F
-      69795D7A8B6C8D9F5672827296A97B9EB2799CAF7698AD99BBCFC9E8F982A8BC
-      24313B18252C0204090202022C3C46435966638496769AAE6F8FA3618092536E
-      7E37485327333D3D515F5672833C515D30424C3547552E3F482D3E493A4F5962
-      819367869A5C7A8B536D7E4F69785C788A526C7B5C7A8D6F8FA38CADC27EA0B6
-      7094A94E6C80627C8BA0B4C03D525F111B20445B697496AB7194A97294A9607F
-      8F4B6371425A69384D58455B6A617F92445C6A3549562E3E473A4F5B5A76866C
-      8CA0789DAF6C8CA04257643F5662455C6B3C515C4D66766A899A6D8EA2516E82
-      7497ABAACADE0000000000004C63721F2D34020202283841617E8F6585986D8C
-      A25A77863D525D465D6C597586617F92465F6D3E556127353F2E3D485A778883
-      A5BB96B9D07C9FB4374B563F5561526E7C4E6A785772847FA2B688ACC3799EB4
-      0000000000000000000000003B4F5A2D3D470E1519080F13344650445B6B4C62
-      70537080486170415763506B7A6C8DA0516D7B3C515D233039273741516B7C72
-      96AB6A8BA0455D6D4B62716280937CA1B6789CAF90B3C87B9DB1000000000000
-      000000000000000000000000455C6B2E414B222E35070E111B262D3E55622535
-      3D394D59394D592332392C3D473E53623A505C24323D2938426B899C83ACC156
-      70802A3C46203038698999678899536E8097B9CD000000000000000000000000
-      0000000000000000000000004D6575283841222F370C12161923283C4F5B455F
-      6B485F6E4F6A79465D6D394C581A252D0406090202022E3B445C778808353902
-      020202020232465297BBCF3A4F5C708C9E000000000000000000000000000000
-      000000000000000000000000384B581D2A3224323C1C2930111B1F2A3B473F55
-      63394E5A607E8F6685987195A932434E080E1202020202020216202657707B43
-      525D0202023749557994A522313B698B9F000000000000000000000000000000
-      00000000000000000000000026353F0F151B0E151A0E151A06080C2230383344
-      4F3848564C6472455B6A6180927193A73A4E593446531B252E2C3B4864819064
-      81930E151B415765243541435C6EA1C0D0000000000000000000000000000000
-      000000000000000000000000222F38020202020202020202020202131D232C3A
-      4524303A384D573D55624E67785977865774853F5562486170465D6B32445019
-      252C263842435D6D415C6F8AB3CB000000000000000000000000000000000000
-      0000000000000000000000001822280202020202020202020207070A11162939
-      42151E2425343C30434C3444502E3D48516C7A61809249616F506A7A62829546
-      60715D7E907198AE000000000000000000000000000000000000000000000000
-      0000000000000000000000000B111402020202020204060819232A192429141E
-      23121B1E2C3945384C562F3F4B3A4E5A4B64725C798B556F80516B7E5B7B8F6D
-      90A4ACCDE2000000000000000000000000000000000000000000000000000000
-      000000000000000000000000020608020202020202020202182328455C6B394D
-      592839431F2D3533444F394D584C6575475F6E3F57643D58665F7F937F9EB2B1
-      D1E4000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000111A1E0A0F120910130F181C19262D2D3E492C3C
-      462E3F491D2A313B515F445B674D6777577486516C7F7294A7B4D4E6B1CDDE8C
-      ACBD000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000002839411620276D8DA34F6978020608020206141D
-      23182227131D2365889C5776894F6A7A6B8DA299BCD1CDEBFEC0DEEF4662746F
-      8EA1000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000018232A30424C799EB32A3B450202020202020202
-      020202022E3F4B8BB3CA93B6CCA4C6D8AFD1E198BBD0A5C8DB83A7BD4966789A
-      B9CD000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000E13182737422A3B450202061F2A313548552837
-      411F313B637C8B000000000000000000A2C0D36E90A75371836F8FA4557284A1
-      BED0000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000002020211191E25333D435A67608090435867526F
-      81425F6E82A2B400000000000000000089ADC16E93A9486270425C6B65849700
-      0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000020202020205394E58455C6C24333A2E414E5977
-      8994B7CC00000000000000000000000093B6CB48657730434F2637425F7A8D00
-      0000000000000000000000000000000000000000000000000000000000000000
-      00000000000000000000000002020205080A374C5626374220313D718E9E0000
-      00000000000000000000000000000000BBD7E97B9CAF384F5C2535415F7A8C00
-      0000000000000000000000000000000000000000000000000000000000000000
-      0000000000000000000000000202050205091B27323449560000000000000000
-      000000000000000000000000000000000000000000008CAEC13D596A59728300
-      0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000859FAE2A3B445A72810000000000000000000000
-      000000000000000000000000000000000000000000000000006F8EA247627200
-      0000000000000000000000000000000000000000000000000000000000000000
-      000000000000000000000000001FFFFF000FFFFF0007FFFF0001FFFF0000000F
-      0000000700000003000000010000000100000000000000000000000000000003
-      0000000F0000003F000000FF000001FF000001FF000001FF000003FF00000FFF
-      00001FFF00003FFF00003FFF00003FFF00003FFF00703FFF00707FFF00F07FFF
-      03F07FFF0FFC7FFF1FFE7FFF}
-  end
-  object Label1: TLabel
-    Left = 56
-    Top = 16
-    Width = 126
-    Height = 13
-    Caption = 'Generating Map Preview...'
-  end
-  object ProgressBar1: TProgressBar
-    Left = 56
-    Top = 32
-    Width = 150
-    Height = 17
-    TabOrder = 0
-  end
-end

Deleted: trunk/WPGM/Progress.~pas
===================================================================
--- trunk/WPGM/Progress.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/Progress.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,27 +0,0 @@
-unit Progress;
-
-interface
-
-uses
-  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
-  Dialogs, ExtCtrls, ComCtrls, StdCtrls;
-
-type
-  TfrmProgress = class(TForm)
-    Image1: TImage;
-    Label1: TLabel;
-    ProgressBar1: TProgressBar;
-  private
-    { Private declarations }
-  public
-    { Public declarations }
-  end;
-
-var
-  frmProgress: TfrmProgress;
-
-implementation
-
-{$R *.dfm}
-
-end.

Deleted: trunk/WPGM/SQLite.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/SQLiteTable.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Spawnregions.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Spawnregions.~ddp
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/Spawnregions.~dfm
===================================================================
--- trunk/WPGM/Spawnregions.~dfm	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/Spawnregions.~dfm	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,230 +0,0 @@
-object frmRegions: TfrmRegions
-  Left = 214
-  Top = 135
-  AutoScroll = False
-  Caption = 'Regions'
-  ClientHeight = 495
-  ClientWidth = 756
-  Color = clBtnFace
-  Font.Charset = DEFAULT_CHARSET
-  Font.Color = clWindowText
-  Font.Height = -11
-  Font.Name = 'MS Sans Serif'
-  Font.Style = []
-  OldCreateOrder = False
-  OnCreate = FormCreate
-  OnDestroy = FormDestroy
-  OnResize = FormResize
-  OnShow = FormShow
-  DesignSize = (
-    756
-    495)
-  PixelsPerInch = 96
-  TextHeight = 13
-  object Label1: TLabel
-    Left = 161
-    Top = 468
-    Width = 96
-    Height = 13
-    Anchors = [akLeft, akBottom]
-    Caption = 'Screen Coordinates:'
-  end
-  object Label2: TLabel
-    Left = 417
-    Top = 468
-    Width = 83
-    Height = 13
-    Anchors = [akLeft, akBottom]
-    Caption = 'Map Coordinates:'
-  end
-  object lblScreen: TLabel
-    Left = 264
-    Top = 468
-    Width = 3
-    Height = 13
-    Anchors = [akLeft, akBottom]
-  end
-  object lblMap: TLabel
-    Left = 512
-    Top = 468
-    Width = 3
-    Height = 13
-    Anchors = [akLeft, akBottom]
-  end
-  object Label3: TLabel
-    Left = 624
-    Top = 264
-    Width = 55
-    Height = 13
-    Anchors = [akTop, akRight]
-    Caption = 'Selected:'
-    Font.Charset = DEFAULT_CHARSET
-    Font.Color = clWindowText
-    Font.Height = -11
-    Font.Name = 'MS Sans Serif'
-    Font.Style = [fsBold]
-    ParentFont = False
-  end
-  object lblSelected: TLabel
-    Left = 624
-    Top = 280
-    Width = 3
-    Height = 13
-    Anchors = [akTop, akRight]
-  end
-  object cbMap: TComboBox
-    Left = 8
-    Top = 464
-    Width = 145
-    Height = 21
-    Style = csDropDownList
-    Anchors = [akLeft, akBottom]
-    ItemHeight = 13
-    ItemIndex = 0
-    TabOrder = 0
-    Text = 'Felucca'
-    Items.Strings = (
-      'Felucca'
-      'Trammel'
-      'Ilshenar'
-      'Malas'
-      'Tokuno Islands')
-  end
-  object pbMap: TPaintBox32
-    Left = 3
-    Top = 8
-    Width = 597
-    Height = 433
-    Anchors = [akLeft, akTop, akRight, akBottom]
-    TabOrder = 1
-    OnMouseDown = pbMapMouseDown
-    OnMouseMove = pbMapMouseMove
-    OnMouseUp = pbMapMouseUp
-    OnPaintBuffer = pbMapPaintBuffer
-  end
-  object sbX: TScrollBar
-    Left = 4
-    Top = 440
-    Width = 597
-    Height = 17
-    Anchors = [akLeft, akRight, akBottom]
-    LargeChange = 50
-    PageSize = 0
-    TabOrder = 2
-    OnScroll = sbXScroll
-  end
-  object sbY: TScrollBar
-    Left = 601
-    Top = 8
-    Width = 17
-    Height = 432
-    Anchors = [akTop, akRight, akBottom]
-    Kind = sbVertical
-    LargeChange = 50
-    PageSize = 0
-    TabOrder = 3
-    OnScroll = sbYScroll
-  end
-  object lbRects: TListBox
-    Left = 624
-    Top = 8
-    Width = 121
-    Height = 217
-    Anchors = [akTop, akRight]
-    ItemHeight = 13
-    TabOrder = 4
-    OnDblClick = lbRectsDblClick
-    OnKeyDown = lbRectsKeyDown
-  end
-  object btnAdd: TButton
-    Left = 624
-    Top = 232
-    Width = 57
-    Height = 25
-    Anchors = [akTop, akRight]
-    Caption = 'Add'
-    Enabled = False
-    TabOrder = 5
-    OnClick = btnAddClick
-  end
-  object btnRemove: TButton
-    Left = 688
-    Top = 232
-    Width = 57
-    Height = 25
-    Anchors = [akTop, akRight]
-    Caption = 'Remove'
-    TabOrder = 6
-    OnClick = btnRemoveClick
-  end
-  object Button1: TButton
-    Left = 624
-    Top = 304
-    Width = 121
-    Height = 25
-    Anchors = [akTop, akRight]
-    Caption = 'Copy as Spawnregion'
-    TabOrder = 7
-    OnClick = Button1Click
-  end
-  object Button2: TButton
-    Left = 624
-    Top = 336
-    Width = 121
-    Height = 25
-    Anchors = [akTop, akRight]
-    Caption = 'Copy as Region'
-    TabOrder = 8
-    OnClick = Button2Click
-  end
-  object Button3: TButton
-    Left = 624
-    Top = 368
-    Width = 121
-    Height = 25
-    Anchors = [akTop, akRight]
-    Caption = 'Paste Spawnregion'
-    TabOrder = 9
-    OnClick = Button3Click
-  end
-  object Button4: TButton
-    Left = 624
-    Top = 400
-    Width = 121
-    Height = 25
-    Anchors = [akTop, akRight]
-    Caption = 'Paste Region'
-    TabOrder = 10
-    OnClick = Button4Click
-  end
-  object btnZoomOut: TButton
-    Left = 624
-    Top = 432
-    Width = 41
-    Height = 25
-    Anchors = [akRight, akBottom]
-    Caption = '-'
-    TabOrder = 11
-    OnClick = btnZoomOutClick
-  end
-  object btnZoomIn: TButton
-    Left = 672
-    Top = 432
-    Width = 41
-    Height = 25
-    Anchors = [akRight, akBottom]
-    Caption = '+'
-    TabOrder = 12
-    OnClick = btnZoomInClick
-  end
-  object btnRedraw: TButton
-    Left = 624
-    Top = 464
-    Width = 89
-    Height = 25
-    Anchors = [akRight, akBottom]
-    Caption = 'Redraw'
-    TabOrder = 13
-    OnClick = btnRedrawClick
-  end
-end

Deleted: trunk/WPGM/Spawnregions.~pas
===================================================================
--- trunk/WPGM/Spawnregions.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/Spawnregions.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,660 +0,0 @@
-unit Spawnregions;
-
-interface
-
-uses
-  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
-  Dialogs, StdCtrls, GR32, GR32_Blend, GR32_Image, UOMap, UOStatics, ClipBrd;
-
-type
-  TfrmRegions = class(TForm)
-    cbMap: TComboBox;
-    pbMap: TPaintBox32;
-    sbX: TScrollBar;
-    sbY: TScrollBar;
-    Label1: TLabel;
-    Label2: TLabel;
-    lblScreen: TLabel;
-    lblMap: TLabel;
-    lbRects: TListBox;
-    btnAdd: TButton;
-    btnRemove: TButton;
-    Label3: TLabel;
-    lblSelected: TLabel;
-    Button1: TButton;
-    Button2: TButton;
-    Button3: TButton;
-    Button4: TButton;
-    btnZoomOut: TButton;
-    btnZoomIn: TButton;
-    btnRedraw: TButton;
-    procedure FormShow(Sender: TObject);
-    procedure FormCreate(Sender: TObject);
-    procedure pbMapPaintBuffer(Sender: TObject);
-    procedure sbXScroll(Sender: TObject; ScrollCode: TScrollCode;
-      var ScrollPos: Integer);
-    procedure sbYScroll(Sender: TObject; ScrollCode: TScrollCode;
-      var ScrollPos: Integer);
-    procedure FormDestroy(Sender: TObject);
-    procedure FormResize(Sender: TObject);
-    procedure pbMapMouseMove(Sender: TObject; Shift: TShiftState; X,
-      Y: Integer);
-    procedure btnRemoveClick(Sender: TObject);
-    procedure pbMapMouseDown(Sender: TObject; Button: TMouseButton;
-      Shift: TShiftState; X, Y: Integer);
-    procedure pbMapMouseUp(Sender: TObject; Button: TMouseButton;
-      Shift: TShiftState; X, Y: Integer);
-    procedure btnAddClick(Sender: TObject);
-    procedure Button1Click(Sender: TObject);
-    procedure Button2Click(Sender: TObject);
-    procedure Button3Click(Sender: TObject);
-    procedure Button4Click(Sender: TObject);
-    procedure lbRectsKeyDown(Sender: TObject; var Key: Word;
-      Shift: TShiftState);
-    procedure lbRectsDblClick(Sender: TObject);
-    procedure btnZoomOutClick(Sender: TObject);
-    procedure btnZoomInClick(Sender: TObject);
-    procedure btnRedrawClick(Sender: TObject);
-  private
-    { Private declarations }
-    Places: Array of TRect;
-
-  public
-    { Public declarations }
-    procedure ChangeMap(MapId: Byte);
-    procedure RedrawBuffer(Buffer: TBitmap32; StartX: Integer; StartY: Integer; Width: Integer; Height: Integer);
-
-    function MapToBuffer(Point: TPoint): TPoint;
-    function BufferToMap(Point: TPoint): TPoint;
-    procedure AddRect(X1: Integer; Y1: Integer; X2: Integer; Y2: Integer);
-    procedure UpdateSelectionLabel;
-  end;
-
-var
-  frmRegions: TfrmRegions;
-  Map: TMapReader;
-  Statics: TStaticReader;
-  Scale: Single;
-  Buffer: TBitmap32; // This is for copying map2map
-  SelStartX, SelStartY: Integer;
-  SelEndX, SelEndY: Integer;
-
-implementation
-
-{$R *.dfm}
-
-uses Main, Math, XMLReader, StrLib, UORadarCol;
-
-function TfrmRegions.MapToBuffer(Point: TPoint): TPoint;
-begin
-  Result.X := Ceil((Point.X - sbX.Position) / Scale);
-  Result.Y := Ceil((Point.Y - sbY.Position) / Scale);
-end;
-
-function TfrmRegions.BufferToMap(Point: TPoint): TPoint;
-begin
-  Result.X := Ceil(Point.X * Scale) + sbX.Position;
-  Result.Y := Ceil(Point.Y * Scale) + sbY.Position;
-end;
-
-procedure TfrmRegions.RedrawBuffer(Buffer: TBitmap32; StartX: Integer; StartY: Integer; Width: Integer; Height: Integer);
-var
-  X, Y, RealX, RealY: Integer;
-  MapBlock: TMapBlock;
-  i, j, k, l: Integer;
-  MapX, MapY: Integer; // Map Coordinates
-  MapPoint, ScreenPoint: TPoint;
-  MinBlockX, MinBlockY: Integer; // The lowest blocks we draw
-  MaxBlockX, MaxBlockY: Integer; // The highest blocks we draw
-  BlendColor: TColor32;
-  PixelCount: Integer;
-  StaticBlock: TStaticBlock;
-  DrawColor: TColor32;
-  DrawColorZ: Integer;
-begin
-  BlendColor := Color32(255, 255, 255, 127);
-
-  MapPoint := BufferToMap(Point(StartX, StartY));
-  MinBlockX := MapPoint.X div 8;
-  MinBlockY := MapPoint.Y div 8;
-
-  MapPoint := BufferToMap(Point(StartX + Width - 1, StartY + Height - 1));
-  MaxBlockX := MapPoint.X div 8;
-  MaxBlockY := MapPoint.Y div 8;
-
-  // Scale down/up ? (If Scale &gt; 1, we draw less blocks), thus
-  // we have to divide and round up
-  {MaxBlockX := Ceil(MaxBlockX / Scale);
-  MaxBlockY := Ceil(MaxBlockY / Scale);}
-
-  for X := MinBlockX to MaxBlockX + 1 do
-    for Y := MinBlockY to MaxBlockY + 1 do begin
-      ScreenPoint := MapToBuffer(Point(X * 8, Y * 8));
-
-      // Out of screen check
-      if (ScreenPoint.X &lt; -7) or (ScreenPoint.Y &lt; -7) then
-        continue;
-
-      // Out of screen check
-      if (ScreenPoint.X &gt;= Buffer.Width) or (ScreenPoint.Y &gt;= Buffer.Height) then
-        continue;
-
-      Map.ReadBlock(X, Y, MapBlock);
-      Statics.ReadBlock(X, Y, StaticBlock);
-
-      for i := 0 to 63 do begin
-        PixelCount := Ceil(1.0 / Scale);
-
-        DrawColor := RadarCol.GetLandColor(MapBlock.Cells[i].Id);
-        DrawColorZ := MapBlock.Cells[i].Height;
-
-        // Get the topmost color here
-        for j := 0 to Length(StaticBlock) - 1 do begin
-          if (StaticBlock[j].X = i mod 8) and (StaticBlock[j].Y = i div 8) and
-            (StaticBlock[j].Z &gt;= DrawColorZ) then begin
-              DrawColorZ := StaticBlock[j].Z;
-              DrawColor := RadarCol.GetItemColor(StaticBlock[j].Id);
-            end;
-        end;
-
-        RealX := ScreenPoint.X + (i mod 8) * PixelCount;
-        RealY := ScreenPoint.Y + (i div 8) * PixelCount;
-        if Scale &lt;&gt; 1.0 then begin
-          for j := 0 to PixelCount - 1 do begin
-            for k := 0 to PixelCount - 1 do begin
-              Buffer.PixelS[RealX + j, RealY + k] := DrawColor;
-            end;
-          end;
-        end else begin
-          Buffer.PixelS[RealX, RealY] := DrawColor;
-        end;
-
-        MapX := X * 8 + i mod 8;
-        MapY := Y * 8 + i div 8;
-
-        // Pr&#252;fen ob der Punkt teil eines Rectangles ist
-        for j := 0 to Length(Places) - 1 do begin
-          if (Places[j].Left &lt;= MapX) and (Places[j].Right &gt;= MapX)
-            and (Places[j].Top &lt;= MapY) and (Places[j].Bottom &gt;= MapY) then
-          begin
-            // Found a match!!
-            Buffer.PixelS[RealX, RealY] := BlendReg(BlendColor, Buffer.PixelS[RealX, RealY]);
-            EMMS();
-            //break;
-          end;
-        end;
-      end;
-    end;
-
-  // Redraw selection rectangle
-  if (SelStartX &lt;&gt; -1) and (SelStartY &lt;&gt; -1) then begin
-    MapPoint := MapToBuffer(Point(SelStartX, SelStartY));
-
-    pbMap.Buffer.Canvas.Brush.Style := bsClear;
-    pbMap.Buffer.Canvas.Pen.Color := clWhite;
-    pbMap.Buffer.Canvas.Pen.Style := psDot;
-
-    if (SelEndX &lt;&gt; -1) and (SelEndY &lt;&gt; -1) then begin
-      ScreenPoint := MapToBuffer(Point(SelEndX, SelEndY));
-    end else begin
-      ScreenPoint := pbMap.ScreenToClient(Mouse.CursorPos);
-    end;
-
-    pbMap.Buffer.Canvas.Rectangle(MapPoint.X, MapPoint.Y, ScreenPoint.X, ScreenPoint.Y);
-  end;
-end;
-
-procedure TfrmRegions.ChangeMap(MapId: Byte);
-begin
-  if MapId &gt;= Length(Maps) then
-    exit;
-
-  Map := Main.Maps[MapId];
-  Statics := Main.Statics[MapId];
-
-  sbX.Max := Map.getWidth * 8 - 1 - pbMap.ClientWidth;
-  sbX.Min := 0;
-  sbX.Position := 0;
-
-  sbY.Max := Map.getHeight * 8 - 1 - pbMap.ClientHeight;
-  sbY.Min := 0;
-  sbY.Position := 0;
-
-  pbMap.Invalidate;
-end;
-
-procedure TfrmRegions.FormShow(Sender: TObject);
-begin
-  ChangeMap(0);
-end;
-
-procedure TfrmRegions.FormCreate(Sender: TObject);
-begin
-  Map := nil;
-  Statics := nil;
-  Scale := 1;
-  Buffer := TBitmap32.Create;
-
-  SelStartX := -1;
-  SelStartY := -1;
-  SelEndX := -1;
-  SelEndY := -1;
-
-  {AddRect(1776, 60, 3060, 670);
-  AddRect(1900, 670, 2515, 870);
-  AddRect(2515, 670, 2762, 870);
-  AddRect(3009, 100, 3055, 720);
-  AddRect(3055, 150, 3110, 655);
-  AddRect(3110, 320, 3210, 595);
-  AddRect(3210, 375, 3360, 550);
-  AddRect(3360, 410, 3424, 510);
-  AddRect(3424, 410, 3453, 465);}
-end;
-
-procedure TfrmRegions.pbMapPaintBuffer(Sender: TObject);
-begin
-  RedrawBuffer(pbMap.Buffer, 0, 0, pbMap.Buffer.Width, pbMap.Buffer.Height);
-end;
-
-procedure TfrmRegions.sbXScroll(Sender: TObject; ScrollCode: TScrollCode;
-  var ScrollPos: Integer);
-var
-  Diff: Integer;
-  OldPos: Integer;
-begin
-  Diff := ScrollPos - (Sender as TScrollBar).Position;
-
-  if (Buffer.Width &lt;&gt; pbMap.Buffer.Height) or (Buffer.Height &lt;&gt; pbMap.Buffer.Height) then
-  begin
-    Buffer.SetSizeFrom(pbMap.Buffer);
-  end;
-
-  if (Abs(Diff) &gt; pbMap.Width) then
-    pbMap.Invalidate
-  else begin
-    pbMap.Buffer.DrawTo(Buffer);
-    Buffer.DrawTo(pbMap.Buffer, - Ceil(Diff / Scale), 0);
-
-    OldPos := sbX.Position;
-    sbX.Position := ScrollPos;
-
-    // If Diff is Positive, redraw right part
-    if Diff &gt;= 0 then
-      RedrawBuffer(pbMap.Buffer, pbMap.Buffer.Width - Ceil(Diff / Scale), 0, Trunc(Diff / Scale), pbMap.Buffer.Height);
-
-    // If Diff is Negative, redraw left part
-    if Diff &lt; 0 then
-      RedrawBuffer(pbMap.Buffer, 0, 0, - Trunc(Diff / Scale), pbMap.Buffer.Height);
-
-    sbX.Position := OldPos;                              
-
-    pbMap.Flush;
-  end;
-end;
-
-procedure TfrmRegions.sbYScroll(Sender: TObject; ScrollCode: TScrollCode;
-  var ScrollPos: Integer);
-var
-  Diff: Integer;
-  OldPos: Integer;
-begin
-  Diff := ScrollPos - (Sender as TScrollBar).Position;
-
-  if (Buffer.Width &lt;&gt; pbMap.Buffer.Height) or (Buffer.Height &lt;&gt; pbMap.Buffer.Height) then
-  begin
-    Buffer.SetSizeFrom(pbMap.Buffer);
-  end;
-
-  if (Abs(Diff) &gt; pbMap.Height) then
-    pbMap.Invalidate
-  else begin
-    pbMap.Buffer.DrawTo(Buffer);
-    Buffer.DrawTo(pbMap.Buffer, 0, - Ceil(Diff / Scale));
-
-    OldPos := sbY.Position;
-    sbY.Position := ScrollPos;
-
-    // If Diff is Positive, redraw right part
-    if Diff &gt;= 0 then
-      RedrawBuffer(pbMap.Buffer, 0, pbMap.Height - Ceil(Diff / Scale), pbMap.Buffer.Width, Ceil(Diff / Scale));
-
-    // If Diff is Negative, redraw right part
-    if Diff &lt; 0 then
-      RedrawBuffer(pbMap.Buffer, 0, 0, pbMap.Buffer.Width, - Ceil(Diff / Scale));
-
-    sbY.Position := OldPos;
-    pbMap.Flush;
-  end;
-end;
-
-procedure TfrmRegions.FormDestroy(Sender: TObject);
-begin
-  Buffer.Free;
-end;
-
-procedure TfrmRegions.FormResize(Sender: TObject);
-var
-  OldX, OldY: Integer;
-begin
-  OldX := sbX.Position;
-  OldY := sbY.Position;
-
-  ChangeMap(MapId);
-  sbX.Position := OldX;
-  sbY.Position := OldY;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmRegions.pbMapMouseMove(Sender: TObject; Shift: TShiftState;
-  X, Y: Integer);
-var
-  P: TPoint;
-begin
-  P := BufferToMap(Point(X, Y));
-
-  lblScreen.Caption := Format('%d,%d', [X, Y]);
-  lblMap.Caption := Format('%d,%d', [P.X, P.Y]);
-
-  if ((SelStartX &lt;&gt; -1) or (SelStartY &lt;&gt; -1)) and
-    ((SelEndX = -1) and (SelEndY = -1)) then begin
-    pbMap.Invalidate;
-  end;
-end;
-
-procedure TfrmRegions.btnRemoveClick(Sender: TObject);
-var
-  i: Integer;
-begin
-  if lbRects.ItemIndex &lt;&gt; -1 then begin
-    if lbRects.ItemIndex &lt; Length(Places) - 1 then begin
-      // Copy Downwards
-      for i := lbRects.ItemIndex to Length(Places) - 2 do begin
-        Places[i] := Places[i+1];
-      end;
-      SetLength(Places, Length(Places) - 1);
-      pbMap.Invalidate;
-    end;
-    lbRects.Items.Delete(lbRects.ItemIndex);
-  end;
-end;
-
-procedure TFrmRegions.AddRect(X1: Integer; Y1: Integer; X2: Integer; Y2: Integer);
-var
-  Temp: Integer;
-begin
-  if X1 &gt; X2 then begin
-    Temp := X1;
-    X1 := X2;
-    X2 := temp;
-  end;
-
-  if Y1 &gt; Y2 then begin
-    Temp := Y1;
-    Y1 := Y2;
-    Y2 := temp;
-  end;
-
-  SetLength(Places, Length(Places) + 1);
-  Places[Length(Places) - 1] := Rect(X1, Y1, X2, Y2);
-
-  lbRects.Items.Add(Format('%d,%d to %d,%d', [X1, Y1, X2, Y2]));
-end;
-
-procedure TfrmRegions.pbMapMouseDown(Sender: TObject; Button: TMouseButton;
-  Shift: TShiftState; X, Y: Integer);
-var
-  P: TPoint;
-begin
-  SelStartX := -1;
-  SelStartY := -1;
-  SelEndX := -1;
-  SelEndY := -1;
-
-  P := BufferToMap(Point(X, Y));
-  SelStartX := P.X;
-  SelStartY := P.Y;
-
-  UpdateSelectionLabel;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmRegions.pbMapMouseUp(Sender: TObject; Button: TMouseButton;
-  Shift: TShiftState; X, Y: Integer);
-var
-  P: TPoint;
-begin
-  P := BufferToMap(Point(X, Y));
-  SelEndX := P.X;
-  SelEndY := P.Y;
-  UpdateSelectionLabel;
-  pbMap.Invalidate;
-end;
-
-procedure TFrmRegions.UpdateSelectionLabel;
-begin
-  if (SelStartX = -1) or (SelStartY = -1) or (SelEndX = -1) or (SelEndY = -1) then
-  begin
-    lblSelected.Caption := '';
-    btnAdd.Enabled := False;
-  end else begin
-    lblSelected.Caption := Format('%d,%d to %d,%d', [SelStartX, SelStartY, SelEndX, SelEndY]);
-    btnAdd.Enabled := True;
-  end;
-end;
-
-procedure TfrmRegions.btnAddClick(Sender: TObject);
-begin
-  AddRect(SelStartX, SelStartY, SelEndX, SelEndY);
-  SelStartX := -1;
-  SelStartY := -1;
-  SelEndX := -1;
-  SelEndY := -1;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmRegions.Button1Click(Sender: TObject);
-var
-  i: Integer;
-  Result: String;
-  ClipBoard: TClipboard;
-begin
-  ClipBoard := TClipBoard.Create;
-
-  for i := 0 to Length(Places) - 1 do begin
-    Result := Result + Format(#9 + #9 + '&lt;rectangle from=&quot;%d,%d&quot; to=&quot;%d,%d&quot; map=&quot;%u&quot; /&gt;' + #13, [Places[i].Left, Places[i].Top, Places[i].Right, Places[i].Bottom, cbMap.ItemIndex]);
-  end;
-
-  ClipBoard.SetTextBuf(PChar(result));
-end;
-
-procedure TfrmRegions.Button2Click(Sender: TObject);
-var
-  i: Integer;
-  Result: String;
-  ClipBoard: TClipboard;
-begin
-  ClipBoard := TClipBoard.Create;
-
-  for i := 0 to Length(Places) - 1 do begin
-    Result := Result + Format(#9 + #9 + '&lt;rectangle x1=&quot;%d&quot; y1=&quot;%d&quot; x2=&quot;%d y2=&quot;%d&quot; map=&quot;%u&quot; /&gt;' + #13, [Places[i].Left, Places[i].Top, Places[i].Right, Places[i].Bottom, cbMap.ItemIndex]);
-  end;
-
-  ClipBoard.SetTextBuf(PChar(result));
-  ClipBoard.Free;
-end;
-
-procedure TfrmRegions.Button3Click(Sender: TObject);
-var
-  ClipBoard: TClipboard;
-  Content: String;
-  Reader: TXMLReader;
-  Document, Node: TXMLNode;
-  i: Integer;
-  sFrom, sTo: String;
-  Parts: TStringList;
-  x1, x2, y1, y2: Integer;
-begin
-  ClipBoard := TClipBoard.Create;
-  Content := '&lt;rectangles&gt;' + ClipBoard.AsText + '&lt;/rectangles&gt;';
-
-  Reader := nil;
-  Document := nil;
-  Parts := TStringList.Create;
-
-  try
-    Reader := TXMLStringReader.Create(Content);
-    Document := Reader.ParseDocument.Nodes[0];
-
-    // Iterate over the rectangle nodes
-    for i := 0 to Document.NodeCount - 1 do begin
-      Node := Document.Nodes[i];
-
-      if Node.Name &lt;&gt; 'rectangle' then
-        continue; // Skip this node
-
-      // Look up From + To
-      Node.LookupBasicData('from', sFrom);
-      Node.LookupBasicData('to', sTo);
-
-      Parts.Clear;
-      Split(sFrom, ',', Parts);
-      if Parts.Count &lt;&gt; 2 then
-        continue; // From attribute is incorrect
-
-      x1 := StrToIntDef(Parts[0], 0);
-      y1 := StrToIntDef(Parts[1], 0);
-
-      Parts.Clear;
-      Split(sTo, ',', Parts);
-      if Parts.Count &lt;&gt; 2 then
-        continue; // To attribute is incorrect
-
-      x2 := StrToIntDef(Parts[0], 0);
-      y2 := StrToIntDef(Parts[1], 0);
-
-      AddRect(x1, y1, x2, y2);
-    end;
-  except
-    on e: Exception do begin
-      Application.MessageBox(PAnsiChar('The following error occured while parsing the XML definition: ' + #13 + e.Message), 'Error', MB_OK+MB_ICONERROR);
-    end;
-  end;
-
-  Reader.Free;
-  Document.Free;
-  Parts.Free;
-  ClipBoard.Free;
-end;
-
-procedure TfrmRegions.Button4Click(Sender: TObject);
-var
-  ClipBoard: TClipboard;
-  Content: String;
-  Reader: TXMLReader;
-  Document, Node: TXMLNode;
-  i: Integer;
-  Temp: String;
-  x1, x2, y1, y2: Integer;
-begin
-  ClipBoard := TClipBoard.Create;
-  Content := '&lt;rectangles&gt;' + ClipBoard.AsText + '&lt;/rectangles&gt;';
-
-  Reader := nil;
-  Document := nil;
-
-  try
-    Reader := TXMLStringReader.Create(Content);
-    Document := Reader.ParseDocument.Nodes[0];
-
-    // Iterate over the rectangle nodes
-    for i := 0 to Document.NodeCount - 1 do begin
-      Node := Document.Nodes[i];
-
-      if Node.Name &lt;&gt; 'rectangle' then
-        continue; // Skip this node
-
-      Node.LookupBasicData('x1', temp);
-      x1 := StrToIntDef(temp, 0);
-
-      Node.LookupBasicData('x2', temp);
-      x2 := StrToIntDef(temp, 0);
-
-      Node.LookupBasicData('y1', temp);
-      y1 := StrToIntDef(temp, 0);
-
-      Node.LookupBasicData('y2', temp);
-      y2 := StrToIntDef(temp, 0);
-
-      AddRect(x1, y1, x2, y2);
-    end;
-  except
-    on e: Exception do begin
-      Application.MessageBox(PAnsiChar('The following error occured while parsing the XML definition: ' + #13 + e.Message), 'Error', MB_OK+MB_ICONERROR);
-    end;
-  end;
-
-  Reader.Free;
-  Document.Free;
-  ClipBoard.Free;
-end;
-
-procedure TfrmRegions.lbRectsKeyDown(Sender: TObject; var Key: Word;
-  Shift: TShiftState);
-begin
-  if Key = 46 then
-    btnRemoveClick(Sender);
-end;
-
-procedure TfrmRegions.lbRectsDblClick(Sender: TObject);
-var
-  centerx, centery: Integer;
-begin
-  if lbRects.ItemIndex = -1 then
-    exit;
-
-  // center the map view on the dbl clicked region
-  CenterX := (Places[lbRects.ItemIndex].Right - Places[lbRects.ItemIndex].Left) div 2;
-  CenterX := CenterX + Places[lbRects.ItemIndex].Left;
-
-  CenterY := (Places[lbRects.ItemIndex].Bottom - Places[lbRects.ItemIndex].Top) div 2;
-  CenterY := CenterY + Places[lbRects.ItemIndex].Top;
-
-  // Now take the viewport into account
-  CenterX := CenterX - Trunc((pbMap.ClientWidth div 2) * Scale);
-  CenterY := CenterY - Trunc((pbMap.ClientHeight div 2) * Scale);
-
-  if CenterX &gt; sbX.Max then
-    CenterX := sbX.Max;
-
-  if CenterY &gt; sbY.Max then
-    CenterY := sbY.Max;
-
-  if CenterX &lt; 0 then
-    CenterX := 0;
-
-  if CenterY &lt; 0 then
-    CenterY := 0;
-
-  sbX.Position := CenterX;
-  sbY.Position := CenterY;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmRegions.btnZoomOutClick(Sender: TObject);
-begin
-  Scale := Scale / 0.5;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmRegions.btnZoomInClick(Sender: TObject);
-begin
-  Scale := Scale * 0.5;
-  pbMap.Invalidate;
-end;
-
-procedure TfrmRegions.btnRedrawClick(Sender: TObject);
-begin
-  pbMap.Invalidate;
-end;
-
-end.

Deleted: trunk/WPGM/Strlib.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/UOCache.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/UOCache.~pas
===================================================================
--- trunk/WPGM/UOCache.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/UOCache.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,88 +0,0 @@
-unit UOCache;
-
-interface
-
-uses Classes;
-
-(*
-	TCache
-    A utility class for caching objects.
-*)
-type TCache = class( TObject )
-	private
-    	Data: TList;
-        Size: Cardinal;
-        
-    public
-    	constructor Create( Size: Cardinal );
-        destructor Destroy; override;
-
-        procedure Add( Key: Cardinal; Data: Pointer );
-        function Lookup( Key: Cardinal ): Pointer;
-end;
-
-implementation
-
-uses IniFiles;
-
-type TPrivateCacheObject = record
-	Key: Cardinal;
-    Data: Pointer;
-end;
-
-type PPrivateCacheObject = ^TPrivateCacheObject;
-
-constructor TCache.Create( Size: Cardinal );
-begin
-	Data := TList.Create;
-    Self.Size := Size;
-end;
-
-destructor TCache.Destroy;
-var
-	i: Integer;
-begin
-	  for i := 0 to Data.Count - 1 do
-    begin
-    	Dispose( PPrivateCacheObject( Data[i] ).Data );
-	    Dispose( Data[i] );
-    end;
-    Data.Free;
-end;
-
-procedure TCache.Add( Key: Cardinal; Data: Pointer );
-var
-	CacheObject: PPrivateCacheObject;
-begin
-	new( CacheObject );
-    CacheObject.Key := Key;
-    CacheObject.Data := Data;
-
-    if ( Self.Data.Count &gt;= Integer( Self.Size ) ) and ( Self.Size &gt; 0 ) then
-    begin
-		Dispose( PPrivateCacheObject( Self.Data[0] ).Data );
-        Dispose( Self.Data[0] );
-        Self.Data.Delete( 0 );
-    end;
-
-    Self.Data.Add( CacheObject );
-end;
-
-function TCache.Lookup( Key: Cardinal ): Pointer;
-var
-	I: Integer;
-begin
-	Result := nil;
-
-	for I := 0 to ( Data.Count - 1 ) do
-    begin
-    	if PPrivateCacheObject( Data[i] ).Key = Key then
-        begin
-        	Result := PPrivateCacheObject( Data[i] ).Data;
-            Exit;
-        end;
-    end;
-end;
-
-end.
- 
\ No newline at end of file

Deleted: trunk/WPGM/UOHues.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/UOHues.~pas
===================================================================
--- trunk/WPGM/UOHues.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/UOHues.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,135 +0,0 @@
-unit UOHues;
-
-interface
-
-uses Classes, Graphics;
-
-type THue = packed record
-  Colors: Array[0..31] of Word;
-  TableStart: Word;
-  TableEnd: Word;
-  Name: Array[0..19] of Char;
-end;
-
-type THueBlock = packed record
-  Header: Cardinal;
-  Hues: Array[0..7] of THue;
-end;
-
-type TProcessedHue = Array[0..31] of TColor;
-type PHue = ^THue;
-
-type THuesReader = class(TObject)
-	private
-    Colors: Array[0..$BB7] of TProcessedHue;
-    Hues: Array[0..374] of THueBlock;
-    TrueBlack: THue;
-	public
-    constructor Create; overload;
-    function Load( FileName: String ): Boolean;
-    function getHue(Id: Word): PHue;
-    function translateColor(Hue: Word; Color: TColor;
-      Partial: Boolean = False): TColor;
-    function getColor(Hue: Word; Color: Byte): TColor;
-end;
-
-implementation
-
-uses Windows, SysUtils, UOUtilities;
-
-constructor THuesReader.Create;
-begin
-	ZeroMemory( @Colors, $BB8 * sizeof( TProcessedHue ) );
-  ZeroMemory(@Hues, $BB8 * sizeof( THue ) );
-  ZeroMemory(@TrueBlack, sizeof(THue));
-  TrueBlack.Name := 'True Black';
-end;
-
-function THuesReader.Load( FileName: String ): Boolean;
-var
-  Input: TFileStream;
-  i, j, k: Integer;
-begin
-  Result := False;
-
-  try
-    Input := TFileStream.Create( FileName, fmOpenRead+fmShareDenyNone );
-
-    // Read Blocks
-    for i := 0 to 374 do
-    begin
-      Input.Read(Hues[i], sizeof(THueBlock));
-      for j := 0 to 7 do
-      begin
-        for k := 0 to 31 do
-          Colors[i * 8 + j][k] := Color15to24(Hues[i].Hues[j].Colors[k]);
-      end;
-    end;
-
-    Input.Free;
-    Result := True;
-  except
-  end;
-end;
-
-function THuesReader.getHue(Id: Word): PHue;
-var
-  Block: Word;
-begin
-  Result := nil;
-
-  if Id = 0 then
-    exit;
-
-  If Id = 1 then
-  begin
-    Result := @TrueBlack;
-    exit;
-  end;
-
-  Dec(Id, 1);
-
-  Block := Id div 8;
-  if Block &lt;= 374 then
-    Result := @(Hues[Block].Hues[Id mod 8]);
-end;
-
-function THuesReader.translateColor(Hue: Word; Color: TColor;
-  Partial: Boolean = False): TColor;
-var
-  Offset: Byte;
-begin
-  if Hue = 1 then
-  begin
-    Result := clBlack;
-    exit;
-  end;
-
-  if Hue = 0 then
-  begin
-    Result := Color;
-    exit;
-  end;
-
-  Dec(Hue); // Hue 1 is Blue
-
-  Hue := Hue mod $BB8;
-  Offset := GetRValue(Color) div 8;
-  Result := Colors[Hue][Offset];
-end;
-
-function THuesReader.getColor(Hue: Word; Color: Byte): TColor;
-begin
-  if Hue = 1 then
-  begin
-      Result := clBlack;
-      exit;
-  end;
-
-  Dec(Hue); // Hue 1 is blue
-  Hue := Hue mod $BB8;
-
-  Result := Colors[Hue][Color mod 32];
-end;
-
-end.

Deleted: trunk/WPGM/UOLib/UOAnim.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/UOLib/UOAnim.~pas
===================================================================
--- trunk/WPGM/UOLib/UOAnim.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/UOLib/UOAnim.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,534 +0,0 @@
-unit UOAnim;
-
-interface
-
-uses Classes, SysUtils, GR32, UOHues;
-
-// Animation Frame
-type TAnimFrame = record
-  Image: TBitmap32;
-  CenterX, CenterY: Integer;
-end;
-
-type PAnimFrame = ^TAnimFrame;
-
-type TAnimation = class
-private
-  Frames: TList;
-public
-  Body: Word;
-  Action: Word;
-  FrameDelay: Word;
-  Hue: Word;
-
-  function getTotalHeight: Integer;
-  function getTotalWidth: Integer;
-
-  constructor Create;
-  destructor Destroy; override;
-
-  function frameCount: Integer;
-  function getFrame(i: Integer): PAnimFrame;
-  procedure addFrame(frame: PAnimFrame);
-end;
-
-type TBodyConv = record
-  Body: Integer;
-  Anim2: Integer;
-  Anim3: Integer;
-end;
-
-type TBodyDef = record
-  Body: Integer;
-  NewBody: Integer;
-  NewHue: Integer;
-end;
-
-type TAnimReader = class
-private
-    dStream, iStream: TStream;
-    dStream2, iStream2: TStream;
-    dStream3, iStream3: TStream;
-    disabled: Boolean;
-    BodyConv: Array of TBodyConv;
-    BodyDef: Array of TBodyDef;
-                     
-    function GetData( Body: Word; Action: Word; var Length: Cardinal ): TStream;
-    procedure LoadBodyConv(Filename: String);
-    procedure LoadBodyDef(FileName: String);
-public
-    hues: THuesReader;
-
-    constructor Create;
-    destructor Free;
-    function GetFrames( Body, Action, Color: Word): TAnimation; overload;
-    function GetFrames( Body, Action: Word ): TAnimation; overload;
-    procedure getBodyConv(Body: Word; var Anim2: Integer; var Anim3: Integer);
-    function getBodyDef(var Body: Word; var Color: Word): Boolean;
-
-    function Open( IndexName1, DataName1, IndexName2, DataName2, IndexName3, DataName3, BodyConv, BodyDef: String ): Boolean;
-    procedure Close();
-end;
-
-implementation
-
-uses Forms, Windows, UOUtilities, Graphics, Math, StrUtils;
-
-constructor TAnimation.Create;
-begin
-  Frames := TList.Create;
-end;
-
-function TAnimation.getTotalHeight: Integer;
-var
-  i: Integer;
-  frame: PAnimFrame;
-begin
-  Result := 0;
-
-  for i := 0 to frameCount - 1 do
-  begin
-    frame := frames[i];
-    Result := Max(Result, frame.Image.Height - frame.CenterY);
-  end;
-end;
-
-function TAnimation.getTotalWidth: Integer;
-var
-  i: Integer;
-  frame: PAnimFrame;
-begin
-  Result := 0;
-
-  for i := 0 to frameCount - 1 do
-  begin
-    frame := frames[i];
-    Result := Max(Result, frame.Image.Width - frame.CenterX);
-  end;
-end;
-
-destructor TAnimation.Destroy;
-var
-  i: Integer;
-begin
-  for i := 0 to frames.Count - 1 do begin
-    dispose(Frames[i]);
-  end;
-  Frames.Free;
-  inherited Destroy;
-end;
-
-function TAnimation.frameCount: Integer;
-begin
-  Result := Frames.Count;
-end;
-
-function TAnimation.getFrame(i: Integer): PAnimFrame;
-begin
-  if I &gt;= frames.count then
-    result := nil
-  else
-    result := frames[i];
-end;
-
-procedure TAnimation.addFrame(frame: PAnimFrame);
-begin
-  frames.Add(frame);
-end;
-
-type TIndexRecord = packed record
-    Offset: Integer;
-    Length: Integer;
-    Extra: Integer
-end;
-
-// Get a TMemoryStream of the desired data
-function TAnimReader.GetData( Body: Word; Action: Word; var Length: Cardinal ): TStream;
-var
-    IndexRecord: TIndexRecord;
-    Offset: Cardinal;
-    Anim2, Anim3: Integer;
-begin
-    // CHECK FOR VERDATA HERE
-
-    getBodyConv(Body, Anim2, Anim3);
-
-    // Read From Anim3.mul
-    if (Anim3 &lt;&gt; -1) and (iStream3 &lt;&gt; nil) and (dStream3 &lt;&gt; nil) then begin
-      if Anim3 &lt; 300 then
-        Offset := Anim3 * 65 + Action
-      else if Anim3 &lt; 400 then
-        Offset := 33000 + (Anim3 - 300) * 110 + Action
-      else
-        Offset := 35000 + (Anim3 - 400) * 175 + Action;
-
-      iStream3.Seek( Offset * 12, soFromBeginning );
-      iStream3.Read( IndexRecord, SizeOf( TIndexRecord ) );
-
-      if IndexRecord.Offset &lt;&gt; -1 then begin
-        Length := IndexRecord.Length;
-        dStream3.Seek( IndexRecord.Offset, soFromBeginning );
-        Result := dStream3;
-        exit;
-      end;
-    end;
-
-    // Read From Anim2.mul
-    if (Anim2 &lt;&gt; -1) and (iStream2 &lt;&gt; nil) and (dStream2 &lt;&gt; nil) then begin
-      if Anim2 &lt; 200 then
-        Offset := Anim2 * 110 + Action
-      else
-        Offset := 22000 + (Anim2 - 200) * 65 + Action;
-
-      iStream2.Seek( Offset * 12, soFromBeginning );
-      iStream2.Read( IndexRecord, SizeOf( TIndexRecord ) );
-
-      if IndexRecord.Offset &lt;&gt; -1 then begin
-        Length := IndexRecord.Length;
-        dStream2.Seek( IndexRecord.Offset, soFromBeginning );
-        Result := dStream2;
-        exit;
-      end;
-    end;
-
-    if Body &lt;= $C7 then begin
-      Action := Action mod 110;
-      Offset := Body * 110 + Action;
-    end else if Body &lt;= $18F then begin
-      Action := Action mod 65;
-      Offset := (Body - $C8) * 65 + Action + 22000;
-    end else begin
-      Action := Action mod 175;
-      Offset := (Body - $190) * 175 + Action + 35000;
-    end;
-
-    iStream.Seek( Offset * 12, soFromBeginning );
-    iStream.Read( IndexRecord, SizeOf( TIndexRecord ) );
-
-    if IndexRecord.Offset = -1 then begin
-      Result := nil;
-      Length := 0;
-      exit;
-    end;
-
-    Length := IndexRecord.Length;
-
-    dStream.Seek( IndexRecord.Offset, soFromBeginning );
-    Result := dStream;
-end;
-
-function TAnimReader.Open( IndexName1, DataName1, IndexName2, DataName2, IndexName3, DataName3, BodyConv, BodyDef: String ): Boolean;
-begin
- 	Result := False;
-  try
-   	dStream := TFileStream.Create( DataName1, fmOpenRead+fmShareDenyNone );
-    iStream := TFileStream.Create( IndexName1, fmOpenRead+fmShareDenyNone );
-    Disabled := False;
-  except
-    Close;
-  end;
-
-  dStream2 := nil;
-  dStream3 := nil;
-  iStream2 := nil;
-  iStream3 := nil;
-
-  try
-    dStream2 := TFileStream.Create( DataName2, fmOpenRead+fmShareDenyNone );
-    iStream2 := TFileStream.Create( IndexName2, fmOpenRead+fmShareDenyNone );
-  except
-    FreeAndNil(iStream2);
-    FreeAndNil(dStream2);
-  end;
-
-  try
-    dStream3 := TFileStream.Create( DataName3, fmOpenRead+fmShareDenyNone );
-    iStream3 := TFileStream.Create( IndexName3, fmOpenRead+fmShareDenyNone );
-  except
-    FreeAndNil(iStream3);
-    FreeAndNil(dStream3);
-  end;
-
-  // Load Bodyconv.def
-  LoadBodyConv(BodyConv);
-
-  // Load Body.def
-  LoadBodyDef(BodyDef);
-end;
-
-procedure TAnimReader.Close();
-begin
-    FreeAndNil( dStream );
-	FreeAndNil( iStream );
-    disabled := True;
-end;
-
-constructor TAnimReader.Create;
-begin
-    disabled := True;
-    dStream := nil;
-    iStream := nil;
-    hues := nil;
-end;
-
-destructor TAnimReader.Free;
-begin
-end;
-
-function TAnimReader.GetFrames( Body, Action, Color: Word): TAnimation;
-var
-  Data: TStream;
-  Length: Cardinal;
-  Palette: Array[0..255] of TColor32;
-  i, j: Integer;
-  Color15: Word;
-  FrameCount: Integer;
-  FrameOffsets: Array of Integer;
-  ImageCenterX, ImageCenterY: Smallint;
-  Width, Height: Word;
-  YOffset, XOffset, XRun: Integer;
-  Chunk: Integer;
-  SeekStart: Integer;
-  PaletteIndex: Byte;
-  Frame: PAnimFrame;
-  Hue: PHue;
-begin
-  Data := GetData(Body, Action, Length);
-
-  if Data = nil then begin
-    getBodyDef(Body, Color);
-
-    Data := GetData(Body, Action, Length);
-
-    if Data = nil then begin
-      //Application.MessageBox(PAnsiChar('Unknown Body Id: ' + IntToStr(Body)), 'Error: Invalid Body Id', MB_OK+MB_ICONERROR);
-      result := nil;
-      exit;
-    end;
-  end;
-
-  result := TAnimation.Create;
-  result.body := body;
-  result.action := action;
-  result.FrameDelay := 80;
-
-  if (Hues &lt;&gt; nil) and (Color &lt;&gt; 0) then
-    Hue := Hues.getHue(Color)
-  else
-    Hue := nil;
-
-  // Read the palette
-  for i := 0 to 255 do begin
-    Data.Read(Color15, 2);
-
-    if hue &lt;&gt; nil then
-      Color15 := hue.Colors[((Color15 shr 10) and $1F)];
-
-    if Color15 = 0 then
-      Palette[i] := 0
-    else
-      Palette[i] := Color15to32(Color15);
-  end;
-
-  SeekStart := Data.Position;
-
-  Data.Read(FrameCount, 4);
-  SetLength(FrameOffsets, FrameCount);
-
-  for i := 0 to FrameCount - 1 do begin
-    Data.Read(FrameOffsets[i], 4);
-  end;
-
-  // Seek to the requested frame
-  for j := 0 to FrameCount - 1 do begin
-    Data.Seek(SeekStart + FrameOffsets[j], soFromBeginning);
-
-    // Read Frame Header
-    Data.Read(ImageCenterX, 2);
-    Data.Read(ImageCenterY, 2);
-    Data.Read(Width, 2);
-    Data.Read(Height, 2);
-
-    new(Frame);
-    Frame.Image := TBitmap32.Create;
-    Frame.Image.SetSize(Width, Height);
-    Frame.Image.DrawMode := dmBlend;
-    Frame.CenterX := ImageCenterX;
-    Frame.CenterY := ImageCenterY;
-
-    while true do begin
-      // Read a Chunk
-      Data.Read(Chunk, 4);
-
-      if (Chunk = $7FFF7FFF) then
-        break;
-
-      XRun := Chunk and $FFF; // Pixel Amount
-      YOffset := (Chunk shr 12) and $3FF;
-      XOffset := (Chunk shr 22) and $3FF;
-
-      if XOffset and $200 &lt;&gt; 0 then
-        XOffset := Integer(Cardinal(XOffset) or $FFFFFC00);
-
-      if YOffset and $200 &lt;&gt; 0 then
-        YOffset := Integer(Cardinal(YOffset) or $FFFFFC00);
-
-      Inc(YOffset, Height);
-
-      for i := 0 to XRun - 1 do begin
-        Data.Read(PaletteIndex, 1);
-
-        if Palette[PaletteIndex] &lt;&gt; 0 then
-          Frame.Image.Pixel[ImageCenterX + XOffset + i, ImageCenterY + YOffset] := Palette[PaletteIndex];
-      end;
-    end;
-
-    Result.addFrame(frame);
-  end;
-end;
-
-function TAnimReader.GetFrames( Body, Action: Word ): TAnimation;
-begin
-  Result := GetFrames(Body, Action, 0);
-end;
-
-procedure TAnimReader.LoadBodyConv(Filename: String);
-var
-  Input: TextFile;
-  Line: String;
-  Pos, Body, Anim2, Anim3: Integer;
-begin
-  try
-    AssignFile(Input, FileName);
-    Reset(Input);
-
-    // Read Line By Line
-    while not Eof(Input) do begin
-      ReadLn(Input, Line);
-
-      // Comment Lines
-      if LeftStr(Line, 1) = '#' then
-        continue;
-
-      // Get First Token
-      Pos := AnsiPos(Char($9), Line);
-      Body := StrToIntDef(LeftStr(Line, Pos - 1), -1);
-
-      if Body = -1 then
-        continue;
-
-      // Get Second Token
-      Line := RightStr(Line, Length(Line) - pos);
-      Pos := AnsiPos(Char($9), Line);
-      Anim2 := StrToIntDef(LeftStr(Line, Pos - 1), -1);
-
-      // Get Third Token
-      Line := RightStr(Line, Length(Line) - pos);
-      Pos := AnsiPos(Char($9), Line);
-      Anim3 := StrToIntDef(LeftStr(Line, Pos - 1), -1);
-
-      // Save Token
-      Pos := Length(BodyConv);
-      SetLength(BodyConv, Pos + 1);
-      BodyConv[Pos].Body := Body;
-      BodyConv[Pos].Anim2 := Anim2;
-      BodyConv[Pos].Anim3 := Anim3;
-    end;
-
-    CloseFile(Input);
-  except
-  end;
-end;
-
-procedure TAnimReader.LoadBodyDef(Filename: String);
-var
-  Input: TextFile;
-  Line: String;
-  Pos, Body, NewBody, NewHue: Integer;
-  NewBodies: String;
-begin
-  try
-    AssignFile(Input, FileName);
-    Reset(Input);
-
-    // Read Line By Line
-    while not Eof(Input) do begin
-      ReadLn(Input, Line);
-
-      // Comment Lines
-      if LeftStr(Line, 1) = '#' then
-        continue;
-
-      // Get First Token
-      Pos := AnsiPos(' ', Line);
-      Body := StrToIntDef(LeftStr(Line, Pos - 1), -1);
-
-      if Body = -1 then
-        continue;
-
-      // Get Last Token
-      Line := RightStr(Line, Length(Line) - pos);
-      Pos := LastDelimiter(' ', Line);
-      NewBodies := LeftStr(Line, Pos - 1);
-
-      // Get Third Token
-      Line := RightStr(Line, Length(Line) - pos);
-      NewHue := StrToIntDef(Line, 0);
-
-      If AnsiPos(',', NewBodies) = 0 then begin
-        NewBody := StrToIntDef(MidStr(NewBodies, 2, Length(NewBodies) - 2), Body);
-      end else begin
-        // Get the first number and use it
-        NewBodies := RightStr(NewBodies, Length(NewBodies) - 1);
-        Pos := AnsiPos(',', NewBodies);
-        NewBodies := LeftStr(NewBodies, Pos - 1);
-        NewBody := StrToIntDef(NewBodies, Body);
-      end;
-
-      Pos := Length(BodyDef);
-      SetLength(BodyDef, Pos + 1);
-      BodyDef[Pos].Body := Body;
-      BodyDef[Pos].NewBody := NewBody;
-      BodyDef[Pos].NewHue := NewHue;
-    end;
-
-    CloseFile(Input);
-  except
-  end;
-end;
-
-
-
-procedure TAnimReader.getBodyConv(Body: Word; var Anim2: Integer; var Anim3: Integer);
-var
-  i: Integer;
-begin
-  for i := 0 to Length(BodyConv) - 1 do begin
-    if BodyConv[i].Body = Body then begin
-      Anim2 := BodyConv[i].Anim2;
-      Anim3 := BodyConv[i].Anim3;
-      exit;
-    end;
-  end;
-
-  Anim2 := -1;
-  Anim3 := -1;
-end;
-
-function TAnimReader.getBodyDef(var Body: Word; var Color: Word): Boolean;
-var
-  i: Integer;
-begin
-  for i := 0 to Length(BodyDef) - 1 do begin
-    if BodyDef[i].Body = Body then begin
-      Body := BodyDef[i].NewBody;
-      Color := BodyDef[i].NewHue;
-      Result := true;
-      exit;
-    end;
-  end;
-
-  Result := false;
-end;
-
-end.

Deleted: trunk/WPGM/UOLib/UOArt.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/UOLib/UOArt.~pas
===================================================================
--- trunk/WPGM/UOLib/UOArt.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/UOLib/UOArt.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,188 +0,0 @@
-unit UOArt;
-
-interface
-
-uses Classes, SysUtils, GR32, UOHues;
-
-type TArtReader = class
-private
-    dStream, iStream: TStream;
-    disabled: Boolean;
-    function GetData( ID: Word; var Length: Integer ): TStream;
-public
-    hues: THuesReader;
-    
-    constructor Create;
-    destructor Free;
-    function GetTile( ID, Color: Word ): TBitmap32; overload;
-    function GetTile( Id: Word ): TBitmap32; overload;
-
-    function Open( IndexName: String; DataName: String ): Boolean;
-    procedure Close();
-end;
-
-var
-    Art: TArtReader;
-
-implementation
-
-uses Forms, Windows, UOUtilities, Graphics;
-
-type TIndexRecord = packed record
-    Offset: Integer;
-    Length: Integer;
-    Extra: Integer
-end;
-
-// Get a TMemoryStream of the desired data
-function TArtReader.GetData( ID: Word; var Length: Integer ): TStream;
-var
-    IndexRecord: TIndexRecord;
-    Offset: Cardinal;
-begin
-    Result := nil;
-
-    // CHECK FOR VERDATA HERE
-
-    Offset := 12 * ( $4000 + Id );
-
-    iStream.Seek( Offset, soFromBeginning );
-    iStream.Read( IndexRecord, SizeOf( TIndexRecord ) );
-    Length := IndexRecord.Length;
-
-    if Length = -1 then
-      exit;
-
-    dStream.Seek( IndexRecord.Offset, soFromBeginning );
-    Result := dStream;
-end;
-
-function TArtReader.Open( IndexName: String; DataName: String ): Boolean;
-begin
- 	Result := False;
-  try
-   	dStream := TFileStream.Create( DataName, fmOpenRead+fmShareDenyNone );
-    iStream := TFileStream.Create( IndexName, fmOpenRead+fmShareDenyNone );
-    Disabled := False;
-  except
-    Close;
-  end;
-end;
-
-procedure TArtReader.Close();
-begin
-    FreeAndNil( dStream );
-	FreeAndNil( iStream );
-    disabled := True;
-end;
-
-constructor TArtReader.Create;
-begin
-    disabled := True;
-    dStream := nil;
-    iStream := nil;
-    hues := nil;
-end;
-
-destructor TArtReader.Free;
-begin
-end;
-
-// Create an Art-tile
-function TArtReader.GetTile( ID, Color: Word ): TBitmap32;
-var
-    Data: TStream;
-    x, y, i: Cardinal;
-    Length: Integer;
-    Width, Height: Word;
-    LookupTable: Array of Word;
-    DataSTArtReader: Cardinal;
-    XOffset, RunLength, RunColor: Word;
-    hue: PHue;
-begin
-    if (Color &lt;&gt; 0) and (hues &lt;&gt; nil) then begin
-      hue := hues.getHue(color);
-    end else begin
-      hue := nil;
-    end;
-
-    Result := TBitmap32.Create;
-
-    if disabled then
-    begin
-        Result.SetSize( 44, 44 );
-        Result.Clear( Color32( clBtnFace ) );
-        Result.Line( 1, 1, 43, 43, clRed32 );
-        Result.Line( 43, 0, 0, 43, clRed32 );
-        exit;
-    end;
-
-    Data := GetData( Id, Length );
-
-    if( Length = -1 ) then
-        exit;
-
-    Data.Seek( 4, soFromCurrent );
-    Data.Read( Width, 2 );
-    Data.Read( Height, 2 );
-
-    SetLength( LookupTable, Height );
-    for i := 0 to Height-1 do
-        Data.Read( LookupTable[i], 2 );
-
-    DataSTArtReader := Data.Position;
-    Result.SetSize( Width, Height );
-    //Result.Clear( Color32( clBtnFace ) );
-    Result.Clear(Color32(clBtnFace));
-
-    // Draw the &quot;tile&quot; 3d wireframe
-    for x := 0 to 21 do begin
-      Result.PixelS[((Width - 1) div 2) - x, Height - 1 - x] := clRed32;
-      Result.PixelS[((Width - 1) div 2) + x, Height - 1 - x] := clRed32;
-      Result.PixelS[((Width - 1) div 2) - x, Height - 44 + x] := clRed32;
-      Result.PixelS[((Width - 1) div 2) + x, Height - 44 + x] := clRed32;
-    end;
-
-    // Parse each line of the image
-    for y := 0 to Height-1 do
-    begin
-        Data.Seek( DataSTArtReader + ( LookupTable[y] * 2 ), soFromBeginning );
-        X := 0;
-
-        // RLE Decoding (Read Chunks)
-        repeat begin
-            Data.Read( XOffset, 2 );
-            Data.Read( RunLength, 2 );
-
-            inc( x, XOffset );
-
-            if( RunLength &gt; 0 ) then
-                for i := 0 to RunLength-1 do
-                begin
-                    Data.Read( RunColor, 2 );
-
-                    // INSERT HUE PROCESSING HERE
-                    if hue &lt;&gt; nil then begin
-                      RunColor := hue.Colors[((RunColor shr 10) and $1F)];
-                    end;
-
-                    // 0 RRRRR GG|GGG BBBBB Encoding
-                    try
-                        Result.Pixel[ x+i, y ] := Color15to24( RunColor );
-                    except
-                        Application.MessageBox( PChar( 'Invalid Data, X=' + IntToStr(x) + ', Y=' + IntToStr(y) ), 'Invalid Data', 0 );
-                    end;
-                end;
-
-            inc( X, RunLength );
-
-        end until ( ( RunLength = 0 ) and ( XOffset = 0 ) );
-    end;
-end;
-
-function TArtReader.GetTile( Id: Word ): TBitmap32;
-begin
-    Result := GetTile( Id, 0 );
-end;
-
-end.

Deleted: trunk/WPGM/UOLib/UOTiledata.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/UOLib/UOTiledata.~pas
===================================================================
--- trunk/WPGM/UOLib/UOTiledata.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/UOLib/UOTiledata.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,90 +0,0 @@
-unit UOTiledata;
-
-interface
-
-type TLandTiledata = packed record
-	flags: Cardinal;
-    texture: Word;
-    name: array[0..19] of Char;
-end;
-
-type TItemTiledata = packed record
-	flags: Cardinal;
-    weight: Byte;
-    layer: Byte;
-    unknown1: word;
-    unknown2: byte;
-    quantity: byte;
-    animation: word;
-    unknown3: byte;
-    hue: byte;
-    unknown4: byte;
-    unknown5: byte;
-    height: byte;
-    name: array[0..19] of Char;
-end;
-
-type PItemTiledata = ^TItemTiledata;
-
-type TTiledataReader = class( TObject )
-	private
-		StaticTiles: Array[0..$3FFF] of TItemTiledata;
-
-	public
-    	constructor Create;
-    	destructor Destroy; override;
-
-        function Open( FileName: String ): Boolean;
-        function getItemName( id: Word ): String;
-end;
-
-implementation
-
-uses Classes, SysUtils;
-
-constructor TTiledataReader.Create;
-begin
-end;
-
-destructor TTiledataReader.Destroy;
-begin
-end;
-
-function TTiledataReader.Open( FileName: String ): Boolean;
-var
-	Input: TFileStream;
-    i,j: Cardinal;
-begin
-  Result := False;
-  Input  := Nil;
-  try
-   	Input := TFileStream.Create( FileName, fmOpenRead+fmShareDenyNone );
-
-    // Skip Land Tiles (for now)
-    Input.Seek( 512 * ( 4 + ( 32 * sizeof( TLandTiledata ) ) ), soFromBeginning );
-
-    // Read all blocks
-    for i := 0 to 511 do
-    begin
-      Input.Seek( 4, soFromCurrent );
-
-      for j := 0 to 31 do
-      begin
-        Input.Read( StaticTiles[ ( i * 32 ) + j ], sizeof( TItemTiledata ) );
-      end;
-    end;
-
-    Input.Free;
-    Result := True;
-  except
-  end;    
-end;
-
-function TTiledataReader.getItemName( id: Word ): String;
-begin
-    Assert( id &lt;= $3fff );
-
-    Result := StaticTiles[ id ].name;
-end;
-
-end.

Deleted: trunk/WPGM/UOLib/UOUtilities.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/UOLib/UOUtilities.~pas
===================================================================
--- trunk/WPGM/UOLib/UOUtilities.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/UOLib/UOUtilities.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,93 +0,0 @@
-unit UOUtilities;
-
-interface
-
-uses Graphics, GR32;
-
-function Color15to24( Color: Word ): TColor;
-function Color15to32( Color: Word ): TColor32;
-function SendCommand( Command: String; Activate: Boolean = False ): Boolean;
-function GetUoPath: String;
-
-implementation
-
-uses Windows, Forms, Messages, Registry, SysUtils, Main, uConfig;
-
-function Color15to32( Color: Word ): TColor32;
-begin
-	Result := Color32( ((Color shr 10) and $1F) * 8,
-                ((Color shr 5) and $1F) * 8,
-                  ((Color and $1F) * 8),
-                  255);
-end;
-
-function Color15to24( Color: Word ): TColor;
-begin
-	Result := TColor( ( ( (Color shr 10 ) and $1F ) * 8 shl 16 ) or
-                ( ( ( Color shr 5  ) and $1F ) * 8  shl 8 ) or
-                  ( Color and $1F) * 8 );
-end;
-
-function SendCommand(Command: String; Activate: Boolean): Boolean;
-var
-	Window: HWND;
-    PStr: PChar;
-    i: Integer;
-  Prefix: String;
-begin
-  Prefix := Main.Config.getString('Command Prefix', '''');
-  Command := Prefix + Command;
-
-  Result := False;
-  Window := FindWindow('Ultima Online', nil);
-
-  if Window = 0 then
-  begin
-    Application.MessageBox(PChar('Please start the Ultima Online client before sending any commands.' + #13 + 'Ignored Command: ' + Command ), 'Ultima Online Error', MB_OK+MB_ICONWARNING);
-    exit;
-  end;
-
-  PStr := PChar(Command);
-
-  SendMessage(Window, WM_CHAR, 13, 0);
-
-  for i := 0 to Length( Command ) - 1 do
-  begin
-    PostMessage(Window, WM_CHAR, Integer( PStr[i] ), 0);
-  end;
-
-  PostMessage(Window, WM_CHAR, 13, 0);
-
-  if Activate then
-  begin
-    BringWindowToTop(Window);
-    SetFocus(Window);
-  end;
-end;
-
-function GetUoPath: String;
-var
-	Registry: TRegistry;
-begin
-  Registry := TRegistry.Create;
-  Result := '';
-
-  Registry.RootKey := HKEY_LOCAL_MACHINE;
-  if not Registry.OpenKey( 'SOFTWARE\Origin Worlds Online\Ultima Online\1.0', False ) then
-  begin
-    Registry.Free;
-  exit;
-  end;
-
-  if not Registry.ValueExists( 'ExePath' ) then
-  begin
-    Registry.Free;
-    exit;
-  end;
-
-  Result := ExtractFilePath( Registry.ReadString( 'ExePath' ) );
-
-  Registry.Free;
-end;
-
-end.

Deleted: trunk/WPGM/UOMap.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/UOMap.~pas
===================================================================
--- trunk/WPGM/UOMap.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/UOMap.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,177 +0,0 @@
-unit UOMap;
-
-interface
-
-uses Classes, UOCache;
-
-type TMapCell = packed record
-	Id: Word;
-    Height: Shortint;
-end;
-
-type TMapBlock = packed record
-	Header: Cardinal;
-    Cells: Array[0..63] of TMapCell;
-end;
-
-type TMapReader = class( TObject )
-	private
-    Input: TFileStream;
-    Height, Width: Word;
-    Cache: TCache;
-    Disabled: Boolean;
-    LastModifyTime: TDateTime;
-
-	public
-    function getHeight: Word;
-    function getWidth: Word;
-    constructor Create;
-    destructor Destroy; override;
-
-    function Open( FileName: String; MapWidth: Word = 0; MapHeight: Word = 0 ): Boolean;
-    procedure Close;
-
-    procedure ReadBlock( XBlock: Word; YBlock: Word; var MapBlock: TMapBlock );
-    procedure ReadCell( X: Word; Y: Word; var MapCell: TMapCell );
-    function LastModified(): TDateTime;
-    //procedure WriteBlock( X: Word, Y: Word; MapBlock: TMapBlock );
-    //procedure WriteCell( X: Word; Y: Word; MapCell: TMapCell );
-end;
-
-implementation
-
-uses Windows, Dialogs, SysUtils;
-
-function TMapReader.getWidth: Word;
-begin
-  Result := Width;
-end;
-
-function TMapReader.getHeight: Word;
-begin
-  Result := Height;
-end;
-
-constructor TMapReader.Create;
-begin
-  Input := nil;
-  Width := 0;
-  Height := 0;
-  Cache := TCache.Create( 100 ); // 100 Blocks
-  Disabled := True;
-  LastModifyTime := GetTime;  
-end;
-
-destructor TMapReader.Destroy;
-begin
-	Input.Free;
-	Cache.Free;
-end;
-
-function TMapReader.Open( FileName: String; MapWidth: Word; MapHeight: Word ): Boolean;
-begin
-	Result := False;
-  Input := nil;
-
-	try
-    Input := TFileStream.Create( FileName, fmOpenRead+fmShareDenyNone );
-    Result := True;
-
-    // Measure Map Height
-    Height := MapHeight;
-    Width := MapWidth;
-
-    if Height = 0 then case Input.Size of
-    77070336:
-      begin
-        Width := 768;
-        Height := 512;
-        Disabled := False;
-      end;
-
-    11289600:
-      begin
-        Width := 288;
-        Height := 200;
-        Disabled := False;
-      end;
-
-    16056320:
-      begin
-        Width := 320;
-        Height := 256;
-        Disabled := False;
-      end;
-
-    6421156:
-      begin
-        Width := 181;
-        Height := 181;
-        Disabled := False;
-      end;
-    end;
-
-    // Try to read the modify time
-    LastModifyTime := FileDateToDateTime(FileAge(FileName));
-  except
-    Input.Free;
-  end;
-end;
-
-procedure TMapReader.Close;
-begin
-	Input.Free;
-    Input := nil;
-end;
-
-procedure TMapReader.ReadBlock(XBlock: Word; YBlock: Word; var MapBlock: TMapBlock);
-var
-  BlockId: Cardinal;
-  CacheEntry: ^TMapBlock;
-begin
-  if Disabled then begin
-    ZeroMemory(@MapBlock, sizeof(TMapBlock));
-    exit;
-  end;
-
-  BlockId := XBlock * Height + YBlock;
-
-  // See if the block is cached
-  CacheEntry := Cache.Lookup(BlockId);
-
-  if CacheEntry &lt;&gt; nil then begin
-    MapBlock := CacheEntry^;
-    exit;
-  end;
-
-  ZeroMemory(@MapBlock, sizeof(TMapBlock));
-  if (Input = nil) or (Height = 0) then
-    exit;
-
-  new(CacheEntry);
-  Input.Seek( BlockId * sizeof( TMapBlock ), soFromBeginning );
-  Input.Read(CacheEntry^, sizeof(TMapBlock));
-  MapBlock := CacheEntry^;
-  Cache.Add(BlockId, CacheEntry);  
-end;
-
-procedure TMapReader.ReadCell( X: Word; Y: Word; var MapCell: TMapCell );
-var
-	Block: TMapBlock;
-begin
-	ZeroMemory( @MapCell, sizeof( TMapCell ) );
-
-    if( Input = nil ) or ( Height = 0 ) then
-    	exit;
-
-    ReadBlock( X div 8, Y div 8, Block );
-
-	MapCell := Block.Cells[ ( ( Y mod 8 ) * 8 ) + ( X mod 8 ) ];   
-end;
-
-function TMapReader.LastModified(): TDateTime;
-begin
-  Result := LastModifyTime;
-end;
-
-end.

Deleted: trunk/WPGM/UORadarCol.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/UORadarCol.~pas
===================================================================
--- trunk/WPGM/UORadarCol.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/UORadarCol.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,63 +0,0 @@
-unit UORadarCol;
-
-interface
-
-uses Classes, Graphics;
-
-type TRadarColReader = class( TObject )
-	private
-		Colors: Array[0..$7FFF] of TColor;
-
-	public
-    	constructor Create; overload;
-        function Load( FileName: String ): Boolean;
-
-        function GetLandColor( Id: Word ): TColor;
-        function GetItemColor( Id: Word ): TColor;
-end;
-
-implementation
-
-uses Windows, SysUtils, UOUtilities;
-
-constructor TRadarColReader.Create;
-begin
-	ZeroMemory( @Colors, $8000 * sizeof( TColor ) );
-end;
-
-function TRadarColReader.Load( FileName: String ): Boolean;
-var
-	Input: TFileStream;
-    i: Integer;
-begin
-	Result := False;
-
-	try
-   	Input := TFileStream.Create( FileName, fmOpenRead+fmShareDenyWrite );
-
-		for i := 0 to $7FFF do
-        begin
-			Input.Read( Colors[i], 2 );
-            Colors[i] := Color15to24( Colors[i] );
-        end;
-
-        Input.Free;
-        Result := True;
-    except
-    end;
-end;
-
-function TRadarColReader.GetLandColor( Id: Word ): TColor;
-begin
-	if Id &gt;= $7FFF then
-    	Result := clBlack
-    else
-    	Result := Colors[ Id ];
-end;
-
-function TRadarColReader.GetItemColor( Id: Word ): TColor;
-begin
-	Result := GetLandColor($4000 + Id);
-end;
-
-end.

Deleted: trunk/WPGM/UOStatics.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/UOStatics.~pas
===================================================================
--- trunk/WPGM/UOStatics.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/UOStatics.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,331 +0,0 @@
-{$A8,B-,C-,D-,E-,F-,G+,H+,I-,J+,K-,L-,M-,N+,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Y-,Z1}
-{$MINSTACKSIZE $00004000}
-{$MAXSTACKSIZE $00100000}
-{$IMAGEBASE $00400000}
-{$APPTYPE GUI}
-{$WARN SYMBOL_DEPRECATED ON}
-{$WARN SYMBOL_LIBRARY ON}
-{$WARN SYMBOL_PLATFORM ON}
-{$WARN UNIT_LIBRARY ON}
-{$WARN UNIT_PLATFORM ON}
-{$WARN UNIT_DEPRECATED ON}
-{$WARN HRESULT_COMPAT ON}
-{$WARN HIDING_MEMBER ON}
-{$WARN HIDDEN_VIRTUAL ON}
-{$WARN GARBAGE ON}
-{$WARN BOUNDS_ERROR ON}
-{$WARN ZERO_NIL_COMPAT ON}
-{$WARN STRING_CONST_TRUNCED ON}
-{$WARN FOR_LOOP_VAR_VARPAR ON}
-{$WARN TYPED_CONST_VARPAR ON}
-{$WARN ASG_TO_TYPED_CONST ON}
-{$WARN CASE_LABEL_RANGE ON}
-{$WARN FOR_VARIABLE ON}
-{$WARN CONSTRUCTING_ABSTRACT ON}
-{$WARN COMPARISON_FALSE ON}
-{$WARN COMPARISON_TRUE ON}
-{$WARN COMPARING_SIGNED_UNSIGNED ON}
-{$WARN COMBINING_SIGNED_UNSIGNED ON}
-{$WARN UNSUPPORTED_CONSTRUCT ON}
-{$WARN FILE_OPEN ON}
-{$WARN FILE_OPEN_UNITSRC ON}
-{$WARN BAD_GLOBAL_SYMBOL ON}
-{$WARN DUPLICATE_CTOR_DTOR ON}
-{$WARN INVALID_DIRECTIVE ON}
-{$WARN PACKAGE_NO_LINK ON}
-{$WARN PACKAGED_THREADVAR ON}
-{$WARN IMPLICIT_IMPORT ON}
-{$WARN HPPEMIT_IGNORED ON}
-{$WARN NO_RETVAL ON}
-{$WARN USE_BEFORE_DEF ON}
-{$WARN FOR_LOOP_VAR_UNDEF ON}
-{$WARN UNIT_NAME_MISMATCH ON}
-{$WARN NO_CFG_FILE_FOUND ON}
-{$WARN MESSAGE_DIRECTIVE ON}
-{$WARN IMPLICIT_VARIANTS ON}
-{$WARN UNICODE_TO_LOCALE ON}
-{$WARN LOCALE_TO_UNICODE ON}
-{$WARN IMAGEBASE_MULTIPLE ON}
-{$WARN SUSPICIOUS_TYPECAST ON}
-{$WARN PRIVATE_PROPACCESSOR ON}
-{$WARN UNSAFE_TYPE OFF}
-{$WARN UNSAFE_CODE OFF}
-{$WARN UNSAFE_CAST OFF}
-{$A8,B-,C-,D-,E-,F-,G+,H+,I-,J+,K-,L-,M-,N+,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Y-,Z1}
-{$MINSTACKSIZE $00004000}
-{$MAXSTACKSIZE $00100000}
-{$IMAGEBASE $00400000}
-{$APPTYPE GUI}
-{$WARN SYMBOL_DEPRECATED ON}
-{$WARN SYMBOL_LIBRARY ON}
-{$WARN SYMBOL_PLATFORM ON}
-{$WARN UNIT_LIBRARY ON}
-{$WARN UNIT_PLATFORM ON}
-{$WARN UNIT_DEPRECATED ON}
-{$WARN HRESULT_COMPAT ON}
-{$WARN HIDING_MEMBER ON}
-{$WARN HIDDEN_VIRTUAL ON}
-{$WARN GARBAGE ON}
-{$WARN BOUNDS_ERROR ON}
-{$WARN ZERO_NIL_COMPAT ON}
-{$WARN STRING_CONST_TRUNCED ON}
-{$WARN FOR_LOOP_VAR_VARPAR ON}
-{$WARN TYPED_CONST_VARPAR ON}
-{$WARN ASG_TO_TYPED_CONST ON}
-{$WARN CASE_LABEL_RANGE ON}
-{$WARN FOR_VARIABLE ON}
-{$WARN CONSTRUCTING_ABSTRACT ON}
-{$WARN COMPARISON_FALSE ON}
-{$WARN COMPARISON_TRUE ON}
-{$WARN COMPARING_SIGNED_UNSIGNED ON}
-{$WARN COMBINING_SIGNED_UNSIGNED ON}
-{$WARN UNSUPPORTED_CONSTRUCT ON}
-{$WARN FILE_OPEN ON}
-{$WARN FILE_OPEN_UNITSRC ON}
-{$WARN BAD_GLOBAL_SYMBOL ON}
-{$WARN DUPLICATE_CTOR_DTOR ON}
-{$WARN INVALID_DIRECTIVE ON}
-{$WARN PACKAGE_NO_LINK ON}
-{$WARN PACKAGED_THREADVAR ON}
-{$WARN IMPLICIT_IMPORT ON}
-{$WARN HPPEMIT_IGNORED ON}
-{$WARN NO_RETVAL ON}
-{$WARN USE_BEFORE_DEF ON}
-{$WARN FOR_LOOP_VAR_UNDEF ON}
-{$WARN UNIT_NAME_MISMATCH ON}
-{$WARN NO_CFG_FILE_FOUND ON}
-{$WARN MESSAGE_DIRECTIVE ON}
-{$WARN IMPLICIT_VARIANTS ON}
-{$WARN UNICODE_TO_LOCALE ON}
-{$WARN LOCALE_TO_UNICODE ON}
-{$WARN IMAGEBASE_MULTIPLE ON}
-{$WARN SUSPICIOUS_TYPECAST ON}
-{$WARN PRIVATE_PROPACCESSOR ON}
-{$WARN UNSAFE_TYPE OFF}
-{$WARN UNSAFE_CODE OFF}
-{$WARN UNSAFE_CAST OFF}
-{$A8,B-,C-,D-,E-,F-,G+,H+,I-,J+,K-,L-,M-,N+,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Y-,Z1}
-{$MINSTACKSIZE $00004000}
-{$MAXSTACKSIZE $00100000}
-{$IMAGEBASE $00400000}
-{$APPTYPE GUI}
-{$WARN SYMBOL_DEPRECATED ON}
-{$WARN SYMBOL_LIBRARY ON}
-{$WARN SYMBOL_PLATFORM ON}
-{$WARN UNIT_LIBRARY ON}
-{$WARN UNIT_PLATFORM ON}
-{$WARN UNIT_DEPRECATED ON}
-{$WARN HRESULT_COMPAT ON}
-{$WARN HIDING_MEMBER ON}
-{$WARN HIDDEN_VIRTUAL ON}
-{$WARN GARBAGE ON}
-{$WARN BOUNDS_ERROR ON}
-{$WARN ZERO_NIL_COMPAT ON}
-{$WARN STRING_CONST_TRUNCED ON}
-{$WARN FOR_LOOP_VAR_VARPAR ON}
-{$WARN TYPED_CONST_VARPAR ON}
-{$WARN ASG_TO_TYPED_CONST ON}
-{$WARN CASE_LABEL_RANGE ON}
-{$WARN FOR_VARIABLE ON}
-{$WARN CONSTRUCTING_ABSTRACT ON}
-{$WARN COMPARISON_FALSE ON}
-{$WARN COMPARISON_TRUE ON}
-{$WARN COMPARING_SIGNED_UNSIGNED ON}
-{$WARN COMBINING_SIGNED_UNSIGNED ON}
-{$WARN UNSUPPORTED_CONSTRUCT ON}
-{$WARN FILE_OPEN ON}
-{$WARN FILE_OPEN_UNITSRC ON}
-{$WARN BAD_GLOBAL_SYMBOL ON}
-{$WARN DUPLICATE_CTOR_DTOR ON}
-{$WARN INVALID_DIRECTIVE ON}
-{$WARN PACKAGE_NO_LINK ON}
-{$WARN PACKAGED_THREADVAR ON}
-{$WARN IMPLICIT_IMPORT ON}
-{$WARN HPPEMIT_IGNORED ON}
-{$WARN NO_RETVAL ON}
-{$WARN USE_BEFORE_DEF ON}
-{$WARN FOR_LOOP_VAR_UNDEF ON}
-{$WARN UNIT_NAME_MISMATCH ON}
-{$WARN NO_CFG_FILE_FOUND ON}
-{$WARN MESSAGE_DIRECTIVE ON}
-{$WARN IMPLICIT_VARIANTS ON}
-{$WARN UNICODE_TO_LOCALE ON}
-{$WARN LOCALE_TO_UNICODE ON}
-{$WARN IMAGEBASE_MULTIPLE ON}
-{$WARN SUSPICIOUS_TYPECAST ON}
-{$WARN PRIVATE_PROPACCESSOR ON}
-{$WARN UNSAFE_TYPE OFF}
-{$WARN UNSAFE_CODE OFF}
-{$WARN UNSAFE_CAST OFF}
-unit UOStatics;
-
-interface
-
-uses Classes, UOCache;
-
-type TStaticItem = packed record
-	Id: Word;
-  X: Byte;
-  Y: Byte;
-  Z: Shortint;
-  Hue: Word;
-end;
-
-type TStaticBlock = array of TStaticItem;
-
-type TStaticReader = class( TObject )
-	private
-    Index, Data: TFileStream;
-    MapWidth, MapHeight: Word;
-    Cache: TCache;
-    Disabled: Boolean;
-    ModifyTimeData: TDateTime;
-    ModifyTimeIndex: TDateTime;
-
-  public
-    constructor Create;
-    destructor Destroy; override;
-    function Open( IndexName: String; DataName: String; MapHeight: Word = 0; MapWidth: Word = 0 ): Boolean;
-    procedure Close;
-    procedure ReadBlock( XBlock, YBlock: Word; var StaticBlock: TStaticBlock );
-    function LastDataModification: TDateTime;
-    function LastIndexModification: TDateTime;
-end;
-
-implementation
-
-uses SysUtils;
-
-constructor TStaticReader.Create;
-begin
-  Index := nil;
-  Data := nil;
-  MapWidth := 0;
-  MapHeight := 0;
-  Cache := TCache.Create(75);
-  Disabled := True;
-  ModifyTimeData := Time;
-  ModifyTimeIndex := Time;
-end;
-
-destructor TStaticReader.Destroy;
-begin
-	Data.Free;
-	Index.Free;
-  Cache.Free;
-end;
-
-function TStaticReader.Open( IndexName: String; DataName: String; MapHeight: Word = 0; MapWidth: Word = 0 ): Boolean;
-begin
-  Result := False;
-
-  try
-    Index := TFileStream.Create( IndexName, fmOpenRead+fmShareDenyNone );
-    Data := TFileStream.Create( DataName, fmOpenRead+fmShareDenyNone );
-
-    if MapHeight = 0 then case Index.Size of
-      4718592:
-      begin
-        MapHeight := 512;
-        MapWidth := 768;
-      end;
-
-      691200:
-      begin
-        MapHeight := 200;
-        MapWidth := 288;
-      end;
-
-      983040:
-      begin
-        MapWidth := 320;
-        MapHeight := 256;
-      end;
-
-      393132:
-      begin
-        MapWidth := 181;
-        MapHeight := 181;
-      end;
-    end;
-
-    if MapHeight = 0 then
-      raise Exception.Create( 'Couldn''t determine correct mapsize for TStaticReader' );
-
-    Self.MapHeight := MapHeight;
-    Self.MapWidth := MapWidth;
-
-    Disabled := False;
-    Result := True;
-
-    // Get modification times
-    ModifyTimeData := FileDateToDateTime(FileAge(DataName));
-    ModifyTimeIndex := FileDateToDateTime(FileAge(IndexName));
-  except
-    FreeAndNil(Data);
-    FreeAndNil(Index);
-  end;
-end;
-
-procedure TStaticReader.Close;
-begin
-	Data.Free;
-    Index.Free;
-
-    Data := nil;
-    Index := nil;
-end;
-
-procedure TStaticReader.ReadBlock( XBlock, YBlock: Word; var StaticBlock: TStaticBlock );
-var
-	Offset, Length: Cardinal;
-  I: Integer;
-  BlockId: Cardinal;
-  CacheEntry: ^TStaticBlock;
-begin
-	SetLength( StaticBlock, 0 );
-
-  if Disabled then
-    exit;
-
-  BlockId := XBlock * MapHeight + YBlock;
-
-  CacheEntry := Cache.Lookup(BlockId);
-
-  if CacheEntry &lt;&gt; nil then begin
-    StaticBlock := CacheEntry^;
-    exit;
-  end;
-
-	Index.Seek( BlockId * 12, soFromBeginning );
-  Index.Read( Offset, 4 );
-  Index.Read( Length, 4 );
-
-    if ( Offset = $FFFFFFFF ) or ( Length = 0 ) then
-    	exit;
-
-	Data.Seek( Offset, soFromBeginning );
-
-  new(CacheEntry);
-  SetLength(CacheEntry^, Length div sizeof( TStaticItem ) );
-
-	for i := 0 to ( Length div sizeof( TStaticItem ) ) - 1 do
-		Data.Read( CacheEntry^[i], sizeof( TStaticItem ) );
-
-  Cache.Add(BlockId, CacheEntry);
-
-  StaticBlock := CacheEntry^;
-end;
-
-function TStaticReader.LastDataModification: TDateTime;
-begin
-  Result := ModifyTimeData;
-end;
-
-function TStaticReader.LastIndexModification: TDateTime;
-begin
-  Result := ModifyTimeIndex;
-end;
-
-end.
- 
\ No newline at end of file

Deleted: trunk/WPGM/WPGM.~dpr
===================================================================
--- trunk/WPGM/WPGM.~dpr	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/WPGM.~dpr	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,31 +0,0 @@
-program WPGM;
-
-uses
-  Forms,
-  Main in 'Main.pas' {frmMain},
-  UOTiledata in 'UOLib\UOTiledata.pas',
-  UOUtilities in 'UOLib\UOUtilities.pas',
-  UOArt in 'UOLib\UOArt.pas',
-  uConfig in 'uConfig.pas',
-  UOHues in 'UOHues.pas',
-  uChooseHue in 'uChooseHue.pas' {frmChooseHue},
-  UOAnim in 'UOLib\UOAnim.pas',
-  uCenter in 'uCenter.pas' {frmCenter},
-  Overview in 'Overview.pas' {frmOverview},
-  Progress in 'Progress.pas' {frmProgress},
-  Spawnregions in 'Spawnregions.pas' {frmRegions},
-  uPatternColor in 'uPatternColor.pas' {frmPatternColor};
-
-{$R *.RES}
-
-begin
-  Application.Initialize;
-  Application.Title := 'Wolfpack - GM Tool';
-  Application.CreateForm(TfrmMain, frmMain);
-  Application.CreateForm(TfrmChooseHue, frmChooseHue);
-  Application.CreateForm(TfrmCenter, frmCenter);
-  Application.CreateForm(TfrmOverview, frmOverview);
-  Application.CreateForm(TfrmRegions, frmRegions);
-  Application.CreateForm(TfrmPatternColor, frmPatternColor);
-  Application.Run;
-end.

Deleted: trunk/WPGM/XMLReader.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/uCenter.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/uCenter.~dfm
===================================================================
--- trunk/WPGM/uCenter.~dfm	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/uCenter.~dfm	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,71 +0,0 @@
-object frmCenter: TfrmCenter
-  Left = 536
-  Top = 411
-  BorderStyle = bsToolWindow
-  Caption = 'Center Map'
-  ClientHeight = 101
-  ClientWidth = 140
-  Color = clBtnFace
-  Font.Charset = DEFAULT_CHARSET
-  Font.Color = clWindowText
-  Font.Height = -11
-  Font.Name = 'MS Sans Serif'
-  Font.Style = []
-  OldCreateOrder = False
-  PixelsPerInch = 96
-  TextHeight = 13
-  object Label1: TLabel
-    Left = 66
-    Top = 42
-    Width = 6
-    Height = 20
-    Caption = ','
-    Font.Charset = DEFAULT_CHARSET
-    Font.Color = clWindowText
-    Font.Height = -16
-    Font.Name = 'MS Sans Serif'
-    Font.Style = [fsBold]
-    ParentFont = False
-  end
-  object Button1: TButton
-    Left = 8
-    Top = 70
-    Width = 75
-    Height = 22
-    Caption = '&amp;Center'
-    TabOrder = 0
-    OnClick = Button1Click
-  end
-  object Map: TComboBox
-    Left = 8
-    Top = 8
-    Width = 121
-    Height = 21
-    Style = csDropDownList
-    ItemHeight = 13
-    ItemIndex = 0
-    TabOrder = 1
-    Text = 'Felucca'
-    Items.Strings = (
-      'Felucca'
-      'Trammel'
-      'Ilshenar'
-      'Malas')
-  end
-  object X: TEdit
-    Left = 8
-    Top = 40
-    Width = 57
-    Height = 21
-    TabOrder = 2
-    Text = 'X'
-  end
-  object Y: TEdit
-    Left = 72
-    Top = 40
-    Width = 57
-    Height = 21
-    TabOrder = 3
-    Text = 'Y'
-  end
-end

Deleted: trunk/WPGM/uCenter.~pas
===================================================================
--- trunk/WPGM/uCenter.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/uCenter.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,39 +0,0 @@
-unit uCenter;
-
-interface
-
-uses
-  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
-  Dialogs, StdCtrls;
-
-type
-  TfrmCenter = class(TForm)
-    Button1: TButton;
-    Map: TComboBox;
-    X: TEdit;
-    Y: TEdit;
-    Label1: TLabel;
-    procedure Button1Click(Sender: TObject);
-  private
-    { Private declarations }
-  public
-    { Public declarations }
-  end;
-
-var
-  frmCenter: TfrmCenter;
-
-implementation
-
-uses Main;
-
-{$R *.dfm}
-
-procedure TfrmCenter.Button1Click(Sender: TObject);
-begin
-  MapCenterX := StrToIntDef(X.Text, MapCenterX);
-  MapCenterY := StrToIntDef(Y.Text, MapCenterY);
-  
-end;
-
-end.

Deleted: trunk/WPGM/uChooseHue.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/uChooseHue.~ddp
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/uChooseHue.~dfm
===================================================================
--- trunk/WPGM/uChooseHue.~dfm	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/uChooseHue.~dfm	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,79 +0,0 @@
-object frmChooseHue: TfrmChooseHue
-  Left = 364
-  Top = 284
-  BorderStyle = bsDialog
-  Caption = 'Chose Hue'
-  ClientHeight = 394
-  ClientWidth = 404
-  Color = clBtnFace
-  Font.Charset = DEFAULT_CHARSET
-  Font.Color = clWindowText
-  Font.Height = -11
-  Font.Name = 'MS Sans Serif'
-  Font.Style = []
-  OldCreateOrder = False
-  OnCreate = FormCreate
-  OnShow = FormShow
-  PixelsPerInch = 96
-  TextHeight = 13
-  object lblId: TLabel
-    Left = 8
-    Top = 336
-    Width = 12
-    Height = 13
-    Caption = 'Id:'
-  end
-  object lblName: TLabel
-    Left = 80
-    Top = 336
-    Width = 31
-    Height = 13
-    Caption = 'Name:'
-  end
-  object pbHueSelection: TPaintBox32
-    Left = 8
-    Top = 8
-    Width = 384
-    Height = 320
-    TabOrder = 0
-    OnMouseDown = pbHueSelectionMouseDown
-    OnPaintBuffer = pbHueSelectionPaintBuffer
-  end
-  object btnOk: TButton
-    Left = 8
-    Top = 360
-    Width = 75
-    Height = 25
-    Caption = 'Ok'
-    ModalResult = 1
-    TabOrder = 1
-  end
-  object btnCancel: TButton
-    Left = 88
-    Top = 360
-    Width = 75
-    Height = 25
-    Caption = 'Cancel'
-    ModalResult = 2
-    TabOrder = 2
-  end
-  object tbHue: TTrackBar
-    Left = 169
-    Top = 360
-    Width = 224
-    Height = 25
-    Max = 31
-    Frequency = 2
-    Position = 31
-    TabOrder = 3
-    OnChange = tbHueChange
-  end
-  object pbHuePreview: TPaintBox32
-    Left = 264
-    Top = 333
-    Width = 128
-    Height = 18
-    TabOrder = 4
-    OnPaintBuffer = pbHuePreviewPaintBuffer
-  end
-end

Deleted: trunk/WPGM/uChooseHue.~pas
===================================================================
--- trunk/WPGM/uChooseHue.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/uChooseHue.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,119 +0,0 @@
-unit uChooseHue;
-
-interface
-
-uses
-  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
-  Dialogs, StdCtrls, GR32_Image, ComCtrls;
-
-type
-  TfrmChooseHue = class(TForm)
-    pbHueSelection: TPaintBox32;
-    btnOk: TButton;
-    btnCancel: TButton;
-    tbHue: TTrackBar;
-    lblId: TLabel;
-    lblName: TLabel;
-    pbHuePreview: TPaintBox32;
-    procedure pbHueSelectionPaintBuffer(Sender: TObject);
-    procedure tbHueChange(Sender: TObject);
-    procedure FormCreate(Sender: TObject);
-    procedure pbHueSelectionMouseDown(Sender: TObject;
-      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-    procedure pbHuePreviewPaintBuffer(Sender: TObject);
-    procedure FormShow(Sender: TObject);
-  private
-    { Private declarations }
-  public
-    { Public declarations }
-    ColorId: Word;
-  end;
-
-var
-  frmChooseHue: TfrmChooseHue;
-
-implementation
-
-uses Main, GR32, Math;
-
-{$R *.dfm}
-
-procedure TfrmChooseHue.pbHueSelectionPaintBuffer(Sender: TObject);
-var
-  hue, xhue, yhue: Word;
-begin
-  for xhue := 0 to 46 do
-    for yhue := 0 to 63 do begin
-      hue := 1 + xhue * 64 + yhue; // First hue: 0x01
-
-      if Hue &lt;= $BB7 then
-        // Fill a 6x6 picture
-        pbHueSelection.Buffer.FillRect(xhue * 6, yhue * 5,
-          xhue * 6 + 5, yhue * 5 + 4, Main.Hues.getColor(Hue, tbHue.Position));            
-    end;
-end;
-
-procedure TfrmChooseHue.tbHueChange(Sender: TObject);
-begin
-  pbHueSelection.Invalidate;
-end;
-
-procedure TfrmChooseHue.FormCreate(Sender: TObject);
-begin
-    ColorId := 1;
-    lblId.Caption := Format('Id: 0x%x', [ColorId]);
-    lblName.Caption := Format('Name: %s', [Main.Hues.getHue(ColorId).Name]);
-end;
-
-procedure TfrmChooseHue.pbHueSelectionMouseDown(Sender: TObject;
-  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
-var
-  xhue, yhue, hue: word;
-begin
-  xhue := x div 6;
-  yhue := y div 5;
-
-  // The black border doesnt trigger anything
-  if x mod 6 = 5 then
-    exit;
-
-  if y mod 5 = 4 then
-    exit;
-
-  hue := 1 + xhue * 64 + yhue;
-
-  if Hue &gt; 
-
-  ColorId := Hue;
-  lblId.Caption := Format('Id: 0x%x', [ColorId]);
-  lblName.Caption := Format('Name: %s', [Main.Hues.getHue(ColorId).Name + #0]);
-  pbHuePreview.Invalidate;
-end;
-
-procedure TfrmChooseHue.pbHuePreviewPaintBuffer(Sender: TObject);
-var
-  i: Integer;
-  Width: Integer;
-  Hue: Word;
-begin
-  Hue := ColorId;
-
-  if Hue = 0 then begin
-    pbHuePreview.Buffer.Clear(clGray32);
-    exit;
-  end;
-
-  Width := Ceil(pbHuePreview.Width / 32.0);
-  for i := 0 to 31 do
-  begin
-    pbHuePreview.Buffer.FillRect(i * Width, 0, (i + 1) * Width,
-      pbHuePreview.Height, Hues.getColor(Hue, i));
-  end;
-end;
-
-procedure TfrmChooseHue.FormShow(Sender: TObject);
-begin
-  pbHuePreview.Invalidate;
-end;
-
-end.

Deleted: trunk/WPGM/uConfig.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/uConfig.~pas
===================================================================
--- trunk/WPGM/uConfig.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/uConfig.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,105 +0,0 @@
-unit uConfig;
-
-interface
-
-uses IniFiles, Registry;
-
-type TConfig = class
-	private
-    IniCache: TMemIniFile;
-
-  public
-    constructor Create;
-    destructor Destroy; override;
-    function Load( FileName: String ): Boolean;
-    function Save: Boolean;
-    procedure setString(Name: String; Value: String);
-    function getString(Name: String; Default: String): String;
-    procedure setBool(Name: String; Value: Boolean);
-    function getBool(Name: String; Default: Boolean): Boolean;
-    procedure setInt(Name: String; Value: Integer);
-    function getInt(Name: String; Default: Integer): Integer;
-end;
-
-implementation
-
-uses SysUtils, UOUtilities, Forms, Windows;
-
-constructor TConfig.Create;
-begin
-	inherited Create;
-
-	IniCache := nil;
-end;
-
-destructor TConfig.Destroy;
-begin
-	IniCache.Free;
-
-    inherited Destroy;
-end;
-
-function TConfig.Load( FileName: String ): Boolean;
-begin
-	Result := False;
-
-  try
-    IniCache := TMemIniFile.Create(FileName);
-  except
-    FreeAndNil( IniCache );
-  end;
-end;
-
-function TConfig.Save: Boolean;
-begin
-	Result := false;
-
-	if IniCache = nil then
-    	exit;
-
-  try
-    IniCache.UpdateFile;
-  except
-  end;
-end;
-
-procedure TConfig.setString(Name: String; Value: String);
-begin
-  IniCache.WriteString('General', Name, Value);
-end;
-
-function TConfig.getString(Name: String; Default: String): String;
-begin
-  if not IniCache.ValueExists('General', Name) then
-    IniCache.WriteString('General', Name, Default);
-
-  Result := IniCache.ReadString('General', Name, Default);
-end;
-
-procedure TConfig.setBool(Name: String; Value: Boolean);
-begin
-  IniCache.WriteBool('General', Name, Value);
-end;
-
-function TConfig.getBool(Name: String; Default: Boolean): Boolean;
-begin
-  if not IniCache.ValueExists('General', Name) then
-    IniCache.WriteBool('Geneal', Name, Default);
-
-  Result := IniCache.ReadBool('General', Name, Default);
-end;
-
-procedure TConfig.setInt(Name: String; Value: Integer);
-begin
-  IniCache.WriteInteger('General', Name, Value);
-end;
-
-function TConfig.getInt(Name: String; Default: Integer): Integer;
-begin
-  if not IniCache.ValueExists('General', Name) then
-    IniCache.WriteInteger('General', Name, Default);
-
-  Result := IniCache.ReadInteger('General', Name, Default);
-end;
-
-end.

Deleted: trunk/WPGM/uPatternColor.dcu
===================================================================
(Binary files differ)

Deleted: trunk/WPGM/uPatternColor.~dfm
===================================================================
--- trunk/WPGM/uPatternColor.~dfm	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/uPatternColor.~dfm	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,87 +0,0 @@
-object frmPatternColor: TfrmPatternColor
-  Left = 513
-  Top = 261
-  BorderIcons = [biSystemMenu, biMinimize]
-  BorderStyle = bsDialog
-  Caption = 'Pattern Tilecolor'
-  ClientHeight = 380
-  ClientWidth = 415
-  Color = clBtnFace
-  Font.Charset = DEFAULT_CHARSET
-  Font.Color = clWindowText
-  Font.Height = -11
-  Font.Name = 'MS Sans Serif'
-  Font.Style = []
-  OldCreateOrder = False
-  PixelsPerInch = 96
-  TextHeight = 13
-  object Shape1: TShape
-    Left = 168
-    Top = 216
-    Width = 65
-    Height = 65
-  end
-  object Image1: TImage
-    Left = 184
-    Top = 240
-    Width = 105
-    Height = 105
-  end
-  object Image2: TImage
-    Left = 200
-    Top = 256
-    Width = 105
-    Height = 105
-  end
-  object RadioButton1: TRadioButton
-    Left = 8
-    Top = 8
-    Width = 41
-    Height = 17
-    Caption = '2x2'
-    Checked = True
-    TabOrder = 0
-    TabStop = True
-  end
-  object RadioButton2: TRadioButton
-    Left = 104
-    Top = 8
-    Width = 41
-    Height = 17
-    Caption = '3x3'
-    TabOrder = 1
-  end
-  object RadioButton3: TRadioButton
-    Left = 192
-    Top = 8
-    Width = 41
-    Height = 17
-    Caption = '4x4'
-    TabOrder = 2
-  end
-  object Button1: TButton
-    Left = 8
-    Top = 216
-    Width = 75
-    Height = 25
-    Caption = '&amp;Tile'
-    TabOrder = 3
-  end
-  object ImgView321: TImgView32
-    Left = 8
-    Top = 32
-    Width = 225
-    Height = 169
-    Scale = 1.000000000000000000
-    ScrollBars.ShowHandleGrip = True
-    ScrollBars.Style = rbsDefault
-    SizeGrip = sgNone
-    OverSize = 0
-    TabOrder = 4
-  end
-  object Timer1: TTimer
-    OnTimer = Timer1Timer
-    Left = 120
-    Top = 184
-  end
-end

Deleted: trunk/WPGM/uPatternColor.~pas
===================================================================
--- trunk/WPGM/uPatternColor.~pas	2007-06-21 20:19:19 UTC (rev 6838)
+++ trunk/WPGM/uPatternColor.~pas	2007-06-22 17:52:13 UTC (rev 6839)
@@ -1,72 +0,0 @@
-unit uPatternColor;
-
-interface
-
-uses
-  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
-  Dialogs, StdCtrls, ExtCtrls, GR32_Image, GR32, GR32_Layers;
-
-type
-  TfrmPatternColor = class(TForm)
-    RadioButton1: TRadioButton;
-    RadioButton2: TRadioButton;
-    RadioButton3: TRadioButton;
-    Button1: TButton;
-    Timer1: TTimer;
-    ImgView321: TImgView32;
-    Image1: TImage;
-    Image2: TImage;
-    Shape1: TShape;
-    procedure Timer1Timer(Sender: TObject);
-  private
-    { Private declarations }
-  public
-    { Public declarations }
-  end;
-
-var
-  frmPatternColor: TfrmPatternColor;
-
-implementation
-
-{$R *.dfm}
-
-uses UOArt, Main;
-
-procedure TfrmPatternColor.Timer1Timer(Sender: TObject);
-var
-  Layer: TBitmapLayer;
-
-begin
-  Image1.Picture.Assign(Main.Art.GetTIle($50d, 0));
-
-
-  ImgView321.Scale := 1.0;
-  ImgView321.Centered := True;
-  ImgView321.Bitmap.SetSize(66, 66);
-  ImgView321.Bitmap.Draw(0, 0, Main.Art.GetTile($50d, 0));
-  ImgView321.Bitmap.Draw(22, 22, Main.Art.GetTile($50d, 0));
-
-  Layer := ImgView321.Layers.Add(TBitmapLayer) as TBitmapLayer;
-  Layer.Bitmap := Main.Art.GetTile($50d, 0);
-  Layer.AlphaHit := True;
-
-  Layer := ImgView321.Layers.Add(TBitmapLayer) as TBitmapLayer;
-  Layer.Bitmap := Main.Art.GetTile($50d, 0);
-  Layer.AlphaHit := True;
-
-  Layer := ImgView321.Layers.Add(TBitmapLayer) as TBitmapLayer;
-  Layer.Bitmap := Main.Art.GetTile($50d, 0);
-  Layer.AlphaHit := True;
-
-  Layer := ImgView321.Layers.Add(TBitmapLayer) as TBitmapLayer;
-  Layer.Bitmap := Main.Art.GetTile($50d, 0);
-  Layer.AlphaHit := True;
-
-{  Image322.Bitmap := Main.Art.GetTile($50d, 0);
-  Image323.Bitmap := Main.Art.GetTile($50d, 0); }
-
-  Timer1.Enabled := False;
-end;
-
-end.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000043.html">[Wolfpack-svn] r6838 - in trunk/server:	boost/include/boost/python/detail	boost/include/boost/tuple/detail src src/ai src/muls	src/network src/python src/twofish
</A></li>
	<LI>Next message: <A HREF="000045.html">[Wolfpack-svn] r6840 - trunk/server/release/scripts/wolfpack
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#44">[ date ]</a>
              <a href="thread.html#44">[ thread ]</a>
              <a href="subject.html#44">[ subject ]</a>
              <a href="author.html#44">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wolfpack-svn">More information about the Wolfpack-svn
mailing list</a><br>
</body></html>
